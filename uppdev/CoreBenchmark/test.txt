
#line 116 "d:\\sdk\\Microsoft SDK\\include\\reason.h"
#line 810 "d:\\sdk\\Microsoft SDK\\include\\winreg.h"


















__declspec(dllimport)
BOOL
__stdcall
InitiateSystemShutdownExA(
     LPSTR lpMachineName,
     LPSTR lpMessage,
     DWORD dwTimeout,
     BOOL bForceAppsClosed,
     BOOL bRebootAfterShutdown,
     DWORD dwReason
    );
__declspec(dllimport)
BOOL
__stdcall
InitiateSystemShutdownExW(
     LPWSTR lpMachineName,
     LPWSTR lpMessage,
     DWORD dwTimeout,
     BOOL bForceAppsClosed,
     BOOL bRebootAfterShutdown,
     DWORD dwReason
    );




#line 855 "d:\\sdk\\Microsoft SDK\\include\\winreg.h"


__declspec(dllimport)
LONG
__stdcall
RegSaveKeyExA (
     HKEY hKey,
     LPCSTR lpFile,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes,
     DWORD Flags
    );
__declspec(dllimport)
LONG
__stdcall
RegSaveKeyExW (
     HKEY hKey,
     LPCWSTR lpFile,
     LPSECURITY_ATTRIBUTES lpSecurityAttributes,
     DWORD Flags
    );




#line 880 "d:\\sdk\\Microsoft SDK\\include\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
Wow64Win32ApiEntry (
    DWORD dwFuncNumber,
    DWORD dwFlag,
    DWORD dwRes
    );


}
#line 893 "d:\\sdk\\Microsoft SDK\\include\\winreg.h"


#line 896 "d:\\sdk\\Microsoft SDK\\include\\winreg.h"

#line 4 "u:/idisapp\\Core/Win32Util.h"







inline bool IsWinNT() { return GetVersion() < 0x80000000; }
bool IsWin2K();
bool IsWinXP();
bool IsWinVista();
#line 16 "u:/idisapp\\Core/Win32Util.h"

HINSTANCE AppGetHandle();
void      AppSetHandle(HINSTANCE dll_instance);

String AsString(const wchar_t *buffer);
String AsString(const wchar_t *buffer, int count);
String AsString(const wchar_t *buffer, const wchar_t *end);

String GetWinRegString(const char *value, const char *path, HKEY base_key = (( HKEY ) (ULONG_PTR)((LONG)0x80000002) ));
int    GetWinRegInt(const char *value, const char *path, HKEY base_key = (( HKEY ) (ULONG_PTR)((LONG)0x80000002) ));
bool   SetWinRegString(const String& string, const char *value, const char *path, HKEY base_key = (( HKEY ) (ULONG_PTR)((LONG)0x80000002) ));
bool   SetWinRegExpandString(const String& string, const char *value, const char *path, HKEY base_key);
bool   SetWinRegInt(int data, const char *value, const char *path, HKEY base_key = (( HKEY ) (ULONG_PTR)((LONG)0x80000002) ));
void   DeleteWinReg(const String& key, HKEY base = (( HKEY ) (ULONG_PTR)((LONG)0x80000002) ));


String GetSystemDirectoryA();
String GetWindowsDirectoryA();
#line 35 "u:/idisapp\\Core/Win32Util.h"
String GetModuleFileNameA(HINSTANCE instance = AppGetHandle());


class SyncObject {
protected:
	HANDLE     handle;

public:
	bool       Wait(int time_ms);
	bool       Wait();

	HANDLE     GetHandle() const { return handle; }

	SyncObject();
	~SyncObject();
};


class Event : public SyncObject {
public:
	void       Set();

	Event();
};

#line 61 "u:/idisapp\\Core/Win32Util.h"
#line 449 "u:/idisapp\\Core/Core.h"



#line 453 "u:/idisapp\\Core/Core.h"


inline void AssertMoveable0(POINT *) {}
inline void AssertMoveable0(SIZE *) {}
inline void AssertMoveable0(RECT *) {}
#line 459 "u:/idisapp\\Core/Core.h"

};














#line 476 "u:/idisapp\\Core/Core.h"




inline Upp::int64  abs(Upp::int64 x)          { return x < 0 ? -x : x; }
#line 482 "u:/idisapp\\Core/Core.h"

void      RegisterTopic__(const char *topicfile, const char *topic, const char *title, const Upp::byte *data, int len);


typedef HMODULE DLLHANDLE;


#line 490 "u:/idisapp\\Core/Core.h"

DLLHANDLE LoadDll__(Upp::String& fn, const char *const *names, void *const *procs);
void      FreeDll__(DLLHANDLE dllhandle);


using Upp::byte;
#line 497 "u:/idisapp\\Core/Core.h"





#line 1 "u:/idisapp\\Core/dli_header.h"

#line 1 "u:/idisapp\\Core/dli.h"
#pragma BLITZ_APPROVE















#line 18 "u:/idisapp\\Core/dli.h"






#line 25 "u:/idisapp\\Core/dli.h"
#line 26 "u:/idisapp\\Core/dli.h"



#line 30 "u:/idisapp\\Core/dli.h"






#line 37 "u:/idisapp\\Core/dli.h"








struct T_UnicodeWin32{
	T_UnicodeWin32();

	Upp::String       GetLibName() const        { return libname; }
	void              SetLibName(const char *n) { if(handle) Free(); libname = n; checked = false; }

	bool              Load();
	bool              Load(const char *n)       { SetLibName(n); return Load(); }
	void              Force();
	void              Free();

	operator          bool ()      { return handle; }

#line 1 "u:/idisapp\\Core/Kernel32W.dli"
typedef UINT (__stdcall GetSystemDirectoryW_type) (LPWSTR lpBuffer, UINT uSize); GetSystemDirectoryW_type *GetSystemDirectoryW;
typedef DWORD (__stdcall GetTempPathW_type) (DWORD nBufferLength, LPWSTR lpBuffer); GetTempPathW_type *GetTempPathW;
typedef UINT (__stdcall GetWindowsDirectoryW_type) (LPWSTR lpBuffer, UINT uSize); GetWindowsDirectoryW_type *GetWindowsDirectoryW;
typedef DWORD (__stdcall GetModuleFileNameW_type) (HMODULE hModule, LPWSTR lpFilename, DWORD nSize); GetModuleFileNameW_type *GetModuleFileNameW;
typedef int (__stdcall GetLocaleInfoW_type) (LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData); GetLocaleInfoW_type *GetLocaleInfoW;
typedef DWORD (__stdcall GetCurrentDirectoryW_type) (DWORD nBufferLength, LPWSTR lpBuffer); GetCurrentDirectoryW_type *GetCurrentDirectoryW;
typedef DWORD (__stdcall GetFullPathNameW_type) (LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart); GetFullPathNameW_type *GetFullPathNameW;
typedef HANDLE (__stdcall FindFirstFileW_type) (LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData); FindFirstFileW_type *FindFirstFileW;
typedef BOOL (__stdcall FindNextFileW_type) (HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData); FindNextFileW_type *FindNextFileW;
typedef BOOL (__stdcall GetVolumeInformationA_type) (LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize); GetVolumeInformationA_type *GetVolumeInformationA;
typedef HANDLE (__stdcall CreateFileW_type) (LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile); CreateFileW_type *CreateFileW;
typedef BOOL (__stdcall CopyFileW_type) (LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists); CopyFileW_type *CopyFileW;
typedef BOOL (__stdcall MoveFileW_type) (LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName); MoveFileW_type *MoveFileW;
typedef BOOL (__stdcall DeleteFileW_type) (LPCWSTR lpFileName); DeleteFileW_type *DeleteFileW;
typedef BOOL (__stdcall RemoveDirectoryW_type) (LPCWSTR lpPathName); RemoveDirectoryW_type *RemoveDirectoryW;
typedef BOOL (__stdcall CreateDirectoryW_type) (LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes); CreateDirectoryW_type *CreateDirectoryW;
#line 59 "u:/idisapp\\Core/dli.h"
private:
	Upp::String       libname;
	DLLHANDLE         handle;
	bool              checked;
};






T_UnicodeWin32& UnicodeWin32();
T_UnicodeWin32& UnicodeWin32_();

#line 74 "u:/idisapp\\Core/dli.h"







































































































#line 178 "u:/idisapp\\Core/dli.h"

















#line 3 "u:/idisapp\\Core/dli_header.h"
#line 503 "u:/idisapp\\Core/Core.h"




#line 1 "u:/idisapp\\Core/dli_header.h"

#line 1 "u:/idisapp\\Core/dli.h"
#pragma BLITZ_APPROVE















#line 18 "u:/idisapp\\Core/dli.h"






#line 25 "u:/idisapp\\Core/dli.h"
#line 26 "u:/idisapp\\Core/dli.h"










#line 37 "u:/idisapp\\Core/dli.h"








struct T_UnicodeWin32Net{
	T_UnicodeWin32Net();

	Upp::String       GetLibName() const        { return libname; }
	void              SetLibName(const char *n) { if(handle) Free(); libname = n; checked = false; }

	bool              Load();
	bool              Load(const char *n)       { SetLibName(n); return Load(); }
	void              Force();
	void              Free();

	operator          bool ()      { return handle; }

#line 1 "u:/idisapp\\Core/Mpr32W.dli"
typedef DWORD (__stdcall WNetEnumResourceW_type) (HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize); WNetEnumResourceW_type *WNetEnumResourceW;
#line 59 "u:/idisapp\\Core/dli.h"
private:
	Upp::String       libname;
	DLLHANDLE         handle;
	bool              checked;
};






T_UnicodeWin32Net& UnicodeWin32Net();
T_UnicodeWin32Net& UnicodeWin32Net_();

#line 74 "u:/idisapp\\Core/dli.h"







































































































#line 178 "u:/idisapp\\Core/dli.h"

















#line 3 "u:/idisapp\\Core/dli_header.h"
#line 508 "u:/idisapp\\Core/Core.h"
#line 509 "u:/idisapp\\Core/Core.h"

#line 511 "u:/idisapp\\Core/Core.h"
#line 5 "u:/uppsrc\\Draw/Draw.h"
































namespace Upp {


















































class Drawing;
class Draw;


HDC ScreenHDC();
#line 94 "u:/uppsrc\\Draw/Draw.h"

bool ScreenInPaletteMode();
Size GetScreenSize();

#line 1 "u:\\uppsrc\\draw\\Image.h"


enum ImageKind {
	IMAGE_UNKNOWN,
	IMAGE_EMPTY,
	IMAGE_ALPHA,
	IMAGE_MASK,
	IMAGE_OPAQUE,
};

inline bool operator==(const RGBA& a, const RGBA& b)
{
	return a.r == b.r && a.g == b.g && a.b == b.b && a.a == b.a;
}

inline bool operator!=(const RGBA& a, const RGBA& b)
{
	return !(a == b);
}

inline RGBA RGBAZero() { RGBA c; c.r = c.g = c.b = c.a = 0; return c; }

void Fill(RGBA *t, const RGBA& src, int n);
void FillColor(RGBA *t, const RGBA& src, int n);

void Copy(RGBA *t, const RGBA *s, int n);

int  Premultiply(RGBA *t, const RGBA *s, int len);
int  Unmultiply(RGBA *t, const RGBA *s, int len);

void AlphaBlend(RGBA *t, const RGBA *s, int len);
void AlphaBlend(RGBA *t, const RGBA *s, int len, Color color);

void AlphaBlendOpaque(RGBA *t, const RGBA *s, int len, Color color);
void AlphaBlendOpaque(RGBA *t, const RGBA *s, int len);

void AlphaBlendStraight(RGBA *b, const RGBA *f, int len);
void AlphaBlendStraight(RGBA *b, const RGBA *f, int len, Color color);
void AlphaBlendStraightOpaque(RGBA *t, const RGBA *s, int len);
void AlphaBlendStraightOpaque(RGBA *t, const RGBA *s, int len, int alpha);

int  GetChMaskPos32(dword mask);
void AlphaBlendOverBgST(RGBA *b, RGBA bg, int len);

const byte *UnpackRLE(RGBA *t, const byte *src, int len);
String      PackRLE(const RGBA *s, int len);

inline int  Grayscale(int r, int g, int b) { return (77 * r + 151 * g + 28 * b) >> 8; }
inline int  Grayscale(const RGBA& c)       { return Grayscale(c.r, c.g, c.b); }
inline byte Saturate255(int x)             { return byte(~(x >> 24) & (x | (-(x >> 8) >> 24)) & 0xff); }

class  Image;
class  ImageDraw;

class ImageBuffer : NoCopy {
	mutable int  kind;
	Size         size;
	Buffer<RGBA> pixels;
	Point        hotspot;
	Point        spot2;
	Size         dots;

	void         Set(Image& img);
	void         DeepCopy(const ImageBuffer& img);

	RGBA*        Line(int i) const      { ; return (RGBA *)~pixels + i * size.cx; }
	friend void  DropPixels___(ImageBuffer& b) { b.pixels.Clear(); }

	friend class Image;

public:
	void  SetKind(int k)                { kind = k; }
	int   GetKind() const               { return kind; }
	int   ScanKind() const;
	int   GetScanKind() const           { return kind == IMAGE_UNKNOWN ? ScanKind() : kind; }

	void  SetHotSpot(Point p)           { hotspot = p; }
	Point GetHotSpot() const            { return hotspot; }

	void  Set2ndSpot(Point p)           { spot2 = p; }
	Point Get2ndSpot() const            { return spot2; }

	void  SetDots(Size sz)              { dots = sz; }
	Size  GetDots() const               { return dots; }

	Size  GetSize() const               { return size; }
	int   GetWidth() const              { return size.cx; }
	int   GetHeight() const             { return size.cy; }
	int   GetLength() const             { return size.cx * size.cy; }

	RGBA *operator[](int i)             { return Line(i); }
	const RGBA *operator[](int i) const { return Line(i); }
	RGBA *operator~()                   { return pixels; }
	operator RGBA*()                    { return pixels; }
	const RGBA *operator~() const       { return pixels; }
	operator const RGBA*() const        { return pixels; }

	void  Create(int cx, int cy);
	void  Create(Size sz)               { Create(sz.cx, sz.cy); }
	bool  IsEmpty() const               { return (size.cx | size.cy) == 0; }
	void  Clear()                       { Create(0, 0); }

	void  operator=(Image& img);
	void  operator=(ImageBuffer& img);

	ImageBuffer()                       { Create(0, 0); }
	ImageBuffer(int cx, int cy)         { Create(cx, cy); }
	ImageBuffer(Size sz)                { Create(sz.cx, sz.cy); }
	ImageBuffer(Image& img);
	ImageBuffer(ImageDraw& w);
	ImageBuffer(ImageBuffer& b);
};

void Premultiply(ImageBuffer& b);
void Unmultiply(ImageBuffer& b);

void SetSurface(Draw& w, int x, int y, int cx, int cy, const RGBA *pixels);

class Image : public AssignValueTypeNo< Image, 150, Moveable<Image> > {
private:
	struct Data : Link<Data> {
		Atomic refcount;
		int64  serial;
		int    paintcount;

		static Link<Data>            ResData[1];
		static int                   ResCount;

		void   Retain()  { AtomicInc(refcount); }
		void   Release() { if(AtomicDec(refcount) == 0) delete this; }


		LPCSTR      cursor_cheat;
		HBITMAP     hbmp;
		HBITMAP     hmask;
		HBITMAP     himg;
		RGBA       *section;

		void CreateHBMP(HDC dc, const RGBA *data);
		int  GetResCount() const { return !!hbmp + !!hmask + !!himg; }
#line 142 "u:\\uppsrc\\draw\\Image.h"








		ImageBuffer buffer;
		bool        paintonly;

		void        SysInit();
		void        SysRelease();
		int         GetKind();
		void        Paint(Draw& w, int x, int y, const Rect& src, Color c);
		void        PaintOnlyShrink();

		Data(ImageBuffer& b);
		~Data();
	};

	Data *data;

	static Link<Image::Data>     ResData[1];
	static int                   ResCount;

	void Set(ImageBuffer& b);

	friend class ImageBuffer;
	friend struct Data;

	friend class Draw;

	void PaintImage(Draw& w, int x, int y, const Rect& src, Color c) const;

	friend void SetPaintOnly___(Image& m);



	void         SetCursorCheat(LPCSTR id)   { data->cursor_cheat = id; }
	LPCSTR       GetCursorCheat() const      { return data ? data->cursor_cheat : 0; }
	friend Image Win32IconCursor(LPCSTR id, int iconsize, bool cursor);
	friend HICON IconWin32(const Image& img, bool cursor);
#line 186 "u:\\uppsrc\\draw\\Image.h"
#line 187 "u:\\uppsrc\\draw\\Image.h"








public:
	const RGBA*    operator~() const;
	operator const RGBA*() const;
	const RGBA* operator[](int i) const;

	Size  GetSize() const;
	int   GetWidth() const                    { return GetSize().cx; }
	int   GetHeight() const                   { return GetSize().cy; }
	int   GetLength() const;
	Point GetHotSpot() const;
	Point Get2ndSpot() const;
	Size  GetDots() const;
	int   GetKindNoScan() const;
	int   GetKind() const;

	int64 GetSerialId() const                 { return data ? data->serial : 0; }
	bool  IsSame(const Image& img) const      { return GetSerialId() == img.GetSerialId(); }

	bool   operator==(const Image& img) const;
	bool   operator!=(const Image& img) const;
	dword  GetHashValue() const;
	String ToString() const;

	void  Serialize(Stream& s);
	void  Clear();

	Image& operator=(const Image& img);
	Image& operator=(ImageBuffer& img);

	bool IsNullInstance() const         { Size sz = GetSize(); return (sz.cx|sz.cy) == 0; }

	bool IsEmpty() const                { return IsNullInstance(); }
	operator Value() const              { return RichValue<Image>(*this); }

	Image()                             { data = 0; }
	Image(const Nuller&)                { data = 0; }
	Image(const Value& src);
	Image(const Image& img);
	Image(Image (*fn)());
	Image(ImageBuffer& b);
	~Image();


	static Image Arrow();
	static Image Wait();
	static Image IBeam();
	static Image No();
	static Image SizeAll();
	static Image SizeHorz();
	static Image SizeVert();
	static Image SizeTopLeft();
	static Image SizeTop();
	static Image SizeTopRight();
	static Image SizeLeft();
	static Image SizeRight();
	static Image SizeBottomLeft();
	static Image SizeBottom();
	static Image SizeBottomRight();
	static Image Cross();
	static Image Hand();


	struct Init {
		const char *const *scans;
		int16 scan_count;
		char info[24];
	};
	explicit Image(const Init& init);
};

Image Premultiply(const Image& img);
Image Unmultiply(const Image& img);

Vector<Image> UnpackImlData(const void *ptr, int len);
Vector<Image> UnpackImlData(const String& d);

class Iml {
	struct IImage : Moveable<IImage> {
		bool  loaded;
		Image image;

		IImage() { loaded = false; }
	};
	struct Data : Moveable<Data> {
		const char *data;
		int   len, count;
	};
	Vector<Data> data;
	VectorMap<String, IImage> map;
	const Image::Init *img_init;
	const char **name;
	bool  premultiply;

	void  Init(int n);

public:
	void   Enter();
	void   Leave();
	void   Reset();
	int    GetCount() const                  { return map.GetCount(); }
	String GetId(int i)                      { return map.GetKey(i); }
	Image  Get(int i);
	int    Find(const String& s) const       { return map.Find(s); }
	void   Set(int i, const Image& img);
	void   Premultiplied()                   { premultiply = false; }





	Iml(const Image::Init *img_init, const char **name, int n);
	void AddData(const byte *data, int len, int count);
};

void   Register(const char *imageclass, Iml& iml);

int    GetImlCount();
String GetImlName(int i);
Iml&   GetIml(int i);
int    FindIml(const char *name);
Image  GetImlImage(const char *name);
void   SetImlImage(const char *name, const Image& m);

String StoreImageAsString(const Image& img);
Image  LoadImageFromString(const String& s);
Size   GetImageStringSize(const String& src);
Size   GetImageStringDots(const String& src);

#line 1 "u:\\uppsrc\\draw\\Raster.h"
enum {
	RASTER_1,
	RASTER_2,
	RASTER_4,
	RASTER_8,
	RASTER_8ALPHA,
	RASTER_16,
	RASTER_24,
	RASTER_32,
	RASTER_32ALPHA,
	RASTER_32PREMULTIPLIED,

	RASTER_MSBFIRST = 0x80,

	RASTER_MAP_R = 32,
	RASTER_SHIFT_R = 3,
	RASTER_MAP_G = 64,
	RASTER_SHIFT_G = 2,
	RASTER_MAP_B = 16,
	RASTER_SHIFT_B = 4,

	RASTER_MAP_MAX = 64
};

struct PaletteCv {
	Buffer<byte> cv;

	byte *At(int r, int b)           { return cv + (r << 10) + (b << 6); }
	byte  Get(const RGBA& b) const   { return cv[(int(b.r >> RASTER_SHIFT_R) << 10) +
	                                             (int(b.g >> RASTER_SHIFT_G)) +
	                                             (int(b.b >> RASTER_SHIFT_B) << 6)]; }
	PaletteCv()                      { cv.Alloc(RASTER_MAP_R * RASTER_MAP_G * RASTER_MAP_B); }
};

struct RasterFormat {
	byte  type;
	dword rmask, gmask, bmask, amask;

	void Set1lf()                    { type = RASTER_1; }
	void Set1mf()                    { type = RASTER_1|RASTER_MSBFIRST; }
	void Set2lf()                    { type = RASTER_2; }
	void Set2mf()                    { type = RASTER_2|RASTER_MSBFIRST; }
	void Set4lf()                    { type = RASTER_4; }
	void Set4mf()                    { type = RASTER_4|RASTER_MSBFIRST; }
	void Set8()                      { type = RASTER_8; }
	void Set8A()                     { type = RASTER_8ALPHA; }
	void Set16le(dword rmask, dword gmask, dword bmask);
	void Set16be(dword rmask, dword gmask, dword bmask);
	void Set24le(dword rmask, dword gmask, dword bmask);
	void Set24be(dword rmask, dword gmask, dword bmask);
	void Set32le(dword rmask, dword gmask, dword bmask, dword amask = 0);
	void Set32be(dword rmask, dword gmask, dword bmask, dword amask = 0);
	void Set32leStraight(dword rmask, dword gmask, dword bmask, dword amask);
	void Set32beStraight(dword rmask, dword gmask, dword bmask, dword amask);
	void SetRGBA();
	void SetRGBAStraight();

	int  IsRGBA() const;
	int  GetByteCount(int cx) const;
	int  GetBpp() const;
	bool HasAlpha() const;
	int  GetColorCount() const;
	int  GetPaletteCount() const;

	void Read(RGBA *t, const byte *s, int cx, const RGBA *palette) const;
	void Write(byte *t, const RGBA *s, int cx, const PaletteCv *palcv) const;

private:
	byte  rpos, gpos, bpos, apos;
	static void TailBits(RGBA *t, const byte *src, int cx, byte andm, byte shift, const RGBA *palette);
	static void TailBitsMSB1st(RGBA *t, const byte *src, int cx, byte shift1, byte andm, byte shift, const RGBA *palette);
};

class Raster {
public:
	class Line {
		mutable const RGBA *data;
		const byte         *fmtdata;
		Raster             *raster;
		mutable bool        free;
		bool                fmtfree;

		friend class       Raster;

		void               MakeRGBA() const;

	public:
		const RGBA         *GetRGBA() const     { if(!data) MakeRGBA(); return data; }
		const byte         *GetRawData() const  { return fmtdata; }
		operator const RGBA *() const           { return GetRGBA(); }
		const RGBA *operator~() const           { return GetRGBA(); }

		Line(const RGBA *data, bool free)
			: data(data), fmtdata((byte *)data), raster(0), free(free), fmtfree(false) {}
		Line(const byte *fmtdata, Raster *raster, bool fmtfree)
			: data(0), fmtdata(fmtdata), raster(raster), free(false), fmtfree(fmtfree) {}
		Line( Line& b)                     { Pick(b); }
		Line()                                  { data = 0; fmtdata = 0; raster = 0; free = fmtfree = false; }
		~Line()                                 { Free(); }

		void Free()                             { if(free) delete[] data; if(fmtfree) delete[] fmtdata; }
		void Pick( Line& b);

		void operator=( Line& b)           { Free(); Pick(b); }
	};

	struct Info {
		int   bpp;
		int   colors;
		Size  dots;
		Point hotspot;
		int   kind;

		Info();
	};

public:
	virtual void    SeekPage(int page);
	virtual int     GetPageCount();

	virtual bool    Create();
	virtual Size    GetSize() = 0;
	virtual Info    GetInfo();
	virtual Line    GetLine(int line) = 0;
	virtual bool    IsError();
	virtual int     GetPaletteCount();
	virtual const RGBA *GetPalette();
	virtual const RasterFormat *GetFormat();

	int    GetWidth()                              { return GetSize().cx; }
	int    GetHeight()                             { return GetSize().cy; }
	Line   operator[](int i)                       { return GetLine(i); }

	Image  GetImage(int x, int y, int cx, int cy, const Gate2<int, int> progress = false);
	Image  GetImage(const Gate2<int, int> progress = false);

	virtual ~Raster();
};

typedef Raster::Line RasterLine;
typedef Raster::Info RasterInfo;

void CreatePaletteCv(const RGBA *palette, int ncolors, PaletteCv& cv_pal);
void CreatePalette(Raster& raster, RGBA *palette, int ncolors);
void CreatePalette(Raster& raster, RGBA *palette, int ncolors, PaletteCv& cv);

class ImageRaster : public Raster {
	Image img;

public:
	virtual Size    GetSize();
	virtual Line    GetLine(int line);
	virtual Info    GetInfo();

	ImageRaster(const Image& img) : img(img) {}
};

class MemoryRaster : public Raster {
public:
	MemoryRaster();
	MemoryRaster(Raster& raster)                 { Load(raster); }

	virtual Size               GetSize()         { return size; }
	virtual Info               GetInfo()         { return info; }
	virtual Line               GetLine(int line);
	virtual int                GetPaletteCount() { return palette.GetCount(); }
	virtual RGBA               *GetPalette()     { return palette.Begin(); }
	virtual const RasterFormat *GetFormat()      { return &format; }

	void                       Load(Raster& raster);
	int                        GetLength() const;

private:
	RasterFormat    format;
	Info            info;
	Size            size;
	Vector< Buffer<byte> > lines;
	Vector<RGBA>    palette;
};

class StreamRaster : public Raster {
	Stream *s;
	bool    error;

	typedef StreamRaster *(*RasterFactory)();
	template <class T> static StreamRaster *FactoryFn() { return new T; }
	static void AddFormat(RasterFactory f);
	static Vector<void *>& Map();

public:
	Stream& GetStream()                 { return *s; }
	bool    Open(Stream& _s);
	bool    IsError();

	void    SetError()                  { error = true; }

	Image Load(Stream& s, const Gate2<int, int> progress = false);
	Image LoadFile(const char *fn, const Gate2<int, int> progress = false);
	Image LoadStringA(const String& s, const Gate2<int, int> progress = false);

	template <class T>
	static void Register()              { AddFormat(&StreamRaster::FactoryFn<T>); }

	static One<StreamRaster> OpenAny(Stream& s);
	static Image LoadAny(Stream& s, const Gate2<int, int> progress = false);
	static Image LoadFileAny(const char *fn, const Gate2<int, int> progress = false);
	static Image LoadStringAny(const String& s, const Gate2<int, int> progress = false);

	StreamRaster()                      { error = true; }
};

class RasterEncoder {
	Size           size, dots;
	Point          hotspot;
	RGBA          *line;
	Buffer<byte>   scanline;
	int            line_bytes;
	Buffer<RGBA>   h;
	Buffer<RGBA>   palette;
	One<PaletteCv> palette_cv;

	RGBA          *Pal();

protected:
	RasterFormat   format;
	void           SetLine(RGBA *_line);

public:
	virtual int  GetPaletteCount();
	virtual void Start(Size sz) = 0;
	virtual void WriteLineRaw(const byte *data) = 0;

	void WriteLine();
	void WriteLine(const RGBA *s);

	const RasterFormat& GetFormat() const        { return format; }
	const RGBA         *GetPalette();
	const PaletteCv    *GetPaletteCv()           { return ~palette_cv; }

	operator RGBA *()                            { return line; }
	RGBA *operator~()                            { return line; }
	Size GetSize() const                         { return size; }
	int  GetWidth() const                        { return GetSize().cx; }
	int  GetHeight() const                       { return GetSize().cy; }

	void  SetHotSpot(Point p)                    { hotspot = p; }
	Point GetHotSpot() const                     { return hotspot; }

	void SetDots(Size _dots)                     { dots = _dots; }
	Size GetDots() const                         { return dots; }

	void SetPalette(const RGBA *palette);
	void SetPalette(Raster& pal_raster);

	void Create(Size sz);
	void Create(int cx, int cy)                  { Create(Size(cx, cy)); }

	void Create(Size sz, const RGBA *palette);
	void Create(int cx, int cy, const RGBA *palette);
	void Create(Size sz, Raster& pal_raster);
	void Create(int cx, int cy, Raster& pal_raster);

	RasterEncoder();
	virtual ~RasterEncoder();
};

class ImageEncoder : public RasterEncoder {
	int         ii;
	ImageBuffer ib;

public:
	virtual void Start(Size sz);
	virtual void WriteLineRaw(const byte *data);

	Size GetSize() const                { return ib.GetSize(); }
	int  GetWidth() const               { return GetSize().cx; }
	int  GetHeight() const              { return GetSize().cy; }

	operator const RGBA *()             { return Image(ib); }
	operator Image()                    { return Image(ib); }
};

class StreamRasterEncoder : public RasterEncoder {
	Stream *s;

public:
	Stream& GetStream()                 { return *s; }
	void    SetStream(Stream& _s)       { s = &_s; }

	void    Save(Stream& s, Raster& raster);
	bool    SaveFile(const char *fn, Raster& raster);
	String  SaveString(Raster& raster);

	void    Save(Stream& s, const Image& img);
	bool    SaveFile(const char *fn, const Image& img);
	String  SaveString(const Image& img);
};
#line 324 "u:\\uppsrc\\draw\\Image.h"
#line 1 "u:\\uppsrc\\draw\\ImageOp.h"
Image CreateImage(Size sz, Color color);
Image SetColorKeepAlpha(const Image& img, Color c);

Image WithHotSpots(const Image& m, int x1, int y1, int x2, int y2);
Image WithHotSpot(const Image& m, int x1, int y1);

void Over(ImageBuffer& dest, Point p, const Image& src, const Rect& srect);
void Copy(ImageBuffer& dest, Point p, const Image& src, const Rect& srect);

void  Copy(Image& dest, Point p, const Image& src, const Rect& srect);
void  Over(Image& dest, Point p, const Image& src, const Rect& srect);

void  OverStraightOpaque(ImageBuffer& dest, Point p, const Image& src, const Rect& srect);
void  OverStraightOpaque(Image& dest, Point p, const Image& _src, const Rect& srect);

void  Crop(RasterEncoder& tgt, Raster& img, const Rect& rc);
Image Crop(const Image& img, const Rect& rc);
Image Crop(const Image& img, int x, int y, int cx, int cy);

Image ColorMask(const Image& src, Color transparent);

void  CanvasSize(RasterEncoder& tgt, Raster& img, int cx, int cy);
Image CanvasSize(const Image& img, int cx, int cy);

Image AssignAlpha(const Image& img, const Image& new_alpha);

Image Grayscale(const Image& img);
Image Grayscale(const Image& img, int amount);
Image Contrast(const Image& img, int amount = 256);

Image HorzFadeOut(int cx, int cy, Color color);
Image HorzFadeOut(Size sz, Color color);

class RescaleImage {
	Raster       *src;
	Size          tsz;
	Vector<dword> horz;
	Vector<dword> vert;
	void        (*row_proc)(dword *dest, const RGBA *src, const dword *map);
	Size          size;
	int           cx4;
	int           count;
	int           segment;
	int           entry;
	int           step;
	int           segspan;
	bool          bigseg;
	Buffer<dword> row_buffers;
	int           first;
	int           full;
	const dword  *offsets;
	int           offset;
	int           y;

	struct Ln {
		RasterLine line;
		int        ii;
	};

	Ln            cache[4];
	int           cii;
	const RGBA   *GetLine(int i);

public:
	void Create(Size sz, Raster& src, const Rect& src_rc);
	void Get(RGBA *line);
};

void DrawRasterData(Draw& w, int x, int y, int cx, int cy, const String& data);

void  Rescale(RasterEncoder& tgt, Size sz, Raster& src, const Rect& src_rc);
Image Rescale(const Image& src, Size sz, const Rect& src_rc);
Image Rescale(const Image& src, Size sz);
Image Rescale(const Image& src, int cx, int cy);

struct ImageFilter9 {
	virtual RGBA operator()(const RGBA **mx) = 0;
	virtual ~ImageFilter9() {}
};

Image Filter(const Image& img, ImageFilter9& filter);
void  Filter(RasterEncoder& target, Raster& src, ImageFilter9& filter);

Image Etched(const Image& img);
Image Sharpen(const Image& img, int amount = 100);

Image RotateClockwise(const Image& img);
Image RotateAntiClockwise(const Image& img);
Image MirrorHorz(const Image& img);
Image MirrorVert(const Image& img);
Image Rotate(const Image& m, int angle);


Image Colorize(const Image& img, Color color, int alpha = 100);
Image Equalight(const Image& img, int thold = 10);



int   Diff(RGBA a, RGBA b);
Image Unglyph(const Image& m, Color& c, double& factor);
Image Unglyph(const Image& m, Color& c);
Image Unglyph(const Image& m);
Image VertBlend(Image img1, Image img2, int y0, int y1);
Image HorzBlend(Image img1, Image img2, int x0, int x1);
Image HorzSymm(Image src);

enum {
	IMAGECONTENT_VERTDUP = 1,
	IMAGECONTENT_HORZDUP = 2,
	IMAGECONTENT_OPAQUEBODY = 4,
};

int    ClassifyContent(const Image& m, const Rect& rect);

Image  RecreateAlpha(const Image& overwhite, const Image& overblack);
int    ImageMargin(const Image& m, int p, int dist);

struct ChPartMaker {
	Image image;
	Color border;
	Color bg;

	bool  t, b, l, r;
	byte  tl, tr, bl, br;

	void ResetShape();
	Image Make() const;

	ChPartMaker(const Image& m);
};



struct ImageMaker {
	virtual String Key() const = 0;
	virtual Image  Make() const = 0;
	virtual ~ImageMaker() {}
};

Image MakeImage(const ImageMaker& m);
Image MakeImage(const Image& image, Image (*make)(const Image& image));

void  SetMakeImageCacheSize(int m);
void  SetMakeImageCacheMax(int m);

Image MakeImagePaintOnly(const ImageMaker& m);

Image CachedRescale(const Image& m, Size sz, const Rect& src);
Image CachedRescale(const Image& m, Size sz);
Image CachedRescalePaintOnly(const Image& m, Size sz, const Rect& src);
Image CachedRescalePaintOnly(const Image& m, Size sz);

Image Magnify(const Image& img, int nx, int ny);
#line 325 "u:\\uppsrc\\draw\\Image.h"




Image Win32Icon(LPCSTR id, int iconsize = 0);
Image Win32Icon(int id, int iconsize = 0);
Image Win32Cursor(LPCSTR id);
Image Win32Cursor(int id);
HICON IconWin32(const Image& img, bool cursor = false);
Image Win32DllIcon(const char *dll, int ii, bool large);

#line 337 "u:\\uppsrc\\draw\\Image.h"
#line 338 "u:\\uppsrc\\draw\\Image.h"




#line 99 "u:/uppsrc\\Draw/Draw.h"

void EnterDraw();
void LeaveDraw();

struct DrawLock {
	DrawLock()    { EnterDraw(); }
	~DrawLock()   { LeaveDraw(); }
};

const int FONT_V = 40;

class FontInfo;

class Font : AssignValueTypeNo<Font, FONT_V, Moveable<Font> >{
	word  face;
	word  flags;
	int16 height;
	int16 width;

public:
	enum {
		FIXEDPITCH  = 0x0001,
		SCALEABLE   = 0x0002,
		SYMBOLTYPE  = 0x0004,
		COMPOSED    = 0x0008,
		LOCAL       = 0x0010,
	};

	static int    GetFaceCount();
	static String GetFaceName(int index);
	static int    FindFaceNameIndex(const char *name);
	static dword  GetFaceInfo(int index);

	enum {
		STDFONT,
		SCREEN_SERIF,
		SCREEN_SANS,
		SCREEN_FIXED,
		ROMAN,
		ARIAL,
		COURIER,
		SYMBOL,

		WINGDINGS,
		TAHOMA,
	#line 145 "u:/uppsrc\\Draw/Draw.h"
		OTHER,
	};

	int    GetFace() const          { return face; }
	int    GetHeight() const        { return height; }
	int    GetWidth() const         { return width; }
	bool   IsBold() const           { return flags & 0x8000; }
	bool   IsItalic() const         { return flags & 0x4000; }
	bool   IsUnderline() const      { return flags & 0x2000; }
	bool   IsStrikeout() const      { return flags & 0x1000; }
	bool   IsNonAntiAliased() const { return flags & 0x800; }
	bool   IsTrueTypeOnly() const   { return flags & 0x400; }
	String GetFaceName() const;
	dword  GetFaceInfo() const;

	FontInfo Info() const;

	Font& Face(int n)            { face = n; return *this; }
	Font& Height(int n)          { height = n; return *this; }
	Font& Width(int n)           { width = n; return *this; }
	Font& Bold()                 { flags |= 0x8000; return *this; }
	Font& NoBold()               { flags &= ~0x8000; return *this; }
	Font& Bold(bool b)           { return b ? Bold() : NoBold(); }
	Font& Italic()               { flags |= 0x4000; return *this; }
	Font& NoItalic()             { flags &= ~0x4000; return *this; }
	Font& Italic(bool b)         { return b ? Italic() : NoItalic(); }
	Font& Underline()            { flags |= 0x2000; return *this; }
	Font& NoUnderline()          { flags &= ~0x2000; return *this; }
	Font& Underline(bool b)      { return b ? Underline() : NoUnderline(); }
	Font& Strikeout()            { flags |= 0x1000; return *this; }
	Font& NoStrikeout()          { flags &= ~0x1000; return *this; }
	Font& Strikeout(bool b)      { return b ? Strikeout() : NoStrikeout(); }
	Font& NonAntiAliased()       { flags |= 0x800; return *this; }
	Font& NoNonAntiAliased()     { flags &= ~0x800; return *this; }
	Font& NonAntiAliased(bool b) { return b ? NonAntiAliased() : NoNonAntiAliased(); }
	Font& TrueTypeOnly()         { flags |= 0x400; return *this; }
	Font& NoTrueTypeOnly()       { flags &= ~0x400; return *this; }
	Font& TrueTypeOnly(bool b)   { return b ? TrueTypeOnly() : NoTrueTypeOnly(); }
	Font& FaceName(const String& name);

	Font  operator()() const       { return *this; }
	Font  operator()(int n) const  { return Font(*this).Height(n); }

	void  Serialize(Stream& s);

	bool  operator==(Font f) const { return face == f.face && flags == f.flags &&
	                                        width == f.width && height == f.height; }
	bool  operator!=(Font f) const { return !operator==(f); }

	dword GetHashValue() const     { return ((LONG)(((WORD)((DWORD_PTR)(flags) & 0xffff)) | ((DWORD)((WORD)((DWORD_PTR)(width) & 0xffff))) << 16)) ^ ((LONG)(((WORD)((DWORD_PTR)(face) & 0xffff)) | ((DWORD)((WORD)((DWORD_PTR)(height) & 0xffff))) << 16)); }
	bool  IsNull() const           { return face == 0xffff; }

	Font()                         { height = width = 0; face = flags = 0; }
	Font(int _face, int _height)   { face = _face; height = _height; flags = 0; width = 0; }
	Font(const Nuller&)            { face = 0xffff; height = width = 0; flags = 0; }

	operator Value() const         { return RichValue<Font>(*this); }
	Font(const Value& q)           { *this = RichValue<Font>::Extract(q); }
};

template<>
inline bool IsNull(const Font& f)            { return f.IsNull(); }

template<>
inline unsigned GetHashValue(const Font& f)  { return f.GetHashValue(); }

template<>
String AsString(const Font& f);

class FontInfo : Moveable<FontInfo> {
	struct CharMetrics : Moveable<CharMetrics> {
		int  width;
		int  lspc;
		int  rspc;

		bool operator==(const CharMetrics& b) const
		     { return width == b.width && lspc == b.lspc && rspc == b.rspc; }
	};

	struct Kinfo : Moveable<Kinfo> {
		CharMetrics std;
		byte       *flags;

		Kinfo() {
			flags = 0;
		}
		~Kinfo() {
			if(flags)
				delete[] flags;
		}
	};

	struct Data : public Link<Data, 2> {
		void         GetMetrics(CharMetrics *t, int from, int count);




		int          refcount;
		Font         font;
		int          angle;
		int          device;

		HFONT        hfont;
	#line 250 "u:/uppsrc\\Draw/Draw.h"




		int          ascent;
		int          descent;
		int          external;
		int          internal;
		int          height;
		int          lineheight;
		int          overhang;
		Size         offset;
		int          avewidth;
		int          maxwidth;
		int          firstchar;
		int          charcount;
		int          default_char;

		CharMetrics *base[64];

		Mutex         xmutex;
		Vector<Kinfo> kinfo;
		VectorMap<dword, CharMetrics> xx;

		bool         fixedpitch;
		bool         scaleable;
		int          spacebefore;
		int          spaceafter;









		VectorMap<dword, int> kerning;

		Data();
		~Data();
	};

	Data *ptr;
	int   charset;

	friend class Draw;

	CharMetrics       *CreateMetricsPage(int page) const;
	CharMetrics       *GetPage(int page) const;
	void               ComposeMetrics(Font fnt, CharMetrics *m, int from) const;
	CharMetrics        GetCM(int c) const;

	void       Release();
	void       Retain(const FontInfo& f);
	FontInfo(Data *ptr) : ptr(ptr)       { charset = 255; }

	bool        IsEqual(byte charset, Font f, int angle, int device) const;
	CharMetrics GetComposedMetrics(int c);

public:
	int        GetAscent() const                  { return ptr->ascent; }
	int        GetDescent() const                 { return ptr->descent; }
	int        GetExternal() const                { return ptr->external; }
	int        GetInternal() const                { return ptr->internal; }
	int        GetHeight() const                  { return ptr->height; }
	int        GetLineHeight() const              { return ptr->lineheight; }
	int        GetOverhang() const                { return ptr->overhang; }
	int        GetAveWidth() const                { return ptr->avewidth; }
	int        GetMaxWidth() const                { return ptr->maxwidth; }
	int        GetWidth(int c) const;
	int        operator[](int c) const            { return GetWidth(c); }
	int        GetLeftSpace(int c) const;
	int        GetRightSpace(int c) const;
	int        GetKerning(int c1, int c2) const   { return ptr->kerning.Get(((LONG)(((WORD)((DWORD_PTR)(c1) & 0xffff)) | ((DWORD)((WORD)((DWORD_PTR)(c2) & 0xffff))) << 16)), 0); }
	bool       IsFixedPitch() const               { return ptr->fixedpitch; }
	bool       IsScaleable() const                { return ptr->scaleable; }

	Font       GetFont() const                    { return ptr->font; }
	int        GetFontHeight() const              { return ptr->font.GetHeight(); }





	HFONT      GetHFONT() const                   { return ptr->hfont; }
#line 337 "u:/uppsrc\\Draw/Draw.h"

	void       Clear()                            { Release(); ptr = 0; }
	bool       IsEmpty() const                    { return !ptr; }
	operator   bool() const                       { return ptr; }

	FontInfo(const FontInfo& f);
	FontInfo& operator=(const FontInfo& f);

	FontInfo()                                    { ptr = 0; charset = 255; }
	~FontInfo()                                   { Release(); }
};

Font StdFont();

inline Font StdFont(int h)                        { return StdFont().Height(h); }

struct ScreenSans : public Font  { ScreenSans(int n = 0) : Font(SCREEN_SANS, n) {} };
struct ScreenSerif : public Font { ScreenSerif(int n = 0) : Font(SCREEN_SERIF, n) {} };
struct ScreenFixed : public Font { ScreenFixed(int n = 0) : Font(SCREEN_FIXED, n) {} };

struct Roman     : public Font { Roman(int n) : Font(ROMAN, n) {} };
struct Arial     : public Font { Arial(int n) : Font(ARIAL, n) {} };
struct Courier   : public Font { Courier(int n) : Font(COURIER, n) {} };
struct Symbol    : public Font { Symbol(int n) : Font(SYMBOL, n) {} };


struct WingDings : public Font { WingDings(int n) : Font(WINGDINGS, n) {} };
struct Tahoma    : public Font { Tahoma(int n) : Font(TAHOMA, n) {} };
#line 366 "u:/uppsrc\\Draw/Draw.h"



HPALETTE GetQlibPalette();
#line 371 "u:/uppsrc\\Draw/Draw.h"
#line 372 "u:/uppsrc\\Draw/Draw.h"

Size GetTextSize(const wchar *text, Font font, int n = -1);
Size GetTextSize(const WString& text, Font font);
Size GetTextSize(const char *text, byte charset, Font font, int n = -1);
Size GetTextSize(const char *text, Font font, int n = -1);
Size GetTextSize(const String& text, Font font);

enum {
	PEN_NULL = -1,
	PEN_SOLID = -2,
	PEN_DASH = -3,

	PEN_DOT = -4,
	PEN_DASHDOT = -5,
	PEN_DASHDOTDOT = -6,
#line 388 "u:/uppsrc\\Draw/Draw.h"
};

class Image;

struct DrawingPos;


Color SBlack();
Color SGray();
Color SLtGray();
Color SWhiteGray();
Color SWhite();
Color SRed();
Color SGreen();
Color SBrown();
Color SBlue();
Color SMagenta();
Color SCyan();
Color SYellow();
Color SLtRed();
Color SLtGreen();
Color SLtYellow();
Color SLtBlue();
Color SLtMagenta();
Color SLtCyan();


Color SColorPaper();
Color SColorText();
Color SColorHighlight();
Color SColorHighlightText();
Color SColorMenu();
Color SColorMenuText();
Color SColorInfo();
Color SColorInfoText();
Color SColorMark();
Color SColorDisabled();
Color SColorLight();
Color SColorFace();
Color SColorShadow();

Color SColorLtFace();
Color SColorDkShadow();


void SBlack_Write(Color c);
void SGray_Write(Color c);
void SLtGray_Write(Color c);
void SWhiteGray_Write(Color c);
void SWhite_Write(Color c);
void SRed_Write(Color c);
void SGreen_Write(Color c);
void SBrown_Write(Color c);
void SBlue_Write(Color c);
void SMagenta_Write(Color c);
void SCyan_Write(Color c);
void SYellow_Write(Color c);
void SLtRed_Write(Color c);
void SLtGreen_Write(Color c);
void SLtYellow_Write(Color c);
void SLtBlue_Write(Color c);
void SLtMagenta_Write(Color c);
void SLtCyan_Write(Color c);

void SColorPaper_Write(Color c);
void SColorText_Write(Color c);
void SColorHighlight_Write(Color c);
void SColorHighlightText_Write(Color c);
void SColorMenu_Write(Color c);
void SColorMenuText_Write(Color c);
void SColorInfo_Write(Color c);
void SColorInfoText_Write(Color c);
void SColorMark_Write(Color c);
void SColorDisabled_Write(Color c);
void SColorLight_Write(Color c);
void SColorFace_Write(Color c);
void SColorShadow_Write(Color c);

void SColorLtFace_Write(Color c);
void SColorDkShadow_Write(Color c);


inline Color InvertColor() { return Color(255, 0); }
inline Color DefaultInk() { return Black(); }

class Draw {
protected:
	bool      palette:1;
	bool      color16:1;
	bool      printer:1;
	bool      pixels:1;
	bool      aborted:1;
	bool      backdraw:1;
	bool      is_mono:1;

	static bool      sFini;

	enum { LRU, HASH };
	static FontInfo::Data *GetFontHash(int hash);
	static FontInfo::Data *GetFontLru();
	static int       FontCached;

	static bool      StdFontSizeSet;
	static Size      StdFontSize;
	static Font      AStdFont;

	typedef Link<FontInfo::Data, 2> FontLink;

	Size   pagePixels;
	Size   pageMMs;
	Size   inchPixels;
	Size   sheetPixels;
	Point  pageOffset;

	Draw();

	friend bool DrawDrawing(Draw& w, Stream& s, const Rect& target, Size sz);

	friend class  BackRectDraw;
	friend class  ImageDraw;
	friend class  FontInfo;
	friend class  Font;

	friend void StaticExitDraw_();
	friend Font StdFont();

	static void      InitColors();
	static void      InitFonts();
	static void      FreeFonts();
	static void      Release(FontInfo::Data *font);

	int       device;
	FontInfo  lastFont;

	Point        actual_offset;
	struct Cloff : Moveable<Cloff> {
		Point org;

		HRGN  hrgn;
	#line 528 "u:/uppsrc\\Draw/Draw.h"




		Rect  drawingclip;
	};
	Array<Cloff> cloff;
	Rect         drawingclip;

	static void      InitPlatformFonts();

	enum FontHashConst { FONTHASH = 97 };

	void ComposeText(int x, int y, int angle, const wchar *text, Font font, Color ink,
                     int n, const int *dx);



	static int __stdcall AddFace(const LOGFONT *logfont, const TEXTMETRIC *, dword type,
	                            LPARAM param);
	static int       EnumFace(HDC hdc, const char *face);
	static void      ForceFace(HDC hdc, const char *face, const char *aface);
	static void      Win32__InitColors();
	static FontInfo  Acquire(Font font, HDC hdc, int angle, int device);

	HDC       handle;
	COLORREF  lastTextColor;
	Color     lastColor;
	HBRUSH    orgBrush;
	HBRUSH    actBrush;
	HFONT     orgFont;
	HPEN      orgPen;
	HPEN      actPen;
	int       lastPen;
	Color     lastPenColor;

	void   Unselect0();
	void   Cinit();
	void   Init();

	void   LoadCaps();
	void   SetDevice(const char *devicename);
	void   SetPrinterMode();
	void   Reset();
	void   SetOrg();
	friend HPALETTE GetQlibPalette();

	static const char *FontScreenSans;
	static const char *FontScreenSerif;
	static const char *FontScreenFixed;
	static const char *FontRoman;
	static const char *FontArial;
	static const char *FontCourier;
	static const char *FontSymbol;
	static const char *FontWingdings;
	static const char *FontTahoma;

public:
	static bool AutoPalette();
	static void SetAutoPalette(bool ap);

#line 590 "u:/uppsrc\\Draw/Draw.h"




















public:
	static int  FontCacheMax;

	static void SinCos(int angle, double& sina, double& cosa);

	static void SetStdFont(Font font);
	static Font GetStdFont();
	static Size GetStdFontSize();
	static int  GetStdFontCy()                          { return GetStdFontSize().cy; }





	static void Flush()                                 { GdiFlush(); }
#line 626 "u:/uppsrc\\Draw/Draw.h"
#line 627 "u:/uppsrc\\Draw/Draw.h"




	bool  PaletteMode() const                           { return palette; }
	bool  IsMono() const                                { return is_mono; }

	Size  GetPagePixels() const                         { return pagePixels; }

	Size  GetPageMMs() const                            { return pageMMs; }
	Size  GetPixelsPerInch() const                      { return inchPixels; }



	bool  Pixels() const                                { return pixels; }
	bool  Dots() const                                  { return !pixels; }

	bool  IsPrinter() const                             { return printer; }
	bool  IsAborted() const                             { return aborted; }
	bool  IsBack() const                                { return backdraw; }

	bool  IsSystem() const                              { return handle; }
#line 650 "u:/uppsrc\\Draw/Draw.h"



	bool  IsDrawing() const;

	enum {
		BEGIN               = 1,
		OFFSET              = 2,
		CLIP                = 3,
		CLIPOFF             = 4,
		EXCLUDECLIP         = 5,
		INTERSECTCLIP       = 6,
		END                 = 7,
		DRAWRECT            = 8,
		DRAWIMAGE           = 9,
		DRAWMONOIMAGE       = 10,
		DRAWDRAWING         = 11,
		DRAWLINE            = 12,
		DRAWELLIPSE         = 13,
		DRAWTEXT            = 14,
		DRAWARC             = 15,
		DRAWPOLYPOLYLINE    = 16,
		DRAWPOLYPOLYPOLYGON = 17,
		DRAWDATA            = 18,
	};
	typedef void (*Drawer)(Draw&, Stream&, const DrawingPos&);

	Stream&  DrawingOp(int code);
	Stream&  PutRect(const Rect& r);

	static void  Register(int code, Drawer drawer);

	virtual void StartPage();
	virtual void EndPage();

	virtual void BeginOp();
	virtual void EndOp();
	virtual void OffsetOp(Point p);
	virtual bool ClipOp(const Rect& r);
	virtual bool ClipoffOp(const Rect& r);
	virtual bool ExcludeClipOp(const Rect& r);
	virtual bool IntersectClipOp(const Rect& r);
	virtual Rect GetClipOp() const;
	virtual bool IsPaintingOp(const Rect& r) const;

	virtual	void DrawRectOp(int x, int y, int cx, int cy, Color color);
	virtual void DrawImageOp(int x, int y, int cx, int cy, const Image& img, const Rect& src, Color color);
	virtual void DrawDataOp(int x, int y, int cx, int cy, const String& data, const char *id);
	virtual void DrawLineOp(int x1, int y1, int x2, int y2, int width, Color color);


	virtual void DrawPolyPolylineOp(const Point *vertices, int vertex_count,
	                                const int *counts, int count_count,
	                                int width, Color color, Color doxor);
	virtual void DrawPolyPolyPolygonOp(const Point *vertices, int vertex_count,
	                                   const int *subpolygon_counts, int scc,
	                                   const int *disjunct_polygon_counts, int dpcc,
	                                   Color color, int width, Color outline,
	                                   uint64 pattern, Color doxor);
	virtual void DrawArcOp(const Rect& rc, Point start, Point end, int width, Color color);
#line 711 "u:/uppsrc\\Draw/Draw.h"
	virtual void DrawEllipseOp(const Rect& r, Color color, int pen, Color pencolor);
	virtual void DrawTextOp(int x, int y, int angle, const wchar *text, Font font,
		                    Color ink, int n, const int *dx);
	virtual void DrawDrawingOp(const Rect& target, const Drawing& w);

	void  Begin()                                       { BeginOp(); }
	void  End()                                         { EndOp(); }
	void  Offset(Point p)                               { OffsetOp(p); }
	void  Offset(int x, int y);
	bool  Clip(const Rect& r)                           { return ClipOp(r); }
	bool  Clip(int x, int y, int cx, int cy);
	bool  Clipoff(const Rect& r)                        { return ClipoffOp(r); }
	bool  Clipoff(int x, int y, int cx, int cy);
	bool  ExcludeClip(const Rect& r)                    { return ExcludeClipOp(r); }
	bool  ExcludeClip(int x, int y, int cx, int cy);
	bool  IntersectClip(const Rect& r)                  { return IntersectClipOp(r); }
	bool  IntersectClip(int x, int y, int cx, int cy);
	Rect  GetClip() const                               { return GetClipOp(); }
	bool  IsPainting(const Rect& r) const               { return IsPaintingOp(r); }
	bool  IsPainting(int x, int y, int cx, int cy) const;

	Point GetOffset() const                             { return actual_offset; }

	int   GetCloffLevel() const                         { return cloff.GetCount(); }


	void DrawRect(int x, int y, int cx, int cy, Color color)
	{ DrawRectOp(x, y, cx, cy, color); }
	void DrawRect(const Rect& rect, Color color);

	void DrawImage(int x, int y, int cx, int cy, const Image& img, const Rect& src);
	void DrawImage(int x, int y, int cx, int cy, const Image& img);
	void DrawImage(int x, int y, int cx, int cy, const Image& img, const Rect& src, Color color);
	void DrawImage(int x, int y, int cx, int cy, const Image& img, Color color);

	void DrawImage(const Rect& r, const Image& img, const Rect& src);
	void DrawImage(const Rect& r, const Image& img);
	void DrawImage(const Rect& r, const Image& img, const Rect& src, Color color);
	void DrawImage(const Rect& r, const Image& img, Color color);

	void DrawImage(int x, int y, const Image& img, const Rect& src);
	void DrawImage(int x, int y, const Image& img);
	void DrawImage(int x, int y, const Image& img, const Rect& src, Color color);
	void DrawImage(int x, int y, const Image& img, Color color);

	void DrawData(int x, int y, int cx, int cy, const String& data, const char *type);
	void DrawData(const Rect& r, const String& data, const char *type);

	void DrawLine(int x1, int y1, int x2, int y2, int width = 0, Color color = DefaultInk)
	{ DrawLineOp(x1, y1, x2, y2, width, color); }
	void DrawLine(Point p1, Point p2, int width = 0, Color color = DefaultInk);

	void DrawEllipse(const Rect& r, Color color = DefaultInk,
	                 int pen = Null, Color pencolor = DefaultInk)
	{ DrawEllipseOp(r, color, pen, pencolor); }
	void DrawEllipse(int x, int y, int cx, int cy, Color color = DefaultInk,
		             int pen = Null, Color pencolor = DefaultInk);


	void DrawArc(const Rect& rc, Point start, Point end, int width = 0, Color color = DefaultInk)
	{ DrawArcOp(rc, start, end, width, color); }

	void DrawPolyPolyline(const Point *vertices, int vertex_count,
	                      const int *counts, int count_count,
	                      int width = 0, Color color = DefaultInk, Color doxor = Null)
	{ DrawPolyPolylineOp(vertices, vertex_count, counts, count_count, width, color, doxor); }
	void DrawPolyPolyline(const Vector<Point>& vertices, const Vector<int>& counts,
		                  int width = 0, Color color = DefaultInk, Color doxor = Null);
	void DrawPolyline(const Point *vertices, int count,
		              int width = 0, Color color = DefaultInk, Color doxor = Null);
	void DrawPolyline(const Vector<Point>& vertices,
		              int width = 0, Color color = DefaultInk, Color doxor = Null);

	void   DrawPolyPolyPolygon(const Point *vertices, int vertex_count,
		                       const int *subpolygon_counts, int subpolygon_count_count,
		                       const int *disjunct_polygon_counts, int disjunct_polygon_count_count,
		                       Color color = DefaultInk, int width = 0, Color outline = Null,
		                       uint64 pattern = 0, Color doxor = Null)
	{ DrawPolyPolyPolygonOp(vertices, vertex_count, subpolygon_counts, subpolygon_count_count,
		                  disjunct_polygon_counts, disjunct_polygon_count_count,
		                  color, width, outline, pattern, doxor); }

	void   DrawPolyPolyPolygon(const Vector<Point>& vertices,
	                           const Vector<int>& subpolygon_counts,
	                           const Vector<int>& disjunct_polygon_counts,
	                           Color color = DefaultInk, int width = 0, Color outline = Null, uint64 pattern = 0, Color doxor = Null);
	void   DrawPolyPolygon(const Point *vertices, int vertex_count,
	                       const int *subpolygon_counts, int subpolygon_count_count,
	                       Color color = DefaultInk, int width = 0, Color outline = Null, uint64 pattern = 0, Color doxor = Null);
	void   DrawPolyPolygon(const Vector<Point>& vertices, const Vector<int>& subpolygon_counts,
	                       Color color = DefaultInk, int width = 0, Color outline = Null, uint64 pattern = 0, Color doxor = Null);
	void   DrawPolygons(const Point *vertices, int vertex_count,
	                    const int *polygon_counts, int polygon_count_count,
	                    Color color = DefaultInk, int width = 0, Color outline = Null, uint64 pattern = 0, Color doxor = Null);
	void   DrawPolygons(const Vector<Point>& vertices, const Vector<int>& polygon_counts,
	                    Color color = DefaultInk, int width = 0, Color outline = Null, uint64 pattern = 0, Color doxor = Null);
	void   DrawPolygon(const Point *vertices, int vertex_count,
	                   Color color = DefaultInk, int width = 0, Color outline = Null, uint64 pattern = 0, Color doxor = Null);
	void   DrawPolygon(const Vector<Point>& vertices,
	                   Color color = DefaultInk, int width = 0, Color outline = Null, uint64 pattern = 0, Color doxor = Null);
#line 812 "u:/uppsrc\\Draw/Draw.h"

	void DrawDrawing(const Rect& r, const Drawing& iw) { DrawDrawingOp(r, iw); }
	void DrawDrawing(int x, int y, int cx, int cy, const Drawing& iw);

	void DrawTextA(int x, int y, int angle, const wchar *text, Font font = StdFont(),
		          Color ink = DefaultInk, int n = -1, const int *dx = 0);
	void DrawTextA(int x, int y, const wchar *text, Font font = StdFont(),
		          Color ink = DefaultInk, int n = -1, const int *dx = 0);

	void DrawTextA(int x, int y, const WString& text, Font font = StdFont(),
		          Color ink = DefaultInk, const int *dx = 0);
	void DrawTextA(int x, int y, int angle, const WString& text, Font font = StdFont(),
		          Color ink = DefaultInk, const int *dx = 0);

	void DrawTextA(int x, int y, int angle, const char *text, byte charset,
	              Font font = StdFont(), Color ink = DefaultInk, int n = -1, const int *dx = 0);
	void DrawTextA(int x, int y, const char *text, byte charset, Font font = StdFont(),
		          Color ink = DefaultInk, int n = -1, const int *dx = 0);

	void DrawTextA(int x, int y, int angle, const char *text,
	              Font font = StdFont(), Color ink = DefaultInk, int n = -1, const int *dx = 0);
	void DrawTextA(int x, int y, const char *text, Font font = StdFont(),
		          Color ink = DefaultInk, int n = -1, const int *dx = 0);

	void DrawTextA(int x, int y, const String& text, Font font = StdFont(),
		          Color ink = DefaultInk, const int *dx = 0);
	void DrawTextA(int x, int y, int angle, const String& text, Font font = StdFont(),
		          Color ink = DefaultInk, const int *dx = 0);


	bool         IsMetaFile() const                     { return device == -1; }

	COLORREF GetColor(Color color) const;

	Point LPtoDP(Point p) const;
	Point DPtoLP(Point p) const;
	Rect  LPtoDP(const Rect& r) const;
	Rect  DPtoLP(const Rect& r) const;
#line 851 "u:/uppsrc\\Draw/Draw.h"
	void SetColor(Color color);
	void SetFont(Font font, int angle = 0);
	void SetDrawPen(int width, Color color);

	Size  GetSizeCaps(int i, int j) const;
	HDC   BeginGdi();
	void  EndGdi();
	HDC   GetHandle()                    { return handle; }
	operator HDC() const                 { return handle; }
	void  Unselect();
	void  Attach(HDC ahandle)            { handle = ahandle; Init(); }
	HDC   Detach()                       { Unselect(); HDC h = handle; handle = 0; return h; }

	Draw(HDC hdc);
	virtual ~Draw();
#line 867 "u:/uppsrc\\Draw/Draw.h"























private:
	FontInfo GetFontInfo(byte charset, Font font = StdFont());
	FontInfo GetFontInfo(Font font = StdFont());
	FontInfo GetFontInfoW(Font font = StdFont());

	Size GetTextSize(const wchar *text, Font font = StdFont(), int n = -1) { return Upp::GetTextSize(text, font, n); }
	Size GetTextSize(const WString& text, Font font = StdFont()) { return Upp::GetTextSize(text, font); }
	Size GetTextSize(const char *text, byte charset, Font font = StdFont(), int n = -1) { return Upp::GetTextSize(text, charset, font); }
	Size GetTextSize(const char *text, Font font = StdFont(), int n = -1) { return Upp::GetTextSize(text, font, n); }
	Size GetTextSize(const String& text, Font font = StdFont()) { return Upp::GetTextSize(text, font); }

private:
	Draw(const Draw&);
	void operator=(const Draw&);
};

void DrawImageBandRLE(Draw& w, int x, int y, const Image& m, int minp);

class DataDrawer {
	typedef DataDrawer *(*Factory)();
	template <class T> static DataDrawer *FactoryFn() { return new T; }
	static void AddFormat(const char *id, Factory f);
	static VectorMap<String, void *>& Map();

public:
	virtual void  Open(const String& data, int cx, int cy) = 0;
	virtual void  Render(ImageBuffer& ib) = 0;
	virtual ~DataDrawer();

	static  One<DataDrawer> Create(const String& id);

	template <class T>	static void Register(const char *id)  { AddFormat(id, &DataDrawer::FactoryFn<T>); }
};

struct DrawingPos {
	Size    source;
	Size    target;
	Point   srcoff;
	Point   trgoff;
	Point   trgini;
	Vector<Point16> stack;

	bool  Identity() const                               { return source == target; }

	int   GetX(int x) const;
	int   GetY(int y) const;
	int   GetCx(int cx) const;
	int   GetCy(int cy) const;
	int   GetW(int w) const;
	Point Get(int x, int y) const;
	Point Get(Point p) const;
	Size  Get(Size sz) const;
	Rect  Get(const Rect& r) const;
	Rect  Get(int x, int y, int cx, int cy) const;

	Point operator()(int x, int y) const                 { return Get(x, y); }
	Point operator()(Point p) const                      { return Get(p); }
	Size  operator()(Size sz) const                      { return Get(sz); }
	Rect  operator()(const Rect& r) const                { return Get(r); }
	Rect  operator()(int x, int y, int cx, int cy) const { return Get(x, y, cx, cy); }

	void TransformX(int& x) const                        { x = GetX(x); }
	void TransformY(int& y) const                        { y = GetY(y); }
	void TransformW(int& w) const                        { w = GetW(w); }
	void Transform(int& x, int& y) const                 { TransformX(x); TransformY(y); }
	void Transform(Point& p) const                       { p = Get(p); }
	void Transform(Size& sz) const                       { sz = Get(sz); }
	void Transform(Rect& r) const                        { r = Get(r); }
};

class DrawerRegistrator {
public:
	DrawerRegistrator(int code, Draw::Drawer w)          { Draw::Register(code, w); }
};


class WinMetaFile;
#line 968 "u:/uppsrc\\Draw/Draw.h"

class Drawing : Moveable<Drawing> {
	Size   size;
	String data;

	friend class DrawingDraw;
	friend class Draw;

public:
	operator bool() const          { return !data.IsEmpty(); }
	Size GetSize() const           { return size; }
	void SetSize(Size sz)          { size = sz; }
	void SetSize(int cx, int cy)   { size = Size(cx, cy); }

	Size RatioSize(int cx, int cy) const;
	Size RatioSize(Size sz) const  { return RatioSize(sz.cx, sz.cy); }

	void Clear()                   { data.Clear(); size = Null; }

	void Append(Drawing& dw);

	void Serialize(Stream& s);

	bool IsNullInstance() const    { return data.IsEmpty(); }

	operator Value() const         { return RawValue<Drawing>(*this); }
	Drawing(const Value& src)      { if(!IsNull(src)) *this = RawValue<Drawing>::Extract(src); }

	Drawing()                      { size = Null; }
	Drawing(const Nuller&)         { size = Null; }




	static Drawing FromWMF(const WinMetaFile& wmf);
	static Drawing LoadWMF(const char *file);
	static Drawing ReadClipboardWMF();
	WinMetaFile AsWMF() const;
	void        WriteClipboardWMF() const;
#line 1008 "u:/uppsrc\\Draw/Draw.h"
#line 1009 "u:/uppsrc\\Draw/Draw.h"
};

class DrawingDraw : public Draw {
public:
	virtual void BeginOp();
	virtual void EndOp();
	virtual void OffsetOp(Point p);
	virtual bool ClipOp(const Rect& r);
	virtual bool ClipoffOp(const Rect& r);
	virtual bool ExcludeClipOp(const Rect& r);
	virtual bool IntersectClipOp(const Rect& r);
	virtual Rect GetClipOp() const;
	virtual bool IsPaintingOp(const Rect& r) const;

	virtual	void DrawRectOp(int x, int y, int cx, int cy, Color color);
	virtual void DrawImageOp(int x, int y, int cx, int cy, const Image& img, const Rect& src, Color color);
	virtual void DrawDataOp(int x, int y, int cx, int cy, const String& data, const char *id);
	virtual void DrawLineOp(int x1, int y1, int x2, int y2, int width, Color color);
	virtual void DrawPolyPolylineOp(const Point *vertices, int vertex_count,
	                                const int *counts, int count_count,
	                                int width, Color color, Color doxor);
	virtual void DrawPolyPolyPolygonOp(const Point *vertices, int vertex_count,
	                                   const int *subpolygon_counts, int scc,
	                                   const int *disjunct_polygon_counts, int dpcc,
	                                   Color color, int width, Color outline,
	                                   uint64 pattern, Color doxor);
	virtual void DrawEllipseOp(const Rect& r, Color color, int pen, Color pencolor);
	virtual void DrawArcOp(const Rect& rc, Point start, Point end, int pen, Color pencolor);
	virtual void DrawTextOp(int x, int y, int angle, const wchar *text, Font font,
		                    Color ink, int n, const int *dx);

	virtual void DrawDrawingOp(const Rect& target, const Drawing& w);

private:
	Size         size;
	StringStream drawing;

	void         DInit();
	void         DrawingBegin();

public:
	void     SetPixels(bool b = true)         { pixels = b; }

	Stream&  GetStream()                      { return drawing; }

	void     Create(int cx, int cy);
	void     Create(Size sz);

	Size     GetSize() const                  { return size; }

	Drawing  GetResult();
	operator Drawing()                        { return GetResult(); }

	DrawingDraw();
	DrawingDraw(int cx, int cy);
	DrawingDraw(Size sz);
	~DrawingDraw();
};

class NilDraw : public Draw {
public:
	virtual void BeginOp();
	virtual void EndOp();
	virtual void OffsetOp(Point p);
	virtual bool ClipOp(const Rect& r);
	virtual bool ClipoffOp(const Rect& r);
	virtual bool ExcludeClipOp(const Rect& r);
	virtual bool IntersectClipOp(const Rect& r);
	virtual Rect GetClipOp() const;
	virtual bool IsPaintingOp(const Rect& r) const;

	virtual	void DrawRectOp(int x, int y, int cx, int cy, Color color);
	virtual void DrawImageOp(int x, int y, int cx, int cy, const Image& img,
	                         const Rect& src, Color color);
	virtual void DrawLineOp(int x1, int y1, int x2, int y2, int width, Color color);
	virtual void DrawEllipseOp(const Rect& r, Color color, int pen, Color pencolor);
	virtual void DrawTextOp(int x, int y, int angle, const wchar *text, Font font,
		                    Color ink, int n, const int *dx);

	virtual void DrawDrawingOp(const Rect& target, const Drawing& w);

	NilDraw();
	~NilDraw();
};

class BackDraw : public Draw {
public:
	virtual bool IsPaintingOp(const Rect& r) const;

protected:

	HBITMAP hbmpold;
	HBITMAP hbmp;
#line 1103 "u:/uppsrc\\Draw/Draw.h"



	Size    size;
	Draw   *painting;
	Point   painting_offset;


public:
	void  Put(Draw& w, int x, int y);
	void  Put(Draw& w, Point p)                  { Put(w, p.x, p.y); }

	void Create(Draw& draw, int cx, int cy);
	void Create(Draw& draw, Size sz)             { Create(draw, sz.cx, sz.cy); }
	void Create(int cx, int cy);
	void Create(Size sz)                         { Create(sz.cx, sz.cy); }
	void Destroy();

	void SetPaintingDraw(Draw& w, Point off)     { painting = &w; painting_offset = off; }

	BackDraw();
	~BackDraw();
};

void         AddNotEmpty(Vector<Rect>& result, int left, int right, int top, int bottom);
bool         Subtract(const Rect& r, const Rect& sub, Vector<Rect>& result);
bool         Subtract(const Vector<Rect>& rr, const Rect& sub, Vector<Rect>& result);
Vector<Rect> Subtract(const Vector<Rect>& rr, const Rect& sub, bool& changed);
Vector<Rect> Intersect(const Vector<Rect>& b, const Rect& a, bool& changed);

void Subtract(Vector<Rect>& rr, const Rect& sub);
void Union(Vector<Rect>& rr, const Rect& add);





void DrawRect(Draw& w, const Rect& rect, const Image& img, bool ralgn = false);
void DrawRect(Draw& w, int x, int y, int cx, int cy, const Image& img, bool ra = false);

void DrawTiles(Draw& w, int x, int y, int cx, int cy, const Image& img);
void DrawTiles(Draw& w, const Rect& rect, const Image& img);

void DrawFatFrame(Draw& w, int x, int y, int cx, int cy, Color color, int n);
void DrawFatFrame(Draw& w, const Rect& r, Color color, int n);

void DrawFrame(Draw& w, int x, int y, int cx, int cy,
			   Color leftcolor, Color topcolor, Color rightcolor, Color bottomcolor);
void DrawFrame(Draw& w, const Rect& r,
			   Color leftcolor, Color topcolor, Color rightcolor, Color bottomcolor);
void DrawFrame(Draw& w, int x, int y, int cx, int cy,
			   Color topleftcolor, Color bottomrightcolor);
void DrawFrame(Draw& w, const Rect& r,
			   Color topleftcolor, Color bottomrightcolor);
void DrawFrame(Draw& w, int x, int y, int cx, int cy, Color color);
void DrawFrame(Draw& w, const Rect& r, Color color);

void DrawBorder(Draw& w, int x, int y, int cx, int cy, const ColorF *colors_ltrd);
void DrawBorder(Draw& w, const Rect& r, const ColorF *colors_ltrd);

const ColorF *BlackBorder();
const ColorF *ButtonPushBorder();
const ColorF *EdgeButtonBorder();
const ColorF *DefButtonBorder();
const ColorF *ButtonBorder();
const ColorF *InsetBorder();
const ColorF *OutsetBorder();
const ColorF *ThinOutsetBorder();
const ColorF *ThinInsetBorder();

void DrawBorder(Draw& w, int x, int y, int cx, int cy, const ColorF *(*colors_ltrd)());
void DrawBorder(Draw& w, const Rect& r, const ColorF *(*colors_ltrd)());

void DrawRectMinusRect(Draw& w, const Rect& rect, const Rect& inner, Color color);

void DrawHighlightImage(Draw& w, int x, int y, const Image& img, bool highlight = true,
                        bool enabled = true, Color maskcolor = SColorPaper);

Color GradientColor(Color fc, Color tc, int i, int n);

void DrawDragRect(Draw& w, const Rect& rect1, const Rect& rect2, const Rect& clip, int n, Color color, uint64 pattern);

enum {
	BUTTON_NORMAL, BUTTON_OK, BUTTON_HIGHLIGHT, BUTTON_PUSH, BUTTON_DISABLED, BUTTON_CHECKED,
	BUTTON_VERTICAL = 0x100,
	BUTTON_EDGE = 0x200,
	BUTTON_TOOL = 0x400,
	BUTTON_SCROLL = 0x800,
};

void DrawXPButton(Draw& w, Rect r, int type);

void DrawTextEllipsis(Draw& w, int x, int y, int cx, const char *text, const char *ellipsis,
				      Font font = StdFont(), Color ink = SColorText(), int n = -1);
void DrawTextEllipsis(Draw& w, int x, int y, int cx, const wchar *text, const char *ellipsis,
				      Font font = StdFont(), Color ink = SColorText(), int n = -1);
Size GetTLTextSize(const wchar *text, Font font = StdFont());
int  GetTLTextHeight(const wchar *s, Font font = StdFont());
void DrawTLText(Draw& draw, int x, int y, int cx, const wchar *text, Font font = StdFont(),
                Color ink = SColorText(), int accesskey = 0);


typedef String (*DrawingToPdfFnType)(const Array<Drawing>& report, Size pagesize, int margin);

void SetDrawingToPdfFn(DrawingToPdfFnType Pdf);
DrawingToPdfFnType GetDrawingToPdfFn();



#line 1 "u:\\uppsrc\\draw\\DrawWin32.h"

class WinMetaFile {
	Size size;
	mutable HENHMETAFILE hemf;

	void     ChkP() const                   { ; }
	void     Init();
	void     Pick( WinMetaFile& src);
	void     Copy(const WinMetaFile& src);

public:
	void          Attach(HENHMETAFILE emf);
	HENHMETAFILE *Detach();

	bool     IsPicked() const               { return (uintptr_t) hemf == 0xffffffff; }

	operator bool() const                   { ChkP(); return hemf; }
	Size     GetSize() const                { ChkP(); return hemf ? size : Size(0, 0); }

	void     Clear();

	void     Paint(Draw& w, const Rect& r) const;
	void     Paint(Draw& w, int x, int y, int cx, int cy) const;

	void     Serialize(Stream& s);

	void     ReadClipboard();
	void     WriteClipboard() const;
	bool     Load(const char *file);

	WinMetaFile()                                 { Init(); }
	WinMetaFile(HENHMETAFILE hemf);
	WinMetaFile(HENHMETAFILE hemf, Size sz);
	WinMetaFile(const char *file);

	WinMetaFile( WinMetaFile& src)           { Pick(src); }
	WinMetaFile(const WinMetaFile& src, int)      { Copy(src); }
	void     operator=( WinMetaFile& src)    { Clear(); Pick(src); }
	void     operator<<=(const WinMetaFile& src)  { Clear(); Copy(src); }

	~WinMetaFile()                                { Clear(); }

	HENHMETAFILE GetHEMF() const                  { ChkP(); return hemf; }
};

class WinMetaFileDraw : public Draw {
	Size size;

public:
	bool        Create(HDC hdc, int cx, int cy, const char *app = 0, const char *name = 0, const char *file = 0);
	bool        Create(int cx, int cy, const char *app = 0, const char *name = 0, const char *file = 0);
	WinMetaFile Close();

	WinMetaFileDraw() {}
	WinMetaFileDraw(HDC hdc, int cx, int cy, const char *app = 0, const char *name = 0, const char *file = 0);
	WinMetaFileDraw(int cx, int cy, const char *app = 0, const char *name = 0, const char *file = 0);
	~WinMetaFileDraw();
};
#line 60 "u:\\uppsrc\\draw\\DrawWin32.h"

class ScreenDraw : public Draw {
public:
	ScreenDraw(bool ic = false);
	~ScreenDraw();
};


class PrintDraw : public Draw {
public:
	virtual void StartPage();
	virtual void EndPage();

private:
	void  InitPrinter();
public:
	void  Abort()                                       { aborted = true; }

	PrintDraw(HDC hdc, const char *jobname);
	~PrintDraw();
};
#line 82 "u:\\uppsrc\\draw\\DrawWin32.h"

inline bool     BitBlt(HDC ddc, Point d, HDC sdc, const Rect& s, dword rop = (DWORD)0x00CC0020)
{ return BitBlt(ddc, d.x, d.y, s.Width(), s.Height(), sdc, s.left, s.top, rop); }

inline bool     StretchBlt(HDC ddc, const Rect& r, HDC sdc, const Rect& s, dword rop = (DWORD)0x00CC0020)
{ return StretchBlt(ddc, r.left, r.top, r.Width(), r.Height(), sdc, s.left, s.top, s.Width(), s.Height(), rop); }

inline bool     PatBlt(HDC dc, const Rect& r, dword rop = (DWORD)0x00F00021)
{ return PatBlt(dc, r.left, r.top, r.Width(), r.Height(), rop); }

inline void     MoveTo(HDC hdc, Point pt)                         { MoveToEx(hdc, pt.x, pt.y, 0); }
inline void     LineTo(HDC hdc, Point pt)                         { LineTo(hdc, pt.x, pt.y); }

inline void     DrawLine(HDC hdc, Point p, Point q)               { MoveTo(hdc, p); LineTo(hdc, q); }
inline void     DrawLine(HDC hdc, int px, int py, int qx, int qy) { MoveToEx(hdc, px, py, 0); LineTo(hdc, qx, qy); }


inline void     DrawArc(HDC hdc, const Rect& rc, Point p, Point q){ Arc(hdc, rc.left, rc.top, rc.right, rc.bottom, p.x, p.y, q.x, q.y); }
#line 101 "u:\\uppsrc\\draw\\DrawWin32.h"
inline void     DrawCircle(HDC hdc, int x, int y, int radius)     { Ellipse(hdc, x - radius, y - radius, x + radius + 1, y + radius + 1); }
inline void     DrawCircle(HDC hdc, Point centre, int radius)     { DrawCircle(hdc, centre.x, centre.y, radius); }
inline void     DrawEllipse(HDC hdc, const Rect& rc)              { Ellipse(hdc, rc.left, rc.top, rc.right, rc.bottom); }

inline void     DrawRect(HDC hdc, const Rect& rc)                 { Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom); }
#line 1213 "u:/uppsrc\\Draw/Draw.h"

#line 1215 "u:/uppsrc\\Draw/Draw.h"

#line 1 "u:\\uppsrc\\draw\\Display.h"
class Display {
public:
	enum {
		CURSOR   = 0x01,
		FOCUS    = 0x02,
		SELECT   = 0x04,
		READONLY = 0x08,
	};

	virtual void PaintBackground(Draw& w, const Rect& r, const Value& q,
	                             Color ink, Color paper, dword style) const;
	virtual void Paint(Draw& w, const Rect& r, const Value& q,
		               Color ink, Color paper, dword style) const;
	virtual Size GetStdSize(const Value& q) const;
	virtual Size RatioSize(const Value& q, int cx, int cy) const;



	virtual ~Display();
};

struct AttrText {
	WString text;
	Font    font;
	Color   ink;
	Color   paper;
	int     align;

	AttrText& Ink(Color c)              { ink = c; return *this; }
	AttrText& Paper(Color c)            { paper = c; return *this; }
	AttrText& SetFont(Font f)           { font = f; return *this; }
	AttrText& Align(int a)              { align = a; return *this; }
	AttrText& Left()                    { return Align(ALIGN_LEFT); }
	AttrText& Center()                  { return Align(ALIGN_CENTER); }
	AttrText& Right()                   { return Align(ALIGN_RIGHT); }

	operator Value() const;

	AttrText(const char *text);
	AttrText(const wchar *text);
	AttrText(const WString& text);

private:
	void Init();
};

const Display& StdDisplay();
const Display& StdCenterDisplay();
const Display& StdRightDisplay();

const Display& ColorDisplay();
const Display& SizeTextDisplay();
const Display& ImageDisplay();
const Display& FittedImageDisplay();
const Display& CenteredImageDisplay();
const Display& CenteredHighlightImageDisplay();
const Display& DrawingDisplay();

class ColorDisplayNull : public Display {
public:




	ColorDisplayNull(String nulltext = Null) : nulltext(nulltext) {}
#line 67 "u:\\uppsrc\\draw\\Display.h"
	virtual void Paint(Draw& w, const Rect& r, const Value& q,
		               Color ink, Color paper, dword style) const;
private:
	String nulltext;
};

class PaintRect : Moveable<PaintRect> {
protected:
	Value          value;
	const Display *display;

public:
	void     Paint(Draw& w, const Rect& r,
	               Color ink = SColorText, Color paper = SColorPaper, dword style = 0) const;
	void     Paint(Draw& w, int x, int y, int cx, int cy,
		           Color ink = SColorText, Color paper = SColorPaper, dword style = 0) const;
	Size     GetStdSize() const;
	Size     RatioSize(int cx, int cy) const;
	Size     RatioSize(Size sz) const              { return RatioSize(sz.cx, sz.cy); }

	void     SetDisplay(const Display& d)          { display = &d; }
	void     SetValue(const Value& v)              { value = v; }
	void     Set(const Display& d, const Value& v) { display = &d; value = v; }
	void     Clear()                               { display = 0; }

	const Value&   GetValue() const                { return value; }
	const Display& GetDisplay() const              { return *display; }

	operator bool() const                          { return display; }

	PaintRect();
	PaintRect(const Display& display);
	PaintRect(const Display& display, const Value& val);
};
#line 1217 "u:/uppsrc\\Draw/Draw.h"
#line 1 "u:\\uppsrc\\draw\\ImageDraw.h"
class ImageDraw : public Draw, NoCopy {
	Size    size;


	struct  Section {
		HDC     dc;
		HBITMAP hbmp, hbmpOld;
		RGBA   *pixels;

		void Init(int cx, int cy);
		~Section();
	};

	Section rgb;
	Section a;
	Draw    alpha;
#line 18 "u:\\uppsrc\\draw\\ImageDraw.h"





	bool    has_alpha;

	void Init();
	Image Get(bool pm) const;

public:
	Draw& Alpha();

	operator Image() const;

	Image GetStraight() const;

	ImageDraw(Size sz);
	ImageDraw(int cx, int cy);
	~ImageDraw();
};
#line 1218 "u:/uppsrc\\Draw/Draw.h"
#line 1 "u:\\uppsrc\\draw\\Debug.h"
String DumpLanguage(int language);
String DumpColor(Color color);
String DumpFont(Font font);
String DumpFontInfo(FontInfo fi);
String DumpAlign(int align);









class SimpleTiming
{
public:
	SimpleTiming(const char *name) : name(name)
	{
		last_ticks = start_ticks = GetTickCount();
		Upp::LockLog(), Upp::VppLog() << name << " (open) & " << start_ticks << EOL, Upp::UnlockLog();
	}

	void Show(const char *part)
	{
		int ticks = GetTickCount();
		Upp::LockLog(), Upp::VppLog() << name << " in " << (ticks - start_ticks) << ", " << part << " in " << (ticks - last_ticks) << EOL, Upp::UnlockLog();
		last_ticks = ticks;
	}

	~SimpleTiming()
	{
		int ticks = GetTickCount();
		String out;
		Upp::LockLog(), Upp::VppLog() << name << " done in " << (ticks - start_ticks) << ", last part in " << (ticks - last_ticks) << EOL, Upp::UnlockLog();
	}

private:
	String name;
	int    start_ticks;
	int    last_ticks;
};

int GdiGetFreeSpace();
#line 1219 "u:/uppsrc\\Draw/Draw.h"
#line 1 "u:\\uppsrc\\draw\\Cham.h"
enum LookOp {
	LOOK_PAINT,
	LOOK_MARGINS,
	LOOK_PAINTEDGE,
	LOOK_ISOPAQUE,
	LOOK_ISBODYOPAQUE,
};

void  ChLookFn(Value (*fn)(Draw& w, const Rect& r, const Value& look, int lookop));

Image AdjustColors(const Image& img);

void   Override(Iml& target, Iml& source, bool colored = false);
void   ColoredOverride(Iml& target, Iml& source);

void   ChReset();
void   ChFinish();

void   ChPaint(Draw& w, const Rect& r, const Value& look);
void   ChPaint(Draw& w, int x, int y, int cx, int cy, const Value& look);
void   ChPaintEdge(Draw& w, const Rect& r, const Value& look);
void   ChPaintEdge(Draw& w, int x, int y, int cx, int cy, const Value& look);
void   ChPaintBody(Draw& w, const Rect& r, const Value& look);
void   ChPaintBody(Draw& w, int x, int y, int cx, int cy, const Value& look);
Rect   ChMargins(const Value& look);
bool   ChIsOpaque(const Value& look);
bool   ChIsBodyOpaque(const Value& look);

void   DeflateMargins(Rect& r, const Rect& margin);
void   ChDeflateMargins(Rect& r, const Value& look);
void   DeflateMargins(Size& sz, const Rect& m);
void   ChDeflateMargins(Size& sz, const Value& look);
void   InflateMargins(Rect& r, const Rect& m);
void   ChInflateMargins(Rect& r, const Value& look);
void   InflateMargins(Size& sz, const Rect& m);
void   ChInflateMargins(Size& sz, const Value& look);

template <class T>
struct ChStyle {
	byte status;
	byte registered;
	T   *standard;

	const T& Standard() const      { return *standard; }
	T&       Write() const         { T& x = *(T *)this; x.status = 2; return x; }
	void     Assign(const T& src)  { *(T *)this = src; }

	ChStyle()                      { status = 0; registered = 0; standard = 0; }
};













































struct ChColor : ChStyle<ChColor> { Color value; };


struct ChInt : ChStyle<ChInt> { int value; };


struct ChValue : ChStyle<ChValue> { Value value; };


struct ChImage : ChStyle<ChImage> { Image value; };


void ChPaint(Draw& w, const Rect& r, const Value& element);
void ChPaint(Draw& w, int x, int y, int cx, int cy, const Value& element);

Value ChLookWith(const Value& look, const Image& img, Point offset = Point(0, 0));
Value ChLookWith(const Value& look, const Image& img, Color color, Point offset = Point(0, 0));
Value ChLookWith(const Value& look, const Image& img, Color (*color)(int i), int i, Point offset = Point(0, 0));


void ChRegisterStyle__(byte& state, byte& registered, void (*init)());

Value ChBorder(const ColorF *colors, const Value& face = SColorFace());
#line 1220 "u:/uppsrc\\Draw/Draw.h"

};

#line 1224 "u:/uppsrc\\Draw/Draw.h"
#line 5 "u:/uppsrc\\CtrlCore/CtrlCore.h"

namespace Upp {

enum {
	K_DELTA        = 0x010000,

	K_ALT          = 0x080000,
	K_SHIFT        = 0x040000,
	K_CTRL         = 0x020000,

	K_KEYUP        = 0x100000,

	K_MOUSEMIDDLE  = 0x200000,
	K_MOUSERIGHT   = 0x400000,
	K_MOUSELEFT    = 0x800000,
	K_MOUSEDOUBLE  = 0x1000000,
	K_MOUSETRIPLE  = 0x2000000,

	K_SHIFT_CTRL = K_SHIFT|K_CTRL,
};

#line 1 "u:\\uppsrc\\ctrlcore\\MKeys.h"




enum {





	#line 1 "u:\\uppsrc\\ctrlcore\\Win32Keys.i"
K_BACK       = 0x08 + K_DELTA,
K_BACKSPACE  = 0x08 + K_DELTA,

K_TAB        = 9,

K_SPACE      = 32,

K_RETURN     = 13,
K_ENTER      = K_RETURN,

K_SHIFT_KEY  = 0x10 + K_DELTA,
K_CTRL_KEY   = 0x11 + K_DELTA,
K_ALT_KEY    = 0x12 + K_DELTA,
K_CAPSLOCK   = 0x14 + K_DELTA,
K_ESCAPE     = 0x1B + K_DELTA,
K_PRIOR      = 0x21 + K_DELTA,
K_PAGEUP     = 0x21 + K_DELTA,
K_NEXT       = 0x22 + K_DELTA,
K_PAGEDOWN   = 0x22 + K_DELTA,
K_END        = 0x23 + K_DELTA,
K_HOME       = 0x24 + K_DELTA,
K_LEFT       = 0x25 + K_DELTA,
K_UP         = 0x26 + K_DELTA,
K_RIGHT      = 0x27 + K_DELTA,
K_DOWN       = 0x28 + K_DELTA,
K_INSERT     = 0x2D + K_DELTA,
K_DELETE     = 0x2E + K_DELTA,

K_NUMPAD0    = 0x60 + K_DELTA,
K_NUMPAD1    = 0x61 + K_DELTA,
K_NUMPAD2    = 0x62 + K_DELTA,
K_NUMPAD3    = 0x63 + K_DELTA,
K_NUMPAD4    = 0x64 + K_DELTA,
K_NUMPAD5    = 0x65 + K_DELTA,
K_NUMPAD6    = 0x66 + K_DELTA,
K_NUMPAD7    = 0x67 + K_DELTA,
K_NUMPAD8    = 0x68 + K_DELTA,
K_NUMPAD9    = 0x69 + K_DELTA,
K_MULTIPLY   = 0x6A + K_DELTA,
K_ADD        = 0x6B + K_DELTA,
K_SEPARATOR  = 0x6C + K_DELTA,
K_SUBTRACT   = 0x6D + K_DELTA,
K_DECIMAL    = 0x6E + K_DELTA,
K_DIVIDE     = 0x6F + K_DELTA,
K_SCROLL     = 0x91 + K_DELTA,

K_F1         = 0x70 + K_DELTA,
K_F2         = 0x71 + K_DELTA,
K_F3         = 0x72 + K_DELTA,
K_F4         = 0x73 + K_DELTA,
K_F5         = 0x74 + K_DELTA,
K_F6         = 0x75 + K_DELTA,
K_F7         = 0x76 + K_DELTA,
K_F8         = 0x77 + K_DELTA,
K_F9         = 0x78 + K_DELTA,
K_F10        = 0x79 + K_DELTA,
K_F11        = 0x7A + K_DELTA,
K_F12        = 0x7B + K_DELTA,

K_A          = 'A' + K_DELTA,
K_B          = 'B' + K_DELTA,
K_C          = 'C' + K_DELTA,
K_D          = 'D' + K_DELTA,
K_E          = 'E' + K_DELTA,
K_F          = 'F' + K_DELTA,
K_G          = 'G' + K_DELTA,
K_H          = 'H' + K_DELTA,
K_I          = 'I' + K_DELTA,
K_J          = 'J' + K_DELTA,
K_K          = 'K' + K_DELTA,
K_L          = 'L' + K_DELTA,
K_M          = 'M' + K_DELTA,
K_N          = 'N' + K_DELTA,
K_O          = 'O' + K_DELTA,
K_P          = 'P' + K_DELTA,
K_Q          = 'Q' + K_DELTA,
K_R          = 'R' + K_DELTA,
K_S          = 'S' + K_DELTA,
K_T          = 'T' + K_DELTA,
K_U          = 'U' + K_DELTA,
K_V          = 'V' + K_DELTA,
K_W          = 'W' + K_DELTA,
K_X          = 'X' + K_DELTA,
K_Y          = 'Y' + K_DELTA,
K_Z          = 'Z' + K_DELTA,
K_0          = '0' + K_DELTA,
K_1          = '1' + K_DELTA,
K_2          = '2' + K_DELTA,
K_3          = '3' + K_DELTA,
K_4          = '4' + K_DELTA,
K_5          = '5' + K_DELTA,
K_6          = '6' + K_DELTA,
K_7          = '7' + K_DELTA,
K_8          = '8' + K_DELTA,
K_9          = '9' + K_DELTA,

K_CTRL_LBRACKET  = K_CTRL|219|K_DELTA,
K_CTRL_RBRACKET  = K_CTRL|221|K_DELTA,
K_CTRL_MINUS     = K_CTRL|0xbd|K_DELTA,
K_CTRL_GRAVE     = K_CTRL|0xc0|K_DELTA,
K_CTRL_SLASH     = K_CTRL|0xbf|K_DELTA,
K_CTRL_BACKSLASH = K_CTRL|0xdc|K_DELTA,
K_CTRL_COMMA     = K_CTRL|0xbc|K_DELTA,
K_CTRL_PERIOD    = K_CTRL|0xbe|K_DELTA,
K_CTRL_SEMICOLON = K_CTRL|0xbe|K_DELTA,
K_CTRL_EQUAL     = K_CTRL|0xbb|K_DELTA,
K_CTRL_APOSTROPHE= K_CTRL|0xde|K_DELTA,

K_BREAK      = 0x03 + K_DELTA,
#line 12 "u:\\uppsrc\\ctrlcore\\MKeys.h"
#line 13 "u:\\uppsrc\\ctrlcore\\MKeys.h"

	K_CTRL_BACK      = K_CTRL|K_BACKSPACE,
	K_CTRL_BACKSPACE = K_CTRL|K_BACKSPACE,
	K_CTRL_TAB       = K_CTRL|K_TAB,
	K_CTRL_RETURN    = K_CTRL|K_ENTER,
	K_CTRL_ENTER     = K_CTRL|K_ENTER,
	K_CTRL_ESCAPE    = K_CTRL|K_ESCAPE,
	K_CTRL_SPACE     = K_CTRL|K_SPACE,
	K_CTRL_PRIOR     = K_CTRL|K_PAGEUP,
	K_CTRL_PAGEUP    = K_CTRL|K_PAGEUP,
	K_CTRL_NEXT      = K_CTRL|K_PAGEDOWN,
	K_CTRL_PAGEDOWN  = K_CTRL|K_PAGEDOWN,
	K_CTRL_END       = K_CTRL|K_END,
	K_CTRL_HOME      = K_CTRL|K_HOME,
	K_CTRL_LEFT      = K_CTRL|K_LEFT,
	K_CTRL_UP        = K_CTRL|K_UP,
	K_CTRL_RIGHT     = K_CTRL|K_RIGHT,
	K_CTRL_DOWN      = K_CTRL|K_DOWN,
	K_CTRL_INSERT    = K_CTRL|K_INSERT,
	K_CTRL_DELETE    = K_CTRL|K_DELETE,


	K_CTRL_NUMPAD0   = K_CTRL|K_NUMPAD0,
	K_CTRL_NUMPAD1   = K_CTRL|K_NUMPAD1,
	K_CTRL_NUMPAD2   = K_CTRL|K_NUMPAD2,
	K_CTRL_NUMPAD3   = K_CTRL|K_NUMPAD3,
	K_CTRL_NUMPAD4   = K_CTRL|K_NUMPAD4,
	K_CTRL_NUMPAD5   = K_CTRL|K_NUMPAD5,
	K_CTRL_NUMPAD6   = K_CTRL|K_NUMPAD6,
	K_CTRL_NUMPAD7   = K_CTRL|K_NUMPAD7,
	K_CTRL_NUMPAD8   = K_CTRL|K_NUMPAD8,
	K_CTRL_NUMPAD9   = K_CTRL|K_NUMPAD9,
	K_CTRL_MULTIPLY  = K_CTRL|K_MULTIPLY,
	K_CTRL_ADD       = K_CTRL|K_ADD,
	K_CTRL_SEPARATOR = K_CTRL|K_SEPARATOR,
	K_CTRL_SUBTRACT  = K_CTRL|K_SUBTRACT,
	K_CTRL_DECIMAL   = K_CTRL|K_DECIMAL,
	K_CTRL_DIVIDE    = K_CTRL|K_DIVIDE,

	K_CTRL_F1        = K_CTRL|K_F1,
	K_CTRL_F2        = K_CTRL|K_F2,
	K_CTRL_F3        = K_CTRL|K_F3,
	K_CTRL_F4        = K_CTRL|K_F4,
	K_CTRL_F5        = K_CTRL|K_F5,
	K_CTRL_F6        = K_CTRL|K_F6,
	K_CTRL_F7        = K_CTRL|K_F7,
	K_CTRL_F8        = K_CTRL|K_F8,
	K_CTRL_F9        = K_CTRL|K_F9,
	K_CTRL_F10       = K_CTRL|K_F10,
	K_CTRL_F11       = K_CTRL|K_F11,
	K_CTRL_F12       = K_CTRL|K_F12,
	K_CTRL_SCROLL    = K_CTRL|K_SCROLL,

	K_CTRL_A         = K_CTRL|K_A,
	K_CTRL_B         = K_CTRL|K_B,
	K_CTRL_C         = K_CTRL|K_C,
	K_CTRL_D         = K_CTRL|K_D,
	K_CTRL_E         = K_CTRL|K_E,
	K_CTRL_F         = K_CTRL|K_F,
	K_CTRL_G         = K_CTRL|K_G,
	K_CTRL_H         = K_CTRL|K_H,
	K_CTRL_I         = K_CTRL|K_I,
	K_CTRL_J         = K_CTRL|K_J,
	K_CTRL_K         = K_CTRL|K_K,
	K_CTRL_L         = K_CTRL|K_L,
	K_CTRL_M         = K_CTRL|K_M,
	K_CTRL_N         = K_CTRL|K_N,
	K_CTRL_O         = K_CTRL|K_O,
	K_CTRL_P         = K_CTRL|K_P,
	K_CTRL_Q         = K_CTRL|K_Q,
	K_CTRL_R         = K_CTRL|K_R,
	K_CTRL_S         = K_CTRL|K_S,
	K_CTRL_T         = K_CTRL|K_T,
	K_CTRL_U         = K_CTRL|K_U,
	K_CTRL_V         = K_CTRL|K_V,
	K_CTRL_W         = K_CTRL|K_W,
	K_CTRL_X         = K_CTRL|K_X,
	K_CTRL_Y         = K_CTRL|K_Y,
	K_CTRL_Z         = K_CTRL|K_Z,
	K_CTRL_0         = K_CTRL|K_0,
	K_CTRL_1         = K_CTRL|K_1,
	K_CTRL_2         = K_CTRL|K_2,
	K_CTRL_3         = K_CTRL|K_3,
	K_CTRL_4         = K_CTRL|K_4,
	K_CTRL_5         = K_CTRL|K_5,
	K_CTRL_6         = K_CTRL|K_6,
	K_CTRL_7         = K_CTRL|K_7,
	K_CTRL_8         = K_CTRL|K_8,
	K_CTRL_9         = K_CTRL|K_9,

	K_SHIFT_BACK      = K_SHIFT|K_BACKSPACE,
	K_SHIFT_BACKSPACE = K_SHIFT|K_BACKSPACE,
	K_SHIFT_TAB       = K_SHIFT|K_TAB,
	K_SHIFT_RETURN    = K_SHIFT|K_ENTER,
	K_SHIFT_ENTER     = K_SHIFT|K_ENTER,
	K_SHIFT_ESCAPE    = K_SHIFT|K_ESCAPE,
	K_SHIFT_SPACE     = K_SHIFT|K_SPACE,
	K_SHIFT_PRIOR     = K_SHIFT|K_PAGEUP,
	K_SHIFT_PAGEUP    = K_SHIFT|K_PAGEUP,
	K_SHIFT_NEXT      = K_SHIFT|K_PAGEDOWN,
	K_SHIFT_PAGEDOWN  = K_SHIFT|K_PAGEDOWN,
	K_SHIFT_END       = K_SHIFT|K_END,
	K_SHIFT_HOME      = K_SHIFT|K_HOME,
	K_SHIFT_LEFT      = K_SHIFT|K_LEFT,
	K_SHIFT_UP        = K_SHIFT|K_UP,
	K_SHIFT_RIGHT     = K_SHIFT|K_RIGHT,
	K_SHIFT_DOWN      = K_SHIFT|K_DOWN,
	K_SHIFT_INSERT    = K_SHIFT|K_INSERT,
	K_SHIFT_DELETE    = K_SHIFT|K_DELETE,

	K_SHIFT_NUMPAD0   = K_SHIFT|K_NUMPAD0,
	K_SHIFT_NUMPAD1   = K_SHIFT|K_NUMPAD1,
	K_SHIFT_NUMPAD2   = K_SHIFT|K_NUMPAD2,
	K_SHIFT_NUMPAD3   = K_SHIFT|K_NUMPAD3,
	K_SHIFT_NUMPAD4   = K_SHIFT|K_NUMPAD4,
	K_SHIFT_NUMPAD5   = K_SHIFT|K_NUMPAD5,
	K_SHIFT_NUMPAD6   = K_SHIFT|K_NUMPAD6,
	K_SHIFT_NUMPAD7   = K_SHIFT|K_NUMPAD7,
	K_SHIFT_NUMPAD8   = K_SHIFT|K_NUMPAD8,
	K_SHIFT_NUMPAD9   = K_SHIFT|K_NUMPAD9,
	K_SHIFT_MULTIPLY  = K_SHIFT|K_MULTIPLY,
	K_SHIFT_ADD       = K_SHIFT|K_ADD,
	K_SHIFT_SEPARATOR = K_SHIFT|K_SEPARATOR,
	K_SHIFT_SUBRACT   = K_SHIFT|K_SUBTRACT,
	K_SHIFT_DECIMAL   = K_SHIFT|K_DECIMAL,
	K_SHIFT_DIVIDE    = K_SHIFT|K_DIVIDE,
	K_SHIFT_F1        = K_SHIFT|K_F1,
	K_SHIFT_F2        = K_SHIFT|K_F2,
	K_SHIFT_F3        = K_SHIFT|K_F3,
	K_SHIFT_F4        = K_SHIFT|K_F4,
	K_SHIFT_F5        = K_SHIFT|K_F5,
	K_SHIFT_F6        = K_SHIFT|K_F6,
	K_SHIFT_F7        = K_SHIFT|K_F7,
	K_SHIFT_F8        = K_SHIFT|K_F8,
	K_SHIFT_F9        = K_SHIFT|K_F9,
	K_SHIFT_F10       = K_SHIFT|K_F10,
	K_SHIFT_F11       = K_SHIFT|K_F11,
	K_SHIFT_F12       = K_SHIFT|K_F12,
	K_SHIFT_SCROLL    = K_SHIFT|K_SCROLL,

	K_SHIFT_A         = K_SHIFT|K_A,
	K_SHIFT_B         = K_SHIFT|K_B,
	K_SHIFT_C         = K_SHIFT|K_C,
	K_SHIFT_D         = K_SHIFT|K_D,
	K_SHIFT_E         = K_SHIFT|K_E,
	K_SHIFT_F         = K_SHIFT|K_F,
	K_SHIFT_G         = K_SHIFT|K_G,
	K_SHIFT_H         = K_SHIFT|K_H,
	K_SHIFT_I         = K_SHIFT|K_I,
	K_SHIFT_J         = K_SHIFT|K_J,
	K_SHIFT_K         = K_SHIFT|K_K,
	K_SHIFT_L         = K_SHIFT|K_L,
	K_SHIFT_M         = K_SHIFT|K_M,
	K_SHIFT_N         = K_SHIFT|K_N,
	K_SHIFT_O         = K_SHIFT|K_O,
	K_SHIFT_P         = K_SHIFT|K_P,
	K_SHIFT_Q         = K_SHIFT|K_Q,
	K_SHIFT_R         = K_SHIFT|K_R,
	K_SHIFT_S         = K_SHIFT|K_S,
	K_SHIFT_T         = K_SHIFT|K_T,
	K_SHIFT_U         = K_SHIFT|K_U,
	K_SHIFT_V         = K_SHIFT|K_V,
	K_SHIFT_W         = K_SHIFT|K_W,
	K_SHIFT_X         = K_SHIFT|K_X,
	K_SHIFT_Y         = K_SHIFT|K_Y,
	K_SHIFT_Z         = K_SHIFT|K_Z,
	K_SHIFT_0         = K_SHIFT|K_0,
	K_SHIFT_1         = K_SHIFT|K_1,
	K_SHIFT_2         = K_SHIFT|K_2,
	K_SHIFT_3         = K_SHIFT|K_3,
	K_SHIFT_4         = K_SHIFT|K_4,
	K_SHIFT_5         = K_SHIFT|K_5,
	K_SHIFT_6         = K_SHIFT|K_6,
	K_SHIFT_7         = K_SHIFT|K_7,
	K_SHIFT_8         = K_SHIFT|K_8,
	K_SHIFT_9         = K_SHIFT|K_9,

	K_SHIFT_CTRL_BACK      = K_SHIFT_CTRL|K_BACKSPACE,
	K_SHIFT_CTRL_BACKSPACE = K_SHIFT_CTRL|K_BACKSPACE,
	K_SHIFT_CTRL_TAB       = K_SHIFT_CTRL|K_TAB,
	K_SHIFT_CTRL_RETURN    = K_SHIFT_CTRL|K_ENTER,
	K_SHIFT_CTRL_ENTER     = K_SHIFT_CTRL|K_ENTER,
	K_SHIFT_CTRL_ESCAPE    = K_SHIFT_CTRL|K_ESCAPE,
	K_SHIFT_CTRL_SPACE     = K_SHIFT_CTRL|K_SPACE,
	K_SHIFT_CTRL_PRIOR     = K_SHIFT_CTRL|K_PAGEUP,
	K_SHIFT_CTRL_PAGEUP    = K_SHIFT_CTRL|K_PAGEUP,
	K_SHIFT_CTRL_NEXT      = K_SHIFT_CTRL|K_PAGEDOWN,
	K_SHIFT_CTRL_PAGEDOWN  = K_SHIFT_CTRL|K_PAGEDOWN,
	K_SHIFT_CTRL_END       = K_SHIFT_CTRL|K_END,
	K_SHIFT_CTRL_HOME      = K_SHIFT_CTRL|K_HOME,
	K_SHIFT_CTRL_LEFT      = K_SHIFT_CTRL|K_LEFT,
	K_SHIFT_CTRL_UP        = K_SHIFT_CTRL|K_UP,
	K_SHIFT_CTRL_RIGHT     = K_SHIFT_CTRL|K_RIGHT,
	K_SHIFT_CTRL_DOWN      = K_SHIFT_CTRL|K_DOWN,
	K_SHIFT_CTRL_INSERT    = K_SHIFT_CTRL|K_INSERT,
	K_SHIFT_CTRL_DELETE    = K_SHIFT_CTRL|K_DELETE,
	K_SHIFT_CTRL_LBRACKET  = K_SHIFT_CTRL|219|K_DELTA,
	K_SHIFT_CTRL_RBRACKET  = K_SHIFT_CTRL|221|K_DELTA,

	K_SHIFT_CTRL_NUMPAD0   = K_SHIFT_CTRL|K_NUMPAD0,
	K_SHIFT_CTRL_NUMPAD1   = K_SHIFT_CTRL|K_NUMPAD1,
	K_SHIFT_CTRL_NUMPAD2   = K_SHIFT_CTRL|K_NUMPAD2,
	K_SHIFT_CTRL_NUMPAD3   = K_SHIFT_CTRL|K_NUMPAD3,
	K_SHIFT_CTRL_NUMPAD4   = K_SHIFT_CTRL|K_NUMPAD4,
	K_SHIFT_CTRL_NUMPAD5   = K_SHIFT_CTRL|K_NUMPAD5,
	K_SHIFT_CTRL_NUMPAD6   = K_SHIFT_CTRL|K_NUMPAD6,
	K_SHIFT_CTRL_NUMPAD7   = K_SHIFT_CTRL|K_NUMPAD7,
	K_SHIFT_CTRL_NUMPAD8   = K_SHIFT_CTRL|K_NUMPAD8,
	K_SHIFT_CTRL_NUMPAD9   = K_SHIFT_CTRL|K_NUMPAD9,
	K_SHIFT_CTRL_MULTIPLY  = K_SHIFT_CTRL|K_MULTIPLY,
	K_SHIFT_CTRL_ADD       = K_SHIFT_CTRL|K_ADD,
	K_SHIFT_CTRL_SEPARATOR = K_SHIFT_CTRL|K_SEPARATOR,
	K_SHIFT_CTRL_SUBRACT   = K_SHIFT_CTRL|K_SUBTRACT,
	K_SHIFT_CTRL_DECIMAL   = K_SHIFT_CTRL|K_DECIMAL,
	K_SHIFT_CTRL_DIVIDE    = K_SHIFT_CTRL|K_DIVIDE,
	K_SHIFT_CTRL_F1        = K_SHIFT_CTRL|K_F1,
	K_SHIFT_CTRL_F2        = K_SHIFT_CTRL|K_F2,
	K_SHIFT_CTRL_F3        = K_SHIFT_CTRL|K_F3,
	K_SHIFT_CTRL_F4        = K_SHIFT_CTRL|K_F4,
	K_SHIFT_CTRL_F5        = K_SHIFT_CTRL|K_F5,
	K_SHIFT_CTRL_F6        = K_SHIFT_CTRL|K_F6,
	K_SHIFT_CTRL_F7        = K_SHIFT_CTRL|K_F7,
	K_SHIFT_CTRL_F8        = K_SHIFT_CTRL|K_F8,
	K_SHIFT_CTRL_F9        = K_SHIFT_CTRL|K_F9,
	K_SHIFT_CTRL_F10       = K_SHIFT_CTRL|K_F10,
	K_SHIFT_CTRL_F11       = K_SHIFT_CTRL|K_F11,
	K_SHIFT_CTRL_F12       = K_SHIFT_CTRL|K_F12,
	K_SHIFT_CTRL_SCROLL    = K_SHIFT_CTRL|K_SCROLL,

	K_SHIFT_CTRL_A         = K_SHIFT_CTRL|K_A,
	K_SHIFT_CTRL_B         = K_SHIFT_CTRL|K_B,
	K_SHIFT_CTRL_C         = K_SHIFT_CTRL|K_C,
	K_SHIFT_CTRL_D         = K_SHIFT_CTRL|K_D,
	K_SHIFT_CTRL_E         = K_SHIFT_CTRL|K_E,
	K_SHIFT_CTRL_F         = K_SHIFT_CTRL|K_F,
	K_SHIFT_CTRL_G         = K_SHIFT_CTRL|K_G,
	K_SHIFT_CTRL_H         = K_SHIFT_CTRL|K_H,
	K_SHIFT_CTRL_I         = K_SHIFT_CTRL|K_I,
	K_SHIFT_CTRL_J         = K_SHIFT_CTRL|K_J,
	K_SHIFT_CTRL_K         = K_SHIFT_CTRL|K_K,
	K_SHIFT_CTRL_L         = K_SHIFT_CTRL|K_L,
	K_SHIFT_CTRL_M         = K_SHIFT_CTRL|K_M,
	K_SHIFT_CTRL_N         = K_SHIFT_CTRL|K_N,
	K_SHIFT_CTRL_O         = K_SHIFT_CTRL|K_O,
	K_SHIFT_CTRL_P         = K_SHIFT_CTRL|K_P,
	K_SHIFT_CTRL_Q         = K_SHIFT_CTRL|K_Q,
	K_SHIFT_CTRL_R         = K_SHIFT_CTRL|K_R,
	K_SHIFT_CTRL_S         = K_SHIFT_CTRL|K_S,
	K_SHIFT_CTRL_T         = K_SHIFT_CTRL|K_T,
	K_SHIFT_CTRL_U         = K_SHIFT_CTRL|K_U,
	K_SHIFT_CTRL_V         = K_SHIFT_CTRL|K_V,
	K_SHIFT_CTRL_W         = K_SHIFT_CTRL|K_W,
	K_SHIFT_CTRL_X         = K_SHIFT_CTRL|K_X,
	K_SHIFT_CTRL_Y         = K_SHIFT_CTRL|K_Y,
	K_SHIFT_CTRL_Z         = K_SHIFT_CTRL|K_Z,
	K_SHIFT_CTRL_0         = K_SHIFT_CTRL|K_0,
	K_SHIFT_CTRL_1         = K_SHIFT_CTRL|K_1,
	K_SHIFT_CTRL_2         = K_SHIFT_CTRL|K_2,
	K_SHIFT_CTRL_3         = K_SHIFT_CTRL|K_3,
	K_SHIFT_CTRL_4         = K_SHIFT_CTRL|K_4,
	K_SHIFT_CTRL_5         = K_SHIFT_CTRL|K_5,
	K_SHIFT_CTRL_6         = K_SHIFT_CTRL|K_6,
	K_SHIFT_CTRL_7         = K_SHIFT_CTRL|K_7,
	K_SHIFT_CTRL_8         = K_SHIFT_CTRL|K_8,
	K_SHIFT_CTRL_9         = K_SHIFT_CTRL|K_9,

	K_ALT_BACK      = K_ALT|K_BACKSPACE,
	K_ALT_BACKSPACE = K_ALT|K_BACKSPACE,
	K_ALT_TAB       = K_ALT|K_TAB,
	K_ALT_RETURN    = K_ALT|K_ENTER,
	K_ALT_ENTER     = K_ALT|K_ENTER,
	K_ALT_ESCAPE    = K_ALT|K_ESCAPE,
	K_ALT_SPACE     = K_ALT|K_SPACE,
	K_ALT_PRIOR     = K_ALT|K_PAGEUP,
	K_ALT_PAGEUP    = K_ALT|K_PAGEUP,
	K_ALT_NEXT      = K_ALT|K_PAGEDOWN,
	K_ALT_PAGEDOWN  = K_ALT|K_PAGEDOWN,
	K_ALT_END       = K_ALT|K_END,
	K_ALT_HOME      = K_ALT|K_HOME,
	K_ALT_LEFT      = K_ALT|K_LEFT,
	K_ALT_UP        = K_ALT|K_UP,
	K_ALT_RIGHT     = K_ALT|K_RIGHT,
	K_ALT_DOWN      = K_ALT|K_DOWN,
	K_ALT_INSERT    = K_ALT|K_INSERT,
	K_ALT_DELETE    = K_ALT|K_DELETE,

	K_ALT_NUMPAD0   = K_ALT|K_NUMPAD0,
	K_ALT_NUMPAD1   = K_ALT|K_NUMPAD1,
	K_ALT_NUMPAD2   = K_ALT|K_NUMPAD2,
	K_ALT_NUMPAD3   = K_ALT|K_NUMPAD3,
	K_ALT_NUMPAD4   = K_ALT|K_NUMPAD4,
	K_ALT_NUMPAD5   = K_ALT|K_NUMPAD5,
	K_ALT_NUMPAD6   = K_ALT|K_NUMPAD6,
	K_ALT_NUMPAD7   = K_ALT|K_NUMPAD7,
	K_ALT_NUMPAD8   = K_ALT|K_NUMPAD8,
	K_ALT_NUMPAD9   = K_ALT|K_NUMPAD9,
	K_ALT_MULTIPLY  = K_ALT|K_MULTIPLY,
	K_ALT_ADD       = K_ALT|K_ADD,
	K_ALT_SEPARATOR = K_ALT|K_SEPARATOR,
	K_ALT_SUBTRACT  = K_ALT|K_SUBTRACT,
	K_ALT_DECIMAL   = K_ALT|K_DECIMAL,
	K_ALT_DIVIDE    = K_ALT|K_DIVIDE,
	K_ALT_F1        = K_ALT|K_F1,
	K_ALT_F2        = K_ALT|K_F2,
	K_ALT_F3        = K_ALT|K_F3,
	K_ALT_F4        = K_ALT|K_F4,
	K_ALT_F5        = K_ALT|K_F5,
	K_ALT_F6        = K_ALT|K_F6,
	K_ALT_F7        = K_ALT|K_F7,
	K_ALT_F8        = K_ALT|K_F8,
	K_ALT_F9        = K_ALT|K_F9,
	K_ALT_F10       = K_ALT|K_F10,
	K_ALT_F11       = K_ALT|K_F11,
	K_ALT_F12       = K_ALT|K_F12,
	K_ALT_SCROLL    = K_ALT|K_SCROLL,

	K_ALT_A         = K_ALT|K_A,
	K_ALT_B         = K_ALT|K_B,
	K_ALT_C         = K_ALT|K_C,
	K_ALT_D         = K_ALT|K_D,
	K_ALT_E         = K_ALT|K_E,
	K_ALT_F         = K_ALT|K_F,
	K_ALT_G         = K_ALT|K_G,
	K_ALT_H         = K_ALT|K_H,
	K_ALT_I         = K_ALT|K_I,
	K_ALT_J         = K_ALT|K_J,
	K_ALT_K         = K_ALT|K_K,
	K_ALT_L         = K_ALT|K_L,
	K_ALT_M         = K_ALT|K_M,
	K_ALT_N         = K_ALT|K_N,
	K_ALT_O         = K_ALT|K_O,
	K_ALT_P         = K_ALT|K_P,
	K_ALT_Q         = K_ALT|K_Q,
	K_ALT_R         = K_ALT|K_R,
	K_ALT_S         = K_ALT|K_S,
	K_ALT_T         = K_ALT|K_T,
	K_ALT_U         = K_ALT|K_U,
	K_ALT_V         = K_ALT|K_V,
	K_ALT_W         = K_ALT|K_W,
	K_ALT_X         = K_ALT|K_X,
	K_ALT_Y         = K_ALT|K_Y,
	K_ALT_Z         = K_ALT|K_Z,
	K_ALT_0         = K_ALT|K_0,
	K_ALT_1         = K_ALT|K_1,
	K_ALT_2         = K_ALT|K_2,
	K_ALT_3         = K_ALT|K_3,
	K_ALT_4         = K_ALT|K_4,
	K_ALT_5         = K_ALT|K_5,
	K_ALT_6         = K_ALT|K_6,
	K_ALT_7         = K_ALT|K_7,
	K_ALT_8         = K_ALT|K_8,
	K_ALT_9         = K_ALT|K_9,

	K_CTRL_BREAK    = K_CTRL|K_BREAK,
};
#line 27 "u:/uppsrc\\CtrlCore/CtrlCore.h"

enum {
	DELAY_MINIMAL = 0
};

void  SetTimeCallback(int delay_ms, Callback cb, void *id = 0);
void  KillTimeCallback(void *id);
bool  ExistsTimeCallback(void *id);
dword GetTimeClick();

inline
void  PostCallback(Callback cb, void *id = 0)                { SetTimeCallback(1, cb, id); }

class TimeCallback
{
public:
	~TimeCallback()                      { Kill(); }

	void Set(int delay, Callback cb)     { Upp::SetTimeCallback(delay, cb, this); }
	void Post(Callback cb)               { Upp::PostCallback(cb, this); }
	void Kill()                          { Upp::KillTimeCallback(this); }
	void KillSet(int delay, Callback cb) { Kill(); Set(delay, cb); }
	void KillPost(Callback cb)           { Kill(); Post(cb); }

private:
	byte dummy;
};

class Ctrl;

class CtrlFrame {
public:
	virtual void FrameLayout(Rect& r) = 0;
	virtual void FrameAddSize(Size& sz) = 0;
	virtual void FramePaint(Draw& w, const Rect& r);
	virtual void FrameAdd(Ctrl& parent);
	virtual void FrameRemove();
	virtual int  OverPaint() const;





	CtrlFrame() {}
	virtual ~CtrlFrame() {}
#line 73 "u:/uppsrc\\CtrlCore/CtrlCore.h"

private:
	CtrlFrame(const CtrlFrame&);
	void operator=(const CtrlFrame&);
};

struct NullFrameClass : public CtrlFrame {
	virtual void FrameLayout(Rect& r);
	virtual void FramePaint(Draw& draw, const Rect& r);
	virtual void FrameAddSize(Size& sz);
};

CtrlFrame& NullFrame();

class BorderFrame : public CtrlFrame {
public:
	virtual void FrameLayout(Rect& r);
	virtual void FramePaint(Draw& w, const Rect& r);
	virtual void FrameAddSize(Size& sz);

protected:
	const ColorF *border;

public:




	BorderFrame(const ColorF *border) : border(border) {}
#line 103 "u:/uppsrc\\CtrlCore/CtrlCore.h"
};

CtrlFrame& InsetFrame();
CtrlFrame& OutsetFrame();
CtrlFrame& ButtonFrame();
CtrlFrame& ThinInsetFrame();
CtrlFrame& ThinOutsetFrame();
CtrlFrame& BlackFrame();

CtrlFrame& XPFieldFrame();

CtrlFrame& FieldFrame();


CtrlFrame& TopSeparatorFrame();
CtrlFrame& BottomSeparatorFrame();
CtrlFrame& LeftSeparatorFrame();
CtrlFrame& RightSeparatorFrame();

void LayoutFrameLeft(Rect& r, Ctrl *ctrl, int cx);
void LayoutFrameRight(Rect& r, Ctrl *ctrl, int cx);
void LayoutFrameTop(Rect& r, Ctrl *ctrl, int cy);
void LayoutFrameBottom(Rect& r, Ctrl *ctrl, int cy);

dword GetMouseFlags();

Point GetMousePos();
dword GetMouseFlags();











inline bool GetShift()       { return !!(GetKeyState(0x10) & 0x8000); }
inline bool GetCtrl()        { return !!(GetKeyState(0x11) & 0x8000); }
inline bool GetAlt()         { return !!(GetKeyState(0x12) & 0x8000); }
inline bool GetCapsLock()    { return !!(GetKeyState(0x14) & 1); }
inline bool GetMouseLeft()   { return !!(GetKeyState(0x01) & 0x8000); }
inline bool GetMouseRight()  { return !!(GetKeyState(0x02) & 0x8000); }
inline bool GetMouseMiddle() { return !!(GetKeyState(0x04) & 0x8000); }
#line 150 "u:/uppsrc\\CtrlCore/CtrlCore.h"
#line 151 "u:/uppsrc\\CtrlCore/CtrlCore.h"






















#line 1 "u:/uppsrc\\Draw/iml_header.h"













class CtrlCoreImg {
public:


	enum {
#line 1 "u:/uppsrc\\CtrlCore/Ctrl.iml"

I_DndMove,
I_DndMove98,
I_DndNone,
I_DndNone98,
I_DndCopy,
I_DndCopy98,
I_DndData,





























































#line 20 "u:/uppsrc\\Draw/iml_header.h"
		COUNT
	};



public:
	static Upp::Iml&   Iml();

	static void        Register__()                { Register("CtrlCoreImg", Iml()); }

	static int         Find(const Upp::String& s);
	static int         Find(const char *s);
	static int         GetCount()                  { return Iml().GetCount(); }
	static Upp::String GetId(int i)                { return Iml().GetId(i); }

	static Upp::Image  Get(int i);
	static Upp::Image  Get(const char *s);
	static Upp::Image  Get(const Upp::String& s);

	static void   Set(int i, const Upp::Image& m);
	static void   Set(const char *s, const Upp::Image& m);

	static void   Reset()                     { Iml().Reset(); }



#line 1 "u:/uppsrc\\CtrlCore/Ctrl.iml"

static Upp::Image DndMove() { return Get(I_DndMove); }
static Upp::Image DndMove98() { return Get(I_DndMove98); }
static Upp::Image DndNone() { return Get(I_DndNone); }
static Upp::Image DndNone98() { return Get(I_DndNone98); }
static Upp::Image DndCopy() { return Get(I_DndCopy); }
static Upp::Image DndCopy98() { return Get(I_DndCopy98); }
static Upp::Image DndData() { return Get(I_DndData); }





























































#line 47 "u:/uppsrc\\Draw/iml_header.h"



};












#line 64 "u:/uppsrc\\Draw/iml_header.h"
#line 174 "u:/uppsrc\\CtrlCore/CtrlCore.h"

class TopWindow;
class TrayIcon;
class GLCtrl;

enum {
	DND_NONE = 0,
	DND_COPY = 1,
	DND_MOVE = 2,

	DND_ALL  = 3,
};

struct UDropTarget;

struct ClipData : Moveable<ClipData> {
	Value  data;
	String (*render)(const Value& data);

	String  Render() const                   { return (*render)(data); }

	ClipData(const Value& data, String (*render)(const Value& data));
	ClipData(const String& data);
	ClipData();
};

class PasteClip {
	friend struct UDropTarget;
	friend class  Ctrl;
	friend PasteClip sMakeDropClip(bool paste);



	UDropTarget *dt;
#line 209 "u:/uppsrc\\CtrlCore/CtrlCore.h"



	byte         action;
	byte         allowed;
	bool         paste;
	bool         accepted;
	String       fmt;
	String       data;

public:
	bool   IsAvailable(const char *fmt) const;
	String Get(const char *fmt) const;

	bool   Accept();
	bool   Accept(const char *fmt);
	String Get() const                  { return data; }
	operator String() const             { return data; }
	String operator ~() const           { return data; }

	void   Reject()                     { accepted = false; data.Clear(); }

	int    GetAction() const            { return action; }
	int    GetAllowedActions() const    { return allowed; }
	void   SetAction(int x)             { action = x; }

	bool   IsAccepted() const           { return accepted; }

	bool   IsQuery() const              { return !paste; }
	bool   IsPaste() const              { return paste; }

	PasteClip();
};

String  Unicode__(const WString& w);
WString Unicode__(const String& s);

const char *ClipFmtsText();
bool        AcceptText(PasteClip& clip);
String      GetString(PasteClip& clip);
WString     GetWString(PasteClip& clip);
String      GetTextClip(const String& text, const String& fmt);
String      GetTextClip(const WString& text, const String& fmt);
void        Append(VectorMap<String, ClipData>& data, const String& text);
void        Append(VectorMap<String, ClipData>& data, const WString& text);

const char *ClipFmtsImage();
bool        AcceptImage(PasteClip& clip);
Image       GetImage(PasteClip& clip);
String      GetImageClip(const Image& m, const String& fmt);
void        Append(VectorMap<String, ClipData>& data, const Image& img);

bool            AcceptFiles(PasteClip& clip);
Vector<String>  GetFiles(PasteClip& clip);

template <class T>
String ClipFmt()
{
	return String("U++ type: ") + typeid(T).name();
}

template <class T>
bool   Accept(PasteClip& clip)
{
	return clip.Accept(ClipFmt<T>());
}


String GetInternalDropId__(const char *type, const char *id);
void NewInternalDrop__(const void *ptr);
const void *GetInternalDropPtr__();

template <class T>
VectorMap<String, ClipData> InternalClip(const T& x, const char *id = "")
{
	NewInternalDrop__(&x);
	VectorMap<String, ClipData> d;
	d.Add(GetInternalDropId__(typeid(T).name(), id));
	return d;
}

template <class T>
bool IsAvailableInternal(PasteClip& d, const char *id = "")
{
	return d.IsAvailable(GetInternalDropId__(typeid(T).name(), id));
}

template <class T>
bool AcceptInternal(PasteClip& d, const char *id = "")
{
	return d.Accept(GetInternalDropId__(typeid(T).name(), id));
}

template <class T>
const T& GetInternal(PasteClip& d)
{
	return *(T *)GetInternalDropPtr__();
}

class Ctrl : public Pte<Ctrl> {
public:
	enum PlacementConstants {
		CENTER   = 0,
		MIDDLE   = 0,
		LEFT     = 1,
		RIGHT    = 2,
		TOP      = 1,
		BOTTOM   = 2,
		SIZE     = 3,

		MINSIZE  = -16380,
		MAXSIZE  = -16381,
		STDSIZE  = -16382,
	};

	class Logc {
		dword data;

		static int LSGN(dword d)       { return int16(d & 0x7fff | ((d & 0x4000) << 1)); }

	public:
		bool  operator==(Logc q) const { return data == q.data; }
		bool  operator!=(Logc q) const { return data != q.data; }
		int   GetAlign() const         { return (data >> 30) & 3; }
		int   GetA() const             { return LSGN(data >> 15); }
		int   GetB() const             { return LSGN(data); }
		void  SetAlign(int align)      { data = (data & ~(3 << 30)) | (align << 30); }
		void  SetA(int a)              { data = (data & ~(0x7fff << 15)) | ((a & 0x7fff) << 15); }
		void  SetB(int b)              { data = (data & ~0x7fff) | (b & 0x7fff); }
		bool  IsEmpty() const;

		Logc(int al, int a, int b)     { data = (al << 30) | ((a & 0x7fff) << 15) | (b & 0x7fff); }
		Logc()                         { data = 0xffffffff; }
	};

	struct LogPos {
		Logc x, y;

		bool operator==(LogPos b) const   { return x == b.x && y == b.y; }
		bool operator!=(LogPos b) const   { return !(*this == b); }

		LogPos(Logc x, Logc y)            : x(x), y(y) {}
		LogPos()                          {}
	};

	static Logc PosLeft(int pos, int size)       { return Logc(LEFT, pos, size); }
	static Logc PosRight(int pos, int size)      { return Logc(RIGHT, pos, size); }
	static Logc PosTop(int pos, int size)        { return Logc(TOP, pos, size); }
	static Logc PosBottom(int pos, int size)     { return Logc(BOTTOM, pos, size); }
	static Logc PosSize(int lpos, int rpos)      { return Logc(SIZE, lpos, rpos); }
	static Logc PosCenter(int size, int offset)  { return Logc(CENTER, offset, size); }
	static Logc PosCenter(int size)              { return Logc(CENTER, 0, size); }

	typedef bool (*MouseHook)(Ctrl *ctrl, bool inframe, int event, Point p,
	                          int zdelta, dword keyflags);
	typedef bool (*KeyHook)(Ctrl *ctrl, dword key, int count);
	typedef bool (*StateHook)(Ctrl *ctrl, int reason);

	static dword KEYtoK(dword);

private:
	Ctrl(Ctrl&);
	void operator=(Ctrl&);

private:
	struct Frame : Moveable<Frame> {
		CtrlFrame *frame;
		Rect16     view;

		Frame()    { view.Clear(); }
	};
	Ctrl        *parent;

	struct Scroll : Moveable<Scroll> {
		Rect rect;
		int  dx;
		int  dy;
	};

	struct MoveCtrl : Moveable<MoveCtrl> {
		Ptr<Ctrl>  ctrl;
		Rect       from;
		Rect       to;
	};

	friend struct UDropTarget;

	struct Top {

		HWND           hwnd;
		UDropTarget   *dndtgt;
#line 401 "u:/uppsrc\\CtrlCore/CtrlCore.h"



		Vector<Scroll> scroll;
		VectorMap<Ctrl *, MoveCtrl> move;
		VectorMap<Ctrl *, MoveCtrl> scroll_move;
		Ptr<Ctrl>      owner;
	};

	Top         *top;
	int          exitcode;

	Ctrl        *prev, *next;
	Ctrl        *firstchild, *lastchild;
	LogPos       pos;
	Rect16       rect;
	Mitor<Frame> frame;
	String       info;
	int16        caretx, carety, caretcx, caretcy;

	byte         overpaint;

	bool         unicode:1;


	bool         activex:1;
#line 428 "u:/uppsrc\\CtrlCore/CtrlCore.h"
	bool         fullrefresh:1;

	bool         transparent:1;
	bool         visible:1;
	bool         enabled:1;
	bool         wantfocus:1;
	bool         initfocus:1;
	bool         activepopup:1;
	bool         editable:1;
	bool         modify:1;
	bool         ignoremouse:1;
	bool         inframe:1;
	bool         inloop:1;
	bool         isopen:1;
	bool         popup:1;
	bool         popupgrab:1;
	byte         backpaint:2;
	bool         GLX:1;
	bool         hasdhctrl:1;

	bool         akv:1;
	bool         destroying:1;




	static  Ptr<Ctrl> eventCtrl;
	static  Ptr<Ctrl> mouseCtrl;
	static  Point     mousepos;
	static  Point     leftmousepos, rightmousepos, middlemousepos;
	static  Ptr<Ctrl> focusCtrl;
	static  Ptr<Ctrl> focusCtrlWnd;
	static  Ptr<Ctrl> lastActiveWnd;
	static  Ptr<Ctrl> caretCtrl;
	static  Rect      caretRect;
	static  Ptr<Ctrl> captureCtrl;
	static  bool      ignoreclick;
	static  bool      ignorekeyup;
	static  bool      mouseinview;
	static  bool      mouseinframe;
	static  bool      globalbackpaint;
	static  int       LoopLevel;
	static  Ctrl     *LoopCtrl;

	static  Ptr<Ctrl>           defferedSetFocus;
	static  Vector< Ptr<Ctrl> > defferedChildLostFocus;

	static  Ptr<Ctrl> repeatTopCtrl;
	static  Point     repeatMousePos;

	static  Vector<MouseHook>& mousehook();
	static  Vector<KeyHook>&   keyhook();
	static  Vector<StateHook>& statehook();





	static Ptr<Ctrl> FocusCtrl() { return focusCtrl; }
	static void      FocusCtrl(Ptr<Ctrl> fc) { focusCtrl = fc; }
#line 489 "u:/uppsrc\\CtrlCore/CtrlCore.h"

	void    StateDeep(int state);

	void    RemoveChild0(Ctrl *q);

	static  void ChSync();

	static int       FindMoveCtrl(const VectorMap<Ctrl *, MoveCtrl>& m, Ctrl *x);
	static MoveCtrl *FindMoveCtrlPtr(VectorMap<Ctrl *, MoveCtrl>& m, Ctrl *x);

	Size    PosVal(int v) const;
	void    Lay1(int& pos, int& r, int align, int a, int b, int sz) const;
	Rect    CalcRect(LogPos pos, const Rect& prect, const Rect& pview) const;
	Rect    CalcRect(const Rect& prect, const Rect& pview) const;
	void    UpdateRect0();
	void    UpdateRect();
	void    SetPos0(LogPos p, bool inframe);
	void    SetWndRect(const Rect& r);
	void    SyncMoves();

	static  void  EndIgnore();
	static  void  LRep();
	static  void  LHold();
	static  void  LRepeat();
	static  void  RRep();
	static  void  RHold();
	static  void  RRepeat();
	static  void  MRep();
	static  void  MHold();
	static  void  MRepeat();
	static  void  KillRepeat();
	static  void  CheckMouseCtrl();
	static  void  DoCursorShape();
	static  Image& CursorOverride();
	bool    IsMouseActive() const;
	Image   MouseEventH(int event, Point p, int zdelta, dword keyflags);
	Image   FrameMouseEventH(int event, Point p, int zdelta, dword keyflags);
	Image   MEvent0(int e, Point p, int zd);
	Image   DispatchMouse(int e, Point p, int zd = 0);
	Image   DispatchMouseEvent(int e, Point p, int zd = 0);
	void    LogMouseEvent(const char *f, const Ctrl *ctrl, int event, Point p, int zdelta, dword keyflags);

	void    StateH(int reason);

	void    RefreshAccessKeys();
	void    RefreshAccessKeysDo(bool vis);
	static  void  DefferedFocusSync();
	static  void  SyncCaret();
	static  bool  DispatchKey(dword keycode, int count);
	void    SetFocusWnd();
	void    KillFocusWnd();

	static Ptr<Ctrl> dndctrl;
	static Point     dndpos;
	static bool      dndframe;
	static PasteClip dndclip;

	void    DnD(Point p, PasteClip& clip);
	static void DnDRepeat();
	static void DnDLeave();

	void    SyncLayout(int force = 0);
	bool    AddScroll(const Rect& sr, int dx, int dy);
	Rect    GetClippedView();
	void    ScrollRefresh(const Rect& r, int dx, int dy);
	void    SyncScroll();
	void    CtrlPaint(Draw& w, const Rect& clip);
	void    RemoveFullRefresh();
	bool    PaintOpaqueAreas(Draw& w, const Rect& r, const Rect& clip, bool nochild = false);
	void    GatherTransparentAreas(Vector<Rect>& area, Draw& w, Rect r, const Rect& clip);
	Ctrl   *FindBestOpaque(const Rect& clip);
	void    UpdateArea0(Draw& draw, const Rect& clip, int backpaint);
	void    UpdateArea(Draw& draw, const Rect& clip);
	Ctrl   *GetTopRect(Rect& r, bool inframe);
	void    DoSync(Ctrl *q, Rect r, bool inframe);
	bool    HasDHCtrl() const;
	void    SyncDHCtrl();
	void    SetInfoPart(int i, const char *txt);
	String  GetInfoPart(int i) const;


	void WndShow(bool b);

	void WndSetPos(const Rect& rect);

	bool IsWndOpen() const;

	bool SetWndCapture();
	bool HasWndCapture() const;
	bool ReleaseWndCapture();

	static void SetMouseCursor(const Image& m);

	static void DoDeactivate(Ptr<Ctrl> pfocusCtrl, Ptr<Ctrl> nfocusCtrl);
	static void DoKillFocus(Ptr<Ctrl> pfocusCtrl, Ptr<Ctrl> nfocusCtrl);
	static void DoSetFocus(Ptr<Ctrl> pfocusCtrl, Ptr<Ctrl> nfocusCtrl, bool activate);

	void ActivateWnd();
	void ClickActivateWnd();
	bool SetFocus0(bool activate);
	bool SetWndFocus();
	bool HasWndFocus() const;

	static void WndDestroyCaret();
	void WndCreateCaret(const Rect& cr);

	void WndInvalidateRect(const Rect& r);

	void SetWndForeground();
	bool IsWndForeground() const;

	bool WndEnable(bool b);

	Rect GetWndUpdateRect() const;
	Rect GetWndScreenRect() const;
	void WndScrollView(const Rect& r, int dx, int dy);
	void WndUpdate();
	void WndUpdate(const Rect& r);

	void WndFree();
	void WndDestroy();

	static void InitTimer();

	static String appname;

	static Size Dsize;
	static Size Csize;
	static void Csizeinit();
	static void (*skin)();

	friend void CtrlSetDefaultSkin(void (*fn1)(), void (*fn2)());
	friend class DHCtrl;
	friend class ViewDraw;
	friend class TopWindow;
	friend class TrayIcon;
	friend class GLCtrl;
	friend class WaitCursor;
	friend struct UDropSource;
	friend class DnDAction;
	friend class PasteClip;


	static LRESULT __stdcall UtilityProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	static void RenderFormat(int format);
	static void RenderAllFormats();
	static void DestroyClipboard();

public:
	static Event&    ExitLoopEvent();
	static bool&     EndSession();
	static bool      IsEndSession()            { return EndSession(); }
	static HINSTANCE hInstance;

protected:
	static HCURSOR   hCursor;

	static VectorMap< HWND, Ptr<Ctrl> >& Windows();
	static LRESULT __stdcall WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

	static Event  OverwatchEndSession;
	static HWND   OverwatchHWND;
	static HANDLE OverwatchThread;

	static LRESULT __stdcall OverwatchWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
	static DWORD __stdcall Win32OverwatchThread(LPVOID);

	static Rect GetScreenClient(HWND hwnd);
	void  Create(HWND parent, DWORD style, DWORD exstyle, bool savebits, int show, bool dropshadow);
	Image DoMouse(int e, Point p, int zd = 0);

	friend void sSetCursor(Ctrl *ctrl, const Image& m);

public:
	virtual void    NcCreate(HWND hwnd);
	virtual void    NcDestroy();
	virtual void    PreDestroy();
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

	HWND  GetHWND() const              { return parent ? 0 : top ? top->hwnd : 0; }
	HWND  GetOwnerHWND() const;

	static Ctrl  *CtrlFromHWND(HWND hwnd);
#line 673 "u:/uppsrc\\CtrlCore/CtrlCore.h"










































































































private:
			void    DoRemove();

protected:
	static void     TimerProc(dword time);

			Ctrl&   Unicode()                         { unicode = true; return *this; }

public:
	enum StateReason {
		FOCUS      = 10,
		ACTIVATE   = 11,
		DEACTIVATE = 12,
		SHOW       = 13,
		ENABLE     = 14,
		EDITABLE   = 15,
		OPEN       = 16,
		CLOSE      = 17,
		POSITION   = 100,
		LAYOUTPOS  = 101,
	};

	enum MouseEvents {
		BUTTON        = 0x0F,
		ACTION        = 0xF0,

		MOUSEENTER    = 0x10,
		MOUSEMOVE     = 0x20,
		MOUSELEAVE    = 0x30,
		CURSORIMAGE   = 0x40,
		MOUSEWHEEL    = 0x50,

		DOWN          = 0x80,
		UP            = 0x90,
		DOUBLE        = 0xa0,
		REPEAT        = 0xb0,
		DRAG          = 0xc0,
		HOLD          = 0xd0,
		TRIPLE        = 0xe0,

		LEFTDOWN      = LEFT|DOWN,
		LEFTDOUBLE    = LEFT|DOUBLE,
		LEFTREPEAT    = LEFT|REPEAT,
		LEFTUP        = LEFT|UP,
		LEFTDRAG      = LEFT|DRAG,
		LEFTHOLD      = LEFT|HOLD,
		LEFTTRIPLE    = LEFT|TRIPLE,

		RIGHTDOWN     = RIGHT|DOWN,
		RIGHTDOUBLE   = RIGHT|DOUBLE,
		RIGHTREPEAT   = RIGHT|REPEAT,
		RIGHTUP       = RIGHT|UP,
		RIGHTDRAG     = RIGHT|DRAG,
		RIGHTHOLD     = RIGHT|HOLD,
		RIGHTTRIPLE   = RIGHT|TRIPLE,

		MIDDLEDOWN     = MIDDLE|DOWN,
		MIDDLEDOUBLE   = MIDDLE|DOUBLE,
		MIDDLEREPEAT   = MIDDLE|REPEAT,
		MIDDLEUP       = MIDDLE|UP,
		MIDDLEDRAG     = MIDDLE|DRAG,
		MIDDLEHOLD     = MIDDLE|HOLD,
		MIDDLETRIPLE   = MIDDLE|TRIPLE
	};

	enum {
		NOBACKPAINT,
		FULLBACKPAINT,
		TRANSPARENTBACKPAINT,
		EXCLUDEPAINT,
	};

	static  Vector<Ctrl *> GetTopCtrls();
	static  Vector<Ctrl *> GetTopWindows();
	static  void   CloseTopCtrls();

	static  void   InstallMouseHook(MouseHook hook);
	static  void   DeinstallMouseHook(MouseHook hook);

	static  void   InstallKeyHook(KeyHook hook);
	static  void   DeinstallKeyHook(KeyHook hook);

	static  void   InstallStateHook(StateHook hook);
	static  void   DeinstallStateHook(StateHook hook);

	virtual bool   Accept();
	virtual void   Reject();
	virtual void   SetData(const Value& data);
	virtual Value  GetData() const;
	virtual void   Serialize(Stream& s);
	virtual void   SetModify();
	virtual void   ClearModify();
	virtual bool   IsModified() const;

	virtual void   Paint(Draw& draw);
	virtual int    OverPaint() const;

	virtual void   CancelMode();

	virtual void   Activate();
	virtual void   Deactivate();

	virtual Image  FrameMouseEvent(int event, Point p, int zdelta, dword keyflags);
	virtual Image  MouseEvent(int event, Point p, int zdelta, dword keyflags);
	virtual void   MouseEnter(Point p, dword keyflags);
	virtual void   MouseMove(Point p, dword keyflags);
	virtual void   LeftDown(Point p, dword keyflags);
	virtual void   LeftDouble(Point p, dword keyflags);
	virtual void   LeftTriple(Point p, dword keyflags);
	virtual void   LeftRepeat(Point p, dword keyflags);
	virtual void   LeftDrag(Point p, dword keyflags);
	virtual void   LeftHold(Point p, dword keyflags);
	virtual void   LeftUp(Point p, dword keyflags);
	virtual void   RightDown(Point p, dword keyflags);
	virtual void   RightDouble(Point p, dword keyflags);
	virtual void   RightTriple(Point p, dword keyflags);
	virtual void   RightRepeat(Point p, dword keyflags);
	virtual void   RightDrag(Point p, dword keyflags);
	virtual void   RightHold(Point p, dword keyflags);
	virtual void   RightUp(Point p, dword keyflags);
	virtual void   MiddleDown(Point p, dword keyflags);
	virtual void   MiddleDouble(Point p, dword keyflags);
	virtual void   MiddleTriple(Point p, dword keyflags);
	virtual void   MiddleRepeat(Point p, dword keyflags);
	virtual void   MiddleDrag(Point p, dword keyflags);
	virtual void   MiddleHold(Point p, dword keyflags);
	virtual void   MiddleUp(Point p, dword keyflags);
	virtual void   MouseWheel(Point p, int zdelta, dword keyflags);
	virtual void   MouseLeave();

	virtual void   DragAndDrop(Point p, PasteClip& d);
	virtual void   FrameDragAndDrop(Point p, PasteClip& d);
	virtual void   DragRepeat(Point p);
	virtual void   DragEnter();
	virtual void   DragLeave();
	virtual String GetDropData(const String& fmt) const;
	virtual String GetSelectionData(const String& fmt) const;

	virtual Image  CursorImage(Point p, dword keyflags);

	virtual bool   Key(dword key, int count);
	virtual void   GotFocus();
	virtual void   LostFocus();
	virtual bool   HotKey(dword key);

	virtual dword  GetAccessKeys() const;
	virtual void   AssignAccessKeys(dword used);

	virtual void   PostInput();

	virtual void   ChildFrameMouseEvent(Ctrl *child, int event, Point p, int zdelta, dword keyflags);
	virtual void   ChildMouseEvent(Ctrl *child, int event, Point p, int zdelta, dword keyflags);
	virtual void   ChildGotFocus();
	virtual void   ChildLostFocus();
	virtual void   ChildAdded(Ctrl *child);
	virtual void   ChildRemoved(Ctrl *child);
	virtual void   ParentChange();

	virtual void   State(int reason);

	virtual void   Layout();

	virtual Size   GetMinSize() const;
	virtual Size   GetStdSize() const;
	virtual Size   GetMaxSize() const;

	virtual bool   IsShowEnabled() const;

	virtual Rect   GetOpaqueRect();
	virtual Rect   GetVoidRect();

	virtual void   Updated();

	virtual void   Close();

	virtual bool   IsOcxChild();

	virtual String GetDesc() const;

	Callback       WhenAction;

	void             AddChild(Ctrl *child);
	void             AddChild(Ctrl *child, Ctrl *insafter);
	void             AddChildBefore(Ctrl *child, Ctrl *insbefore);
	void             RemoveChild(Ctrl *child);
	Ctrl            *GetParent() const           { return parent; }
	Ctrl            *GetLastChild() const        { return lastchild; }
	Ctrl            *GetFirstChild() const       { return firstchild; }
	Ctrl            *GetPrev() const             { return parent ? prev : 0; }
	Ctrl            *GetNext() const             { return parent ? next : 0; }

	bool             IsChild() const             { return parent; }

	Ctrl            *ChildFromPoint(Point& pt) const;

	bool             IsForeground() const;
	void             SetForeground();

	const Ctrl      *GetTopCtrl() const;
	Ctrl            *GetTopCtrl();
	const Ctrl      *GetOwner() const;
	Ctrl            *GetOwner();
	const Ctrl      *GetTopCtrlOwner() const;
	Ctrl            *GetTopCtrlOwner();

	Ctrl            *GetOwnerCtrl();
	const Ctrl      *GetOwnerCtrl() const;

	const TopWindow *GetTopWindow() const;
	TopWindow       *GetTopWindow();

	const TopWindow *GetMainWindow() const;
	TopWindow       *GetMainWindow();

	Ctrl&            SetFrame(int i, CtrlFrame& frm);
	Ctrl&            SetFrame(CtrlFrame& frm)            { return SetFrame(0, frm); }
	Ctrl&            AddFrame(CtrlFrame& frm);
	const CtrlFrame& GetFrame(int i = 0) const           { return *frame[i].frame; }
	CtrlFrame&       GetFrame(int i = 0)                 { return *frame[i].frame; }
	void             RemoveFrame(int i);
	void             RemoveFrame(CtrlFrame& frm);
	void             InsertFrame(int i, CtrlFrame& frm);
	int              FindFrame(CtrlFrame& frm);
	int              GetFrameCount() const               { return frame.GetCount(); }
	void             ClearFrames();

	bool        IsOpen() const;

	void        Shutdown()                               { destroying = true; }
	bool        IsShutdown() const                       { return destroying; }

	Ctrl&       SetPos(LogPos p, bool inframe);

	Ctrl&       SetPos(LogPos p);
	Ctrl&       SetPos(Logc x, Logc y)                   { return SetPos(LogPos(x, y)); }
	Ctrl&       SetPosX(Logc x);
	Ctrl&       SetPosY(Logc y);

	void        SetRect(const Rect& r);
	void        SetRect(int x, int y, int cx, int cy);
	void        SetRectX(int x, int cx);
	void        SetRectY(int y, int cy);

	Ctrl&       SetFramePos(LogPos p);
	Ctrl&       SetFramePos(Logc x, Logc y)              { return SetFramePos(LogPos(x, y)); }
	Ctrl&       SetFramePosX(Logc x);
	Ctrl&       SetFramePosY(Logc y);

	void        SetFrameRect(const Rect& r);
	void        SetFrameRect(int x, int y, int cx, int cy);
	void        SetFrameRectX(int x, int cx);
	void        SetFrameRectY(int y, int cy);

	bool        InFrame() const                          { return inframe; }
	bool        InView() const                           { return !inframe; }
	LogPos      GetPos() const                           { return pos; }

	void        RefreshLayout()                          { SyncLayout(1); }
	void        RefreshLayoutDeep()                      { SyncLayout(2); }
	void        RefreshParentLayout()                    { if(parent) parent->RefreshLayout(); }

	Ctrl&       LeftPos(int a, int size = STDSIZE);
	Ctrl&       RightPos(int a, int size = STDSIZE);
	Ctrl&       TopPos(int a, int size = STDSIZE);
	Ctrl&       BottomPos(int a, int size = STDSIZE);
	Ctrl&       HSizePos(int a = 0, int b = 0);
	Ctrl&       VSizePos(int a = 0, int b = 0);
	Ctrl&       SizePos();
	Ctrl&       HCenterPos(int size = STDSIZE, int delta = 0);
	Ctrl&       VCenterPos(int size = STDSIZE, int delta = 0);

	Ctrl&       LeftPosZ(int a, int size = STDSIZE);
	Ctrl&       RightPosZ(int a, int size = STDSIZE);
	Ctrl&       TopPosZ(int a, int size = STDSIZE);
	Ctrl&       BottomPosZ(int a, int size = STDSIZE);
	Ctrl&       HSizePosZ(int a = 0, int b = 0);
	Ctrl&       VSizePosZ(int a = 0, int b = 0);
	Ctrl&       HCenterPosZ(int size = STDSIZE, int delta = 0);
	Ctrl&       VCenterPosZ(int size = STDSIZE, int delta = 0);

	Rect        GetRect() const;
	Rect        GetScreenRect() const;

	Rect        GetView() const;
	Rect        GetScreenView() const;
	Size        GetSize() const;

	Rect        GetVisibleScreenRect() const;
	Rect        GetVisibleScreenView() const;

	Rect        GetWorkArea() const;

	Size        AddFrameSize(int cx, int cy) const;
	Size        AddFrameSize(Size sz) const              { return AddFrameSize(sz.cx, sz.cy); }

	void        Refresh(const Rect& r);
	void        Refresh(int x, int y, int cx, int cy);
	void        Refresh();
	bool        IsFullRefresh() const                    { return fullrefresh; }

	void        RefreshFrame(const Rect& r);
	void        RefreshFrame(int x, int y, int cx, int cy);
	void        RefreshFrame();

	void        ScrollView(const Rect& r, int dx, int dy);
	void        ScrollView(int x, int y, int cx, int cy, int dx, int dy);
	void        ScrollView(int dx, int dy);
	void        ScrollView(const Rect& r, Size delta)    { ScrollView(r, delta.cx, delta.cy); }
	void        ScrollView(Size delta)                   { ScrollView(delta.cx, delta.cy); }

	void        Sync();
	void        Sync(const Rect& r);

	static Image OverrideCursor(const Image& m);

	void        DrawCtrl(Draw& w, int x = 0, int y = 0);
	void        DrawCtrlWithParent(Draw& w, int x = 0, int y = 0);

	bool    HasChild(Ctrl *ctrl) const;
	bool    HasChildDeep(Ctrl *ctrl) const;

	Ctrl&   IgnoreMouse(bool b = true)                   { ignoremouse = b; return *this; }
	Ctrl&   NoIgnoreMouse()                              { return IgnoreMouse(false); }
	bool    HasMouse() const;
	bool    HasMouseDeep() const;
	bool    HasMouseInFrame(const Rect& r);
	bool    HasMouseIn(const Rect& r) const;
	Point   GetMouseViewPos() const;
	static Ctrl *GetMouseCtrl();

	static void IgnoreMouseClick();
	static void IgnoreMouseUp();

	bool    SetCapture();
	bool    ReleaseCapture();
	bool    HasCapture() const;
	static bool ReleaseCtrlCapture();

	bool    SetFocus();
	bool    HasFocus() const                   { return FocusCtrl() == this; }
	bool    HasFocusDeep() const;
	Ctrl&   WantFocus(bool ft = true)          { wantfocus = ft; return *this; }
	Ctrl&   NoWantFocus()                      { return WantFocus(false); }
	bool	IsWantFocus() const                { return wantfocus; }
	bool    SetWantFocus();
	Ctrl&   InitFocus(bool ft = true)          { initfocus = ft; return *this; }
	Ctrl&   NoInitFocus()                      { return InitFocus(false); }
	bool    IsInitFocus()                      { return initfocus; }
	Ctrl   *GetFocusChild() const              { return HasChild(FocusCtrl()) ? ~FocusCtrl() : 0; }
	Ctrl   *GetFocusChildDeep() const          { return HasChildDeep(FocusCtrl()) ? ~FocusCtrl() : 0; }

	void    CancelModeDeep();

	void    SetCaret(int x, int y, int cx, int cy);
	void    SetCaret(const Rect& r);
	Rect    GetCaret() const;
	void    KillCaret();

	static Ctrl *GetFocusCtrl()                { return FocusCtrl(); }

	static Ctrl *GetEventTopCtrl()             { return eventCtrl; }

	static bool  IterateFocusForward(Ctrl *ctrl, Ctrl *top, bool noframe = false, bool init = false, bool all = false);
	static bool  IterateFocusBackward(Ctrl *ctrl, Ctrl *top, bool noframe = false, bool all = false);

	static dword AccessKeyBit(byte accesskey);
	dword   GetAccessKeysDeep() const;
	void    DistributeAccessKeys();
	bool    VisibleAccessKeys();

	void    Show(bool show = true);
	void    Hide()                             { Show(false); }
	bool    IsShown() const                    { return visible; }
	bool    IsVisible() const;

	void    Enable(bool enable = true);
	void    Disable()                          { Enable(false); }
	bool    IsEnabled() const                  { return enabled; }

	Ctrl&   SetEditable(bool editable = true);
	Ctrl&   SetReadOnly()                      { return SetEditable(false); }
	bool    IsEditable() const                 { return editable; }
	bool    IsReadOnly() const                 { return !editable; }

	void    ResetModify()                      { modify = false; }
	bool    IsModifySet() const                { return modify; }

	void    UpdateRefresh();
	void    Update();
	void    Action();
	void    UpdateAction();
	void    UpdateActionRefresh();

	Ctrl&   BackPaint(int bp = FULLBACKPAINT)  { backpaint = bp; return *this; }
	Ctrl&   TransparentBackPaint()             { backpaint = TRANSPARENTBACKPAINT; return *this; }
	Ctrl&   NoBackPaint()                      { return BackPaint(NOBACKPAINT); }
	Ctrl&   BackPaintHint();
	int     GetBackPaint()                     { return backpaint; }
	Ctrl&   Transparent(bool bp = true)        { transparent = bp; return *this; }
	Ctrl&   NoTransparent()                    { return Transparent(false); }
	bool    IsTransparent() const              { return transparent; }

	Ctrl&   ActiveX(bool ax = true)            { activex = ax; return *this; }
	Ctrl&   NoActiveX()                        { return ActiveX(false); }
	bool    IsActiveX() const                  { return activex; }
#line 1185 "u:/uppsrc\\CtrlCore/CtrlCore.h"

	Ctrl&   Info(const char *txt)              { info = txt; return *this; }
	String  GetInfo() const                    { return info; }

	Ctrl&   Tip(const char *txt);
	Ctrl&   HelpLine(const char *txt);
	Ctrl&   Description(const char *txt);
	Ctrl&   HelpTopic(const char *txt);
	Ctrl&   LayoutId(const char *txt);

	String  GetTip() const;
	String  GetHelpLine() const;
	String  GetDescription() const;
	String  GetHelpTopic() const;
	String  GetLayoutId() const;

	void    Add(Ctrl& ctrl)                    { AddChild(&ctrl); }
	Ctrl&   operator<<(Ctrl& ctrl)             { Add(ctrl); return *this; }

	void    Remove();

	Value        operator~() const             { return GetData(); }
	const Value& operator<<=(const Value& v)   { SetData(v); return v; }
	bool         IsNullInstance() const        { return GetData().IsNull(); }

	Callback     operator<<=(Callback action)  { WhenAction = action; return action; }
	Callback&    operator<<(Callback action)   { return WhenAction << action; }

	void    SetTimeCallback(int delay_ms, Callback cb, int id = 0);
	void    KillTimeCallback(int id = 0);
	void    KillSetTimeCallback(int delay_ms, Callback cb, int id);
	bool    ExistsTimeCallback(int id = 0) const;
	void    PostCallback(Callback cb, int id = 0);
	void    KillPostCallback(Callback cb, int id);

	enum { TIMEID_COUNT = 1 };

	static void  SetTimerGranularity(int ms);

	static Ctrl *GetActiveCtrl();
	static Ctrl *GetActiveWindow();

	static Ctrl *GetVisibleChild(Ctrl *ctrl, Point p, bool pointinframe);


	void   PopUpHWND(HWND hwnd, bool savebits = true, bool activate = true, bool dropshadow = false,
	                 bool topmost = false);
#line 1233 "u:/uppsrc\\CtrlCore/CtrlCore.h"
	void   PopUp(Ctrl *owner = 0, bool savebits = true, bool activate = true, bool dropshadow = false,
	             bool topmost = false);

	void   SetAlpha(byte alpha);

	static bool IsWaitingEvent();
	static bool ProcessEvent(bool *quit = 0);
	static bool ProcessEvents(bool *quit = 0);

	bool   IsPopUp() const          { return popup; }

	static void  EventLoop(Ctrl *loopctrl = 0);
	static int   GetLoopLevel()     { return LoopLevel; }
	static Ctrl *GetLoopCtrl()      { return LoopCtrl; }

	void   EndLoop()                { inloop = false; }
	void   EndLoop(int code)        { ; exitcode = code; EndLoop(); }
	bool   InLoop() const           { return inloop; }
	bool   InCurrentLoop() const    { return GetLoopCtrl() == this; }
	int    GetExitCode() const      { return exitcode; }

	static PasteClip& Clipboard();
	static PasteClip& Selection();

	void   SetSelectionSource(const char *fmts);

	int    DoDragAndDrop(const char *fmts, const Image& sample, dword actions,
	                     const VectorMap<String, ClipData>& data);
	int    DoDragAndDrop(const char *fmts, const Image& sample = Null, dword actions = DND_ALL);
	int    DoDragAndDrop(const VectorMap<String, ClipData>& data, const Image& sample = Null,
	                     dword actions = DND_ALL);
	static Ctrl *GetDragAndDropSource();
	static Ctrl *GetDragAndDropTarget();
	bool   IsDragAndDropSource()    { return this == GetDragAndDropSource(); }
	bool   IsDragAndDropTarget()    { return this == GetDragAndDropTarget(); }
	static Size  StdSampleSize()    { return Size(126, 106); }

	void SetMinSize(Size sz) {}

public:
	static void SetSkin(void (*skin)());

	static const char *GetZoomText();
	static void SetZoomSize(Size sz, Size bsz = Size(0, 0));
	static int  HorzLayoutZoom(int cx);
	static int  VertLayoutZoom(int cy);
	static Size LayoutZoom(int cx, int cy);
	static Size LayoutZoom(Size sz);
	static void NoLayoutZoom();
	static void GetZoomRatio(Size& m, Size& d);

	static int  HZoom(int cx)                            { return HorzLayoutZoom(cx); }

	static bool ClickFocus();
	static void ClickFocus(bool cf);

	static Rect   GetVirtualWorkArea();
	static Rect   GetVirtualScreenArea();
	static Rect   GetPrimaryWorkArea();
	static Rect   GetPrimaryScreenArea();
	static int    GetKbdDelay();
	static int    GetKbdSpeed();
	static bool   IsAlphaSupported();
	static Rect   GetDefaultWindowRect();
	static String GetAppName();
	static void   SetAppName(const String& appname);
	static bool   IsCompositedGui();

	static void   GlobalBackPaint(bool b = true);
	static void   GlobalBackPaintHint();

	String      Name() const;








	static void ShowRepaint(int ms);

	static bool MemoryCheck;


	static void InitWin32(HINSTANCE hinst);
	static void ExitWin32();



	static void GuiFlush()                              { ::GdiFlush(); }
#line 1325 "u:/uppsrc\\CtrlCore/CtrlCore.h"
#line 1326 "u:/uppsrc\\CtrlCore/CtrlCore.h"







	static void GuiSleep(int ms);

	Ctrl();
	virtual ~Ctrl();
};

Font FontZ(int face, int height = 0);
Font StdFontZ(int height = 0);
Font ScreenSansZ(int height = 0);
Font ScreenSerifZ(int height = 0);
Font ScreenFixedZ(int height = 0);
Font RomanZ(int height = 0);
Font ArialZ(int height = 0);
Font CourierZ(int height = 0);

int   EditFieldIsThin();
Value TopSeparator1();
Value TopSeparator2();
int   FrameButtonWidth();
int   ScrollBarArrowSize();
Color FieldFrameColor();

enum { GUISTYLE_FLAT, GUISTYLE_CLASSIC, GUISTYLE_XP, GUISTYLE_X };
int GUI_GlobalStyle();

int GUI_DragFullWindow();

enum { GUIEFFECT_NONE, GUIEFFECT_SLIDE, GUIEFFECT_FADE };
int GUI_PopUpEffect();

int GUI_DropShadows();
int GUI_AltAccessKeys();
int GUI_AKD_Conservative();
int GUI_DragDistance();
int GUI_DblClickTime();

void GUI_GlobalStyle_Write(int);
void GUI_DragFullWindow_Write(int);
void GUI_PopUpEffect_Write(int);
void GUI_DropShadows_Write(int);
void GUI_AltAccessKeys_Write(int);
void GUI_AKD_Conservative_Write(int);
void GUI_DragDistance_Write(int);
void GUI_DblClickTime_Write(int);

void  EditFieldIsThin_Write(int);
void  TopSeparator1_Write(Value);
void  TopSeparator2_Write(Value);
void  FrameButtonWidth_Write(int);
void  ScrollBarArrowSize_Write(int);
void  FieldFrameColor_Write(Color);

String Name(const Ctrl *ctrl);
String Desc(const Ctrl *ctrl);
void   Dump(const Ctrl *ctrl);

inline Ctrl *operator<<(Ctrl *parent, Ctrl& child)
{
	parent->Add(child);
	return parent;
}

inline unsigned GetHashValue(Ctrl *x)
{
	return (unsigned)(intptr_t)x;
}

String GetKeyDesc(dword key);

Vector< Ptr<Ctrl> > DisableCtrls(const Vector<Ctrl *>& ctrl, Ctrl *exclude = 0);
void EnableCtrls(const Vector< Ptr<Ctrl> >& ctrl);

template <class T>
class FrameCtrl : public T, public CtrlFrame {
public:
	virtual void FrameAdd(Ctrl& parent) { parent.Add(*this); }
	virtual void FrameRemove()          { this->Ctrl::Remove(); }

	FrameCtrl()                         { this->NoWantFocus(); }
};

template <class T>
class FrameLR : public FrameCtrl<T> {
public:
	virtual void FrameAddSize(Size& sz) { sz.cx += (cx ? cx : sz.cy) * this->IsShown(); }

protected:
	int cx;

public:
	FrameLR& Width(int _cx)             { cx = _cx; this->RefreshParentLayout(); return *this; }
	int      GetWidth() const           { return cx; }
	FrameLR()                           { cx = 0; }
};

template <class T>
class FrameLeft : public FrameLR<T> {
public:
	virtual void FrameLayout(Rect& r) {
		LayoutFrameLeft(r, this, this->cx ? this->cx : FrameButtonWidth());
	}
};

template <class T>
class FrameRight : public FrameLR<T> {
public:
	virtual void FrameLayout(Rect& r) {
		LayoutFrameRight(r, this, this->cx ? this->cx : FrameButtonWidth());
	}
};

template <class T>
class FrameTB : public FrameCtrl<T> {
public:
	virtual void FrameAddSize(Size& sz) { sz.cy += (cy ? cy : sz.cx) * this->IsShown(); }

protected:
	int cy;

public:
	FrameTB& Height(int _cy)            { cy = _cy; this->RefreshParentLayout(); return *this; }
	int      GetHeight() const          { return cy; }
	FrameTB()                           { cy = 0; }
};

template <class T>
class FrameTop : public FrameTB<T> {
public:
	virtual void FrameLayout(Rect& r) {
		LayoutFrameTop(r, this, this->cy ? this->cy : r.Width());
	}
};

template <class T>
class FrameBottom : public FrameTB<T> {
public:
	virtual void FrameLayout(Rect& r) {
		LayoutFrameBottom(r, this, this->cy ? this->cy : r.Width());
	}
};

class Modality {
	Ptr<Ctrl>           active;
	bool                fore_only;
	Vector< Ptr<Ctrl> > enable;

public:
	void Begin(Ctrl *modal, bool fore_only = false);
	void End();

	~Modality()      { End(); }
};

class ViewDraw : public Draw {
public:
	ViewDraw(Ctrl *ctrl);
	~ViewDraw();

protected:

	HWND   hwnd;
#line 1495 "u:/uppsrc\\CtrlCore/CtrlCore.h"



};



inline unsigned GetHashValue(const HWND& hwnd)
{
	return (unsigned)(intptr_t)hwnd;
}
#line 1507 "u:/uppsrc\\CtrlCore/CtrlCore.h"
#line 1508 "u:/uppsrc\\CtrlCore/CtrlCore.h"

class LocalLoop : public Ctrl {
	Ctrl *master;

public:
	void  Run();
	void  SetMaster(Ctrl& m)      { master = &m; }
	Ctrl& GetMaster() const       { return *master; }

	LocalLoop()                   { master = 0; }
};

void DrawDragRect(Ctrl& q, const Rect& rect1, const Rect& rect2, const Rect& clip, int n,
                  Color color, const word *pattern);

bool PointLoop(Ctrl& ctrl, const Vector<Image>& ani, int ani_ms);
bool PointLoop(Ctrl& ctrl, const Image& img);

class RectTracker : public LocalLoop {
public:
	virtual void  LeftUp(Point, dword);
	virtual void  RightUp(Point, dword);
	virtual void  MouseMove(Point p, dword);
	virtual Image CursorImage(Point, dword);

public:
	struct Rounder {
		virtual Rect Round(const Rect& r) = 0;
		virtual ~Rounder() {}
	};

protected:
	Rect            rect;
	int             tx, ty;
	Rect            maxrect;
	Size            minsize, maxsize;
	bool            keepratio;
	Rect            clip;
	Color           color;
	Image           cursorimage;
	int             width;
	uint64          pattern;
	int             animation;
	int             panim;
	Rounder        *rounder;

	Rect            org;
	Rect            o;
	Point           op;

	Rect            Round(const Rect& r)           { return rounder ? rounder->Round(r) : r; }

	virtual void    DrawRect(Rect r1, Rect r2);

public:
	Callback1<Rect> sync;

	RectTracker&    SetCursorImage(const Image& m) { cursorimage = m; return *this; }
	RectTracker&    MinSize(Size sz)               { minsize = sz; return *this; }
	RectTracker&    MaxSize(Size sz)               { maxsize = sz; return *this; }
	RectTracker&    MaxRect(const Rect& mr)        { maxrect = mr; return *this; }
	RectTracker&    Clip(const Rect& c)            { clip = c; return *this; }
	RectTracker&    Width(int n)                   { width = n; return *this; }
	RectTracker&    SetColor(Color c)              { color = c; return *this; }
	RectTracker&    Pattern(uint64 p)              { pattern = p; return *this; }
	RectTracker&    Dashed();
	RectTracker&    Solid();
	RectTracker&    Animation(int step_ms = 40)    { animation = step_ms; return *this; }
	RectTracker&    KeepRatio(bool b)              { keepratio = b; return *this; }
	RectTracker&    Round(Rounder& r)              { rounder = &r; return *this; }

	Rect            Get()                          { return rect; }

	Rect Track(const Rect& r, int tx = ALIGN_RIGHT, int ty = ALIGN_BOTTOM);
	int  TrackHorzLine(int x0, int y0, int cx, int line);
	int  TrackVertLine(int x0, int y0, int cy, int line);

	RectTracker(Ctrl& master);
	virtual ~RectTracker();
};

class WaitCursor {
	Image   prev;
	bool    flag;

public:
	void    Show();

	WaitCursor(bool show = true);
	~WaitCursor();
};

class AutoWaitCursor : public WaitCursor {
protected:
	int&   avg;
	int    time0;

public:
	void Cancel()                   { time0 = 0; }

	AutoWaitCursor(int& avg);
	~AutoWaitCursor();
};

void    ClearClipboard();
void    AppendClipboard(const char *format, const byte *data, int length);
void    AppendClipboard(const char *format, const String& data);
void    AppendClipboard(const char *format, const Value& data, String (*render)(const Value& data));
String  ReadClipboard(const char *format);
bool    IsClipboardAvailable(const char *format);

inline  void WriteClipboard(const char *format, const String& data)
	{ ClearClipboard(); AppendClipboard(format, data); }

void    AppendClipboardText(const String& s);
String  ReadClipboardText();
void    AppendClipboardUnicodeText(const WString& s);
WString ReadClipboardUnicodeText();
bool    IsClipboardAvailableText();

inline  void WriteClipboardText(const String& s)
	{ ClearClipboard(); AppendClipboardText(s); }
inline  void WriteClipboardUnicodeText(const WString& s)
	{ ClearClipboard(); AppendClipboardUnicodeText(s); }

template <class T>
inline void AppendClipboardFormat(const T& object) {
	AppendClipboard(typeid(T).name(), StoreAsString(const_cast<T&>(object)));
}

template <class T>
inline void WriteClipboardFormat(const T& object) {
	ClearClipboard();
	AppendClipboardFormat(object);
}

template <class T>
inline bool ReadClipboardFormat(T& object)
{
	String s = ReadClipboard(typeid(T).name());
	return !IsNull(s) && LoadFromString(object, s);
}

template <class T>
bool IsClipboardFormatAvailable()
{
	return IsClipboardAvailable(typeid(T).name());
}

template <class T>
inline T ReadClipboardFormat() {
	T object;
	ReadClipboardFormat(object);
	return object;
}

Image  ReadClipboardImage();
void   AppendClipboardImage(const Image& img);

inline void WriteClipboardImage(const Image& img)
	{ ClearClipboard(); AppendClipboardImage(img); }

#line 1 "u:/uppsrc\\CtrlCore/TopWindow.h"
















enum {
	IDEXIT = 6
};

class TopWindow : public Ctrl {
public:
	virtual Size     GetMinSize() const;
	virtual Size     GetStdSize() const;
	virtual void     Activate();
	virtual void     Deactivate();
	virtual bool     Accept();
	virtual void     Reject();
	virtual void     Paint(Draw& w);
	virtual bool     IsShowEnabled() const;
	virtual bool     Key(dword key, int count);
	virtual void     Close();
	virtual String   GetDesc() const;
	virtual void     ChildGotFocus();


public:
	virtual LRESULT  WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

private:

	dword       style;
	dword       exstyle;
	HICON       ico, lico;

	void        DeleteIco();
#line 48 "u:/uppsrc\\CtrlCore/TopWindow.h"

protected:
	enum {
		TIMEID_DEFSYNCTITLE = Ctrl::TIMEID_COUNT,
		TIMEID_COUNT,
	};











	static  Rect      windowFrameMargin;

private:
	struct Abreak : Pte<Abreak> {
		int         ID;
		TopWindow *dlg;

		void    Accept()      { dlg->AcceptBreak(ID); }
		void    Reject()      { dlg->RejectBreak(ID); }
		void    Break()       { dlg->Break(ID); }
	};

	Array<Abreak> action;
	Ptr<Ctrl>     activefocus;
	String        backup;
	PaintRect     background;
	Size          minsize;
	bool          dokeys;
	bool          fullscreen;

	byte          center:2;

	void          PlaceFocus();
	void          ActiveFocus0(Ctrl& ctrl);
	Abreak       *FindAddAction(int ID);
	Abreak       *FindAction(int ID);


	void          CenterRect(HWND owner, int center);
#line 95 "u:/uppsrc\\CtrlCore/TopWindow.h"







	Rect        overlapped;

	void        SyncSizeHints();
	void        SyncTitle();
	void        SyncCaption();

	void        SetupRect();

	void        FixIcons();

	enum { MINIMIZED, MAXIMIZED, OVERLAPPED };

	WString     title;
	bool        minimizebox:1;
	bool        maximizebox:1;
	bool        sizeable:1;
	bool        tool:1;
	byte        state;
	Image       icon, largeicon;





public:
	Callback    WhenClose;

	void        Backup();
	void        Restore();

	void        Break(int ID = IDEXIT);
	bool        AcceptBreak(int ID);
	void        RejectBreak(int ID);

	void        WorkAreaTrim();

	Callback    Breaker(int ID = IDEXIT);
	Callback    Acceptor(int ID);
	Callback    Rejector(int ID);

	TopWindow&  Breaker(Ctrl& m, int ID = -1);
	TopWindow&  Acceptor(Ctrl& m, int ID);
	TopWindow&  Rejector(Ctrl& m, int ID);

	TopWindow&  NoCenter()                          { center = 0; return *this; }
	TopWindow&  CenterOwner()                       { center = 1; return *this; }
	TopWindow&  CenterScreen()                      { center = 2; return *this; }

	void        SetMinSize(Size sz)                 { minsize = sz; }


	void       Open(HWND ownerhwnd);
	TopWindow& Style(dword _style);
	dword      GetStyle() const                       { return style; }
	TopWindow& ExStyle(dword _exstyle);
	dword      GetExStyle() const                     { return exstyle; }
#line 159 "u:/uppsrc\\CtrlCore/TopWindow.h"

	void       Open(Ctrl *owner);
	void       Open();
	void       OpenMain();
	int        Run(bool appmodal = false);
	int        RunAppModal()                          { return Run(true); }
	int        Execute();
	bool       ExecuteOK()                            { return Execute() == 1;     }
	bool       ExecuteCancel()                        { return Execute() == 2; }

	void       Minimize(bool effect = false);
	void       Maximize(bool effect = false);
	void       Overlap(bool effect = false);

	bool       IsMaximized() const                    { return state == MAXIMIZED; }
	bool       IsMinimized() const                    { return state == MINIMIZED; }
	bool       IsOverlapped() const                   { return state == OVERLAPPED; }

	TopWindow& ActiveFocus(Ctrl& ctrl)                { ActiveFocus0(ctrl); return *this; }

	TopWindow& Title(const WString& _title);
	TopWindow& Title(const char *s);
	const WString& GetTitle() const                   { return title; }
	TopWindow& Sizeable(bool b = true);
	TopWindow& NoSizeable()                           { return Sizeable(false); }
	bool       IsSizeable() const                     { return sizeable; }
	TopWindow& MinimizeBox(bool b = true);
	TopWindow& MaximizeBox(bool b = true);
	TopWindow& Zoomable(bool b = true)                { MinimizeBox(b); return MaximizeBox(b); }
	TopWindow& NoZoomable()                           { return Zoomable(false); }
	bool       IsZoomable() const                     { return maximizebox; }
	TopWindow& Background(const PaintRect& prect);
	const PaintRect& GetBackground() const            { return background; }
	TopWindow& ToolWindow(bool b = true);
	TopWindow& NoToolWindow()                         { return ToolWindow(false); }
	bool       IsToolWindow() const                   { return tool; }
	TopWindow& TopMost(bool b = true, bool stay_top = true);
	TopWindow& NoTopMost()                            { return TopMost(false); }
	bool       IsTopMost() const;
	TopWindow& FullScreen(bool b = true)              { fullscreen = b; return *this; }
	bool       IsFullScreen() const                   { return fullscreen; }
	TopWindow& NoAccessKeysDistribution()             { dokeys = false; return *this; }

	TopWindow& Icon(const Image& m);
	TopWindow& LargeIcon(const Image& m);
	TopWindow& Icon(const Image& smallicon, const Image& largeicon);

	Image      GetIcon() const                        { return icon; }
	Image      GetLargeIcon() const                   { return largeicon; }

	void       SerializePlacement(Stream& s, bool reminimize = false);

	typedef TopWindow CLASSNAME;

	TopWindow();
	~TopWindow();
};

void Maxisize(TopWindow& win, int screencxmax);

void ArrangeOKCancel(Ctrl& ok, Ctrl& cancel);

int  SwapOKCancel();
void SwapOKCancel_Write(int b);

template <class L>
void InitLayout(Ctrl& ctrl, L& layout)
{
	InitLayout(ctrl, layout, layout, layout);
}

template <class T>
void CtrlLayout(T& ctrl) {
	InitLayout(ctrl, ctrl, ctrl, ctrl);
	Size sz = ctrl.AddFrameSize(T::GetLayoutSize());
	ctrl.SetMinSize(sz);
	ctrl.SetRect(sz);
}

template <class T>
void CtrlLayout(T& ctrl, const char *title) {
	CtrlLayout(ctrl);
	ctrl.Title(title);
}

template <class T>
void CtrlLayoutOK(T& ctrl, const char *title) {
	CtrlLayout(ctrl, title);
	ctrl.Acceptor(ctrl.ok, 1);
	ctrl.ok.Ok();
}

template <class T>
void CtrlLayoutCancel(T& ctrl, const char *title) {
	CtrlLayout(ctrl, title);
	ctrl.Rejector(ctrl.cancel, 2);
	ctrl.cancel.Cancel();
}

template <class T>
void CtrlLayoutOKCancel(T& ctrl, const char *title) {
	CtrlLayoutOK(ctrl, title);
	ctrl.Rejector(ctrl.cancel, 2);
	ctrl.cancel.Cancel();
	ArrangeOKCancel(ctrl.ok, ctrl.cancel);
}

template <class T>
void CtrlLayoutExit(T& ctrl, const char *title) {
	CtrlLayout(ctrl, title);
	ctrl.Acceptor(ctrl.exit, IDEXIT);
	ctrl.exit.Exit();
}
#line 1671 "u:/uppsrc\\CtrlCore/CtrlCore.h"

bool (*&DisplayErrorFn())(const Value& v);
inline bool DisplayError(const Value& v) { return DisplayErrorFn()(v); }



Vector<String>& coreCmdLine__();
Vector<String> SplitCmdLine__(const char *cmd);











































#line 1723 "u:/uppsrc\\CtrlCore/CtrlCore.h"
#line 1724 "u:/uppsrc\\CtrlCore/CtrlCore.h"

























class DHCtrl : public Ctrl {
public:
	virtual void    State(int reason);
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	virtual void    NcCreate(HWND hwnd);
	virtual void    NcDestroy();

private:
	HWND   hwnd;

	void CloseHWND();
	void OpenHWND();
	void SyncHWND();

public:
	HWND    GetHWND()                              { return hwnd; }

	DHCtrl();
	~DHCtrl();
};

#line 1771 "u:/uppsrc\\CtrlCore/CtrlCore.h"
#line 1772 "u:/uppsrc\\CtrlCore/CtrlCore.h"















































};




#line 1 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"




















#line 22 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"
#line 23 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"








#line 32 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"
#line 33 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"








#line 42 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"
#line 43 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"



#line 1 "d:\\sdk\\Microsoft SDK\\include\\pshpack1.h"























#pragma warning(disable:4103)

#pragma pack(push,1)


#line 30 "d:\\sdk\\Microsoft SDK\\include\\pshpack1.h"


#line 33 "d:\\sdk\\Microsoft SDK\\include\\pshpack1.h"
#line 34 "d:\\sdk\\Microsoft SDK\\include\\pshpack1.h"
#line 47 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"
#line 48 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"


extern "C" {
#line 52 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"



struct HDROP__ { int unused; }; typedef struct HDROP__ *HDROP;

extern "C" __declspec(dllimport) UINT __stdcall DragQueryFileA(HDROP,UINT,LPSTR,UINT);
extern "C" __declspec(dllimport) UINT __stdcall DragQueryFileW(HDROP,UINT,LPWSTR,UINT);




#line 64 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"
extern "C" __declspec(dllimport) BOOL __stdcall DragQueryPoint(HDROP,LPPOINT);
extern "C" __declspec(dllimport) void __stdcall DragFinish(HDROP);
extern "C" __declspec(dllimport) void __stdcall DragAcceptFiles(HWND,BOOL);

extern "C" __declspec(dllimport) HINSTANCE __stdcall ShellExecuteA(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);
extern "C" __declspec(dllimport) HINSTANCE __stdcall ShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);




#line 75 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"
extern "C" __declspec(dllimport) HINSTANCE __stdcall FindExecutableA(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult);
extern "C" __declspec(dllimport) HINSTANCE __stdcall FindExecutableW(LPCWSTR lpFile, LPCWSTR lpDirectory, LPWSTR lpResult);




#line 82 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"
extern "C" __declspec(dllimport) LPWSTR * __stdcall  CommandLineToArgvW(LPCWSTR lpCmdLine, int*pNumArgs);

extern "C" __declspec(dllimport) INT __stdcall ShellAboutA(HWND hWnd, LPCSTR szApp, LPCSTR szOtherStuff, HICON hIcon);
extern "C" __declspec(dllimport) INT __stdcall ShellAboutW(HWND hWnd, LPCWSTR szApp, LPCWSTR szOtherStuff, HICON hIcon);




#line 91 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"
extern "C" __declspec(dllimport) HICON __stdcall DuplicateIcon(HINSTANCE hInst, HICON hIcon);
extern "C" __declspec(dllimport) HICON __stdcall ExtractAssociatedIconA(HINSTANCE hInst, LPSTR lpIconPath, LPWORD lpiIcon);
extern "C" __declspec(dllimport) HICON __stdcall ExtractAssociatedIconW(HINSTANCE hInst, LPWSTR lpIconPath, LPWORD lpiIcon);




#line 99 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"
extern "C" __declspec(dllimport) HICON __stdcall ExtractAssociatedIconExA(HINSTANCE hInst,LPSTR lpIconPath,LPWORD lpiIconIndex, LPWORD lpiIconId);
extern "C" __declspec(dllimport) HICON __stdcall ExtractAssociatedIconExW(HINSTANCE hInst,LPWSTR lpIconPath,LPWORD lpiIconIndex, LPWORD lpiIconId);




#line 106 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"
extern "C" __declspec(dllimport) HICON __stdcall ExtractIconA(HINSTANCE hInst, LPCSTR lpszExeFileName, UINT nIconIndex);
extern "C" __declspec(dllimport) HICON __stdcall ExtractIconW(HINSTANCE hInst, LPCWSTR lpszExeFileName, UINT nIconIndex);




#line 113 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"


typedef struct _DRAGINFOA {
    UINT uSize;
    POINT pt;
    BOOL fNC;
    LPSTR   lpFileList;
    DWORD grfKeyState;
} DRAGINFOA, *LPDRAGINFOA;
typedef struct _DRAGINFOW {
    UINT uSize;
    POINT pt;
    BOOL fNC;
    LPWSTR  lpFileList;
    DWORD grfKeyState;
} DRAGINFOW, *LPDRAGINFOW;




typedef DRAGINFOA DRAGINFO;
typedef LPDRAGINFOA LPDRAGINFO;
#line 136 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"


































typedef struct _AppBarData
{
    DWORD cbSize;
    HWND hWnd;
    UINT uCallbackMessage;
    UINT uEdge;
    RECT rc;
    LPARAM lParam;
} APPBARDATA, *PAPPBARDATA;


extern "C" __declspec(dllimport) UINT_PTR __stdcall SHAppBarMessage(DWORD dwMessage, PAPPBARDATA pData);





extern "C" __declspec(dllimport) DWORD __stdcall   DoEnvironmentSubstA(LPSTR szString, UINT cchString);
extern "C" __declspec(dllimport) DWORD __stdcall   DoEnvironmentSubstW(LPWSTR szString, UINT cchString);




#line 194 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"


extern "C" __declspec(dllimport) UINT __stdcall ExtractIconExA(LPCSTR lpszFile, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons);
extern "C" __declspec(dllimport) UINT __stdcall ExtractIconExW(LPCWSTR lpszFile, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons);




#line 203 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"





























#line 233 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"


#line 236 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"

typedef WORD FILEOP_FLAGS;












typedef WORD PRINTEROP_FLAGS;

#line 253 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"








typedef struct _SHFILEOPSTRUCTA
{
        HWND            hwnd;
        UINT            wFunc;
        LPCSTR          pFrom;
        LPCSTR          pTo;
        FILEOP_FLAGS    fFlags;
        BOOL            fAnyOperationsAborted;
        LPVOID          hNameMappings;
        LPCSTR           lpszProgressTitle;
} SHFILEOPSTRUCTA, *LPSHFILEOPSTRUCTA;
typedef struct _SHFILEOPSTRUCTW
{
        HWND            hwnd;
        UINT            wFunc;
        LPCWSTR         pFrom;
        LPCWSTR         pTo;
        FILEOP_FLAGS    fFlags;
        BOOL            fAnyOperationsAborted;
        LPVOID          hNameMappings;
        LPCWSTR          lpszProgressTitle;
} SHFILEOPSTRUCTW, *LPSHFILEOPSTRUCTW;




typedef SHFILEOPSTRUCTA SHFILEOPSTRUCT;
typedef LPSHFILEOPSTRUCTA LPSHFILEOPSTRUCT;
#line 290 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"

extern "C" __declspec(dllimport) int __stdcall SHFileOperationA(LPSHFILEOPSTRUCTA lpFileOp);
extern "C" __declspec(dllimport) int __stdcall SHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp);




#line 298 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"
extern "C" __declspec(dllimport) void __stdcall SHFreeNameMappings(HANDLE hNameMappings);

typedef struct _SHNAMEMAPPINGA
{
    LPSTR   pszOldPath;
    LPSTR   pszNewPath;
    int   cchOldPath;
    int   cchNewPath;
} SHNAMEMAPPINGA, *LPSHNAMEMAPPINGA;
typedef struct _SHNAMEMAPPINGW
{
    LPWSTR  pszOldPath;
    LPWSTR  pszNewPath;
    int   cchOldPath;
    int   cchNewPath;
} SHNAMEMAPPINGW, *LPSHNAMEMAPPINGW;




typedef SHNAMEMAPPINGA SHNAMEMAPPING;
typedef LPSHNAMEMAPPINGA LPSHNAMEMAPPING;
#line 321 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"



















#line 341 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"






























#line 372 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"



#line 376 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"


#line 379 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"


















#line 398 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"
#line 399 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"

typedef struct _SHELLEXECUTEINFOA
{
        DWORD cbSize;
        ULONG fMask;
        HWND hwnd;
        LPCSTR   lpVerb;
        LPCSTR   lpFile;
        LPCSTR   lpParameters;
        LPCSTR   lpDirectory;
        int nShow;
        HINSTANCE hInstApp;

        LPVOID lpIDList;
        LPCSTR   lpClass;
        HKEY hkeyClass;
        DWORD dwHotKey;
        union {
        HANDLE hIcon;
        HANDLE hMonitor;
        } ;
        HANDLE hProcess;
} SHELLEXECUTEINFOA, *LPSHELLEXECUTEINFOA;
typedef struct _SHELLEXECUTEINFOW
{
        DWORD cbSize;
        ULONG fMask;
        HWND hwnd;
        LPCWSTR  lpVerb;
        LPCWSTR  lpFile;
        LPCWSTR  lpParameters;
        LPCWSTR  lpDirectory;
        int nShow;
        HINSTANCE hInstApp;

        LPVOID lpIDList;
        LPCWSTR  lpClass;
        HKEY hkeyClass;
        DWORD dwHotKey;
        union {
        HANDLE hIcon;
        HANDLE hMonitor;
        } ;
        HANDLE hProcess;
} SHELLEXECUTEINFOW, *LPSHELLEXECUTEINFOW;




typedef SHELLEXECUTEINFOA SHELLEXECUTEINFO;
typedef LPSHELLEXECUTEINFOA LPSHELLEXECUTEINFO;
#line 451 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"

extern "C" __declspec(dllimport) BOOL __stdcall ShellExecuteExA(LPSHELLEXECUTEINFOA lpExecInfo);
extern "C" __declspec(dllimport) BOOL __stdcall ShellExecuteExW(LPSHELLEXECUTEINFOW lpExecInfo);




#line 459 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"
extern "C" __declspec(dllimport) void __stdcall WinExecErrorA(HWND hwnd, int error, LPCSTR lpstrFileName, LPCSTR lpstrTitle);
extern "C" __declspec(dllimport) void __stdcall WinExecErrorW(HWND hwnd, int error, LPCWSTR lpstrFileName, LPCWSTR lpstrTitle);




#line 466 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"



typedef struct _SHCREATEPROCESSINFOW
{
        DWORD cbSize;
        ULONG fMask;
        HWND hwnd;
        LPCWSTR  pszFile;
        LPCWSTR  pszParameters;
        LPCWSTR  pszCurrentDirectory;
         HANDLE hUserToken;
         LPSECURITY_ATTRIBUTES lpProcessAttributes;
         LPSECURITY_ATTRIBUTES lpThreadAttributes;
         BOOL bInheritHandles;
         DWORD dwCreationFlags;
         LPSTARTUPINFOW lpStartupInfo;
         LPPROCESS_INFORMATION lpProcessInformation;
} SHCREATEPROCESSINFOW, *PSHCREATEPROCESSINFOW;

extern "C" __declspec(dllimport) BOOL __stdcall SHCreateProcessAsUserW(PSHCREATEPROCESSINFOW pscpi);










typedef struct _SHQUERYRBINFO {
    DWORD   cbSize;

    __int64 i64Size;
    __int64 i64NumItems;



#line 506 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"
} SHQUERYRBINFO, *LPSHQUERYRBINFO;









extern "C" __declspec(dllimport) HRESULT __stdcall SHQueryRecycleBinA(LPCSTR pszRootPath, LPSHQUERYRBINFO pSHQueryRBInfo);
extern "C" __declspec(dllimport) HRESULT __stdcall SHQueryRecycleBinW(LPCWSTR pszRootPath, LPSHQUERYRBINFO pSHQueryRBInfo);




#line 523 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"
extern "C" __declspec(dllimport) HRESULT __stdcall SHEmptyRecycleBinA(HWND hwnd, LPCSTR pszRootPath, DWORD dwFlags);
extern "C" __declspec(dllimport) HRESULT __stdcall SHEmptyRecycleBinW(HWND hwnd, LPCWSTR pszRootPath, DWORD dwFlags);




#line 530 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"









typedef struct _NOTIFYICONDATAA {
        DWORD cbSize;
        HWND hWnd;
        UINT uID;
        UINT uFlags;
        UINT uCallbackMessage;
        HICON hIcon;

        CHAR   szTip[64];


#line 551 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"










#line 562 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"


#line 565 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"
} NOTIFYICONDATAA, *PNOTIFYICONDATAA;
typedef struct _NOTIFYICONDATAW {
        DWORD cbSize;
        HWND hWnd;
        UINT uID;
        UINT uFlags;
        UINT uCallbackMessage;
        HICON hIcon;

        WCHAR  szTip[64];


#line 578 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"










#line 589 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"


#line 592 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"
} NOTIFYICONDATAW, *PNOTIFYICONDATAW;




typedef NOTIFYICONDATAA NOTIFYICONDATA;
typedef PNOTIFYICONDATAA PNOTIFYICONDATA;
#line 600 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"








#line 609 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"







#line 617 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"






#line 624 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"






#line 631 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"









#line 641 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"







#line 649 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"


#line 652 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"


















#line 671 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"

extern "C" __declspec(dllimport) BOOL __stdcall Shell_NotifyIconA(DWORD dwMessage, PNOTIFYICONDATAA lpData);
extern "C" __declspec(dllimport) BOOL __stdcall Shell_NotifyIconW(DWORD dwMessage, PNOTIFYICONDATAW lpData);




#line 679 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"




























typedef struct _SHFILEINFOA
{
        HICON       hIcon;
        int         iIcon;
        DWORD       dwAttributes;
        CHAR        szDisplayName[260];
        CHAR        szTypeName[80];
} SHFILEINFOA;
typedef struct _SHFILEINFOW
{
        HICON       hIcon;
        int         iIcon;
        DWORD       dwAttributes;
        WCHAR       szDisplayName[260];
        WCHAR       szTypeName[80];
} SHFILEINFOW;



typedef SHFILEINFOA SHFILEINFO;
#line 728 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"



#line 732 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"






















#line 755 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"

extern "C" __declspec(dllimport) DWORD_PTR __stdcall SHGetFileInfoA(LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA *psfi, UINT cbFileInfo, UINT uFlags);
extern "C" __declspec(dllimport) DWORD_PTR __stdcall SHGetFileInfoW(LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW *psfi, UINT cbFileInfo, UINT uFlags);




#line 763 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"




extern "C" __declspec(dllimport) BOOL __stdcall SHGetDiskFreeSpaceExA(LPCSTR pszDirectoryName, ULARGE_INTEGER* pulFreeBytesAvailableToCaller, ULARGE_INTEGER* pulTotalNumberOfBytes, ULARGE_INTEGER* pulTotalNumberOfFreeBytes);
extern "C" __declspec(dllimport) BOOL __stdcall SHGetDiskFreeSpaceExW(LPCWSTR pszDirectoryName, ULARGE_INTEGER* pulFreeBytesAvailableToCaller, ULARGE_INTEGER* pulTotalNumberOfBytes, ULARGE_INTEGER* pulTotalNumberOfFreeBytes);




#line 774 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"
extern "C" __declspec(dllimport) BOOL __stdcall SHGetNewLinkInfoA(LPCSTR pszLinkTo, LPCSTR pszDir, LPSTR pszName, BOOL *pfMustCopy, UINT uFlags);
extern "C" __declspec(dllimport) BOOL __stdcall SHGetNewLinkInfoW(LPCWSTR pszLinkTo, LPCWSTR pszDir, LPWSTR pszName, BOOL *pfMustCopy, UINT uFlags);




#line 781 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"






#line 788 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"


















extern "C" __declspec(dllimport) BOOL __stdcall SHInvokePrinterCommandA(HWND hwnd, UINT uAction, LPCSTR lpBuf1, LPCSTR lpBuf2, BOOL fModal);
extern "C" __declspec(dllimport) BOOL __stdcall SHInvokePrinterCommandW(HWND hwnd, UINT uAction, LPCWSTR lpBuf1, LPCWSTR lpBuf2, BOOL fModal);




#line 813 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"


#line 816 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"












































#line 861 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"



extern "C" __declspec(dllimport) HRESULT __stdcall SHSetLocalizedName(LPWSTR pszPath, LPCWSTR pszResModule, int idsRes);





















int _cdecl ShellMessageBoxA(
    HINSTANCE hAppInst,
    HWND hWnd,
    LPCSTR lpcText,
    LPCSTR lpcTitle,
    UINT fuStyle, ...);
int _cdecl ShellMessageBoxW(
    HINSTANCE hAppInst,
    HWND hWnd,
    LPCWSTR lpcText,
    LPCWSTR lpcTitle,
    UINT fuStyle, ...);




#line 903 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"

extern "C" __declspec(dllimport) BOOL __stdcall IsLFNDriveA(LPCSTR pszPath);
extern "C" __declspec(dllimport) BOOL __stdcall IsLFNDriveW(LPCWSTR pszPath);




#line 911 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"



























#line 939 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"

extern "C" BOOL __stdcall   SHTestTokenMembership(HANDLE hToken, ULONG ulRID);

















#line 959 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"


}
#line 963 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"


#line 1 "d:\\sdk\\Microsoft SDK\\include\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "d:\\sdk\\Microsoft SDK\\include\\poppack.h"


#line 36 "d:\\sdk\\Microsoft SDK\\include\\poppack.h"
#line 37 "d:\\sdk\\Microsoft SDK\\include\\poppack.h"
#line 966 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"
#line 967 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"

#line 969 "d:\\sdk\\Microsoft SDK\\include\\ShellAPI.h"

#line 1825 "u:/uppsrc\\CtrlCore/CtrlCore.h"

#line 1827 "u:/uppsrc\\CtrlCore/CtrlCore.h"
#line 1828 "u:/uppsrc\\CtrlCore/CtrlCore.h"

#line 1830 "u:/uppsrc\\CtrlCore/CtrlCore.h"
#line 5 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\RichText/RichText.h"



#line 1 "u:/uppsrc\\CtrlCore/CtrlCore.h"





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 5 "u:/uppsrc\\RichText/RichText.h"
#line 1 "u:/uppsrc\\plugin/png/png.h"



#line 1 "u:/uppsrc\\Draw/Draw.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 5 "u:/uppsrc\\plugin/png/png.h"

namespace Upp {

class PNGRaster : public StreamRaster {
	class Data;
	One<Data> data;

public:
	PNGRaster();
	~PNGRaster();

	virtual bool    Create();
	virtual Size    GetSize();
	virtual Info    GetInfo();
	virtual Line    GetLine(int line);
	virtual const RGBA *GetPalette();
	virtual const RasterFormat *GetFormat();

private:
	bool            Init();
};

class PNGEncoder : public StreamRasterEncoder {
	class Data;
	One<Data> data;

public:
	PNGEncoder(int bpp = 32, ImageKind kind = IMAGE_UNKNOWN, bool interlace = false);
	~PNGEncoder();

	virtual int  GetPaletteCount();
	virtual void Start(Size sz);
	virtual void WriteLineRaw(const byte *data);

	PNGEncoder&  Bpp(int b)                      { bpp = b; return *this; }
	PNGEncoder&  Interlace(int b = true)         { interlace = b; return *this; }

private:
	int          bpp;
	ImageKind    kind;
	bool         interlace;
};

};

#line 51 "u:/uppsrc\\plugin/png/png.h"
#line 6 "u:/uppsrc\\RichText/RichText.h"

namespace Upp {

struct Zoom {
	int m, d;

	int operator*(int x) const   { return d ? iscale(x, m, d) : 0; }
	int operator&(int x) const   { int q = d ? iscale(x, m, d) : 0; return x > 0 ? max(q, 1) : q; }

	double AsDouble() const      { return (double)m / d; }

	Zoom()                       { m = d = 1; }
	Zoom(const Nuller&)          { m = d = 0; }
	Zoom(int _m, int _d)         { m = _m, d = _d; }

	void Serialize(Stream& s)    { s % m % d; }

	bool operator==(Zoom a)      { return m == a.m && d == a.d; }
	bool operator!=(Zoom a)      { return m != a.m || d != a.d; }

	friend int operator/(int x, Zoom z)  { return z.m ? iscale(x, z.d, z.m) : 0; }
};

inline bool IsNull(Zoom z) { return (z.m | z.d) == 0; }

inline int operator*(int x, Zoom m)
{
	return m * x;
}

inline void operator*=(int& i, Zoom m)
{
	i = m * i;
}

inline void operator*=(Rect& r, Zoom m)
{
	r.left *= m;
	r.right *= m;
	r.top *= m;
	r.bottom *= m;
}

inline Size operator*(Zoom m, Size sz)
{
	return Size(m * sz.cx, m * sz.cy);
}

inline Size operator/(Size sz, Zoom m)
{
	return Size(sz.cx / m, sz.cy / m);
}

struct PageY : Moveable<PageY, RelOps<PageY> > {
	int page;
	int y;

	PageY(int page, int y) : page(page), y(y) {}
	PageY() { page = y = 0; }




};

inline bool operator<(PageY a, PageY b)
{
	return a.page < b.page ? true : a.page == b.page ? a.y < b.y : false;
}

inline bool operator==(PageY a, PageY b)
{
	return a.page == b.page && a.y == b.y;
}

inline PageY operator+(PageY a, int b)
{
	return PageY(a.page, a.y + b);
}

struct PageRect : public Rect {
	int  page;

	operator int() const                 { return page; }
	operator PageY() const               { return PageY(page, top); }
	PageRect& operator=(const Rect& r)   { (Rect&)(*this) = r; page = 0; return *this; }
	PageRect(const Rect& r)              { (Rect&)(*this) = r; page = 0; }
	PageRect()                           { Clear(); page = 0; }
};

struct PageDraw {
	virtual Draw& Info() = 0;
	virtual Draw& Page(int i) = 0;

	operator Draw&()       { return Info(); }

	virtual ~PageDraw() {}
};

class RichObject;
class Bar;

struct RichObjectType : Moveable<RichObjectType> {
	virtual String GetTypeName(const Value& v) const = 0;
	virtual String GetCreateName() const;
	virtual Size   GetDefaultSize(const Value& data, Size maxsize) const;
	virtual Size   GetPhysicalSize(const Value& data) const;
	virtual Size   GetPixelSize(const Value& data) const;
	virtual void   Paint(const Value& data, Draw& w, Size sz) const;
	virtual Image  ToImage(const Value& data, Size sz) const;
	virtual Value  Read(const String& s) const;
	virtual String Write(const Value& v) const;
	virtual void   Menu(Bar& bar, RichObject& ex) const;
	virtual void   DefaultAction(RichObject& ex) const;
	virtual String GetLink(const Value& data, Point pt, Size sz) const;

	virtual bool   Accept(PasteClip& clip);
	virtual Value  Read(PasteClip& clip);
	virtual String GetClipFmts() const;
	virtual String GetClip(const Value& data, const String& fmt) const;

	RichObjectType();
	virtual ~RichObjectType();
};

class RichObject : Moveable<RichObject> {
	Value                 data;
	int                   ydelta;
	Size                  size;
	Size                  physical_size;
	Size                  pixel_size;
	bool                  keepratio;
	const RichObjectType *type;
	int64                 serial;
	String                type_name;

	static VectorMap<String, RichObjectType *>& Map();

	void                  NewSerial();

public:
	static void   Register(const char *name, RichObjectType *type) ;
	static int    GetTypeCount()                 { return Map().GetCount(); }
	static int    FindType(const String& name)   { return Map().Find(name); }
	static RichObjectType& GetType(int i)        { return *Map()[i]; }
	static String GetTypeName(int i)             { return Map().GetKey(i); }

	void   SetSize(int cx, int cy)               { size = Size(cx, cy); NewSerial(); }
	void   SetSize(Size sz)                      { size = sz; NewSerial(); }
	Size   GetSize() const                       { return size; }
	void   Paint(Draw& w, Size sz) const;
	Image  ToImage(Size sz) const;
	Size   GetPhysicalSize() const               { return physical_size; }
	Size   GetPixelSize() const                  { return pixel_size; }
	Size   GetDefaultSize(Size maxsize) const    { return type ? type->GetDefaultSize(data, maxsize) : physical_size; }

	void   Set(RichObjectType *type, const Value& data, Size maxsize = Size(3967, 3967));
	bool   Set(const String& type_name, const Value& data, Size maxsize = Size(3967, 3967));

	String GetTypeName() const;
	Value  GetData() const                       { return data; }
	String GetLink(Point pt, Size sz) const      { return type ? type->GetLink(data, pt, sz) : String(); }

	const RichObjectType& GetType() const;

	bool   Read(const String& type, const String& data, Size sz);
	String Write() const                         { return type ? type->Write(data) : (String)data; }

	void   KeepRatio(bool b)                     { keepratio = b; }
	bool   IsKeepRatio() const                   { return keepratio; }

	void   SetYDelta(int yd)                     { ydelta = yd; }
	int    GetYDelta() const                     { return ydelta; }

	void   Menu(Bar& bar)                        { if(type) type->Menu(bar, *this); }
	void   DefaultAction()                       { if(type) type->DefaultAction(*this); }

	operator bool() const                        { return !IsNull(data); }

	void   Clear();

	int64  GetSerialId() const                   { return serial; }

	RichObject();
	RichObject(RichObjectType *type, const Value& data, Size maxsize = Size(3967, 3967));
	RichObject(const String& type, const Value& data, Size maxsize = Size(3967, 3967));
};

RichObject CreateDrawingObject(const Drawing& dwg, Size dot_size, Size size);
RichObject CreateDrawingObject(const Drawing& dwg, int cx = 0, int cy = 0);
RichObject CreatePNGObject(const Image& img, Size dot_size, Size size);
RichObject CreatePNGObject(const Image& img, Size dot_size, Size size);
RichObject CreateImageObject(const Image& img, int cx = 0, int cy = 0);

struct RichPara;

enum {
	RICHHOT_LM = -1,
	RICHHOT_RM = -2,
};

struct RichHotPos {
	int table;
	int column;
	int delta;
	int left, cx;
	int textleft, textcx;

	RichHotPos()       { table = 0; column = Null; }
};

struct RichValPos : Moveable<RichValPos> {
	PageY   py;
	int     pos;
	WString data;
};

struct PaintInfo {
	Zoom    zoom;
	int     sell, selh;
	int     tablesel;
	Rect    cells;
	PageY   top;
	PageY   bottom;
	Color   hyperlink;
	Color   indexentry;
	bool    usecache;
	bool    sizetracking;
	Color   showcodes;
	Bits  (*spellingchecker)(const RichPara& para);
	int     highlightpara;
	Color   highlight;
	bool    coloroverride;

	PaintInfo();
};

int LineZoom(Zoom z, int a);

class RichTable;

#line 1 "u:\\uppsrc\\richtext\\Para.h"
struct RichCaret;
struct RichPos;

struct RichPara {
	enum Code {
		NONE,

		INDEXENTRY  = 2,
		FIELD       = 3,
		FACE        = 4,
		HEIGHT      = 5,
		LANGUAGE    = 6,
		INK         = 7,
		PAPER       = 8,

		TAB         = 9,

		LINK        = 10,
		SSCRIPT     = 11,

		BOLD0       = 12,
		BOLD1       = 13,
		BOLDS       = 14,
		ITALIC0     = 15,
		ITALIC1     = 16,
		ITALICS     = 17,
		UNDERLINE0  = 18,
		UNDERLINE1  = 19,
		UNDERLINES  = 20,
		CAPITALS0   = 21,
		CAPITALS1   = 22,
		CAPITALSS   = 23,
		STRIKEOUT0  = 24,
		STRIKEOUT1  = 25,
		STRIKEOUTS  = 26,
		DASHED0     = 27,
		DASHED1     = 28,
		DASHEDS     = 29,

		OBJECT      = 31
	};

	enum BULLET_STYLE {
		BULLET_NONE,
		BULLET_ROUND,
		BULLET_ROUNDWHITE,
		BULLET_BOX,
		BULLET_BOXWHITE,
		BULLET_TEXT
	};

	enum NUMBER_STYLE {
		NUMBER_NONE,
		NUMBER_1,
		NUMBER_0,
		NUMBER_a,
		NUMBER_A,
		NUMBER_i,
		NUMBER_I,
	};

	enum LINESPACING {
		LSP10 = 0,
		LSP15 = -1,
		LSP20 = -2,
	};

	struct CharFormat : public Font {
		int     language;
		Color   ink, paper;
		String  link;
		WString indexentry;
		dword   sscript:2;
		bool    capitals;
		bool    dashed;





		CharFormat();
	};

	struct Tab : Moveable<Tab> {
		int   pos;
		byte  align;
		byte  fillchar;

		Tab() { align = ALIGN_LEFT; pos = 0; fillchar = 0; }
	};

	struct NumberFormat {
		String      before_number, after_number;
		bool        reset_number;
		byte        number[8];

		bool        IsNumbered() const;
		int         GetNumberLevel() const;
	};

	struct Format : NumberFormat, CharFormat {
		int         align;
		int         before, lm, indent, rm, after;
		int         tabsize;
		int         bullet;
		int         linespacing;
		bool        newpage, keep, keepnext, orphan;
		WithDeepCopy< Vector<Tab> > tab;
		String      label;
		Uuid        styleid;

		void        SortTabs();





		Format();
	};

	struct Number {
		int     n[8];

		String  AsText(const NumberFormat& format) const;
		void    TestReset(const NumberFormat& format);
		void    Next(const NumberFormat& format);

		Number();
	};

	struct Part {
		RichObject                  object;
		WString                     text;
		CharFormat                  format;
		Id                          field;
		String                      fieldparam;
		WithDeepCopy< Array<Part> > fieldpart;

		bool        NonText() const    { return object || field; }
		bool        IsText() const     { return !NonText(); }
		int         GetLength() const  { return object || field ? 1 : text.GetLength(); }
	};

	struct FieldType {
		virtual Array<Part> Evaluate(const String& param, VectorMap<String, Value>& vars,
		                             const CharFormat& fmt) = 0;
		virtual void        Menu(Bar& bar, String *param) const {}
		virtual void        DefaultAction(String *param) const {}
		virtual ~FieldType() {}
	};

	struct HeightInfo {
		int                  ascent;
		int                  descent;
		int                  external;
		int                  ydelta;
		const RichObject    *object;

		int                  Sum() const { return ascent + descent + external; }
	};

	struct Line : public HeightInfo {
		int  pos;
		int  len;
		int  ppos;
		int  plen;
		int  xpos;
		int  cx;
		int  objecti;
		bool withtabs;
	};

	struct Lines {
		int                        len;
		int                        clen;
		int                        cx;
		Buffer<wchar>              text;
		Buffer<byte>               spell;
		Buffer<int>                pos;
		Buffer<int>                width;
		Buffer<HeightInfo>         height;
		Buffer<const CharFormat *> format;
		Array<Line>                line;
		Array<CharFormat>          hformat;
		int                        first_indent;
		int                        next_indent;


		int                  GetCount() const        { return line.GetCount(); }
		Line&                operator[](int i)       { return line[i]; }
		const Line&          operator[](int i) const { return line[i]; }
		void                 Justify(const Format& format);
		int                  BodyHeight();
	};

	static const VectorMap<Id, FieldType *>& fieldtype();
	static void  Register(Id id, FieldType& ft) ;

	Format      format;
	Array<Part> part;

	static void Charformat(Stream& out, const CharFormat& o, const CharFormat& n,
	                       const CharFormat& s);

	void        Cat(const WString& s, const CharFormat& f);
	void        Cat(const char *s, const CharFormat& f);
	void        Cat(const RichObject& o, const CharFormat& f);
	void        Cat(Id fieldtype, const String& param, const CharFormat& f);

	int         GetLength() const;
	int         GetCount() const                          { return part.GetCount(); }
	bool        IsEmpty() const;
	String      Pack(const Format& style, Array<RichObject>& obj) const;
	void        Unpack(const String& s, const Array<RichObject>& obj,
	                   const Format& style);

	Part&       operator[](int i)                         { return part[i]; }
	const Part& operator[](int i) const                   { return part[i]; }
	int         FindPart(int& pos) const;
	void        Trim(int pos);
	void        Mid(int pos);
	void        Append(const RichPara& p)                 { part.Append(p.part); }

	void        GetRichPos(RichPos& rp, int pos) const;

	Lines       FormatLines(int cx) const;
	void        Paint(PageDraw& pw, const Rect& page, PageY py, const PaintInfo& pi,
	                  const Number& n, const Bits& spellerrors,
	                  int nbefore, int nline) const;
	RichCaret   GetCaret(int pos, const Rect& page, PageY py, int nbefore, int nline) const;
	int         GetPos(int x, PageY y, const Rect& page, PageY py, int nbefore, int nline) const;
	void        GatherLabels(Vector<RichValPos>& info, const Rect& page, PageY py,
	                         int pos, int nbefore, int nline) const;
	void        GatherIndexes(Vector<RichValPos>& info, const Rect& page, PageY py,
	                          int pos, int nbefore, int nline) const;
	int         GetVertMove(int pos, int gx, const Rect& page, int dir) const;

	WString     GetText() const;

	bool        HasPos() const;

	bool        EvaluateFields(VectorMap<String, Value>& vars);

	void        operator<<=(const RichPara& p)            { format = p.format; part <<= p.part; }





	void        ApplyZoom(Zoom z);

private:
	Tab         GetNextTab(int pos) const;
	void        Smh(Lines& lines, HeightInfo *th, int cx) const;
	Lines       Begin(const Rect& page, PageY& py, int nbefore, int nline) const;
	bool        BreaksPage(PageY py, const Lines& pl, int i, const Rect& page) const;
	void        PackParts(Stream& out, const CharFormat& chrstyle,
	                      const Array<Part>& part, CharFormat& cf,
	                      Array<RichObject>& obj) const;
	void        UnpackParts(Stream& in, const CharFormat& chrstyle,
	                        Array<Part>& part, const Array<RichObject>& obj, int& oi);
	static void Flush(Draw& draw, const PaintInfo& pi, wchar *text, const CharFormat **i0,
                      int *wd, int pos, int len, int x0, int x, int y0, int y, int linecy,
                      int lineascent, Zoom z, bool highlight);
	int         PosInLine(int x, const Rect& page, const Lines& pl, int lni) const;
	struct StorePart;
};

inline bool operator==(const RichPara::Tab& a, const RichPara::Tab& b) {
	return a.pos == b.pos && a.align == b.align && a.fillchar == b.fillchar;
}

bool operator==(const Vector<RichPara::Tab>& a, const Vector<RichPara::Tab>& b);

inline
bool operator!=(const Vector<RichPara::Tab>& a, const Vector<RichPara::Tab>& b) {
	return !(a == b);
}

bool NumberingDiffers(const RichPara::Format& fmt1, const RichPara::Format& fmt2);

void Sort(Vector<RichPara::Tab>& tab);

void operator*=(RichPara::Format& fmt, Zoom z);
#line 248 "u:/uppsrc\\RichText/RichText.h"

struct RichPos {
	int              tabtextparti;
	int              tabtextpartcount;
	int              tabposintabtext;
	int              tabtextlen;

	int              table;
	Size             tabsize;
	Point            cell;

	int              tablen;
	int              posintab;

	int              celllen;
	int              posincell;

	int              parai;
	int              partcount;
	int              posinpara;
	int              paralen;

	int              level;
	int              parenttab;

	RichPara::Format format;
	int              chr;
	RichObject       object;
	Id               field;
	String           fieldparam;
	RichPara::CharFormat fieldformat;





	RichPos();
};

inline bool InSameTxt(const RichPos& a, const RichPos& b)
{
	return a.table == b.table && (a.table == 0 || a.cell == b.cell);
}

struct RichCaret : PageRect {
	int  lineascent;
	int  caretascent;
	int  caretdescent;
	int  objectcy;
	int  objectyd;
	int  line;
	Rect textpage;

	RichCaret()         { lineascent = caretascent = caretdescent = 0; }
};

struct RichStyle {
	RichPara::Format     format;
	String               name;
	Uuid                 next;

	static Uuid              GetDefaultId();
	static const RichStyle&  GetDefault();

	RichStyle()          { next = GetDefaultId(); }
};

typedef ArrayMap<Uuid, RichStyle> RichStyles;

const RichStyle& GetStyle(const RichStyles& s, const Uuid& id);
int   FindStyleWithName(const RichStyles& style, const String& name);

struct RichContext {
	const RichStyles& styles;
	Rect              page;
	PageY             py;

	void              Page() { py.page++; py.y = page.top; }

	RichContext(const RichStyles& styles) : styles(styles) {}
};

struct RichCellPos;

#line 1 "u:\\uppsrc\\richtext\\Txt.h"
class RichTxt : DeepCopyOption<RichTxt> {
public:
	enum {
		BOLD       = 0x00000001,
		ITALIC     = 0x00000002,
		UNDERLINE  = 0x00000004,
		FACE       = 0x00000008,
		HEIGHT     = 0x00000010,
		LANGUAGE   = 0x00000020,
		INK        = 0x00000040,
		PAPER      = 0x00000080,
		LINK       = 0x00000100,
		SSCRIPT    = 0x00000200,
		CAPITALS   = 0x00000400,
		STRIKEOUT  = 0x00000800,
		LANG       = 0x00001000,
		INDEXENTRY = 0x00002000,
		DASHED     = 0x00004000,
	};

	enum {
		ALIGN     = 0x80000000,
		BEFORE    = 0x40000000,
		LM        = 0x20000000,
		INDENT    = 0x10000000,
		RM        = 0x08000000,
		AFTER     = 0x04000000,
		TABSIZE   = 0x02000000,
		BULLET    = 0x01000000,
		NEWPAGE   = 0x00800000,
		KEEP      = 0x00400000,
		TABS      = 0x00200000,
		STYLE     = 0x00100000,
		LABEL     = 0x00080000,
		KEEPNEXT  = 0x00040000,
		ORPHAN    = 0x00020000,
		NUMBERING = 0x00010000,
		SPACING   = 0x00008000,
	};

	struct FormatInfo : RichPara::Format {
		dword charvalid;
		dword paravalid;

		void  Set(const RichPara::Format& fmt);
		void  Set(const RichPara::CharFormat& fmt);
		void  Combine(const RichPara::CharFormat& fmt);
		void  Combine(const RichPara::Format& fmt);
		void  Combine(const FormatInfo& fmt);
		void  ApplyTo(RichPara::CharFormat& fmt) const;
		void  ApplyTo(RichPara::Format& fmt) const;
	};

	class Formating {
		Vector<Uuid>    styleid;
		Vector<String>  format;
		friend class RichText;
		friend class RichTxt;
	};

protected:
	struct Para : DeepCopyOption<Para> {
		Uuid                  styleid;
		int                   length;
		String                content;
		Array<RichObject>     object;
		mutable int           cx;
		mutable int           cy;
		mutable int           before;
		mutable Vector<int>   linecy;
		mutable int           after;
		mutable bool          newpage;
		mutable bool          keep;
		mutable bool          keepnext;
		mutable bool          orphan;
		mutable int           numbering;
		mutable Bits          spellerrors;
		mutable bool          checked;
		mutable bool          haspos;
		One<RichPara::NumberFormat> number;

		Para(const Para& src, int);
		Para() { length = 0; cx = -1; numbering = -1; checked = false; haspos = false; }
	};

	struct Part : MoveableAndDeepCopyOption< Part, Any> {
		Part(const Part& src, int);
		Part();
	};

	Vector<Part>           part;
	mutable int            length;
	mutable int            tabcount;
	mutable Rect           rect;
	mutable Vector<PageY>  py;

	enum {
		NONE, SPARA, PARA, FROM, ALL
	};

	int  r_type;
	int  r_parti;
	int  r_paraocx;
	int  r_paraocy;
	bool r_keep;
	bool r_keepnext;
	bool r_newpage;

	void       Init();

	void       Invalidate();

	void       SetRefresh(int parai);
	void       SetRefreshFrom(int parai);
	void       RefreshAll()                   { SetRefreshFrom(0); }

	void       ParaRemove(int parai, int pos, int count);
	void       ParaInsert(int parai, int pos, const RichPara& p);
	RichPara   ParaCopy(int parai, int pos, int count) const;

	void       Put(int i, const RichPara& p, const RichStyle& s);
	void       Put(int i, const RichPara& p, const RichStyles& s);
	int        GetPartLength(int pi) const;
	int        FindPart(int& pos) const;
	int        GetPartPos(int pi) const;

	void        Sync0(const Para& pp, int parti, const RichContext& rc) const;
	inline void Sync(int parti, const RichContext& rc) const {
		int cx = rc.page.Width();
		;
		const Para& pp = part[parti].Get<Para>();
		if(pp.cx == cx) return;
		Sync0(pp, parti, rc);
	}
	bool        BreaksPage(PageY py, const Para& pp, int i, const Rect& page) const;
	PageY       GetNextPageY(int parti, const RichContext& rc) const;
	PageY       GetPartPageY(int parti, RichContext rc) const;

	struct ParaOp {
		virtual bool operator()(RichTxt::Para& p) = 0;
		virtual ~ParaOp() {}
	};
	bool             Update(ParaOp& op);
	RichTxt&         GetText0(int& pos, bool update);
	RichTxt&         GetUpdateText(int& pos);
	const RichTxt&   GetConstText(int& pos) const;
	RichTable&       GetTable0(int table, bool update);
	RichTable&       GetUpdateTable(int table);
	const RichTable& GetConstTable(int table) const;
	RichTxt&         GetTableUpdateText(int table, const RichStyles& style, int& pi);

	void        CombineFormat(FormatInfo& f, int pi, int pi2, bool& first, const RichStyles& style) const;
	static void Apply(const FormatInfo& fi, RichPara& pa);
	void        ApplyFormat(const FormatInfo& f, int pi, int pi2, const RichStyles& style);
	void        SaveFormat(Formating& f, int p1, int p2, const RichStyles& style) const;
	void        RestoreFormat(int pi, const Formating& info, int& ii, const RichStyles& style);

	void        GetAllLanguages(Index<int>& all) const;

	friend class RichTable;
	friend class RichText;
	friend class RichCell;

	int                   ComputeLength() const;

	void                  GetRichPos(int pos, RichPos& rp, int ti, int maxlevel, const RichStyles& st) const;
	RichPara::Format      GetFirstFormat(const RichStyles& st) const;

	PageY                 GetTop(RichContext rc) const;
	PageY                 GetHeight(RichContext rc) const;
	int                   GetWidth(const RichStyles& st) const;
	void                  Paint(PageDraw& w, RichContext rc, const PaintInfo& pi) const;
	RichCaret             GetCaret(int pos, RichContext rc) const;
	int                   GetPos(int x, PageY y, RichContext rc) const;
	int                   GetVertMove(int pos, int gx, RichContext rc, int dir) const;
	RichHotPos            GetHotPos(int x, PageY y, int tolerance, RichContext rc) const;

	void                  GatherValPos(Vector<RichValPos>& f, RichContext rc, int pos, int type) const;

	bool                  EvaluateFields(const RichStyles& s, VectorMap<String, Value>& vars);

	void                  ApplyZoom(Zoom z, const RichStyles& ostyle, const RichStyles& zstyle);

public:
	enum ValPosType { LABELS, INDEXENTRIES };

	RichPara              Get(int i, const RichStyles& s) const;
	RichPara              Get(int i, const Uuid& styleid, const RichStyles& s) const;
	RichPara              Get(int i, const RichStyle& style) const;
	Uuid                  GetParaStyle(int i) const            { return part[i].Get<Para>().styleid; }
	void                  SetParaStyle(int i, const Uuid& si);

	int                   GetPartCount() const                 { return part.GetCount(); }
	bool                  IsPara(int i) const                  { return part[i].Is<Para>(); }
	bool                  IsTable(int i) const;
	const RichTable&      GetTable(int i) const;

	int                   GetLength() const;
	int                   GetTableCount() const;
	bool                  IsEmpty() const;

	RichCellPos           GetCellPos(int table, int row, int column) const;
	RichCellPos           GetCellPos(int table, Point p) const;

	void                  Clear();

	void                  ClearSpelling();

	void                  SetPick(int parti,  RichTable& table);
	void                  CatPick( RichTable& table)             { SetPick(GetPartCount(), table); }
	void                  Set(int parai, const RichPara& p, const RichStyles& s);
	void                  Insert(int parai, const RichPara& p, const RichStyles& s);
	void                  Cat(const RichPara& p, const RichStyles& s) { Set(GetPartCount(), p, s); }

	void                  Normalize();

	Vector<int>           GetAllLanguages() const;
	WString               GetPlainText() const;

	struct UpdateIterator {
		enum { CONTINUE = 0, STOP = 1, UPDATE = 2 };
		virtual int operator()(int pos, RichPara& para) = 0;
		virtual ~UpdateIterator() {}
	};
	bool                  Iterate(UpdateIterator& r, int gpos, const RichStyles& s);

	struct Iterator {
		virtual bool operator()(int pos, const RichPara& para) = 0;
		virtual ~Iterator() {}
	};
	bool                  Iterate(Iterator& r, int gpos, const RichStyles& s) const;

	RichTxt(const RichTxt& src, int);
	RichTxt();




};
#line 333 "u:/uppsrc\\RichText/RichText.h"
#line 1 "u:\\uppsrc\\richtext\\Table.h"
class RichCell : DeepCopyOption<RichCell> {
public:
	struct Format {
		Rect     border;
		Rect     margin;
		int      align;
		int      minheight;
		Color    color;
		Color    bordercolor;
		bool     keep;

		Format();
	};

	Format   format;
	int      vspan, hspan;
	RichTxt  text;

private:
	bool     Reduce(RichContext& rc) const;
	PageY    Align(const RichContext& rc, PageY npy) const;
	void     DrawCell(Draw& w, int l, int r, int y, int yy, const Rect& border) const;

	void        ClearText();
	void        ClearText(const RichPara::Format& format, const RichStyles& style);
	void        Clear();

	PageY       GetTop(RichContext rc) const;
	PageY       GetHeight(RichContext rc) const;
	void        Paint(PageDraw& pw, RichContext rc, PageY npy,
	                  const Rect& xpg, int y, int ny, const PaintInfo& pi,
	                  bool select) const;
	RichCaret   GetCaret(int pos, RichContext rc, PageY pyy) const;
	int         GetPos(int x, PageY y, RichContext rc, PageY pyy) const;
	RichHotPos  GetHotPos(int x, PageY y, int tolerance, RichContext rc, PageY pyy) const;

	void        GatherValPos(Vector<RichValPos>& f, RichContext rc, PageY pyy, int pos, int type) const;

	friend class RichTable;
	friend class RichText;

public:
	RichCell(const RichCell& src, int);
	RichCell();
};

class RichTable : DeepCopyOption<RichTable> {
public:
	struct Format {
		int   before, lm, rm, after;
		int   frame;
		Color framecolor;
		int   grid;
		Color gridcolor;
		WithDeepCopy< Vector<int> > column;
		int   header;
		bool  keep;

		Format();
	};

	struct CellInfo {
		bool  valid;
		Point master;

		operator bool() const { return valid; }

		CellInfo()            { valid = true; }
	};

	Format format;
	Array< Array<RichCell> > cell;

private:
	struct PaintCell : Moveable<PaintCell> {
		int   left;
		int   right;
		Rect  page;
		PageY hy;
		bool  top;
		bool  bottom;

		PaintCell()    { top = true; }
	};

	struct PaintRow : Moveable<PaintRow> {
		PageY             gpy;
		PageY             py, pyy;
		Buffer<PaintCell> cell;
		bool              first;

		PaintCell& operator[](int i)                { return cell[i]; }
		const PaintCell& operator[](int i) const    { return cell[i]; }
	};

	struct Layout {
		Buffer<Rect>      col;
		Buffer<PaintRow>  row;
		int               frame;
		int               grid;
		PageY             pyy;

		PaintRow& operator[](int i)                 { return row[i]; }
		const PaintRow& operator[](int i) const     { return row[i]; }
	};

	struct TabLayout : Layout {
		bool              hasheader;
		Layout            header;
		Rect              page;
		int               page0;
		Size              sz;
	};

	mutable TabLayout clayout;
	mutable Rect      cpage;
	mutable PageY     cpy;

	Buffer< Buffer<CellInfo> > ci;
	int              r_row, r_column;
	Rect             r_page;
	PageY            r_py, r_pyy;

	void             Invalidate();
	void             InvalidateRefresh(int i, int j);
	void             InvalidateRefresh(Point p)            { InvalidateRefresh(p.y, p.x); }

	bool             Reduce(RichContext& rc) const;
	Layout           Realize(RichContext rc, int ny) const;
	bool             RowPaint(PageDraw& pw, const RichStyles& st, const Layout& tab,
	                          int i, int ny, const Rect& pg, VectorMap<int, Rect>& frr,
	                          PaintInfo& pi, int pd, bool sel) const;

	const TabLayout& Realize(RichContext rc) const;

	mutable int  length, tabcount;

	static void  ExpandFrr(VectorMap<int, Rect>& frr, int pi, int l, int r, int t, int b);

	friend class RichTxt;
	friend class RichText;
public:

	Array<RichCell>&       operator[](int i)             { return cell[i]; }
	const Array<RichCell>& operator[](int i) const       { return cell[i]; }
	RichCell&       operator[](Point p)                  { return cell[p.y][p.x]; }
	const RichCell& operator[](Point p) const            { return cell[p.y][p.x]; }
	int             GetCellPos(int i, int j) const;
	int             GetCellPos(Point p) const            { return GetCellPos(p.y, p.x); }
	int             GetTableCount(int i, int j) const;
	int             GetTableCount(Point p) const         { return GetTableCount(p.y, p.x); }
	Point           GetMasterCell(int i, int j) const;
	Point           GetMasterCell(Point p) const         { return GetMasterCell(p.y, p.x); }
	const RichCell& GetMaster(int i, int j) const;

	int           GetLength() const;
	int           GetTableCount() const;

private:
	void          Normalize0();

	RichTable     Copy(const Rect& sel) const;
	void          Paste(Point pos, const RichTable& tab);
	void          RemoveRow0(int rowi);
	void          RemoveRow(int rowi);
	void          InsertRow(int rowi, const RichStyles& style);
	void          RemoveColumn0(int column);
	void          RemoveColumn(int column);
	void          InsertColumn(int column, const RichStyles& style);
	bool          IsRowEmpty(int row);
	bool          IsColumnEmpty(int column);
	void          SplitCell(Point cl, Size sz, const RichStyles& style);
	RichCell::Format GetCellFormat(const Rect& sel) const;
	void             SetCellFormat(const Rect& sel, const RichCell::Format& fmt, bool setkeep);

	PageY         GetHeight(RichContext rc) const;
	PageY         GetTop(RichContext rc) const;
	void          Paint(PageDraw& pw, RichContext rc, const PaintInfo& pi) const;
	RichCaret     GetCaret(int pos, RichContext rc) const;
	int           GetPos(int x, PageY y, RichContext rc) const;
	int           GetVertMove(int pos, int gx, RichContext rc, int dir) const;
	RichHotPos    GetHotPos(int x, PageY y, int tolerance, RichContext rc) const;
	void          AdjustSel(Rect& sel) const;

	void          GatherValPos(Vector<RichValPos>& f, RichContext rc, int pos, int type) const;
	void          ClearSpelling();

	Point         FindCell(int& pos) const;
	RichPos       GetRichPos(int pos, const RichStyles& st) const;

	CellInfo      GetCellInfo(int i, int j)              { return ci[i][j]; }

	int           GetInvalid(PageY& top, PageY& bottom, RichContext rc) const;
	void          Validate();

	void          ApplyZoom(Zoom z, const RichStyles& ostyle, const RichStyles& zstyle);

public:
	void                    AddColumn(int cx);
	void                    SetPick(int i, int j,  RichTxt& text);
	RichTxt                 GetPick(int i, int j);
	const RichTxt&          Get(int i, int j) const                { return cell[i][j].text; }
	void                    SetQTF(int i, int j, const char *qtf);
	void                    SetFormat(int i, int j, const RichCell::Format& fmt);
	const RichCell::Format& GetFormat(int i, int j)                { return cell[i][j].format; }
	bool                    operator()(int i, int j) const         { return ci[i][j].valid; }
	void                    SetSpan(int i, int j, int vspan, int hspan);
	Size                    GetSpan(int i, int j) const;
	void                    SetFormat(const Format& fmt);
	const Format&           GetFormat() const                      { return format; }

	int                     GetColumns() const                     { return format.column.GetCount(); }
	int                     GetRows() const                        { return cell.GetCount(); }
	Size                    GetSize() const                        { return Size(GetColumns(), GetRows()); }

	void          Normalize();

	RichTable(const RichTable& src, int);
	RichTable();
};
#line 334 "u:/uppsrc\\RichText/RichText.h"
#line 1 "u:\\uppsrc\\richtext\\Text.h"
class RichText : public RichTxt, public DeepCopyOption<RichText> {
	RichStyles style;
	String     footer;
	bool       nolinks;

	void       Init();

	struct StyleChangeOp;
	struct SetStylesOp;
	struct RemoveStyleOp;
	struct MergeStylesOp;
	friend struct MergeStylesOp;
	struct OverrideStylesOp;

public:
	void                  Clear();

	int                   GetStyleCount() const                { return style.GetCount(); }
	Uuid                  GetStyleId(int i) const              { return style.GetKey(i); }
	Uuid                  GetStyleId(const String& name) const;
	const RichStyle&      GetStyle(int i) const                { return style[i]; }
	const RichStyle&      GetStyle(const Uuid& id) const       { return Upp::GetStyle(style, id); }
	void                  SetStyle(const Uuid& id, const RichStyle& _style);
	bool                  HasStyle(const Uuid& id)             { return style.Find(id) >= 0; }
	void                  RemoveStyle(const Uuid& id);

	const RichStyles&     GetStyles() const                    { return style; }
	void                  SetStyles(const RichStyles& styles);
	void                  OverrideStyles(const RichStyles& masterstyles,
	                                     bool matchname = true, bool addmissing = true);
	void                  MergeStyles(const RichText& text);

	RichPara              Get(int i) const                     { return RichTxt::Get(i, style); }
	void                  Cat(const RichPara& p)               { RichTxt::Cat(p, style); }
	void                  CatPick( RichText& p);
	using                 RichTxt::CatPick;

	RichContext           Context(const Rect& page) const;

	RichPos               GetRichPos(int pos, int maxlevel = 2147483647) const;
	int                   operator[](int pos) const            { return GetRichPos(pos).chr; }

	void                  ApplyZoom(Zoom z);

	PageY                 GetHeight(PageY py, const Rect& page) const;
	PageY                 GetHeight(const Rect& page) const;
	void                  Paint(PageDraw& w, PageY py, const Rect& page, const PaintInfo& pi) const;
	void                  Paint(PageDraw& w, const Rect& page, const PaintInfo& pi) const;
	RichCaret             GetCaret(int pos, const Rect& page) const;
	int                   GetPos(int x, PageY y, const Rect& page) const;
	RichHotPos            GetHotPos(int x, PageY y, int tolerance, const Rect& page) const;
	int                   GetVertMove(int pos, int gx, const Rect& page, int dir) const;
	int                   GetWidth() const;

	int                   GetHeight(int cx) const;
	int                   GetHeight(Zoom zoom, int cx) const;
	void                  Paint(Draw& w, int x, int y, int cx, const PaintInfo& pi) const;
	void                  Paint(Zoom zoom, Draw& w, int x, int y, int cx) const;
	void                  Paint(Draw& w, int x, int y, int cx) const;

	Vector<RichValPos>    GetValPos(const Rect& page, int type) const;

	int                   AdjustCursor(int anchor, int cursor) const;

	void                  Remove(int pos, int count);
	void                  Insert(int pos, const RichText& p);
	RichText              Copy(int pos, int count) const;

	FormatInfo            GetFormatInfo(int pos, int count) const;
	void                  ApplyFormatInfo(int pos, const RichText::FormatInfo& fi, int count);

	void                  ReStyle(int pos, const Uuid& id);

	Formating             SaveFormat(int pos, int count) const;
	void                  RestoreFormat(int pos, const Formating& info);


	RichTable::Format     GetTableFormat(int table) const;
	void                  SetTableFormat(int table, const RichTable::Format& fmt);
	int                   SetTable(int pos, const RichTable& table);
	void                  DestroyTable(int table);
	RichTable             CopyTable(int table) const;
	void                  ReplaceTable(int table, const RichTable& tab);
	void                  RemoveParaSpecial(int table, bool before);
	bool                  CanRemoveParaSpecial(int table, bool before);
	void                  InsertParaSpecial(int table, bool before, const RichPara::Format& fmt);
	bool                  ShouldInsertParaSpecial(int table, bool before);
	RichTable             CopyTable(int table, const Rect& sel) const;
	void                  ClearTable(int table, const Rect& sel);
	void                  PasteTable(int table, Point pos, const RichTable& tab);
	void                  InsertTableRow(int table, int row);
	void                  RemoveTableRow(int table, int row);
	void                  InsertTableColumn(int table, int column);
	void                  RemoveTableColumn(int table, int column);
	Point                 GetMasterCell(int table, int row, int column);
	Point                 GetMasterCell(int table, Point p)                 { return GetMasterCell(table, p.y, p.x); }
	void                  SplitCell(int table, Point cell, Size sz);
	void                  JoinCell(int table, const Rect& sel);
	RichCell::Format      GetCellFormat(int table, const Rect& sel) const;
	void                  SetCellFormat(int table, const Rect& sel, const RichCell::Format& fmt, bool setkeep);
	FormatInfo            GetTableFormatInfo(int table, const Rect& sel) const;
	void                  ApplyTableFormatInfo(int table, const Rect& sel, const RichText::FormatInfo& fi);
	void                  AdjustTableSel(int table, Rect& sel) const        { return GetConstTable(table).AdjustSel(sel); }

	bool                  Iterate(Iterator& r) const                        { return RichTxt::Iterate(r, 0, style); }
	bool                  Iterate(UpdateIterator& r)                        { return RichTxt::Iterate(r, 0, style); }

	bool                  EvaluateFields(VectorMap<String, Value>& vars)    { return RichTxt::EvaluateFields(style, vars); }

	void                  InvalidateAll()                                   { r_type = ALL; }
	void                  Validate();
	bool                  GetInvalid(PageY& top, PageY& bottom, const Rect& page,
	                                 int sell, int selh, int osell, int oselh) const;

	struct ClipboardType {
		ClipboardType();
		virtual ~ClipboardType();

		virtual int      Level();
		virtual RichText ReadClipboard(const RichPara::Format& f) = 0;
		virtual void     WriteClipboard(const RichText& text) = 0;
	};

	static void           Register(ClipboardType& type);


	void                  SetFooter(const String& s)                          { footer = s; }
	String                GetFooter() const                                   { return footer; }
	void                  PrintNoLinks(bool b = true)                         { nolinks = b; }
	bool                  IsPrintNoLinks() const                              { return nolinks; }

	RichText()            { Init(); }
	RichText(const RichText& x, int);
	RichText( RichTxt& x,  RichStyles& st);
};
#line 335 "u:/uppsrc\\RichText/RichText.h"

struct RichCellPos {
	int               pos;

	int               textlen;

	Size              tabsize;
	int               tabpos;
	int               tablen;
	int               cellpos;
	int               celllen;
	int               level;
	RichCell::Format  format;
	RichTable::Format tableformat;




};

String DeQtf(const char *s);
String DeQtfLf(const char *s);

struct QtfRichObject {
	RichObject obj;

public:
	String ToString() const;

	QtfRichObject() {}
	QtfRichObject(const RichObject& o);
};

String AsQTF(const RichObject& obj);

RichText ParseQTF(const char *qtf, bool scolors = false, byte accesskey = 0);

RichText AsRichText(const wchar *s, const RichPara::Format& f = RichPara::Format());

enum
{
	QTF_BODY = 1,
	QTF_ALL_STYLES = 2,
	QTF_NOSTYLES = 4,
	QTF_CRLF = 8,
	QTF_NOCHARSET = 16,
	QTF_NOLANG = 32,
};

String   AsQTF(const RichText& doc, byte charset = 255,
               dword options = QTF_BODY|QTF_ALL_STYLES|QTF_CRLF);

inline String StylesAsQTF(const RichText& doc, byte charset = 255)
{ return AsQTF(doc, charset, QTF_ALL_STYLES|QTF_CRLF); }

inline String BodyAsQTF(const RichText& doc, byte charset = 255)
{ return AsQTF(doc, charset, QTF_BODY|QTF_CRLF); }

enum
{
	ROUNDOFF          = 1 << 20,
	MAX_FONTS         = 10000,
	MAX_DOTS          = 600 * 100,
	MAX_DOT_HEIGHT    = 1200,
	MAX_POINT_HEIGHT  = MAX_DOT_HEIGHT * 3 / 25,
};

inline int DotTwips (int dots) { return (dots * 12 +  5 * ROUNDOFF +  2) /  5 - ROUNDOFF; }
inline int TwipDots (int twp)  { return (twp  *  5 + 12 * ROUNDOFF +  6) / 12 - ROUNDOFF; }
inline int DotPoints(int dots) { return (dots *  3 + 25 * ROUNDOFF + 12) / 25 - ROUNDOFF; }
inline int PointDots(int pts)  { return (pts  * 25 +  3 * ROUNDOFF +  1) /  3 - ROUNDOFF; }
inline int TwipDotSize(int twp)  { return IsNull(twp) ? 0 : minmax<int>(TwipDots(twp), 0, MAX_DOTS); }
inline int PointDotHeight(int p) { return (minmax<int>(Nvl(p, 0), 0, MAX_POINT_HEIGHT) * 25 + 5) / 6; }

void       EncodeRTF(Stream& stream, const RichText& richtext, byte charset);
String     EncodeRTF(const RichText& richtext, byte charset);
String     EncodeRTF(const RichText& richtext);
RichText   ParseRTF(const char *rtf);

Zoom  GetRichTextStdScreenZoom();

const Display& QTFDisplay();
const Display& QTFDisplayVCenter();

String EncodeHtml(const RichText& text, Index<String>& css,
                  const VectorMap<String, String>& links,
                  const VectorMap<String, String>& labels,
                  const String& path, const String& base = Null, Zoom z = Zoom(8, 40),
                  const VectorMap<String, String>& escape = VectorMap<String, String>(),
                  int imtolerance = 0);
String AsCss(Index<String>& ss);

inline
String EncodeHtml(const RichText& text, Index<String>& css,
                  const VectorMap<String, String>& links,
                  const String& path, const String& base = Null, Zoom z = Zoom(8, 40)) {
	return EncodeHtml(text, css, links, VectorMap<String, String>(), path, base, z);
}

struct SimplePageDraw : PageDraw {
	Draw& w;

	virtual Draw& Info();
	virtual Draw& Page(int);

	SimplePageDraw(Draw& w) : w(w) {}
	virtual ~SimplePageDraw() {}
};

struct PrintPageDraw : PageDraw {
	int     page;
	Draw&   w;
	NilDraw nw;

	Draw& Page(int _page)     { return page == _page ? w : (Draw&)nw; }
	Draw& Info()              { return w; }
	void  SetPage(int _page)  { page = _page; }

	PrintPageDraw(Draw& w) : w(w) {}
	virtual ~PrintPageDraw() {}
};

};

#line 460 "u:/uppsrc\\RichText/RichText.h"
#line 6 "u:/uppsrc\\CtrlLib/CtrlLib.h"

namespace Upp {



#line 1 "u:/uppsrc\\Draw/iml_header.h"













class CtrlImg {
public:


	enum {
#line 1 "u:/uppsrc\\CtrlLib/Ctrl.iml"

I_arrow,
I_exclamation,
I_information,
I_question,
I_error,
I_smallcheck,
I_smallup,
I_smalldown,
I_smallleft,
I_smallright,
I_spinup3,
I_spinup2,
I_spinup,
I_spindown3,
I_spindown2,
I_spindown,
I_reporticon,
I_smallreporticon,
I_ibeam0,
I_HandCursor,
I_HelpCursor0,
I_HelpCursor1,
I_write,
I_open,
I_save,
I_save_as,
I_print,
I_new_doc,
I_menu_window,
I_undo,
I_redo,
I_cut,
I_copy,
I_paste,
I_remove,
I_menu_check,
I_menu_radio,
I_right_arrow,
I_white_right_arrow,
I_check,
I_white_check,
I_left_arrow,
I_white_left_arrow,
I_cross,
I_up_arrow,
I_down_arrow,
I_plus,
I_selection,
I_Dir,
I_DirUp,
I_MkDir,
I_File,
I_Plus,
I_Minus,
I_Toggle,
I_Diskette,
I_Hd,
I_CdRom,
I_Computer,
I_Network,
I_Var,
I_Home,
I_MenuCheck1,
I_MenuCheck0,
I_Empty16x16,
I_MenuRadio0,
I_MenuRadio1,
I_set_transparent,
I_wheel_cursor,
I_white_wheel_cursor,
I_column_cursor,
I_swap_color_cursor,
I_fetch_color,
I_fetch_color_cursor,
I_tab_wheel,
I_hthumb,
I_vthumb,
I_hthumb1,
I_vthumb1,
I_treeplus,
I_tree0,
I_tree1,
I_tree2,
I_treeminus,
I_Add,
I_Remove,
I_SmallDown,
I_SmallUp,
I_SmallRight,
I_SmallLeft,
I_go_back,
I_go_forward,
I_font_size,
I_help,
I_focus_h,
I_focus_v,
I_checkers,
I_SmallDot,
I_SmallDotH,
I_BigDot,
I_BigDotH,
I_Bg,
I_SortUp,
I_SortDown,




























































































































































































#line 20 "u:/uppsrc\\Draw/iml_header.h"
		COUNT
	};



public:
	static Upp::Iml&   Iml();

	static void        Register__()                { Register("CtrlImg", Iml()); }

	static int         Find(const Upp::String& s);
	static int         Find(const char *s);
	static int         GetCount()                  { return Iml().GetCount(); }
	static Upp::String GetId(int i)                { return Iml().GetId(i); }

	static Upp::Image  Get(int i);
	static Upp::Image  Get(const char *s);
	static Upp::Image  Get(const Upp::String& s);

	static void   Set(int i, const Upp::Image& m);
	static void   Set(const char *s, const Upp::Image& m);

	static void   Reset()                     { Iml().Reset(); }



#line 1 "u:/uppsrc\\CtrlLib/Ctrl.iml"

static Upp::Image arrow() { return Get(I_arrow); }
static Upp::Image exclamation() { return Get(I_exclamation); }
static Upp::Image information() { return Get(I_information); }
static Upp::Image question() { return Get(I_question); }
static Upp::Image error() { return Get(I_error); }
static Upp::Image smallcheck() { return Get(I_smallcheck); }
static Upp::Image smallup() { return Get(I_smallup); }
static Upp::Image smalldown() { return Get(I_smalldown); }
static Upp::Image smallleft() { return Get(I_smallleft); }
static Upp::Image smallright() { return Get(I_smallright); }
static Upp::Image spinup3() { return Get(I_spinup3); }
static Upp::Image spinup2() { return Get(I_spinup2); }
static Upp::Image spinup() { return Get(I_spinup); }
static Upp::Image spindown3() { return Get(I_spindown3); }
static Upp::Image spindown2() { return Get(I_spindown2); }
static Upp::Image spindown() { return Get(I_spindown); }
static Upp::Image reporticon() { return Get(I_reporticon); }
static Upp::Image smallreporticon() { return Get(I_smallreporticon); }
static Upp::Image ibeam0() { return Get(I_ibeam0); }
static Upp::Image HandCursor() { return Get(I_HandCursor); }
static Upp::Image HelpCursor0() { return Get(I_HelpCursor0); }
static Upp::Image HelpCursor1() { return Get(I_HelpCursor1); }
static Upp::Image write() { return Get(I_write); }
static Upp::Image open() { return Get(I_open); }
static Upp::Image save() { return Get(I_save); }
static Upp::Image save_as() { return Get(I_save_as); }
static Upp::Image print() { return Get(I_print); }
static Upp::Image new_doc() { return Get(I_new_doc); }
static Upp::Image menu_window() { return Get(I_menu_window); }
static Upp::Image undo() { return Get(I_undo); }
static Upp::Image redo() { return Get(I_redo); }
static Upp::Image cut() { return Get(I_cut); }
static Upp::Image copy() { return Get(I_copy); }
static Upp::Image paste() { return Get(I_paste); }
static Upp::Image remove() { return Get(I_remove); }
static Upp::Image menu_check() { return Get(I_menu_check); }
static Upp::Image menu_radio() { return Get(I_menu_radio); }
static Upp::Image right_arrow() { return Get(I_right_arrow); }
static Upp::Image white_right_arrow() { return Get(I_white_right_arrow); }
static Upp::Image check() { return Get(I_check); }
static Upp::Image white_check() { return Get(I_white_check); }
static Upp::Image left_arrow() { return Get(I_left_arrow); }
static Upp::Image white_left_arrow() { return Get(I_white_left_arrow); }
static Upp::Image cross() { return Get(I_cross); }
static Upp::Image up_arrow() { return Get(I_up_arrow); }
static Upp::Image down_arrow() { return Get(I_down_arrow); }
static Upp::Image plus() { return Get(I_plus); }
static Upp::Image selection() { return Get(I_selection); }
static Upp::Image Dir() { return Get(I_Dir); }
static Upp::Image DirUp() { return Get(I_DirUp); }
static Upp::Image MkDir() { return Get(I_MkDir); }
static Upp::Image File() { return Get(I_File); }
static Upp::Image Plus() { return Get(I_Plus); }
static Upp::Image Minus() { return Get(I_Minus); }
static Upp::Image Toggle() { return Get(I_Toggle); }
static Upp::Image Diskette() { return Get(I_Diskette); }
static Upp::Image Hd() { return Get(I_Hd); }
static Upp::Image CdRom() { return Get(I_CdRom); }
static Upp::Image Computer() { return Get(I_Computer); }
static Upp::Image Network() { return Get(I_Network); }
static Upp::Image Var() { return Get(I_Var); }
static Upp::Image Home() { return Get(I_Home); }
static Upp::Image MenuCheck1() { return Get(I_MenuCheck1); }
static Upp::Image MenuCheck0() { return Get(I_MenuCheck0); }
static Upp::Image Empty16x16() { return Get(I_Empty16x16); }
static Upp::Image MenuRadio0() { return Get(I_MenuRadio0); }
static Upp::Image MenuRadio1() { return Get(I_MenuRadio1); }
static Upp::Image set_transparent() { return Get(I_set_transparent); }
static Upp::Image wheel_cursor() { return Get(I_wheel_cursor); }
static Upp::Image white_wheel_cursor() { return Get(I_white_wheel_cursor); }
static Upp::Image column_cursor() { return Get(I_column_cursor); }
static Upp::Image swap_color_cursor() { return Get(I_swap_color_cursor); }
static Upp::Image fetch_color() { return Get(I_fetch_color); }
static Upp::Image fetch_color_cursor() { return Get(I_fetch_color_cursor); }
static Upp::Image tab_wheel() { return Get(I_tab_wheel); }
static Upp::Image hthumb() { return Get(I_hthumb); }
static Upp::Image vthumb() { return Get(I_vthumb); }
static Upp::Image hthumb1() { return Get(I_hthumb1); }
static Upp::Image vthumb1() { return Get(I_vthumb1); }
static Upp::Image treeplus() { return Get(I_treeplus); }
static Upp::Image tree0() { return Get(I_tree0); }
static Upp::Image tree1() { return Get(I_tree1); }
static Upp::Image tree2() { return Get(I_tree2); }
static Upp::Image treeminus() { return Get(I_treeminus); }
static Upp::Image Add() { return Get(I_Add); }
static Upp::Image Remove() { return Get(I_Remove); }
static Upp::Image SmallDown() { return Get(I_SmallDown); }
static Upp::Image SmallUp() { return Get(I_SmallUp); }
static Upp::Image SmallRight() { return Get(I_SmallRight); }
static Upp::Image SmallLeft() { return Get(I_SmallLeft); }
static Upp::Image go_back() { return Get(I_go_back); }
static Upp::Image go_forward() { return Get(I_go_forward); }
static Upp::Image font_size() { return Get(I_font_size); }
static Upp::Image help() { return Get(I_help); }
static Upp::Image focus_h() { return Get(I_focus_h); }
static Upp::Image focus_v() { return Get(I_focus_v); }
static Upp::Image checkers() { return Get(I_checkers); }
static Upp::Image SmallDot() { return Get(I_SmallDot); }
static Upp::Image SmallDotH() { return Get(I_SmallDotH); }
static Upp::Image BigDot() { return Get(I_BigDot); }
static Upp::Image BigDotH() { return Get(I_BigDotH); }
static Upp::Image Bg() { return Get(I_Bg); }
static Upp::Image SortUp() { return Get(I_SortUp); }
static Upp::Image SortDown() { return Get(I_SortDown); }




























































































































































































#line 47 "u:/uppsrc\\Draw/iml_header.h"



};












#line 64 "u:/uppsrc\\Draw/iml_header.h"
#line 12 "u:/uppsrc\\CtrlLib/CtrlLib.h"



#line 1 "u:/uppsrc\\Draw/iml_header.h"













class CtrlsImg {
public:


	enum {
#line 1 "u:/uppsrc\\CtrlLib/Ctrls.iml"

I_S0,
I_S0h,
I_S0p,
I_S0d,
I_S1,
I_S1h,
I_S1p,
I_S1d,
I_O0,
I_O0h,
I_O0p,
I_O0d,
I_O1,
I_O1h,
I_O1p,
I_O1d,
I_O2,
I_O2h,
I_O2p,
I_O2d,
I_B,
I_Bh,
I_Bp,
I_Bd,
I_EB,
I_EBh,
I_EBp,
I_EBd,
I_SB,
I_SBh,
I_SBp,
I_SBd,
I_SBHT,
I_SBHTh,
I_SBHTp,
I_SBHTd,
I_SBVT,
I_SBVTh,
I_SBVTp,
I_SBVTd,
I_OkB,
I_OkBh,
I_OkBp,
I_OkBd,
I_OBlack,
I_SBlack,
I_SizeGrip,
I_kDA,
I_kUA,
I_kLA,
I_kRA,
I_kSpU,
I_kSpD,
I_DA,
I_UA,
I_LA,
I_RA,
I_SpU,
I_SpD,
I_SBVU,
I_SBVUh,
I_SBVUp,
I_SBVUd,
I_SBVL,
I_SBVLh,
I_SBVLp,
I_SBVLd,
I_SBHU,
I_SBHUh,
I_SBHUp,
I_SBHUd,
I_SBHL,
I_SBHLh,
I_SBHLp,
I_SBHLd,
I_SBVI,
I_SBHI,
I_EFE,
I_VE,
I_HorzPos,
I_HorzSplit,
I_HTB,
I_HTBh,
I_HTBp,
I_HTBd,
I_PI,
I_VPI,
I_PIC,
I_VPIC,
I_TAB,
I_TABh,
I_TABs,
I_TABd,
I_FTAB,
I_FTABh,
I_FTABs,
I_FTABd,
I_LTAB,
I_LTABh,
I_LTABs,
I_LTABd,
I_BTAB,
I_BTABh,
I_BTABs,
I_BTABd,
I_TABB,
I_SLA,
I_SRA,
I_TB,
I_TBh,
I_TBp,
I_TBd,
I_TB1,
I_TB1h,


































































































































































































#line 20 "u:/uppsrc\\Draw/iml_header.h"
		COUNT
	};



public:
	static Upp::Iml&   Iml();

	static void        Register__()                { Register("CtrlsImg", Iml()); }

	static int         Find(const Upp::String& s);
	static int         Find(const char *s);
	static int         GetCount()                  { return Iml().GetCount(); }
	static Upp::String GetId(int i)                { return Iml().GetId(i); }

	static Upp::Image  Get(int i);
	static Upp::Image  Get(const char *s);
	static Upp::Image  Get(const Upp::String& s);

	static void   Set(int i, const Upp::Image& m);
	static void   Set(const char *s, const Upp::Image& m);

	static void   Reset()                     { Iml().Reset(); }



#line 1 "u:/uppsrc\\CtrlLib/Ctrls.iml"

static Upp::Image S0() { return Get(I_S0); }
static Upp::Image S0h() { return Get(I_S0h); }
static Upp::Image S0p() { return Get(I_S0p); }
static Upp::Image S0d() { return Get(I_S0d); }
static Upp::Image S1() { return Get(I_S1); }
static Upp::Image S1h() { return Get(I_S1h); }
static Upp::Image S1p() { return Get(I_S1p); }
static Upp::Image S1d() { return Get(I_S1d); }
static Upp::Image O0() { return Get(I_O0); }
static Upp::Image O0h() { return Get(I_O0h); }
static Upp::Image O0p() { return Get(I_O0p); }
static Upp::Image O0d() { return Get(I_O0d); }
static Upp::Image O1() { return Get(I_O1); }
static Upp::Image O1h() { return Get(I_O1h); }
static Upp::Image O1p() { return Get(I_O1p); }
static Upp::Image O1d() { return Get(I_O1d); }
static Upp::Image O2() { return Get(I_O2); }
static Upp::Image O2h() { return Get(I_O2h); }
static Upp::Image O2p() { return Get(I_O2p); }
static Upp::Image O2d() { return Get(I_O2d); }
static Upp::Image B() { return Get(I_B); }
static Upp::Image Bh() { return Get(I_Bh); }
static Upp::Image Bp() { return Get(I_Bp); }
static Upp::Image Bd() { return Get(I_Bd); }
static Upp::Image EB() { return Get(I_EB); }
static Upp::Image EBh() { return Get(I_EBh); }
static Upp::Image EBp() { return Get(I_EBp); }
static Upp::Image EBd() { return Get(I_EBd); }
static Upp::Image SB() { return Get(I_SB); }
static Upp::Image SBh() { return Get(I_SBh); }
static Upp::Image SBp() { return Get(I_SBp); }
static Upp::Image SBd() { return Get(I_SBd); }
static Upp::Image SBHT() { return Get(I_SBHT); }
static Upp::Image SBHTh() { return Get(I_SBHTh); }
static Upp::Image SBHTp() { return Get(I_SBHTp); }
static Upp::Image SBHTd() { return Get(I_SBHTd); }
static Upp::Image SBVT() { return Get(I_SBVT); }
static Upp::Image SBVTh() { return Get(I_SBVTh); }
static Upp::Image SBVTp() { return Get(I_SBVTp); }
static Upp::Image SBVTd() { return Get(I_SBVTd); }
static Upp::Image OkB() { return Get(I_OkB); }
static Upp::Image OkBh() { return Get(I_OkBh); }
static Upp::Image OkBp() { return Get(I_OkBp); }
static Upp::Image OkBd() { return Get(I_OkBd); }
static Upp::Image OBlack() { return Get(I_OBlack); }
static Upp::Image SBlack() { return Get(I_SBlack); }
static Upp::Image SizeGrip() { return Get(I_SizeGrip); }
static Upp::Image kDA() { return Get(I_kDA); }
static Upp::Image kUA() { return Get(I_kUA); }
static Upp::Image kLA() { return Get(I_kLA); }
static Upp::Image kRA() { return Get(I_kRA); }
static Upp::Image kSpU() { return Get(I_kSpU); }
static Upp::Image kSpD() { return Get(I_kSpD); }
static Upp::Image DA() { return Get(I_DA); }
static Upp::Image UA() { return Get(I_UA); }
static Upp::Image LA() { return Get(I_LA); }
static Upp::Image RA() { return Get(I_RA); }
static Upp::Image SpU() { return Get(I_SpU); }
static Upp::Image SpD() { return Get(I_SpD); }
static Upp::Image SBVU() { return Get(I_SBVU); }
static Upp::Image SBVUh() { return Get(I_SBVUh); }
static Upp::Image SBVUp() { return Get(I_SBVUp); }
static Upp::Image SBVUd() { return Get(I_SBVUd); }
static Upp::Image SBVL() { return Get(I_SBVL); }
static Upp::Image SBVLh() { return Get(I_SBVLh); }
static Upp::Image SBVLp() { return Get(I_SBVLp); }
static Upp::Image SBVLd() { return Get(I_SBVLd); }
static Upp::Image SBHU() { return Get(I_SBHU); }
static Upp::Image SBHUh() { return Get(I_SBHUh); }
static Upp::Image SBHUp() { return Get(I_SBHUp); }
static Upp::Image SBHUd() { return Get(I_SBHUd); }
static Upp::Image SBHL() { return Get(I_SBHL); }
static Upp::Image SBHLh() { return Get(I_SBHLh); }
static Upp::Image SBHLp() { return Get(I_SBHLp); }
static Upp::Image SBHLd() { return Get(I_SBHLd); }
static Upp::Image SBVI() { return Get(I_SBVI); }
static Upp::Image SBHI() { return Get(I_SBHI); }
static Upp::Image EFE() { return Get(I_EFE); }
static Upp::Image VE() { return Get(I_VE); }
static Upp::Image HorzPos() { return Get(I_HorzPos); }
static Upp::Image HorzSplit() { return Get(I_HorzSplit); }
static Upp::Image HTB() { return Get(I_HTB); }
static Upp::Image HTBh() { return Get(I_HTBh); }
static Upp::Image HTBp() { return Get(I_HTBp); }
static Upp::Image HTBd() { return Get(I_HTBd); }
static Upp::Image PI() { return Get(I_PI); }
static Upp::Image VPI() { return Get(I_VPI); }
static Upp::Image PIC() { return Get(I_PIC); }
static Upp::Image VPIC() { return Get(I_VPIC); }
static Upp::Image TAB() { return Get(I_TAB); }
static Upp::Image TABh() { return Get(I_TABh); }
static Upp::Image TABs() { return Get(I_TABs); }
static Upp::Image TABd() { return Get(I_TABd); }
static Upp::Image FTAB() { return Get(I_FTAB); }
static Upp::Image FTABh() { return Get(I_FTABh); }
static Upp::Image FTABs() { return Get(I_FTABs); }
static Upp::Image FTABd() { return Get(I_FTABd); }
static Upp::Image LTAB() { return Get(I_LTAB); }
static Upp::Image LTABh() { return Get(I_LTABh); }
static Upp::Image LTABs() { return Get(I_LTABs); }
static Upp::Image LTABd() { return Get(I_LTABd); }
static Upp::Image BTAB() { return Get(I_BTAB); }
static Upp::Image BTABh() { return Get(I_BTABh); }
static Upp::Image BTABs() { return Get(I_BTABs); }
static Upp::Image BTABd() { return Get(I_BTABd); }
static Upp::Image TABB() { return Get(I_TABB); }
static Upp::Image SLA() { return Get(I_SLA); }
static Upp::Image SRA() { return Get(I_SRA); }
static Upp::Image TB() { return Get(I_TB); }
static Upp::Image TBh() { return Get(I_TBh); }
static Upp::Image TBp() { return Get(I_TBp); }
static Upp::Image TBd() { return Get(I_TBd); }
static Upp::Image TB1() { return Get(I_TB1); }
static Upp::Image TB1h() { return Get(I_TB1h); }


































































































































































































#line 47 "u:/uppsrc\\Draw/iml_header.h"



};












#line 64 "u:/uppsrc\\Draw/iml_header.h"
#line 16 "u:/uppsrc\\CtrlLib/CtrlLib.h"



#line 1 "u:/uppsrc\\Draw/iml_header.h"













class ClassicCtrlsImg {
public:


	enum {
#line 1 "u:/uppsrc\\CtrlLib/ClassicCtrls.iml"

I_S0,
I_S0h,
I_S0p,
I_S0d,
I_S1,
I_S1h,
I_S1p,
I_S1d,
I_SBlack,
I_O0,
I_O0h,
I_O0p,
I_O0d,
I_O1,
I_O1h,
I_O1p,
I_O1d,
I_O2,
I_O2h,
I_O2p,
I_O2d,
I_OBlack,
I_SizeGrip,
I_B,
I_Bh,
I_Bp,
I_Bd,
I_EB,
I_EBh,
I_EBp,
I_EBd,
I_SB,
I_SBh,
I_SBp,
I_SBd,
I_OkB,
I_OkBh,
I_OkBp,
I_OkBd,
I_DA,
I_UA,
I_LA,
I_RA,
I_EFE,
I_VE,
I_TAB,
I_TABh,
I_TABs,
I_TABd,
I_FTAB,
I_FTABh,
I_FTABs,
I_FTABd,
I_LTAB,
I_LTABh,
I_LTABs,
I_LTABd,
I_BTAB,
I_BTABh,
I_BTABs,
I_BTABd,
I_TABB,
I_TB,
I_TBh,
I_TBp,
I_TBd,
I_TB1,
I_TB1h,






































#line 20 "u:/uppsrc\\Draw/iml_header.h"
		COUNT
	};



public:
	static Upp::Iml&   Iml();

	static void        Register__()                { Register("ClassicCtrlsImg", Iml()); }

	static int         Find(const Upp::String& s);
	static int         Find(const char *s);
	static int         GetCount()                  { return Iml().GetCount(); }
	static Upp::String GetId(int i)                { return Iml().GetId(i); }

	static Upp::Image  Get(int i);
	static Upp::Image  Get(const char *s);
	static Upp::Image  Get(const Upp::String& s);

	static void   Set(int i, const Upp::Image& m);
	static void   Set(const char *s, const Upp::Image& m);

	static void   Reset()                     { Iml().Reset(); }



#line 1 "u:/uppsrc\\CtrlLib/ClassicCtrls.iml"

static Upp::Image S0() { return Get(I_S0); }
static Upp::Image S0h() { return Get(I_S0h); }
static Upp::Image S0p() { return Get(I_S0p); }
static Upp::Image S0d() { return Get(I_S0d); }
static Upp::Image S1() { return Get(I_S1); }
static Upp::Image S1h() { return Get(I_S1h); }
static Upp::Image S1p() { return Get(I_S1p); }
static Upp::Image S1d() { return Get(I_S1d); }
static Upp::Image SBlack() { return Get(I_SBlack); }
static Upp::Image O0() { return Get(I_O0); }
static Upp::Image O0h() { return Get(I_O0h); }
static Upp::Image O0p() { return Get(I_O0p); }
static Upp::Image O0d() { return Get(I_O0d); }
static Upp::Image O1() { return Get(I_O1); }
static Upp::Image O1h() { return Get(I_O1h); }
static Upp::Image O1p() { return Get(I_O1p); }
static Upp::Image O1d() { return Get(I_O1d); }
static Upp::Image O2() { return Get(I_O2); }
static Upp::Image O2h() { return Get(I_O2h); }
static Upp::Image O2p() { return Get(I_O2p); }
static Upp::Image O2d() { return Get(I_O2d); }
static Upp::Image OBlack() { return Get(I_OBlack); }
static Upp::Image SizeGrip() { return Get(I_SizeGrip); }
static Upp::Image B() { return Get(I_B); }
static Upp::Image Bh() { return Get(I_Bh); }
static Upp::Image Bp() { return Get(I_Bp); }
static Upp::Image Bd() { return Get(I_Bd); }
static Upp::Image EB() { return Get(I_EB); }
static Upp::Image EBh() { return Get(I_EBh); }
static Upp::Image EBp() { return Get(I_EBp); }
static Upp::Image EBd() { return Get(I_EBd); }
static Upp::Image SB() { return Get(I_SB); }
static Upp::Image SBh() { return Get(I_SBh); }
static Upp::Image SBp() { return Get(I_SBp); }
static Upp::Image SBd() { return Get(I_SBd); }
static Upp::Image OkB() { return Get(I_OkB); }
static Upp::Image OkBh() { return Get(I_OkBh); }
static Upp::Image OkBp() { return Get(I_OkBp); }
static Upp::Image OkBd() { return Get(I_OkBd); }
static Upp::Image DA() { return Get(I_DA); }
static Upp::Image UA() { return Get(I_UA); }
static Upp::Image LA() { return Get(I_LA); }
static Upp::Image RA() { return Get(I_RA); }
static Upp::Image EFE() { return Get(I_EFE); }
static Upp::Image VE() { return Get(I_VE); }
static Upp::Image TAB() { return Get(I_TAB); }
static Upp::Image TABh() { return Get(I_TABh); }
static Upp::Image TABs() { return Get(I_TABs); }
static Upp::Image TABd() { return Get(I_TABd); }
static Upp::Image FTAB() { return Get(I_FTAB); }
static Upp::Image FTABh() { return Get(I_FTABh); }
static Upp::Image FTABs() { return Get(I_FTABs); }
static Upp::Image FTABd() { return Get(I_FTABd); }
static Upp::Image LTAB() { return Get(I_LTAB); }
static Upp::Image LTABh() { return Get(I_LTABh); }
static Upp::Image LTABs() { return Get(I_LTABs); }
static Upp::Image LTABd() { return Get(I_LTABd); }
static Upp::Image BTAB() { return Get(I_BTAB); }
static Upp::Image BTABh() { return Get(I_BTABh); }
static Upp::Image BTABs() { return Get(I_BTABs); }
static Upp::Image BTABd() { return Get(I_BTABd); }
static Upp::Image TABB() { return Get(I_TABB); }
static Upp::Image TB() { return Get(I_TB); }
static Upp::Image TBh() { return Get(I_TBh); }
static Upp::Image TBp() { return Get(I_TBp); }
static Upp::Image TBd() { return Get(I_TBd); }
static Upp::Image TB1() { return Get(I_TB1); }
static Upp::Image TB1h() { return Get(I_TB1h); }






































#line 47 "u:/uppsrc\\Draw/iml_header.h"



};












#line 64 "u:/uppsrc\\Draw/iml_header.h"
#line 20 "u:/uppsrc\\CtrlLib/CtrlLib.h"

class Bar;

#line 1 "u:/uppsrc\\CtrlLib/LabelBase.h"
enum {
	CTRL_NORMAL, CTRL_HOT, CTRL_PRESSED, CTRL_DISABLED,
	CTRL_CHECKED, CTRL_HOTCHECKED
};

struct CtrlsImgLook : Vector<Value> {
	CtrlsImgLook& operator()(int i, int n = 4);
	CtrlsImgLook& operator()(int i, const Image& img, Color (*fn)(int i), int n = 4);
	CtrlsImgLook& operator()(int i, const Image& img, int n = 4);
	CtrlsImgLook(int i, int n = 4);
	CtrlsImgLook(int i, const Image& img, Color (*fn)(int i), int n = 4);
	CtrlsImgLook(int i, const Image& img, int n = 4);
};

void CtrlsImageLook(Value *look, int i, int n = 4);
void CtrlsImageLook(Value *look, int i, const Image& image, const Color *color, int n = 4);
void CtrlsImageLook(Value *look, int i, const Image& image, int n = 4);

String DeAmp(const char *s);

Size GetSmartTextSize(const char *text, Font font = StdFont(), int cx = 2147483647);
int  GetSmartTextHeight(const char *s, int cx, Font font = StdFont());
void DrawSmartText(Draw& w, int x, int y, int cx, const char *text,
                   Font font = StdFont(), Color ink = DefaultInk, int accesskey = 0);

byte  ExtractAccessKey(const char *s, String& label);
bool  CompareAccessKey(byte accesskey, dword key);
byte  ChooseAccessKey(const char *s, dword used);

void DrawFocus(Draw& w, int x, int y, int cx, int cy, Color c = SColorText());
void DrawFocus(Draw& w, const Rect& r, Color c = SColorText());

void DrawHorzDrop(Draw& w, int x, int y, int cx);
void DrawVertDrop(Draw& w, int x, int y, int cy);

Point GetDragScroll(Ctrl *ctrl, Point p, Size max);
Point GetDragScroll(Ctrl *ctrl, Point p, int max = 16);

struct DrawLabel {
	bool      push;
	bool      focus;
	bool      disabled;

	PaintRect paintrect;
	Image     limg;
	Color     lcolor;
	int       lspc;
	String    text;
	Font      font;
	Color     ink;
	Image     rimg;
	Color     rcolor;
	int       rspc;

	int       align, valign;

	int       accesskey;

	Size      GetSize(int txtcx, Size sz1, int lspc, Size sz2, int rspc) const;
	Size      GetSize(int txtcx = 2147483647) const;
	Size      Paint(Draw& w, const Rect& r, bool visibleaccesskey = true) const;
	Size      Paint(Draw& w, int x, int y, int cx, int cy, bool visibleaccesskey = true) const;

	DrawLabel();
};

Image DisabledImage(const Image& img, bool disabled = true);

class LabelBase {
protected:
	virtual void  LabelUpdate();

	DrawLabel   lbl;

public:
	LabelBase&  SetLeftImage(const Image& bmp1, int spc = 0);
	LabelBase&  SetPaintRect(const PaintRect& pr);
	LabelBase&  SetText(const char *text);
	LabelBase&  SetFont(Font font);
	LabelBase&  SetInk(Color color);
	LabelBase&  SetRightImage(const Image& bmp2, int spc = 0);
	LabelBase&  SetAlign(int align);
	LabelBase&  SetVAlign(int align);
	LabelBase&  SetImage(const Image& bmp, int spc = 0)      { SetLeftImage(bmp, spc); return *this; }

	int         GetAlign() const                             { return lbl.align; }
	int         GetVAlign() const                            { return lbl.valign; }
	PaintRect   GetPaintRect() const                         { return lbl.paintrect; }
	String      GetText() const                              { return lbl.text; }
	Font        GetFont() const                              { return lbl.font; }
	Color       GetInk() const                               { return lbl.ink; }

	Size        PaintLabel(Draw& w, const Rect& r,
	                       bool disabled = false, bool push = false, bool focus = false, bool vak = true);
	Size        PaintLabel(Draw& w, int x, int y, int cx, int cy,
	                       bool disabled = false, bool push = false, bool focus = false, bool vak = true);
	Size        GetLabelSize() const;

	virtual ~LabelBase();
};

class DisplayPopup : Ctrl {
	virtual void  Paint(Draw& w);
	virtual void  LeftDown(Point p, dword);
	virtual void  LeftDrag(Point p, dword);
	virtual void  LeftDouble(Point p, dword);
	virtual void  RightDown(Point p, dword);
	virtual void  LeftUp(Point p, dword);
	virtual void  MouseWheel(Point p, int zdelta, dword keyflags);
	virtual void  MouseLeave();
	virtual void  MouseMove(Point p, dword);

private:
	Ptr<Ctrl>      ctrl;
	Rect           item;
	Rect           slim;

	Value          value;
	Color          paper, ink;
	dword          style;
	const Display *display;
	int            margin;

	Point   Op(Point p);
	void    Sync();

public:
	void Set(Ctrl *ctrl, const Rect& item, const Value& v, const Display *display,
	         Color ink, Color paper, dword style, int margin = 0);
	void Cancel();
	bool IsOpen();
	bool HasMouse();

	DisplayPopup();
};
#line 24 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/StaticCtrl.h"
class StaticText : public Ctrl, public LabelBase {
public:
	virtual void   Paint(Draw& w);
	virtual Size   GetMinSize() const;
	virtual void   LabelUpdate();

public:
	StaticText& SetFont(Font font)                      { LabelBase::SetFont(font); return *this; }
	StaticText& SetInk(Color color)                     { LabelBase::SetInk(color); return *this; }
	StaticText& SetAlign(int align)                     { LabelBase::SetAlign(align); return *this; }
	StaticText& SetImage(const Image& img, int spc = 0) { LabelBase::SetImage(img, spc); return *this; }
	StaticText& SetText(const char *text)               { LabelBase::SetText(text); return *this; }

	StaticText& operator=(const char *s)                { SetText(s); return *this; }

	StaticText();
};

class Label : public StaticText {
public:
	virtual bool   HotKey(dword key);
	virtual dword  GetAccessKeys() const;
	virtual void   AssignAccessKeys(dword used);

private:
	bool   noac;

public:
	Label& SetText(const char *text);
	Label& SetLabel(const char *lbl);

	Label& operator=(const char *s)                     { SetText(s); return *this; }

	Label();
	virtual ~Label();
};

class LabelBox : public Label {
public:
	virtual void   Paint(Draw& w);
	virtual void   AssignAccessKeys(dword used);
	virtual Rect   GetVoidRect();

public:
	LabelBox();
	virtual ~LabelBox();
	LabelBox& operator=(const char *s)   { SetText(s); return *this; }
};

Color LabelBoxTextColor();
Color LabelBoxColor();

void LabelBoxTextColor_Write(Color c);
void LabelBoxColor_Write(Color c);

class ParentCtrl : public Ctrl {
	Size minsize;

public:
	virtual Rect   GetVoidRect();
	virtual Size   GetStdSize() const;
	virtual Size   GetMinSize() const;

	void    SetMinSize(Size sz)         { minsize = sz; }

	ParentCtrl();
};

class StaticRect : public Ctrl {
public:
	virtual void   Paint(Draw& w);

protected:
	Value bg;

public:
	StaticRect& Background(const Value& chvalue);
	StaticRect& Color(class Color c)                   { Background(c); return *this; }

	StaticRect();
	virtual ~StaticRect();
};

class ImageCtrl : public Ctrl {
public:
	virtual void   Paint(Draw& w);
	virtual Size   GetStdSize() const;
	virtual Size   GetMinSize() const;

protected:
	Image   img;

public:
	ImageCtrl&   SetImage(const Image& _img)          { img = _img; Refresh(); return *this; }

	ImageCtrl()                                       { Transparent(); NoWantFocus(); }
};

class DisplayCtrl : public Ctrl {
public:
	virtual void   Paint(Draw& w);
	virtual Size   GetMinSize() const;
	virtual void   SetData(const Value& v);

private:
	PaintRect pr;

public:
	void SetDisplay(const Display& d);
};


typedef ImageCtrl Icon;

class Picture : public Ctrl {
public:
	virtual void   Paint(Draw& w);

protected:
	Drawing picture;
	Color   background;
	bool    ratio;

public:
	Picture& Background(Color color)             { background = color; Refresh(); return *this; }
	Picture& KeepRatio(bool keep = true)         { ratio = keep; Refresh(); return *this; }
	Picture& NoKeepRatio()                       { return KeepRatio(false); }
	Picture& Set(const Drawing& _picture)        { picture = _picture; Refresh(); return *this; }

	Picture& operator=(const Drawing& _picture)  { return Set(_picture); }

	Picture();
};

class SeparatorCtrl : public Ctrl {
public:
	virtual Size GetMinSize() const;
	virtual void Paint(Draw& w);

	struct Style : ChStyle<Style> {
		Value l1, l2;
	};

private:
	int          lmargin, rmargin;
	int          size;
	const Style *style;

public:
	static const Style& StyleDefault();

	SeparatorCtrl& Margin(int l, int r);
	SeparatorCtrl& Margin(int w)                { return Margin(w, w); }
	SeparatorCtrl& SetSize(int w);
	SeparatorCtrl& SetStyle(const Style& s)     { style = &s; Refresh(); return *this; }

	SeparatorCtrl();
};
#line 25 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/PushCtrl.h"
class Pusher : public Ctrl {
public:
	virtual void   CancelMode();
	virtual void   LeftDown(Point, dword);
	virtual void   MouseMove(Point, dword);
	virtual void   MouseLeave();
	virtual void   LeftRepeat(Point, dword);
	virtual void   LeftUp(Point, dword);
	virtual void   GotFocus();
	virtual void   LostFocus();
	virtual void   State(int);
	virtual String GetDesc();
	virtual bool   Key(dword key, int);
	virtual bool   HotKey(dword key);
	virtual dword  GetAccessKeys() const;
	virtual void   AssignAccessKeys(dword used);

private:
	bool    push:1;
	bool    keypush:1;

	void    EndPush();

protected:
	byte    accesskey;
	String  label;
	Font    font;

	void    KeyPush();
	bool    IsPush() const                                  { return push || keypush; }
	bool    IsKeyPush()                                     { return keypush; }
	bool    FinishPush();

protected:
	virtual void  RefreshPush();
	virtual void  RefreshFocus();
	virtual void  PerformAction();

public:
	Pusher&  SetFont(Font fnt);
	Pusher&  SetLabel(const char *text);

	void     PseudoPush();

	int GetVisualState() const;

	Callback WhenPush;
	Callback WhenRepeat;

	Pusher();
	virtual ~Pusher();
};


class Button : public Pusher {
public:
	virtual void   Paint(Draw& draw);
	virtual bool   Key(dword key, int);
	virtual bool   HotKey(dword key);
	virtual void   MouseEnter(Point, dword);
	virtual void   MouseLeave();
	virtual dword  GetAccessKeys() const;
	virtual void   AssignAccessKeys(dword used);
	virtual void   Layout();
	virtual void   GotFocus();
	virtual void   LostFocus();
	virtual int    OverPaint() const;

public:
	struct Style : ChStyle<Style> {
		Value look[4];
		Color monocolor[4], textcolor[4];
		Point pressoffset;
		int   focusmargin;
		int   overpaint;
		Font  font;
		Image ok, cancel, exit;
		bool  transparent;
	};

protected:
	enum { NORMAL, OK, CANCEL, EXIT };
	const Style *style;
	Image   img;
	bool    monoimg;
	byte    type;

	void  RefreshOK(Ctrl *p);
	const Style *St() const;

public:
	Button&  SetImage(const Image& img);
	Button&  SetMonoImage(const Image& img);

	static const Style& StyleNormal();
	static const Style& StyleOk();
	static const Style& StyleEdge();
	static const Style& StyleLeftEdge();
	static const Style& StyleScroll();

	Button&  SetStyle(const Style& s);
	Button&  AutoStyle();

	Button&  NormalStyle()                        { return SetStyle(StyleNormal()); }
	Button&  EdgeStyle()                          { return SetStyle(StyleEdge()); }
	Button&  LeftEdgeStyle()                      { return SetStyle(StyleLeftEdge()); }
	Button&  ScrollStyle()                        { return SetStyle(StyleScroll()); }

	Button&  Ok();
	Button&  Cancel();
	Button&  Exit();
	Button&  Normal()                             { type = NORMAL; Refresh(); return *this; }

	Button();
	virtual ~Button();
};

Color ButtonMonoColor(int i);

class SpinButtons : public CtrlFrame {
public:
	virtual void FrameLayout(Rect& r);
	virtual void FrameAddSize(Size& sz);
	virtual void FrameAdd(Ctrl& ctrl);
	virtual void FrameRemove();

public:
	struct Style : ChStyle<Style> {
		Button::Style inc;
		Button::Style dec;
		int           width;
	};

private:
	bool         visible;
	const Style *style;

public:
	Button inc;
	Button dec;

	void         Show(bool s = true);

	static const Style& StyleDefault();

	SpinButtons& SetStyle(const Style& s);

	SpinButtons();
	virtual ~SpinButtons();
};

class Option : public Pusher {
public:
	virtual void   Paint(Draw& draw);
	virtual Size   GetMinSize() const;
	virtual void   SetData(const Value& data);
	virtual Value  GetData() const;
	virtual void   MouseEnter(Point, dword);
	virtual void   MouseLeave();

protected:
	virtual void  RefreshPush();
	virtual void  RefreshFocus();
	virtual void  PerformAction();

protected:
	Image  edge, edged;
	int    option;
	bool   switchimage;
	bool   threestate;
	bool   notnull;
	bool   blackedge;

public:
	void   Set(int b);
	int    Get() const                            { return option; }

	operator int() const                          { return option; }
	void operator=(int b)                         { Set(b); }

	Option& BlackEdge(bool b = true)              { blackedge = b; Refresh(); return *this; }
	Option& SwitchImage(bool b = true)            { switchimage = b; Refresh(); return *this; }
	Option& ThreeState(bool b = true)             { threestate = b; notnull = false; return *this; }
	Option& NotNull(bool nn = true)               { notnull = nn; Refresh(); return *this; }
	Option& NoNotNull()                           { return NotNull(false); }

	Option();
	virtual ~Option();
};

class ButtonOption : public Ctrl {
public:
	virtual void  Paint(Draw& w);
	virtual void  LeftDown(Point, dword);
	virtual void  LeftUp(Point, dword);
	virtual void  MouseMove(Point, dword);
	virtual void  MouseEnter(Point, dword);
	virtual void  MouseLeave();
	virtual void  SetData(const Value& v);
	virtual Value GetData() const;
	virtual void  Serialize(Stream& s);

public:
	struct Style : ChStyle<Style> {
		Value look[4];
	};

private:
	Image        image;
	Image        image1;
	const Style *style;
	bool         option;
	bool         push;

public:
	ButtonOption&  SetImage(const Image& img)                 { image = img; Refresh(); return *this; }
	ButtonOption&  SetImage(const Image& m, const Image& m1)  { image = m; image1 = m1; Refresh(); return *this; }
	void operator=(const Image& img)                          { SetImage(img); }

	void Set(bool b)                                          { option = b; UpdateRefresh(); }
	bool Get() const                                          { return option; }

	void operator=(bool b)                                    { Set(b); }
	operator bool() const                                     { return Get(); }

	ButtonOption& SetStyle(const Style& s)                    { style = &s; Refresh(); return *this; }
	ButtonOption& AutoStyle()                                 { style = 0; Refresh(); return *this; }

	ButtonOption();
};

class Switch : public Ctrl {
public:
	virtual void   Paint(Draw& draw);
	virtual void   CancelMode();
	virtual void   MouseMove(Point p, dword keyflags);
	virtual void   LeftDown(Point p, dword keyflags);
	virtual void   LeftUp(Point p, dword keyflags);
	virtual void   MouseLeave();
	virtual bool   Key(dword key, int count);
	virtual bool   HotKey(dword key);
	virtual dword  GetAccessKeys() const;
	virtual void   AssignAccessKeys(dword used);
	virtual void   SetData(const Value& data);
	virtual Value  GetData() const;
	virtual void   GotFocus();
	virtual void   LostFocus();

public:
	struct Case : Moveable<Case> {
		String label;
		Value  value;
		int    accesskey;
		bool   enabled;

		Case()         { accesskey = 0; enabled = true; }
	};

private:
	Font         font;
	Value        value;
	int          pushindex;
	Array<Case>  cs;
	Vector<int>  posx;
	int          linecy;
	int          light;
	int          mincy;

	int   GetIndex() const;
	int   GetIndex(Point p);
	bool  DoHot(dword key);
	void  Updates();
	void  RefreshCase(int i);

	Rect    GetCaseRect(int i) const;
	Rect    GetCheckRect(int i) const;

public:
	Switch& SetLabel(int i, const char *text);
	Switch& SetLabel(const char *text);
	String  GetLabel() const                                    { return GetLabel(GetIndex()); }
	String  GetLabel(int i) const                               { return cs[i].label; }
	Switch& Set(int i, const Value& val, const char *text);
	Switch& Set(int i, const Value& val);
	Switch& Add(const Value& val, const char *text);
	Switch& Add(const char *text);

	void    EnableCase(int i, bool enable = true);
	void    DisableCase(int i)                                  { EnableCase(i, false); }

	void    EnableValue(const Value& val, bool enable = true);
	void    DisableValue(const Value& val)                      { EnableValue(val, false); }

	void  Reset()                                               { cs.Clear(); }

	const Array<Case>& GetCases() const                         { return cs; }

	operator int() const                                        { return GetData(); }
	void operator=(const Value& v)                              { SetData(v); }

	Switch& SetFont(Font f)                                     { font = f; Refresh(); return *this; }
	Font    GetFont() const                                     { return font; }
	Switch& MinCaseHeight(int cy)                               { mincy = cy; Refresh(); return *this; }

	Switch();
	virtual ~Switch();
};

class DataPusher : public Pusher
{
public:
	virtual void   Paint(Draw& draw);

protected:
	const Convert *convert;
	const Display *display;
	Value          data;

protected:
	virtual void   PerformAction();
	virtual void   DoAction();

public:
	Callback       WhenPreAction;

	DataPusher(const Convert& convert = NoConvert(), const Display& display = StdDisplay());
	DataPusher(const Display& display);
	virtual ~DataPusher();

	DataPusher&    SetConvert(const Convert& _convert) { convert = &_convert; Refresh(); return *this; }
	const Convert& GetConvert() const                  { return *convert; }

	DataPusher&    SetDisplay(const Display& _display) { display = &_display; Refresh(); return *this; }
	const Display& GetDisplay() const                  { return *display; }

	virtual Value  GetData() const;
	virtual void   SetData(const Value& value);

	void           SetDataAction(const Value& value);
};
#line 26 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/MultiButton.h"



class MultiButton : public Ctrl {
public:
	virtual void  Paint(Draw& w);
	virtual void  MouseMove(Point p, dword flags);
	virtual void  LeftDown(Point p, dword flags);
	virtual void  LeftUp(Point p, dword flags);
	virtual void  MouseLeave();
	virtual void  CancelMode();
	virtual void  GotFocus();
	virtual void  LostFocus();
	virtual void  SetData(const Value& data);
	virtual Value GetData() const;
	virtual Size  GetMinSize() const;
	virtual int   OverPaint() const;

public:
	struct Style : public ChStyle<Style> {
		Value edge[4];
		bool  activeedge;
		Value look[4];
		Value left[4];
		Value lmiddle[4];
		Value right[4];
		Value rmiddle[4];
		Value simple[4];
		int   border;
		Value trivial[4];
		int   trivialborder;
		Color monocolor[4];
		Point pressoffset;
		Value sep1, sep2;
		int   sepm;
		int   stdwidth;
		bool  trivialsep;
		bool  usetrivial;
		Rect  margin;
		int   overpaint;
		int   loff, roff;
	};

	class SubButton {
		friend class MultiButton;

		String       tip;
		MultiButton *owner;
		Image        img;
		int          cx;
		bool         main;
		bool         left;
		bool         monoimg;
		bool         enabled;

		void Refresh();

	public:
		Callback WhenPush;
		Callback WhenClick;

		SubButton& SetImage(const Image& m);
		SubButton& SetMonoImage(const Image& m);
		SubButton& SetStdImage();
		SubButton& Left(bool b = true);
		SubButton& Width(int w);
		SubButton& Enable(bool b);
		SubButton& Tip(const char *s)                     { tip = s; return *this; }
		SubButton& Main(bool b = true);

		Callback operator<<=(Callback cb)                 { WhenPush = cb; return cb; }

		SubButton();
	};

private:
	enum { MAIN = -1 };

	virtual bool Frame();

	const Display   *display;
	const Convert   *convert;
	Value            value;
	int              valuecy;
	bool             push;
	String           tip;
	Rect             pushrect;

	Array<SubButton> button;
	int              hl;

	const Style *style;

	int  FindButton(int px);
	void Margins(int& l, int& r);
	Rect ContentRect();
	void GetPos(int ii, int& x, int& cx);
	int  ChState(int i);
	void Lay(Rect& r);
	bool ComplexFrame();
	bool Metrics(int& border, int& lx, int &rx, const Rect& r);
	bool Metrics(int& border, int& lx, int &rx);

	friend class SubButton;
	friend class MultiButtonFrame;

public:
	Callback WhenPush;
	Callback WhenClick;

	static const Style& StyleDefault();
	static const Style& StyleFrame();

	bool IsTrivial() const;

	void Reset();

	void PseudoPush(int bi);
	void PseudoPush();

	SubButton& AddButton();
	SubButton& InsertButton(int i);
	int        GetButtonCount() const                { return button.GetCount(); }
	SubButton& GetButton(int i)                      { return button[i]; }
	SubButton& MainButton();

	Rect  GetPushScreenRect() const                  { return pushrect; }

	const Display& GetDisplay() const                { return *display; }
	const Convert& GetConvert() const                { return *convert; }
	const Value&   Get() const                       { return value; }

	MultiButton& SetDisplay(const Display& d);
	MultiButton& NoDisplay();
	MultiButton& SetConvert(const Convert& c);
	MultiButton& SetValueCy(int cy);
	MultiButton& Set(const Value& v);
	MultiButton& Tip(const char *s)                  { tip = s; return *this; }

	MultiButton& SetStyle(const Style& s)            { style = &s; Refresh(); return *this; }

	MultiButton();
};

class MultiButtonFrame : public MultiButton, public CtrlFrame {
public:
	virtual void  FrameLayout(Rect& r);
	virtual void  FrameAddSize(Size& sz);
	virtual void  FrameAdd(Ctrl& parent);
	virtual void  FrameRemove();

private:
	virtual bool Frame();

public:
	void AddTo(Ctrl& w);
};

#line 160 "u:/uppsrc\\CtrlLib/MultiButton.h"
#line 27 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/ScrollBar.h"
class ScrollBar : public FrameCtrl<Ctrl> {
public:
	virtual void Layout();
	virtual Size GetStdSize() const;
	virtual void Paint(Draw& draw);
	virtual void LeftDown(Point p, dword);
	virtual void MouseMove(Point p, dword);
	virtual void MouseEnter(Point p, dword);
	virtual void MouseLeave();
	virtual void LeftUp(Point p, dword);
	virtual void LeftRepeat(Point p, dword);
	virtual void CancelMode();

	virtual void FrameLayout(Rect& r);
	virtual void FrameAddSize(Size& sz);

public:
	struct Style : ChStyle<Style> {
		int barsize, arrowsize, thumbmin, overthumb;
		bool through;
		Value vupper[4], vthumb[4], vlower[4];
		Value hupper[4], hthumb[4], hlower[4];
		Button::Style up, down, left, right;
		Button::Style up2, down2, left2, right2;
		bool          isup2, isdown2, isleft2, isright2;
	};

private:
	int     thumbpos;
	int     thumbsize;
	bool    horz:1;
	bool    jump:1;
	bool    track:1;
	int     delta;
	int8    push;
	int8    light;

	Button  prev, prev2, next, next2;
	int     pagepos;
	int     pagesize;
	int     totalsize;
	int     linesize;
	int     minthumb;
	bool    autohide:1;
	bool    autodisable:1;

	const Style *style;

	Rect    Slider() const;
	int&    HV(int& h, int& v) const;
	int     GetHV(int h, int v) const;
	Rect    GetPartRect(int p) const;
	void    Bounds();
	bool    SetThumb(int _thumbpos, int _thumbsize);
	void    Drag(Point p);
	int     GetMousePart();
	int     GetRange() const;

	void    Position();
	void    Uset(int a);

	int     ScrollBarSize() const                 { return style->barsize; }

public:
	Callback WhenScroll;
	Callback WhenVisibility;
	Callback WhenLeftClick;

	bool    IsHorz() const                  { return horz; }
	bool    IsVert() const                  { return !horz; }

	void    Set(int pagepos, int pagesize, int totalsize);

	bool    Set(int pagepos);
	void    SetPage(int pagesize);
	void    SetTotal(int totalsize);

	bool    ScrollInto(int pos, int linesize);
	bool    ScrollInto(int pos)             { return ScrollInto(pos, linesize); }

	bool    VertKey(dword key, bool homeend = true);
	bool    HorzKey(dword key);

	void    PrevLine();
	void    NextLine();
	void    PrevPage();
	void    NextPage();
	void    Begin();
	void    End();

	void    Wheel(int zdelta, int lines = 3);

	Size    GetViewSize() const;
	Size    GetReducedViewSize() const;

	int     Get() const                     { return pagepos; }
	int     GetPage() const                 { return pagesize; }
	int     GetTotal() const                { return totalsize; }
	int     GetLine() const                 { return linesize; }

	static const Style& StyleDefault();

	ScrollBar& Horz(bool b = true)          { horz = b; Refresh(); RefreshLayout(); return *this; }
	ScrollBar& Vert()                       { return Horz(false); }

	ScrollBar& SetLine(int _line)           { linesize = _line; return *this; }

	ScrollBar& Track(bool b = true)         { track = b; return *this; }
	ScrollBar& NoTrack()                    { return Track(false); }
	ScrollBar& Jump(bool b = true)          { jump = b; return *this; }
	ScrollBar& NoJump(bool b = true)        { return Jump(false); }
	ScrollBar& AutoHide(bool b = true);
	ScrollBar& NoAutoHide()                 { return AutoHide(false); }
	bool       IsAutoHide() const           { return autohide; }
	ScrollBar& AutoDisable(bool b = true);
	ScrollBar& NoAutoDisable()              { return AutoDisable(false); }
	ScrollBar& MinThumb(int sz)             { minthumb = sz; return *this; }
	ScrollBar& SetStyle(const Style& s);

	operator int() const                    { return pagepos; }
	int operator=(int pagepos)              { Set(pagepos); return pagepos; }

	ScrollBar();
	virtual ~ScrollBar();
};

inline int ScrollBarSize()                  { return ScrollBar::StyleDefault().barsize; }

class VScrollBar : public ScrollBar {
public:
	int operator=(int pagepos)              { Set(pagepos); return pagepos; }
};

class HScrollBar : public ScrollBar {
public:
	int operator=(int pagepos)              { Set(pagepos); return pagepos; }

	HScrollBar() { Horz(); }
};

class SizeGrip : public FrameRight<Ctrl> {
public:
	virtual void  Paint(Draw& w);
	virtual void  LeftDown(Point p, dword);
	virtual Image CursorImage(Point p, dword);

public:
	SizeGrip();
	virtual ~SizeGrip();
};

Image SizeGripImg();
void  SizeGripImg_Write(Image m);

class ScrollBars : public CtrlFrame {
public:
	virtual void FrameLayout(Rect& r);
	virtual void FrameAddSize(Size& sz);
	virtual void FramePaint(Draw& w, const Rect& r);
	virtual void FrameAdd(Ctrl& ctrl);
	virtual void FrameRemove();

protected:
	Ctrl      *box;
	StaticRect the_box;
	int        box_type;
	SizeGrip   grip;

	void    Scroll();

public:
	HScrollBar x;
	VScrollBar y;

	Callback   WhenScroll;
	Callback   WhenLeftClick;

	void    Set(Point pos, Size page, Size total);
	bool    Set(Point pos);
	bool    Set(int x, int y);
	void    SetPage(Size page);
	void    SetPage(int cx, int cy);
	void    SetTotal(Size total);
	void    SetTotal(int cx, int cy);

	void    SetX(int pos, int page, int total)       { x.Set(pos, page, total); }
	bool    SetX(int _x)                             { return x.Set(_x); }
	void    SetPageX(int cx)                         { x.SetPage(cx); }
	void    SetTotalX(int cx)                        { x.SetTotal(cx); }

	void    SetY(int pos, int page, int total)       { y.Set(pos, page, total); }
	bool    SetY(int _y)                             { return y.Set(_y); }
	void    SetPageY(int cy)                         { y.SetPage(cy); }
	void    SetTotalY(int cy)                        { y.SetTotal(cy); }

	bool    ScrollInto(Point pos, Size linesize);
	bool    ScrollInto(const Rect& r)                { return ScrollInto(r.TopLeft(), r.Size()); }
	bool    ScrollInto(Point pos);

	bool    ScrollIntoX(int pos, int linesize)       { return x.ScrollInto(pos, linesize); }
	bool    ScrollIntoX(int pos)                     { return x.ScrollInto(pos); }
	bool    ScrollIntoY(int pos, int linesize)       { return y.ScrollInto(pos, linesize); }
	bool    ScrollIntoY(int pos)                     { return y.ScrollInto(pos); }

	bool    Key(dword key);

	void    LineUp()                                 { y.PrevLine(); }
	void    LineDown()                               { y.NextLine(); }
	void    PageUp()                                 { y.PrevPage(); }
	void    PageDown()                               { y.NextPage(); }
	void    VertBegin()                              { y.Begin(); }
	void    VertEnd()                                { y.End(); }

	void    LineLeft()                               { x.PrevLine(); }
	void    LineRight()                              { x.NextLine(); }
	void    PageLeft()                               { x.PrevPage(); }
	void    PageRight()                              { x.NextPage(); }
	void    HorzBegin()                              { x.Begin(); }
	void    HorzEnd()                                { x.End(); }

	void    WheelX(int zdelta, int lines = 3)        { x.Wheel(zdelta, lines); }
	void    WheelY(int zdelta, int lines = 3)        { y.Wheel(zdelta, lines); }

	Size    GetViewSize() const;
	Size    GetReducedViewSize() const;

	Point   Get() const                              { return Point(x, y); }
	int     GetX() const                             { return x; }
	int     GetY() const                             { return y; }
	Size    GetPage() const                          { return Size(x.GetPage(), y.GetPage()); }
	Size    GetTotal() const                         { return Size(x.GetTotal(), y.GetTotal()); }
	Size    GetLine() const                          { return Size(x.GetLine(), y.GetLine()); }

	void    ShowX(bool show)                         { x.Show(show); }
	void    HideX()                                  { ShowX(false); }
	void    ShowY(bool show)                         { y.Show(show); }
	void    HideY()                                  { ShowY(false); }
	void    Show(bool show = true)                   { x.Show(show); y.Show(show); }
	void    Hide()                                   { Show(false); }

	ScrollBars& SetLine(int linex, int liney);
	ScrollBars& SetLine(Size line)                   { return SetLine(line.cx, line.cy); }
	ScrollBars& SetLine(int line)                    { return SetLine(line, line); }

	ScrollBars& Track(bool b = true);
	ScrollBars& NoTrack()                            { return Track(false); }
	ScrollBars& Jump(bool b = true);
	ScrollBars& NoJump(bool b = true)                { return Jump(false); }
	ScrollBars& AutoHide(bool b = true);
	ScrollBars& NoAutoHide()                         { return AutoHide(false); }
	ScrollBars& AutoDisable(bool b = true);
	ScrollBars& NoAutoDisable()                      { return AutoDisable(false); }

	ScrollBars& NormalBox();
	ScrollBars& NoBox();
	ScrollBars& FixedBox();

	ScrollBars& Box(Ctrl& box);
	ScrollBars& WithSizeGrip()                       { the_box.Add(grip); return *this; }

	ScrollBars& SetStyle(const ScrollBar::Style& s)  { x.SetStyle(s); y.SetStyle(s); return *this; }

	operator Point() const                           { return Get(); }
	Point operator=(Point p)                         { Set(p); return p; }

	ScrollBars();
	virtual ~ScrollBars();
};

class Scroller {
	Point psb;

public:
	void Scroll(Ctrl& p, const Rect& rc, Point newpos, Size cellsize = Size(1, 1));
	void Scroll(Ctrl& p, const Rect& rc, int newpos, int linesize = 1);
	void Scroll(Ctrl& p, Point newpos);
	void Scroll(Ctrl& p, int newposy);

	void Set(Point pos)          { psb = pos; }
	void Set(int pos)            { psb = Point(0, pos); }
	void Clear()                 { psb = Null; }

	Scroller()                   { psb = Null; }
};
#line 28 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/HeaderCtrl.h"
class HeaderCtrl : public Ctrl, public CtrlFrame {
public:
	virtual void  CancelMode();
	virtual void  Paint(Draw& draw);
	virtual Image CursorImage(Point p, dword keyflags);
	virtual void  LeftDown(Point p, dword keyflags);
	virtual void  LeftDrag(Point p, dword keyflags);
	virtual void  MouseMove(Point p, dword keyflags);
	virtual void  MouseLeave();
	virtual void  LeftUp(Point, dword);
	virtual void  RightDown(Point, dword);
	virtual void  Serialize(Stream& s);
	virtual void  Layout();

	virtual void  FrameAdd(Ctrl& parent);
	virtual void  FrameRemove();
	virtual void  FrameLayout(Rect& r);
	virtual void  FrameAddSize(Size& sz);

public:
	struct Style : ChStyle<Style> {
		Value look[4];
		int   gridadjustment;
		bool  pressoffset;
	};

	class Column : public LabelBase {
	protected:
		virtual void  LabelUpdate();

		HeaderCtrl *header;
		double      ratio;
		bool        visible;
		int         min, max;
		int         margin;
		Color       paper;
		int         index;

		void        Paint(bool& first, Draw& w,
		                  int x, int y, int cx, int cy, bool disabled, bool push, bool hl);

		friend class HeaderCtrl;

	public:
		Callback        WhenAction;
		Callback1<Bar&> WhenBar;

		Column&  Min(int _min)                     { min = _min; return *this; }
		Column&  Max(int _max)                     { max = _max; return *this; }
		Column&  MinMax(int m, int n)              { return Min(m).Max(n); }
		Column&  Fixed(int f)                      { return MinMax(f, f); }
		Column&  SetPaper(Color c)                 { paper = c; return *this; }
		Column&  SetRatio(double ratio);
		Column&  SetMargin(int m);

		int      GetMargin() const                 { return margin + 2; }
		Color    GetPaper() const                  { return paper; }
		int      GetIndex() const                  { return index; }

		Column();
	};

	friend class Column;

protected:
	enum { PROPORTIONAL, REDUCELAST, REDUCENEXT, SCROLL };

	Array<Column> col;
	HScrollBar    sb;

	mutable int          oszcx;
	mutable Vector<Rect> tabrect;

	int   split, pushi, li, ti;
	bool  isdrag;
	Image dragtab;
	int   dragd, dragx;
	Rect  colRect;
	bool  push:1;
	bool  track:1;
	bool  invisible:1;
	bool  moving:1;
	byte  mode;
	int   light;
	int   height;
	const Style *style;

	double Denominator() const;
	void   Reduce(int q, double& delta, double rs, int szcx, bool checkmin);
	int    GetNextTabWidth(int i);
	int    GetLastVisibleTab();
	void   WScroll();
	void   Scroll();
	void   ScrollVisibility();
	void   SbTotal();
	void   SetTabWidth0(int i, int cx);
	int    SumMin(int from);
	int    SumMax(int from);
	void   Distribute(const Vector<int>& sci, double delta);
	void   ReCompute();
	void   InvalidateDistribution()                              { oszcx = -1; }
	void   RefreshDistribution();
	Vector<int> GetVisibleCi(int from);

public:
	Callback      WhenLayout;
	Callback      WhenScroll;
	Callback      WhenScrollVisibility;

	Rect          GetTabRect(int i);

	const Column& Tab(int i) const                        { return col[i]; }
	Column&       Tab(int i);

	Column&       Add(const char *text, double ratio = 0);
	Column&       Add();
	const Column& operator[](int i) const                 { return col[i]; }
	int           GetCount() const                        { return col.GetCount(); }
	void          Reset();

	void          ShowTab(int i, bool show = true);
	void          HideTab(int i)                          { ShowTab(i, false); }
	bool          IsTabVisible(int i)                     { return col[i].visible; }
	void          SetTabRatio(int i, double ratio);
	double        GetTabRatio(int i) const                { return col[i].ratio; }
	void          SetTabWidth(int i, int cx);
	int           GetTabWidth(int i);

	void          SwapTabs(int first, int second);
	void          MoveTab(int from, int to);
	int           GetTabIndex(int i)                      { return col[i].index; }
	int           FindIndex(int ndx);

	void          StartSplitDrag(int s);
	int           GetSplit(int x);

	int           GetScroll() const                       { return sb; }
	bool          IsScroll() const                        { return sb.IsShown(); }

	void          SetHeight(int cy);
	int           GetHeight() const;

	static const Style& StyleDefault();

	HeaderCtrl&   Invisible(bool inv);
	HeaderCtrl&   Track(bool _track = true)               { track = _track; sb.Track(track); return *this; }
	HeaderCtrl&   NoTrack()                               { return Track(false); }
	HeaderCtrl&   Proportional();
	HeaderCtrl&   ReduceNext();
	HeaderCtrl&   ReduceLast();
	HeaderCtrl&   Absolute();
	HeaderCtrl&   SetStyle(const Style& s)                { style = &s; Refresh(); return *this; }
	HeaderCtrl&   Moving(bool b = true)                   { moving = b; return *this; }

	HeaderCtrl&   SetScrollBarStyle(const ScrollBar::Style& s)   { sb.SetStyle(s); return *this; }

	static int GetStdHeight()                             { return Draw::GetStdFontCy() + 4; }

	typedef HeaderCtrl CLASSNAME;

	HeaderCtrl();
	virtual ~HeaderCtrl();
};
#line 29 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/EditCtrl.h"
struct TextArrayOps {
	virtual int GetLength() const = 0;
	virtual int GetChar(int i) const = 0;

	bool GetWordSelection(int c, int& sell, int& selh);
	int  GetNextWord(int c);
	int  GetPrevWord(int c);

	virtual ~TextArrayOps() {}
};

class LookFrame : public CtrlFrame {
public:
	virtual void FrameLayout(Rect& r);
	virtual void FramePaint(Draw& w, const Rect& r);
	virtual void FrameAddSize(Size& sz);

private:
	Value (*look)();
	Value lookv;
	Value Get() const { return look ? (*look)() : lookv; }

public:
	void  Set(const Value& v)                  { look = 0; lookv = v; }
	void  Set(Value (*l)())                    { look = l; }
	LookFrame(Value (*look)()) : look(look)    {}
	LookFrame(const Value& v) : lookv(v) { look = 0; }
	LookFrame() { look = 0; }
};

Value EditFieldEdge();
Value ViewEdge();

void ViewEdge_Write(Value);

CtrlFrame& EditFieldFrame();
CtrlFrame& ViewFrame();

class ActiveEdgeFrame : public CtrlFrame {
public:
	virtual void FrameLayout(Rect& r);
	virtual void FramePaint(Draw& w, const Rect& r);
	virtual void FrameAddSize(Size& sz);

private:
	const Value *edge;
	const Ctrl  *ctrl;
	bool  mousein;

public:
	void Set(const Ctrl *ctrl, const Value *edge, bool active);
	void Mouse(bool in) { mousein = in; }

	ActiveEdgeFrame() { edge = 0; mousein = false; }
};

class EditField : public Ctrl, private TextArrayOps {
public:
	virtual void  Layout();
	virtual void  Paint(Draw& draw);
	virtual void  LeftDown(Point p, dword keyflags);
	virtual void  MiddleDown(Point p, dword keyflags);
	virtual void  MouseMove(Point p, dword keyflags);
	virtual void  LeftDouble(Point p, dword keyflags);
	virtual void  LeftTriple(Point p, dword keyflags);
	virtual void  LeftDrag(Point p, dword flags);
	virtual void  LeftUp(Point p, dword flags);
	virtual void  RightDown(Point p, dword keyflags);
	virtual void  MouseEnter(Point p, dword keyflags);
	virtual void  MouseLeave();
	virtual Image CursorImage(Point p, dword keyflags);
	virtual void  DragAndDrop(Point p, PasteClip& d);
	virtual void  DragRepeat(Point p);
	virtual void  DragLeave();
	virtual bool  Key(dword key, int rep);
	virtual void  GotFocus();
	virtual void  LostFocus();
	virtual Size  GetMinSize() const;
	virtual void  SetData(const Value& data);
	virtual Value GetData() const;
	virtual void  CancelMode();
	virtual String GetSelectionData(const String& fmt) const;

public:
	struct Style : ChStyle<Style> {
		Color paper;
		Color disabled;
		Color focus;
		Color invalid;
		Color text, textdisabled;
		Color selected, selectedtext;
		Value edge[4];
		bool  activeedge;
	};

protected:
	const Style *style;

	ActiveEdgeFrame edge;

	WString    text;
	int        sc;
	int        cursor, anchor;

	WString    undotext;
	int        undocursor, undoanchor;

	CharFilter      filter;
	const Convert  *convert;
	const Convert  *inactive_convert;
	Font            font;

	WString         nulltext;
	Color           nullink;
	Font            nullfont;
	int             maxlen;
	int             autosize;
	byte            charset;

	int        dropcursor;
	Rect       dropcaret;
	bool       selclick;

	bool       password:1;
	bool       autoformat:1;
	bool       initcaps:1;
	bool       keep_selection:1;
	bool       clickselect:1;
	bool       nobg:1;
	bool       alignright:1;

	bool    FrameIsEdge();
	void    SetEdge(int i);
	void    SyncEdge();
	int     GetTextCx(const wchar *text, int n, bool password, Font fnt);
	void    Paints(Draw& w, int& x, int fcy, const wchar *&txt,
		           Color ink, Color paper, int n, bool pwd, Font fnt);
	int     GetStringCx(const wchar *text, int n);
	int     GetCaret(int cursor);
	int     GetCursor(int posx);
	void    SyncCaret();
	void    Finish(bool refresh = true);
	void    SaveUndo();
	void    DoAutoFormat();
	int     GetTy();
	void    Undo();
	void    Cut();
	void    Paste();
	void    Erase();
	void    SelectAll();
	void    MenuBar(Bar& menu);



public:
	static const Style& StyleDefault();
	EditField&  SetStyle(const Style& s);

	static  int   GetViewHeight(Font font = StdFont());
	static  int   GetStdHeight(Font font = StdFont());

	int     Insert(int pos, const WString& text);
	int     Insert(int pos, const String& text)         { return Insert(pos, text.ToWString()); }
	int     Insert(int pos, const char *text)           { return Insert(pos, WString(text)); }
	void    Remove(int pos, int n);

	void    Insert(const WString& text);
	void    Insert(const String& text)                  { return Insert(text.ToWString()); }
	void    Insert(const char *text)                    { return Insert(WString(text)); }
	void    Insert(int chr);

	void    Move(int newpos, bool select = false);

	void    SetSelection(int l = 0, int h = 2147483647);
	bool    GetSelection(int& l, int& h) const;
	bool    IsSelection() const;
	bool    RemoveSelection();
	void    CancelSelection();
	void    Copy();

	void           SetText(const WString& text);
	void           SetText(const String& t)  { SetText(t.ToWString()); }
	void           SetText(const char *t)    { SetText(WString(t)); }
	const WString& GetText() const           { return text; }

	operator const WString&() const          { return text; }
	operator String() const                  { return text.ToString(); }
	void operator=(const WString& s)         { SetText(s); }
	int     GetLength() const                { return text.GetLength(); }
	int     GetChar(int i) const             { return text[i]; }

	void    Clear();
	void    Reset();

	EditField& Password(bool pwd = true)     { password = pwd; Finish(); return *this; }
	EditField& SetFilter(int (*f)(int))      { filter = f; return *this; }
	EditField& SetConvert(const Convert& c)  { convert = &c; return *this; }
	EditField& SetInactiveConvert(const Convert& c) { inactive_convert = &c; return *this; }
	EditField& AutoFormat(bool b = true)     { autoformat = b; return *this; }
	EditField& NoAutoFormat()                { return AutoFormat(false); }
	EditField& SetCharset(byte cs)           { charset = cs; return *this; }
	EditField& SetFont(Font _font);
	EditField& ClickSelect(bool b = true)    { clickselect = b; return *this; }
	EditField& InitCaps(bool b = true)       { initcaps = b; return *this; }
	EditField& NullText(const char *text = t_GetLngString("(default)"), Color ink = Brown);
	EditField& NullText(const char *text, Font fnt, Color ink);
	EditField& MaxChars(int mc)              { maxlen = mc; return *this; }
	EditField& AutoSize(int maxcx = 2147483647) { autosize = maxcx; Finish(); return *this; }
	EditField& NoBackground(bool b = true)   { nobg = b; Transparent(); Refresh(); return *this; }
	EditField& AlignRight(bool b = true)     { alignright = b; Refresh(); return *this; }

	CharFilter     GetFilter() const         { return filter; }
	const Convert& GetConvert() const        { return *convert; }
	Font           GetFont() const           { return font; }

	typedef EditField CLASSNAME;

	EditField();
	virtual ~EditField();
};

template <class DataType, class Cv>
class EditValue : public EditField, public Cv {
public:
	EditValue& operator=(const DataType& t)  { SetData(t); return *this; }
	operator DataType() const                { return GetData(); }

	EditValue()                              { SetConvert(*this); }
};

template <class DataType, class Cv>
class EditMinMax : public EditValue<DataType, Cv> {
public:
	EditMinMax& operator=(const DataType& t)          { SetData(t); return *this; }

	EditMinMax() {}
	EditMinMax(DataType min, DataType max)            { Cv::MinMax(min, max); }

	EditMinMax& Min(DataType min)                     { Cv::Min(min); return *this; }
	EditMinMax& Max(DataType max)                     { Cv::Max(max); return *this; }
	EditMinMax& NotNull(bool nn = true)               { Cv::NotNull(nn); return *this; }
};

template <class DataType, class Cv>
class EditMinMaxNotNull : public EditValue<DataType, Cv> {
public:
	EditMinMaxNotNull& operator=(const DataType& t)   { SetData(t); return *this; }

	EditMinMaxNotNull()                               { Cv::NotNull(); }
	EditMinMaxNotNull(DataType min, DataType max)     { Cv::NotNull(); Cv::MinMax(min, max); }

	EditMinMaxNotNull& Min(DataType min)              { Cv::Min(min); return *this; }
	EditMinMaxNotNull& Max(DataType max)              { Cv::Max(max); return *this; }
	EditMinMaxNotNull& NotNull(bool nn = true)        { Cv::NotNull(nn); return *this; }
};

typedef EditMinMax<int, ConvertInt>              EditInt;
typedef EditMinMax<int64, ConvertInt64>          EditInt64;
typedef EditMinMax<double, ConvertDouble>        EditDouble;
typedef EditMinMax<Date, ConvertDate>            EditDate;
typedef EditMinMax<Time, ConvertTime>            EditTime;
typedef EditMinMaxNotNull<int, ConvertInt>       EditIntNotNull;
typedef EditMinMaxNotNull<double, ConvertDouble> EditDoubleNotNull;
typedef EditMinMaxNotNull<Date, ConvertDate>     EditDateNotNull;
typedef EditMinMaxNotNull<Time, ConvertTime>     EditTimeNotNull;

class EditString : public EditValue<WString, ConvertString> {
public:
	operator const WString&() const                  { return GetText(); }

	EditString& operator=(const WString& data)       { SetData(data); return *this; }
	EditString& operator=(const String& data)        { SetData(data); return *this; }

	EditString() {}
	EditString(int maxlen)                           { MaxLen(maxlen); }

	EditString& MaxLen(int maxlen)                   { ConvertString::MaxLen(maxlen); return *this; }
	EditString& NotNull(bool nn = true)              { ConvertString::NotNull(nn); return *this; }
};

class EditStringNotNull : public EditString {
public:
	EditStringNotNull& operator=(const WString& data) { SetData(data); return *this; }
	EditStringNotNull& operator=(const String& data)  { SetData(data); return *this; }

	EditStringNotNull()                               { NotNull(); }
	EditStringNotNull(int maxlen)                     { NotNull(); MaxLen(maxlen); }
};

class EditIntSpin : public EditInt {
public:
	virtual void MouseWheel(Point p, int zdelta, dword keyflags);
	virtual bool Key(dword key, int repcnt);


protected:
	SpinButtons sb;
	int         inc;

	void   Inc();
	void   Dec();
	void   Init();

public:
	EditIntSpin&    ShowSpin(bool s = true)   { sb.Show(s); return *this; }
	EditIntSpin&    SetInc(int _inc)           { inc = _inc; return *this; }
	int             GetInc() const            { return inc; }

	EditIntSpin();
	EditIntSpin(int min, int max);
	virtual ~EditIntSpin();
};

class EditDoubleSpin : public EditDouble
{
public:
	virtual void MouseWheel(Point p, int zdelta, dword keyflags);
	virtual bool Key(dword key, int repcnt);

protected:
	void            Inc();
	void            Dec();
	void            Init();

private:
	SpinButtons     spin;
	double          inc;

public:
	typedef EditDoubleSpin CLASSNAME;
	EditDoubleSpin(double inc = 0.1);
	EditDoubleSpin(double min, double max, double inc = 0.1);
	virtual ~EditDoubleSpin();

	EditDoubleSpin& SetInc(double _inc = 0.1) { inc = _inc; return *this; }
	double          GetInc() const            { return inc; }

	EditDoubleSpin& ShowSpin(bool s = true)   { spin.Show(s); return *this; }
};

class EditDoubleNotNullSpin : public EditDoubleSpin
{
public:
	EditDoubleNotNullSpin(double inc = 0.1) : EditDoubleSpin(inc) { NotNull(); }
	EditDoubleNotNullSpin(double min, double max, double inc = 0.1) : EditDoubleSpin(min, max, inc) { NotNull(); }
};
#line 30 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/AKeys.h"
struct KeyInfo {
	const char *name;
	dword key[4];
};

inline void AssertMoveable0(KeyInfo *) {}

void RegisterKeyBinding(const char *group, const char *id, KeyInfo& (*info)());

KeyInfo& AK_NULL();

void   EditKeys();

String StoreKeys();
void   RestoreKeys(const String& data);

dword ParseKeyDesc(CParser& p);
#line 31 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/Bar.h"
class BarPane : public ParentCtrl {
public:
	virtual void LeftDown(Point pt, dword keyflags);
	virtual void MouseMove(Point p, dword);

private:
	struct Item {
		Ctrl *ctrl;
		int   gapsize;
	};
	Array<Item>    item;
	Vector<int>    breakpos;
	bool           horz;
	Ctrl          *phelpctrl;
	int            vmargin, hmargin;
	bool           menu;

	int&     HoVe(Size& sz)                  { return horz ? sz.cx : sz.cy; }
	int&     VeHo(Size& sz)                  { return horz ? sz.cy : sz.cx; }
	int&     HoVe(bool horz, Size& sz) const { return horz ? sz.cx : sz.cy; }
	int&     VeHo(bool horz, Size& sz) const { return horz ? sz.cy : sz.cx; }

public:
	Callback WhenLeftClick;

	void  PaintBar(Draw& w, const SeparatorCtrl::Style& ss,
	               const Value& pane, const Value& iconbar = Null, int iconsz = 0);

	void  IClear();
	void  Clear();
	bool  IsEmpty() const                    { return item.IsEmpty(); }

	void  Add(Ctrl *ctrl, int gapsize);
	void  AddBreak()                         { Add(0, Null); }
	void  AddGap(int gapsize)                { Add(0, gapsize); }

	void  Margin(int v, int h)               { vmargin = v; hmargin = h; }

	Size  Repos(bool horz, int maxsize);
	Size  GetPaneSize(bool _horz, int maxsize) const;

	int   GetCount() const                   { return breakpos.GetCount() + 1; }

	void  SubMenu()                          { menu = true; }

	BarPane();
	virtual ~BarPane();
};

class Bar : public Ctrl {
public:
	struct Item {
		virtual Item& Text(const char *text);
		virtual Item& Key(dword key);
		virtual Item& Repeat(bool repeat = true);
		virtual Item& Image(const class Image& img);
		virtual Item& Check(bool check);
		virtual Item& Radio(bool check);
		virtual Item& Enable(bool _enable = true);
		virtual Item& Tip(const char *tip);
		virtual Item& Help(const char *help);
		virtual Item& Topic(const char *topic);
		virtual Item& Description(const char *desc);
		virtual void  FinalSync();

		Item&   Label(const char *text);
		Item&   RightLabel(const char *text);

		Item& Key(KeyInfo& (*key)());

		Item();
		virtual ~Item();
	};

protected:
	virtual Item&  AddItem(Callback cb) = 0;
	virtual Item&  AddSubMenu(Callback1<Bar&> proc) = 0;
	virtual void   AddCtrl(Ctrl *ctrl, int gapsize) = 0;
	virtual void   AddCtrl(Ctrl *ctrl, Size sz) = 0;

	class ScanKeys;

public:
	virtual bool   IsEmpty() const = 0;
	virtual void   Separator() = 0;

	static  Item&  NilItem();
	static bool    Scan(Callback1<Bar&> proc, dword key);

	void   Break();
	void   Gap(int size = 8);
	void   GapRight()                               { Gap(2147483647); }

	void   AddNC(Ctrl& ctrl);
	void   Add(Ctrl& ctrl)                          { AddCtrl(&ctrl, ctrl.GetMinSize()); }
	void   Add(Ctrl& ctrl, Size sz)                 { AddCtrl(&ctrl, sz); }
	void   Add(Ctrl& ctrl, int cx, int cy = 0)      { AddCtrl(&ctrl, Size(cx, cy)); }

	void   Add(bool en, Ctrl& ctrl)                     { Add(ctrl); ctrl.Enable(en); }
	void   Add(bool en, Ctrl& ctrl, Size sz)            { Add(ctrl, sz); ctrl.Enable(en); }
	void   Add(bool en, Ctrl& ctrl, int cx, int cy = 0) { Add(ctrl, cx, cy); ctrl.Enable(en); }


	Item&  Add(bool enable, const char *text, const Upp::Image& image, Callback callback);
	Item&  Add(bool enable, KeyInfo& (*key)(), const Upp::Image& image, Callback callback);
	Item&  Add(const char *text, const Upp::Image& image, Callback callback);
	Item&  Add(const String& text, const Upp::Image& image, Callback callback);
	Item&  Add(KeyInfo& (*key)(), const Upp::Image& image, Callback callback);

	Item&  Add(bool enable, const char *text, Callback callback);
	Item&  Add(bool enable, KeyInfo& (*key)(), Callback callback);
	Item&  Add(const char *text, Callback callback);
	Item&  Add(KeyInfo& (*key)(), Callback callback);

	void   MenuSeparator();
	void   MenuBreak();
	void   MenuGap(int size = 8);
	void   MenuGapRight()                           { MenuGap(2147483647); }

	void   AddMenu(Ctrl& ctrl);
	void   AddMenu(Ctrl& ctrl, Size sz);
	void   AddMenu(Ctrl& ctrl, int cx, int cy = 0)  { AddMenu(ctrl, Size(cx, cy)); }

	Item&  AddMenu(bool enable, const char *text, const Upp::Image& image, Callback callback);
	Item&  AddMenu(bool enable, KeyInfo& (*key)(), const Upp::Image& image, Callback callback);
	Item&  AddMenu(const char *text, const Upp::Image& image, Callback callback);
	Item&  AddMenu(const String& t, const Upp::Image& m, Callback c) { return AddMenu(t, m, c); }
	Item&  AddMenu(KeyInfo& (*key)(), const Upp::Image& m, Callback c);

	Item&  Add(bool enable, const char *text, Callback1<Bar&> proc);
	Item&  Add(const char *text, Callback1<Bar&> proc);
	Item&  Add(bool enable, const char *text, const Upp::Image& image, Callback1<Bar&> proc);
	Item&  Add(const char *text, const Upp::Image& image, Callback1<Bar&> proc);

	void   ToolSeparator();
	void   ToolBreak();
	void   ToolGap(int size = 8);
	void   ToolGapRight()                           { ToolGap(2147483647); }

	void   AddTool(Ctrl& ctrl);
	void   AddTool(Ctrl& ctrl, Size sz);
	void   AddTool(Ctrl& ctrl, int cx, int cy = 0)  { AddTool(ctrl, Size(cx, cy)); }

	Item&  Add(const Upp::Image& image, Callback callback);
	Item&  Add(bool enable, const Upp::Image& image, Callback callback);

	virtual void AddKey(dword key, Callback cb);
	        void AddKey(KeyInfo& (*key)(), Callback cb);

	virtual bool IsMenuBar() const                  { return false; }
	virtual bool IsToolBar() const                  { return false; }
	virtual bool IsScanKeys() const                 { return false; }
	virtual bool IsScanHelp() const                 { return false; }

	typedef Bar CLASSNAME;
	Bar();
	virtual ~Bar();
};

class BarCtrl : public Bar, public CtrlFrame {
public:
	virtual void   Layout();

	virtual void   FrameLayout(Rect& r);
	virtual void   FrameAddSize(Size& sz);
	virtual void   FrameAdd(Ctrl& ctrl);
	virtual void   FrameRemove();

	virtual bool   IsEmpty() const;
	virtual void   Separator();

protected:
	virtual void   AddCtrl(Ctrl *ctrl, int gapsize);
	virtual void   AddCtrl(Ctrl *ctrl, Size sz);

private:
	class SizeCtrl : public ParentCtrl {
	public:
		virtual Size GetMinSize() const;

	private:
		Size size;

	public:
		void  SetSize(Size sz)             { size = sz; }

		SizeCtrl()                         { NoWantFocus(); }
	};

	int                  sii;
	Array<SeparatorCtrl> separator;
	int                  zii;
	Array<SizeCtrl>      sizer;
	int                  align;

protected:
	BarPane pane;
	int     ssize;
	int     wrap;
	int     lsepm, rsepm;
	const SeparatorCtrl::Style *sepstyle;

	void     SyncBar();

	void     IClear();
	void     IFinish();

	void     Clear();

	virtual Value GetBackground() const;

	friend class BarPane;

public:
	Callback1<const String&> WhenHelp;
	Callback WhenLeftClick;

	static BarCtrl *GetBarCtrlParent(Ctrl *child);
	static void     SendHelpLine(Ctrl *q);
	static void     ClearHelpLine(Ctrl *q);

	enum {
		BAR_LEFT, BAR_RIGHT, BAR_TOP, BAR_BOTTOM
	};

	void  PaintBar(Draw& w, const SeparatorCtrl::Style& ss,
	               const Value& pane, const Value& iconbar = Null, int iconsz = 0);

	BarCtrl& Align(int align);
	BarCtrl& Top()                       { return Align(BAR_TOP); }
	BarCtrl& Bottom()                    { return Align(BAR_BOTTOM); }
	BarCtrl& Left()                      { return Align(BAR_LEFT); }
	BarCtrl& Right()                     { return Align(BAR_RIGHT); }
	int      GetAlign() const            { return align; }

	BarCtrl& Wrap(int q = 1)             { wrap = q; SyncBar(); return *this; }
	BarCtrl& NoWrap()                    { return Wrap(-1); }

	typedef BarCtrl CLASSNAME;

	BarCtrl();
	virtual ~BarCtrl();
};

class MenuItemBase;

CtrlFrame& MenuFrame();

class MenuBar : public BarCtrl {
public:
	virtual void  LeftDown(Point, dword);
	virtual bool  Key(dword key, int count);
	virtual bool  HotKey(dword key);
	virtual void  ChildGotFocus();
	virtual void  ChildLostFocus();
	virtual void  Deactivate();
	virtual void  CancelMode();
	virtual void  Paint(Draw& w);

protected:
	virtual Item& AddItem(Callback cb);
	virtual Item& AddSubMenu(Callback1<Bar&> proc);
	virtual Value GetBackground() const;

public:
	struct Style : ChStyle<Style> {
		Value item, topitem[3], topbar;
		Color itemtext, topitemtext[3];
		SeparatorCtrl::Style breaksep;
		Value look, arealook;
		Value popupframe, popupbody, popupiconbar;
		SeparatorCtrl::Style separator;
		Size  maxiconsize;
		int   leftgap, textgap;
		int   lsepm, rsepm;
		Point pullshift;
	};

private:
	Array<MenuItemBase> item;

	MenuBar     *parentmenu;
	MenuBar     *submenu;
	Ctrl        *submenuitem;
	Ptr<Ctrl>    restorefocus;
	bool         doeffect;
	Font         font;
	int          leftgap;
	int          lock;
	const Style *style;
	int          arealook;
	Size         maxiconsize;
	LookFrame    frame;

	friend class MenuItemBase;
	friend class SubMenuBase;
	friend class TopSubMenuItem;
	friend class SubMenuItem;

	void     SetParentMenu(MenuBar *parent)    { parentmenu = parent; style = parent->style; }
	MenuBar *GetParentMenu()                   { return parentmenu; }
	void     SetActiveSubmenu(MenuBar *sm, Ctrl *menuitem);
	MenuBar *GetActiveSubmenu()                { return submenu; }
	MenuBar *GetMasterMenu();
	MenuBar *GetLastSubmenu();
	void     DelayedClose();
	void     KillDelayedClose();
	void     SubmenuClose();
	void     PostDeactivate();
	void     SyncState();
	void     SetupRestoreFocus();
	void     PopUp(Ctrl *owner, Point p, Size rsz = Size(0, 0));

protected:
	enum {
		TIMEID_STOP = BarCtrl::TIMEID_COUNT,
		TIMEID_SUBMENUCLOSE,
		TIMEID_POST,
		TIMEID_COUNT
	};

public:
	virtual bool IsMenuBar() const                  { return true; }

	static int GetStdHeight(Font font = StdFont());

	void     CloseMenu();

	void     Set(Callback1<Bar&> menu);
	void     Post(Callback1<Bar&> bar);

	void     PopUp(Point p)                         { PopUp(GetActiveCtrl(), p); }
	void     PopUp()                                { PopUp(GetMousePos()); }

	void     Execute(Ctrl *owner, Point p);
	void     Execute(Point p)                       { Execute(GetActiveCtrl(), p); }
	void     Execute()                              { Execute(GetMousePos()); }

	static void Execute(Ctrl *owner, Callback1<Bar&> proc, Point p);
	static void Execute(Callback1<Bar&> proc, Point p) { Execute(GetActiveCtrl(), proc, p); }
	static void Execute(Callback1<Bar&> proc)          { Execute(proc, GetMousePos()); }

	bool     IsEmpty()                              { return item.IsEmpty(); }
	void     Clear();

	static const Style& StyleDefault();

	MenuBar& LeftGap(int cx)                        { leftgap = cx; return *this; }
	MenuBar& SetFont(Font f)                        { font = f; return *this; }
	MenuBar& SetStyle(const Style& s);
	Font     GetFont() const                        { return font; }
	MenuBar& AreaLook(int q = 1)                    { arealook = q; Refresh(); return *this; }
	MenuBar& MaxIconSize(Size sz)                   { maxiconsize = sz; return *this; }
	Size     GetMaxIconSize() const                 { return maxiconsize; }

	typedef MenuBar CLASSNAME;

	MenuBar();
	virtual ~MenuBar();
};

class ToolButton : public Ctrl, public Bar::Item {
public:
	virtual void   Paint(Draw& w);
	virtual void   MouseEnter(Point, dword);
	virtual void   MouseLeave();
	virtual Size   GetMinSize() const;
	virtual void   LeftDown(Point, dword);
	virtual void   LeftRepeat(Point, dword);
	virtual void   LeftUp(Point, dword);
	virtual bool   HotKey(dword key);
	virtual String GetDesc() const;

	virtual Bar::Item& Text(const char *text);
	virtual Bar::Item& Key(dword key);
	virtual Bar::Item& Repeat(bool repeat = true);
	virtual Bar::Item& Image(const Upp::Image& img);
	virtual Bar::Item& Enable(bool _enable);
	virtual Bar::Item& Tip(const char *tip);
	virtual Bar::Item& Help(const char *help);
	virtual Bar::Item& Topic(const char *help);
	virtual Bar::Item& Description(const char *desc);
	virtual Bar::Item& Radio(bool check);
	virtual Bar::Item& Check(bool check);
	virtual void       FinalSync();

public:
	struct Style : ChStyle<Style> {
		Value  look[6];
		Font   font;
		Color  textcolor[6];
		bool   light[6];
		int    contrast[6];
		Point  offset[6];
	};

protected:
	String  text;
	String  tiptext;
	dword   accel;
	bool    checked;
	bool    paint_checked;
	bool    repeat;

	byte    kind;
	Size    minsize;
	Size    maxiconsize;

	const Style      *style;

private:
	Upp::Image img;

	void       SendHelpLine();
	void       ClearHelpLine();
	void       UpdateTip();
	Upp::Image GetImage() const;

public:
	enum Kind { NOLABEL, RIGHTLABEL, BOTTOMLABEL, FORCE = 0x80 };

	void  Reset();

	static const Style& StyleDefault();
	static const Style& StyleSolid();

	bool		IsChecked()				 { return checked; }

	ToolButton& SetStyle(const Style& s) { style = &s; Refresh(); return *this; }
	ToolButton& MinSize(Size sz)         { minsize = sz; return *this; }
	ToolButton& MaxIconSize(Size sz)     { maxiconsize = sz; return *this; }
	ToolButton& Kind(int _kind)          { kind = _kind; Refresh(); return *this; }
	ToolButton& Label(const char *text, int kind = ToolButton::RIGHTLABEL);

	ToolButton();
	virtual ~ToolButton();
};

void PaintBarArea(Draw& w, Ctrl *x, const Value& look, int bottom = Null);

class ToolBar : public BarCtrl {
public:
	virtual bool HotKey(dword key);
	virtual void Paint(Draw& w);

protected:
	virtual Item& AddItem(Callback cb);
	virtual Item& AddSubMenu(Callback1<Bar&> proc);

public:
	struct Style : ChStyle<Style> {
		ToolButton::Style    buttonstyle;
		Size                 buttonminsize;
		Size                 maxiconsize;
		int                  buttonkind;
		Value                look, arealook;
		SeparatorCtrl::Style breaksep;
		SeparatorCtrl::Style separator;
	};

private:
	int               ii;
	Array<ToolButton> item;
	int               lock;
	Callback1<Bar&>   proc;
	const Style      *style;
	int               arealook;

	Size              buttonminsize;
	Size              maxiconsize;
	int               kind;

protected:
	enum {
		TIMEID_POST = BarCtrl::TIMEID_COUNT,
		TIMEID_COUNT
	};

public:
	virtual bool IsToolBar() const                  { return true; }

	static int GetStdHeight();

	void Clear();
	void Set(Callback1<Bar&> bar);
	void Post(Callback1<Bar&> bar);

	static const Style& StyleDefault();

	ToolBar& SetStyle(const Style& s)               { style = &s; Refresh(); return *this; }

	ToolBar& ButtonMinSize(Size sz)                 { buttonminsize = sz; return *this; }
	ToolBar& MaxIconSize(Size sz)                   { maxiconsize = sz; return *this; }
	ToolBar& ButtonKind(int _kind)                  { kind = _kind; return *this; }
	ToolBar& AreaLook(int q = 1)                    { arealook = q; Refresh(); return *this; }

	typedef ToolBar  CLASSNAME;

	ToolBar();
	virtual ~ToolBar();
};

class StaticBarArea : public Ctrl {
public:
	virtual void Paint(Draw& w);

private:
	bool upperframe;

public:
	StaticBarArea& UpperFrame(bool b) { upperframe = b; Refresh(); return *this; }
	StaticBarArea& NoUpperFrame()     { return UpperFrame(false); }

	StaticBarArea();
};

class LRUList {
	Vector<String> lru;
	int            limit;
	void           Select(String s, Callback1<const String&> WhenSelect);

public:
	static int GetStdHeight();

	void        Serialize(Stream& stream);

	void        operator()(Bar& bar, Callback1<const String&> WhenSelect);

	void        NewEntry(const String& path);
	void        RemoveEntry(const String& path);

	LRUList&    Limit(int _limit)                       { limit = _limit; return *this; }
	int         GetLimit() const                        { return limit; }
	int         GetCount() const                        { return lru.GetCount(); }

	typedef LRUList CLASSNAME;

	LRUList()   { limit = 6; }
};

class ToolTip : public Ctrl {
public:
	virtual void Paint(Draw& w);
	virtual Size GetMinSize() const;

private:
	String  text;

public:
	void   Set(const char *_text)        { text = _text; }
	String Get() const                   { return text; }

	void PopUp(Ctrl *owner, Point p, bool effect);

	ToolTip();
};

void PerformDescription();
#line 32 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/StatusBar.h"
class InfoCtrl : public FrameLR<Ctrl> {
public:
	virtual void Paint(Draw& w);
	virtual void FrameLayout(Rect& r);

private:

	struct Tab {
		PaintRect             info;
		int                   width;

		Tab() { width = 0; }
	};

	Array<Tab>   tab;
	PaintRect    temp;
	bool         right;
	String       defaulttext;
	TimeCallback temptime;

public:
	void Set(int tab, const PaintRect& info, int width);
	void Set(int tab, const Value& info, int width);
	void Set(const PaintRect& info);
	void Set(const Value& info);
	void Temporary(const PaintRect& info, int timeoout = 2000);
	void Temporary(const Value& info, int timeout = 2000);
	void EndTemporary();

	int  GetTabCount() const              { return tab.GetCount(); }
	int  GetTabOffset(int t) const;
	int  GetRealTabWidth(int tabi, int width) const;

	void operator=(const String& s)       { Set(s); }

	InfoCtrl& SetDefault(const String& d) { defaulttext = d; Refresh(); return *this; }
	InfoCtrl& Left(int w);
	InfoCtrl& Right(int w);

	typedef InfoCtrl CLASSNAME;

	InfoCtrl();
};

class StatusBar : public InfoCtrl {
public:
	virtual void FrameLayout(Rect& r);
	virtual void FrameAddSize(Size& sz);
	virtual void Paint(Draw& w);

public:
	struct Style : public ChStyle<Style> {
		Value look;
	};

private:
	int      cy;
	SizeGrip grip;

	struct TopFrame : public CtrlFrame {
		virtual void FrameLayout(Rect& r);
		virtual void FramePaint(Draw& draw, const Rect& r);
		virtual void FrameAddSize(Size& sz);

		const Style *style;
	};

	TopFrame frame;

	void    SetText(const String& s)          { Set(s); }

public:
	void operator=(const String& s)           { Set(s); }

	operator Callback1<const String&>()       { return pteback(this, &StatusBar::SetText); }

	StatusBar&  Height(int _cy);
	StatusBar&  NoSizeGrip()                  { RemoveFrame(grip); return *this; }

	static const Style& StyleDefault();

	InfoCtrl& SetStyle(const Style& s)        { frame.style = &s; Refresh(); return *this; }

	StatusBar();
	~StatusBar();
};


Display& ProgressDisplay();

class ProgressInfo {
	InfoCtrl *info;
	String    text;
	int       tw;
	int       tabi;
	int       cx;
	int       total;
	int       pos;

	void Refresh();
	void Reset()                                { tabi = 0; cx = 200; total = 100; pos = 0; tw = 0; info = 0; }

public:
	ProgressInfo& Text(const String& s)         { text = s; Refresh(); return *this; }
	ProgressInfo& TextWidth(int cx)             { tw = cx; Refresh(); return *this; }
	ProgressInfo& Width(int _cx)                { cx = _cx; Refresh(); return *this;  }
	ProgressInfo& Placement(int _tabi)          { tabi = _tabi; Refresh(); return *this; }
	ProgressInfo& Info(InfoCtrl& _info)         { info = &_info; info->EndTemporary(); Refresh(); return *this; }
	ProgressInfo& Total(int _total)             { total = _total; Refresh(); return *this; }

	ProgressInfo& Set(int _pos, int _total);

	void          Set(int _pos)                 { Set(_pos, total); }
	int           Get() const                   { return pos; }

	void operator=(int p)                       { Set(p); }
	void operator++()                           { pos++; Refresh(); }
	operator int()                              { return pos; }

	ProgressInfo()                              { Reset(); }
	ProgressInfo(InfoCtrl& f)                   { Reset(); Info(f); }
	~ProgressInfo();
};
#line 33 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/TabCtrl.h"
class TabCtrl : public Ctrl {
public:
	virtual bool  Accept();
	virtual void  Paint(Draw& draw);
	virtual void  CancelMode();
	virtual void  MouseMove(Point p, dword keyflags);
	virtual void  LeftDown(Point p, dword keyflags);
	virtual void  MouseLeave();
	virtual bool  Key(dword key, int count);
	virtual bool  HotKey(dword key);
	virtual void  Layout();
	virtual Rect  GetOpaqueRect();
	virtual Value GetData() const;
	virtual void  SetData(const Value& data);

public:
	class Item {
		TabCtrl  *owner;

		int       x;
		Point     pictpos;
		Point     textpos;
		int       cx;

		String    text;
		PaintRect pict;
		Ptr<Ctrl> ctrl;
		bool      enabled;
		Ptr<Ctrl> slave;
		dword     key;

		friend class TabCtrl;

		void Layout(int x, int y, int cy);
		void Paint(Draw& w, int state);
		int  Right() { return x + cx; }

	public:
		Item&          Text(const String& _text);
		Item&          Picture(PaintRect d);
		Item&          SetImage(const Upp::Image& _im)  { return Picture(PaintRect(ImageDisplay(), _im)); }
		Item&          SetCtrl(Ctrl *_ctrl);
		Item&          SetCtrl(Ctrl& c)                 { return SetCtrl(&c); }
		Item&          Slave(Ctrl *_slave);
		Item&          Key(dword _key)                  { key = _key; return *this; }

		Item&          Enable(bool _en = true);
		Item&          Disable()                        { return Enable(false); }
		bool           IsEnabled() const                { return enabled; }
		Ctrl          *GetSlave()                       { return slave; }
		const Ctrl    *GetSlave() const                 { return slave; }
		Ctrl          *GetCtrl()                        { return ctrl; }
		const Ctrl    *GetCtrl() const                  { return ctrl; }

		Item();


		Item&          Control(Ctrl *c)                 { return SetCtrl(c); }
		Item&          Image(const Upp::Image& m)       { return SetImage(m); }
	};

	struct Style : ChStyle<Style> {
		int tabheight, margin, extendleft;
		Rect sel, edge;
		Value normal[4], first[4], last[4], both[4], body;
		Color text_color[4];
		Font font;
	};

private:
	struct Tabs : public Ctrl {
		virtual void Paint(Draw& w);
	};

	Array<Item> tab;
	int         x0;
	int         hot;
	int         sel;
	Tabs        tabs;
	Button      left, right;
	ParentCtrl  pane;
	bool        accept_current;

	const Style *style;

	static Image Fade(int i);

	int        GetTab(Point p);
	void       PaintTabs(Draw& w);
	void       ScrollInto(int i);
	void       Left();
	void       Right();
	void       SyncHot();
	void       SyncTabs();
	int        TabsRight();
	void       Go(int d);

public:
	Callback WhenSet;

	TabCtrl::Item& Add();
	TabCtrl::Item& Add(const char *text);
	TabCtrl::Item& Add(const Image& m, const char *text);
	TabCtrl::Item& Add(Ctrl& slave, const char *text);
	TabCtrl::Item& Add(Ctrl& slave, const Image& m, const char *text);

	TabCtrl::Item& Insert(int i);
	TabCtrl::Item& Insert(int i, const char *text);
	TabCtrl::Item& Insert(int i, const Image& m, const char *text);
	TabCtrl::Item& Insert(int i, Ctrl& slave, const char *text);
	TabCtrl::Item& Insert(int i, Ctrl& slave, const Image& m, const char *text);

	void  Remove(int i);

	int   GetCount() const                       { return tab.GetCount(); }
	Item& GetItem(int i)                         { return tab[i]; }
	const Item& GetItem(int i) const             { return tab[i]; }

	void Set(int i);
	int  Get() const                             { return sel; }

	void GoNext()                                { Go(1); }
	void GoPrev()                                { Go(-1); }

	Size     ComputeSize(Size pane);
	void     Add(Ctrl& c)                        { pane.Add(c.SizePos()); }
	TabCtrl& operator<<(Ctrl& c)                 { Add(c); return *this; }

	static const Style& StyleDefault();

	TabCtrl& AcceptCurrent(bool ac = true)       { accept_current = ac; return *this; }
	TabCtrl& AcceptAll()                         { return AcceptCurrent(false); }
	TabCtrl& SetStyle(const Style& s)            { style = &s; Refresh(); return *this; }

	void Reset();

	typedef TabCtrl CLASSNAME;

	TabCtrl();
};

class TabDlg : public TopWindow {
	void    Rearrange();

	bool    binit;
	Size    sz;

	void           PlaceButton(Button& b, int& r);
	TabCtrl::Item& Add0(Ctrl& tab, const char *text);
	TabDlg&        AButton(Button& b);

public:
	TabCtrl  tabctrl;
	Button   ok;
	Button   cancel;
	Button   exit;
	Button   apply;

	template <class T>
	TabCtrl::Item& Add(T& tab, const char *text)                   { CtrlLayout(tab); return Add0(tab, text); }
	template <class T>
	TabCtrl::Item& Add(T& tab, const Image& img, const char *name) { return Add(tab, name).Image(img); }
	template <class T>
	TabDlg&  operator()(T& tab, const char *text)                  { Add(tab, text); return *this; }
	template <class T>
	TabDlg&  operator()(T& tab, const Image& img, const char *txt) { Add(tab, img, txt); return *this; }

	TabDlg&  OK()                                                  { return AButton(ok); }
	TabDlg&  Cancel()                                              { return AButton(cancel); }
	TabDlg&  OKCancel()                                            { return OK().Cancel(); }
	TabDlg&  Exit()                                                { return AButton(exit); }
	TabDlg&  Apply()                                               { return AButton(apply); }

	TabDlg();
};
#line 34 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/DlgColor.h"



class WheelRampCtrl : public Ctrl
{
public:
	WheelRampCtrl(bool ramp);
	~WheelRampCtrl();

	virtual void  Layout();
	virtual void  Paint(Draw& draw);
	virtual void  SetData(const Value& value);
	virtual Value GetData() const                { return color; }

	virtual void  LeftDown(Point pt, dword keyflags);
	virtual void  LeftUp(Point pt, dword keyflags);
	virtual void  LeftDouble(Point pt, dword keyflags);
	virtual void  MouseMove(Point pt, dword keyflags);

	Callback      WhenLeftDouble;

private:
	void          SetColor(Color color, bool set_norm, bool set_hsv);

	Image         PaintRamp(Size size);
	Image         PaintWheel(Size size);
	void          PaintColumn(Draw& draw);

	int           ClientToLevel(int y) const;
	int           LevelToClient(int l) const;

private:

	bool          ramp;
	Color         color;
	Color         normalized_color;
	int           h16, s16, v16;
	int           round_step;
	int           wheel_style;
	enum STYLE { S_WHEEL, S_RECT, S_HEXAGON };
	STYLE         style;
	Image         cache;
	int           cache_level;
	Image         wheel_cache;
	Rect          wheel_rect;
	Rect          column_rect;

	int           firstclick;

	struct WheelBuff
	{
		int arg;
		int l;
	};
};

struct ColorWheelCtrl : public WheelRampCtrl {
	ColorWheelCtrl() : WheelRampCtrl(false) {}
};

struct ColorRampCtrl : public WheelRampCtrl {
	ColorRampCtrl() : WheelRampCtrl(true) {}
};

class ColorSelector : public Ctrl
{
public:
	ColorSelector(bool not_null = true);

	ColorSelector& NotNull(bool nn = true)                  { impl->NotNull(nn); return *this; }
	ColorSelector& NoNotNull()                              { return NotNull(false); }
	bool           IsNotNull() const                        { return impl->IsNotNull(); }

	Color          Get() const                              { return impl->Get(); }
	void           Set(Color c)                             { impl->Set(c); }

	Vector<Color>  GetPalette() const                       { return impl->GetPalette(); }
	void           SetPalette(const Vector<Color>& palette) { impl->SetPalette(palette); }

	void           SerializeConfig(Stream& stream)          { impl->SerializeConfig(stream); }

	virtual void   SetData(const Value& color)              { Set(color); }
	virtual Value  GetData() const                          { return Get(); }

	Ctrl&          GetImplCtrl()                            { return impl->GetCtrl(); }

public:
	Callback       WhenSetColor;

public:
	class Impl
	{
	public:
		virtual ~Impl() {}

		virtual void          Set(Color c) = 0;
		virtual Color         Get() const = 0;
		virtual void          NotNull(bool nn) = 0;
		virtual bool          IsNotNull() const = 0;
		virtual Vector<Color> GetPalette() const = 0;
		virtual void          SetPalette(const Vector<Color>& pal) = 0;
		virtual void          SerializeConfig(Stream& stream) = 0;
		virtual Ctrl&         GetCtrl() = 0;

	protected:
		Impl() {}
	};

protected:
	One<Impl>      impl;
};

class ColorCtrl : public DataPusher
{
public:
	typedef ColorCtrl CLASSNAME;
	ColorCtrl(bool not_null = true);
	virtual ~ColorCtrl();

	ColorCtrl&     NotNull(bool _nn = true) { empty.Show(!_nn); return *this; }
	ColorCtrl&     NoNotNull()              { return NotNull(false); }
	bool           IsNotNull() const        { return !empty.IsVisible(); }

protected:
	virtual void   DoAction();
	void           OnClear()                { SetDataAction(Null); }

protected:
	FrameRight<Button> empty;
};

Color RunDlgSelectColor(Color init_color = Black, bool not_null = true, const char *title = 0, bool *ok = 0);
const Display& StdColorDisplayNull();

class ColorPopUp : public Ctrl {
public:
	virtual  void Paint(Draw& w);
	virtual  void LeftUp(Point p, dword);
	virtual  void LeftDown(Point p, dword);
	virtual  void MouseMove(Point p, dword);
	virtual  void MouseLeave();
	virtual  void Deactivate();
	virtual  bool Key(dword key, int count);

private:
	int      Get(Point p);
	int      GetCy();
	void     Setup(Color c);
	void     Finish();
	void     Ramp();
	void     Wheel();
	int      GetColorCount() const;
	Color    GetColor(int i) const;
	void     Select();

	void 	 DrawFilledFrame(Draw &w, int x, int y, int cx, int cy, Color fcol, Color bcol);
	void 	 DrawFilledFrame(Draw &w, Rect &r, Color fcol, Color bcol);


	int      colori;
	bool     notnull;
	bool     scolors;
	bool     norampwheel;
	String   nulltext;
	Color    color;

	ColorRampCtrl  ramp;
	ColorWheelCtrl wheel;

public:
	Callback WhenCancel;
	Callback WhenSelect;

	typedef ColorPopUp CLASSNAME;

	void     PopUp(Ctrl *owner, Color c = White);
	Color    Get() const;

	ColorPopUp& NotNull(bool b = true)               { notnull = b; return *this; }
	ColorPopUp& SColors(bool b = true)               { scolors = b; return *this; }
	ColorPopUp& NullText(const char *s)              { nulltext = s; Refresh(); return *this; }
	ColorPopUp& NoRampWheel(bool b = true)           { norampwheel = b; return *this; }

	ColorPopUp();
	virtual ~ColorPopUp();
};

class ColorPusher : public Ctrl {
public:
	virtual void  Paint(Draw& w);
	virtual void  LeftDown(Point p, dword);
	virtual bool  Key(dword key, int);
	virtual void  GotFocus()                  { Refresh(); }
	virtual void  LostFocus()                 { Refresh(); }
	virtual void  SetData(const Value& v);
	virtual Value GetData() const;

protected:
	bool       push;
	bool       withtext;
	bool       track;
	Color      color, saved_color;
	ColorPopUp colors;
	String     nulltext;

	void AcceptColors();
	void CloseColors();
	void NewColor();
	void Drop();

public:
	typedef ColorPusher CLASSNAME;

	ColorPusher& NullText(const char *s)    { nulltext = s; colors.NullText(s); Refresh(); return *this; }
	ColorPusher& NotNull(bool b = true)     { colors.NotNull(b); return *this; }
	ColorPusher& SColors(bool b = true)     { colors.SColors(b); return *this; }
	ColorPusher& WithText()                 { withtext = true; return *this; }
	ColorPusher& Track(bool b = true)       { track = b; return *this; }
	ColorPusher& NoTrack()                  { return Track(false); }
	ColorPusher& NoRampWheel(bool b = true) { colors.NoRampWheel(b); return *this; }

	ColorPusher();
	virtual ~ColorPusher();
};

class ColorButton : public ColorPusher {
public:
	virtual void  Paint(Draw& w);
	virtual void  MouseEnter(Point p, dword keyflags);
	virtual void  MouseLeave();
	virtual Size  GetMinSize() const;

protected:
	Image      image, nullimage, staticimage;
	const ToolButton::Style *style;

public:
	ColorButton& ColorImage(const Image& img)             { image = img; Refresh(); return *this; }
	ColorButton& NullImage(const Image& img)              { nullimage = img; Refresh(); return *this; }
	ColorButton& StaticImage(const Image& img)            { staticimage = img; Refresh(); return *this; }
	ColorButton& SetStyle(const ToolButton::Style& s)     { style = &s; Refresh(); return *this; }

	ColorButton();
	virtual ~ColorButton();
};

String FormatColor(Color c);
Color  ReadColor(CParser& p);

#line 251 "u:/uppsrc\\CtrlLib/DlgColor.h"
#line 35 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/ArrayCtrl.h"

template <class T>
void DefaultCtrlFactoryFn(One<Ctrl>& ctrl)
{
	ctrl = new T;
}

template <class T>
Callback1<One<Ctrl>&> DefaultCtrlFactory()
{
	return callback(DefaultCtrlFactoryFn<T>);
}

class ArrayCtrl : public Ctrl {
public:
	virtual void  CancelMode();
	virtual bool  Accept();
	virtual void  Reject();
	virtual void  Paint(Draw& w);
	virtual void  Layout();
	virtual bool  Key(dword key, int);
	virtual void  LeftDown(Point p, dword);
	virtual void  LeftDouble(Point p, dword);
	virtual void  LeftDrag(Point p, dword);
	virtual void  LeftUp(Point p, dword flags);
	virtual void  RightDown(Point p, dword);
	virtual void  MouseMove(Point p, dword);
	virtual void  MouseWheel(Point p, int zdelta, dword keyflags);
	virtual Image CursorImage(Point p, dword);
	virtual void  DragAndDrop(Point p, PasteClip& d);
	virtual void  DragRepeat(Point p);
	virtual void  DragLeave();
	virtual void  GotFocus();
	virtual void  LostFocus();
	virtual void  ChildGotFocus();
	virtual void  ChildLostFocus();

public:
	struct IdInfo {
		Value           insertval;
		ValueGen       *insertgen;
		int            (*accel)(int);

		IdInfo& InsertValue(const Value& v)  { insertval = v; return *this; }
		IdInfo& InsertValue(ValueGen& g)     { insertgen = &g; return *this; }
		IdInfo& Accel(int (*filter)(int))    { accel = filter; return *this; }
		IdInfo& Accel()                      { return Accel(CharFilterDefaultToUpperAscii); }

		Value   GetInsertValue()             { return insertgen ? insertgen->Get() : insertval; }

		IdInfo()                             { insertgen = 0; accel = 0; }
	};

	class Column : FormatConvert {
		ArrayCtrl            *arrayctrl;
		int                   index;
		Mitor<int>            pos;
		const Convert        *convert;
		Ptr<Ctrl>             edit;
		const Display        *display;
		Callback1<One<Ctrl>&> factory;
		int                 (*accel)(int);
		int                   margin;
		bool                  cached;
		bool                  clickedit;
		Any                   cache;
		const ValueOrder     *order;
		int                 (*cmp)(const Value& a, const Value& b);


		void   InvalidateCache(int i);
		void   InsertCache(int i, int n);
		void   RemoveCache(int i);
		void   ClearCache();
		void   Sorts();

		friend class ArrayCtrl;

	public:
		Column& Add(int _pos)                      { pos.Add(_pos); return *this; }
		Column& Add(Id id)                         { pos.Add(-id.AsNdx()); return *this; }
		Column& AddIndex(Id id)                    { arrayctrl->AddIndex(id); return Add(id); }
		Column& AddIndex()                         { Add(arrayctrl->GetIndexCount()); arrayctrl->AddIndex(); return *this; }

		Column& SetConvert(const Convert& c);
		Column& SetFormat(const char *fmt);
		Column& SetDisplay(const Display& d);
		Column& NoEdit();
		Column& Edit(Ctrl& e);
		Column& Ctrls(Callback1<One<Ctrl>&> factory);
		Column& Ctrls(void (*factory)(One<Ctrl>&)) { return Ctrls(callback(factory)); }
		template <class T>
		Column& Ctrls()                            { return Ctrls(DefaultCtrlFactory<T>()); }
		Column& InsertValue(const Value& v);
		Column& InsertValue(ValueGen& g);
		Column& NoClickEdit()                      { clickedit = false; return *this; }
		Column& Cache();
		Column& Accel(int (*filter)(int))          { accel = filter; return *this; }
		Column& Accel()                            { return Accel(CharFilterDefaultToUpperAscii); }

		Column& Sorting(const ValueOrder& o);
		Column& Sorting(int (*c)(const Value& a, const Value& b));
		Column& Sorting();
		Column& SortDefault();

		Column& Margin(int m)                      { margin = m; return *this; }

		HeaderCtrl::Column& HeaderTab();

		Column();
	};

	struct Order {
		virtual bool operator()(const Vector<Value>& row1, const Vector<Value>& row2) const = 0;
		virtual ~Order() {}
	};

private:
	struct ItemOrder;
	struct RowOrder;
	struct SortPredicate;

	struct Control : Moveable<Control> {
		int   pos;
		Ctrl *ctrl;
	};

	struct CellCtrl : ParentCtrl {
		virtual void LeftDown(Point, dword);

		bool       owned;
		bool       value;
		Ctrl      *ctrl;
	};

	struct CellInfo : Moveable<CellInfo> {
		BitAndPtr ptr;

		void           Set(Ctrl *ctrl, bool owned, bool value);
		bool           IsCtrl() const             { return ptr.GetBit(); }
		CellCtrl&      GetCtrl() const            { ; return *(CellCtrl *)ptr.GetPtr(); }

		void           Set(const Display& d)      { ptr.Set0((void *)&d); }
		bool           IsDisplay() const          { return !ptr.GetBit() && ptr.GetPtr(); }
		const Display& GetDisplay() const         { ; return *(const Display *)ptr.GetPtr(); }

		CellInfo( CellInfo& s);
		CellInfo() {}
		~CellInfo();
	};

	friend class Column;
	friend struct SortPredicate;

	struct Ln : Moveable<Ln> {
		int y;
		int cy;
		Ln()               { cy = Null; }
	};

	struct Line : Moveable<Line> {
		bool          select:1;
		bool          enabled:1;
		Vector<Value> line;

		Line() { select = false; enabled = true; }
	};

	Vector<Line>               array;
	HeaderCtrl                 header;
	ScrollBar                  sb;
	Scroller                   scroller;
	Array<Column>              column;
	Vector<Control>            control;
	ArrayMap<Id, IdInfo>       idx;
	Vector<Ln>                 ln;
	Vector< Vector<CellInfo> > cellinfo;
	Vector<bool>               modify;
	FrameBottom<StaticRect>    scrollbox;
	DisplayPopup               info;

	int   keypos;
	int   cursor;
	int   anchor;
	int   linecy;
	int   virtualcount;
	Point clickpos;
	int   dropline, dropcol;
	int   sortcolumn;
	bool  sortcolumndescending;
	int   acceptingrow;

	mutable int   selectcount;

	String row_name;
	Color  gridcolor;
	Color  evenpaper, evenink, oddpaper, oddink;

	bool  horzgrid:1;
	bool  vertgrid:1;
	bool  nocursor:1;
	bool  mousemove:1;
	bool  editmode:1;
	bool  insertmode:1;

	bool  inserting:1;
	bool  appending:1;
	bool  appendline:1;
	bool  noinsertappend:1;
	bool  autoappend:1;
	bool  removing:1;
	bool  moving:1;
	bool  askremove:1;
	bool  duplicating:1;
	bool  multiselect:1;
	bool  hasctrls:1;
	bool  headerctrls:1;
	bool  popupex:1;
	bool  nobg:1;
	bool  focussetcursor:1;
	bool  allsorting:1;

	mutable bool  selectiondirty:1;

	unsigned  bains:2;

	bool  isdrag:1;
	bool  selclick:1;

	int    Pos(int np) const;

	void   InsertCache(int i);
	void   RemoveCache(int i);

	void   RefreshRow(int i);

	void   SetSb();
	void   HeaderLayout();
	void   Scroll();
	void   Page(int q);

	void   DoPoint(Point p, bool dosel = true);
	void   DoClick(Point p, dword flags);
	void   ClickColumn(Point p);
	void   ClickSel(dword flags);
	Rect   GetCellRect(int i, int col);
	Rect   GetCellRectM(int i, int col);

	Point           FindCellCtrl(Ctrl *c);
	void            SyncCtrls(int from = 0);
	bool            IsCtrl(int i, int j) const;
	const CellCtrl& GetCtrl(int i, int j) const;
	CellCtrl&       GetCtrl(int i, int j);
	void            SetCtrlValue(int i, int ii, const Value& v);

	void   PlaceEdits();
	void   EndEdit();
	void   ColEditSetData(int col);
	void   CtrlSetData(int col);
	Value  Get0(int i, int ii) const;
	void   Set0(int i, int ii, const Value& v);
	void   AfterSet(int i);

	void   Reline(int i, int y);
	bool   AcceptRow();
	void   Remove0(int i);
	void   DisableCtrls();
	void   SetCtrls();
	void   DoRemovem();
	bool   KillCursor0();

	const Display& GetCellInfo(int i, int j, bool f0, Value& v, Color& fg, Color& bg, dword& st);
	Ctrl&  SetCtrl(int i, int j, Ctrl *newctrl, bool owned, bool value);
	Size   DoPaint(Draw& w, bool sample);

	bool   TestKey(int i, int key);

	void   Move(int d);

	bool   SetCursor0(int i, bool dosel = true);

	void   SyncSelection() const;
	void   KeyMultiSelect(int aanchor, dword key);

	void   HeaderScrollVisibility();

	void   RefreshSel();
	bool   DnDInsert(int line, int py, PasteClip& d, int q);
	void   DnD(int line, int col);
	enum { DND_INSERTLINE = -1, DND_LINE = -2 };

	void   SyncInfo();
	void   SortA();
	void   SortB(const Vector<int>& o);

public:
	Ctrl&  SetCtrl(int i, int j, Ctrl *newctrl) { return SetCtrl(i, j, newctrl, true, true); }

protected:
	virtual bool UpdateRow();
	virtual void RejectRow();

	void   ClearModify();

public:
	Callback          WhenLeftDouble;
	Callback          WhenEnterKey;
	Callback          WhenLeftClick;
	Callback1<Bar&>   WhenBar;
	Gate              WhenAcceptRow;
	Callback          WhenUpdateRow;
	Callback          WhenArrayAction;
	Callback          WhenStartEdit;
	Callback          WhenAcceptEdit;
	Callback          WhenCtrlsAction;
	Callback          WhenSel;

	Callback                        WhenDrag;
	Callback3<int, int, PasteClip&> WhenDropCell;
	Callback2<int, PasteClip&>      WhenDropInsert;
	Callback2<int, PasteClip&>      WhenDropLine;
	Callback1<PasteClip&>           WhenDrop;


	Callback          WhenEnterRow;
	Callback          WhenKillCursor;
	Callback          WhenCursor;
	Callback          WhenSelection;

	IdInfo&    IndexInfo(int ii);
	IdInfo&    IndexInfo(Id id);
	IdInfo&    AddIndex(Id id);
	IdInfo&    AddIndex();
	int        GetIndexCount() const        { return idx.GetCount(); }
	Id         GetId(int ii) const          { return idx.GetKey(ii); }
	int        GetPos(Id id) const          { return idx.Find(id); }
	IdInfo&    SetId(int ii, Id id);
	IdInfo&    AddKey(Id id)                { ; return AddIndex(id); }
	IdInfo&    AddKey()                     { ; return AddIndex(); }
	Id         GetKeyId() const             { return idx.GetKey(0); }

	Column&    AddColumn(const char *text = 0, int w = 0);
	Column&    AddColumn(Id id, const char *text, int w = 0);
	Column&    AddColumnAt(int ii, const char *text, int w = 0);
	Column&    AddColumnAt(Id id, const char *text, int w = 0);
	Column&    AddRowNumColumn(const char *text, int w = 0);

	int                       GetColumnCount() const   { return column.GetCount(); }
	int                       FindColumnWithPos(int pos) const;
	int                       FindColumnWithId(Id id) const;
	Column&                   ColumnAt(int i)          { return column[i]; }
	Column&                   ColumnAt(Id id)          { return column[FindColumnWithId(id)]; }
	HeaderCtrl::Column&       HeaderTab(int i)         { return header.Tab(i); }
	HeaderCtrl::Column&       HeaderTab(Id id)         { return header.Tab(FindColumnWithId(id)); }
	const Column&             ColumnAt(int i) const    { return column[i]; }
	const Column&             ColumnAt(Id id) const    { return column[FindColumnWithId(id)]; }
	const HeaderCtrl::Column& HeaderTab(int i) const   { return header.Tab(i); }
	const HeaderCtrl::Column& HeaderTab(Id id) const   { return header.Tab(FindColumnWithId(id)); }

	const HeaderCtrl&         HeaderObject() const     { return header; }
	HeaderCtrl&               HeaderObject()           { return header; }

	void       SerializeHeader(Stream& s)    { header.Serialize(s); }
	void       SerializeSettings(Stream& s);

	IdInfo&    AddCtrl(Ctrl& ctrl);
	IdInfo&    AddCtrl(Id id, Ctrl& ctrl);
	void       AddCtrlAt(int ii, Ctrl& ctrl);
	void       AddCtrlAt(Id id, Ctrl& ctrl);
	void       AddRowNumCtrl(Ctrl& ctrl);

	void       SetCount(int c);
	void       SetVirtualCount(int c);
	int        GetCount() const;
	void       Clear();
	void       Shrink();
	Value      Get(int i, int ii) const;
	Value      Get(int i, Id id) const;
	void       Set(int i, int ii, const Value& v);
	void       Set(int i, Id id, const Value& v);

	Value      Get(int ii) const;
	Value      Get(Id id) const;
	Value      GetOriginal(int ii) const;
	Value      GetOriginal(Id id) const;
	bool       IsModified(int ii) const;
	bool       IsModified(Id id) const;
	Value      GetKey() const;
	Value      GetOriginalKey() const;
	void       Set(int ii, const Value& v);
	void       Set(Id id, const Value& v);

	Value      GetColumn(int row, int col) const;
	Value      GetConvertedColumn(int row, int col);

	int        GetSelectCount() const;
	bool       IsSelection() const                              { return GetSelectCount(); }
	void       Select(int i, bool sel = true);
	void       Select(int i, int count, bool sel = true);
	bool       IsSelected(int i) const                          { return array[i].select; }
	void       ClearSelection();
	bool       IsSel(int i) const;

	void       EnableLine(int i, bool e);
	void       DisableLine(int i)                               { EnableLine(i, false); }
	bool       IsLineDisabled(int i) const                      { return array[i].enabled; }

	Vector<Value> ReadRow(int i) const;
	Vector<Value> GetLine(int i) const                          { return ReadRow(i); }

	void       Set(int i, const Vector<Value>& v);

	void       Add();
	void       Add(const Vector<Value>& v);



	void Add(Value p1); void Add(Value p1, Value p2); void Add(Value p1, Value p2, Value p3); void Add(Value p1, Value p2, Value p3, Value p4); void Add(Value p1, Value p2, Value p3, Value p4, Value p5); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37, Value p38); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37, Value p38, Value p39); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37, Value p38, Value p39, Value p40);



	void       AddSeparator();

	void       Insert(int i);
	void       Insert(int i, int count);
	void       Insert(int i, const Vector<Value>& v);
	void       Insert(int i, const Vector< Vector<Value> >& v);

	void       Remove(int i);

	void       RemoveSelection();

	Image      GetDragSample();

	void       InsertDrop(int line, const Vector< Vector<Value> >& data, PasteClip& d, bool self);
	void       InsertDrop(int line, const Vector<Value>& data, PasteClip& d, bool self);
	void       InsertDrop(int line, const Value& data, PasteClip& d, bool self);
	void       InsertDrop(int line, const ArrayCtrl& src, PasteClip& d);
	void       InsertDrop(int line, PasteClip& d);

	bool       IsCursor() const                        { return cursor >= 0; }
	bool       SetCursor(int i);
	bool       KillCursor();
	void       CancelCursor();
	int        GetCursor() const                       { return cursor; }
	void       GoBegin();
	void       GoEnd();
	int        GetCursorSc() const;
	void       ScCursor(int a);
	void       CenterCursor();
	void       ScrollInto(int line);
	void       ScrollIntoCursor();
	void       SetCursorEditFocus();
	int        GetScroll() const;
	void       ScrollTo(int sc);
	void       ShowAppendLine();

	void       SwapUp();
	void       SwapDown();

	int        Find(const Value& v, int ii = 0, int from = 0) const;
	int        Find(const Value& v, Id id, int from = 0) const;

	bool       FindSetCursor(const Value& val, int ii = 0, int from = 0);
	bool       FindSetCursor(const Value& val, Id id, int from = 0);

	void       Sort(const ArrayCtrl::Order& order);
	void       Sort(int from, int count, const ArrayCtrl::Order& order);
	void       Sort(int (*compare)(const Vector<Value>& v1, const Vector<Value>& v2));
	void       Sort(int ii, int (*compare)(const Value& v1, const Value& v2)
	                = StdValueCompare);
	void       Sort(Id id, int (*compare)(const Value& v1, const Value& v2)
	                = StdValueCompare);
	void       Sort()                                  { Sort(0); }

	void       ColumnSort(int column, const ValueOrder& order);

	void       SetSortColumn(int ii, bool descending = false);
	void       ToggleSortColumn(int ii);
	void       DoColumnSort();
	int        GetSortColumn() const                   { return sortcolumn; }
	bool       IsSortDescending() const                { return sortcolumndescending; }

	bool       IsInsert() const                        { return insertmode; }

	void            SetDisplay(int i, int col, const Display& d);
	const Display&  GetDisplay(int row, int col);
	const Display&  GetDisplay(int col);

	void       SetCtrl(int i, int col, Ctrl& ctrl, bool value = true);

	ArrayCtrl& SetLineCy(int cy);
	void       SetLineCy(int i, int cy);
	int        GetLineCy() const                       { return linecy; }
	int        GetLineY(int i) const;
	int        GetLineCy(int i) const;
	int        GetTotalCy() const;
	int        GetLineAt(int y) const;

	Point      GetClickPos() const                     { return clickpos; }
	int        GetClickColumn() const                  { return clickpos.x; }
	int        GetClickRow() const                     { return clickpos.y; }

	bool       StartEdit(int d = 0);
	int        GetEditColumn() const;
	bool       IsEdit() const                          { return editmode; }

	void       DoEdit();
	void       DoInsert(int cursor);
	void       DoInsertBefore();
	void       DoInsertAfter();
	void       DoAppend();
	bool       DoRemove();
	void       DoDuplicate();
	void       DoSelectAll();
	void       StdBar(Bar& menu);

	bool       IsEditing() const;
	bool       AcceptEnter();

	void       ClearCache();
	void       InvalidateCache(int i);

	void       ScrollUp()                              { sb.PrevLine(); }
	void       ScrollDown()                            { sb.NextLine(); }
	void       ScrollPageUp()                          { sb.PrevPage(); }
	void       ScrollPageDown()                        { sb.NextPage(); }
	void       ScrollEnd()                             { sb.End(); }
	void       ScrollBegin()                           { sb.Begin(); }

	String     RowFormat(const char *s);

	ArrayCtrl& RowName(const char *s)                  { row_name = s; return *this; }
	ArrayCtrl& AppendLine(bool b = true)               { appendline = b; return *this; }
	ArrayCtrl& NoAppendLine()                          { return AppendLine(false); }
	bool       IsAppendLine() const                    { return appendline; }
	ArrayCtrl& Inserting(bool b = true)                { inserting = b; return AppendLine(b); }
	ArrayCtrl& NoInserting()                           { return Inserting(false); }
	bool       IsInserting() const                     { return inserting; }
	ArrayCtrl& Removing(bool b = true)                 { removing = b; return *this; }
	ArrayCtrl& NoRemoving()                            { return Removing(false); }
	bool       IsRemoving() const                      { return removing; }
	ArrayCtrl& Appending(bool b = true)                { appending = b; return *this; }
	bool       IsAppending() const                     { return appending || autoappend; }
	ArrayCtrl& AutoAppending(bool b = true)            { autoappend = b; return *this; }
	bool       IsAutoAppending() const                 { return autoappend; }
	ArrayCtrl& BeforeAfterInserting(int q = 1)         { bains = 1; return *this; }
	ArrayCtrl& AfterBeforeInserting(int q = 2)         { bains = 2; return *this; }
	ArrayCtrl& Duplicating(bool b = true)              { duplicating = b; return *this; }
	ArrayCtrl& NoInsertAppend(bool b = true)           { noinsertappend = b; return *this; }
	bool       IsDuplicating() const                   { return duplicating; }
	ArrayCtrl& Moving(bool b = true)                   { moving = b; return *this; }
	bool       IsMoving() const                        { return moving; }
	ArrayCtrl& NoDuplicating()                         { return Duplicating(false); }
	ArrayCtrl& AskRemove(bool b = true)                { askremove = b; return *this; }
	ArrayCtrl& NoAskRemove()                           { return AskRemove(false); }
	bool       IsAskRemove() const                     { return askremove; }

	ArrayCtrl& Header(bool b = true)                   { header.Invisible(!b); return *this; }
	ArrayCtrl& NoHeader()                              { return Header(false); }
	ArrayCtrl& Track(bool b = true)                    { header.Track(b); return *this; }
	ArrayCtrl& NoTrack()                               { return Track(false); }
	ArrayCtrl& VertGrid(bool b = true)                 { vertgrid = b; Refresh(); return *this; }
	ArrayCtrl& NoVertGrid()                            { return VertGrid(false); }
	ArrayCtrl& HorzGrid(bool b = true)                 { horzgrid = b; Refresh(); return *this; }
	ArrayCtrl& NoHorzGrid()                            { return HorzGrid(false); }
	ArrayCtrl& Grid(bool b = true)                     { return VertGrid(b).HorzGrid(b); }
	ArrayCtrl& NoGrid()                                { return Grid(false); }
	ArrayCtrl& GridColor(Color c)                      { gridcolor = c; return *this; }
	ArrayCtrl& EvenRowColor(Color paper = Blend(SColorMark, SColorPaper, 220), Color ink = SColorText);
	ArrayCtrl& OddRowColor(Color paper = SColorInfo, Color ink = SColorText);
	ArrayCtrl& NoCursor(bool b = true)                 { nocursor = b; return *this; }
	ArrayCtrl& MouseMoveCursor(bool b = true)          { mousemove = b; return *this; }
	ArrayCtrl& NoMouseMoveCursor()                     { return MouseMoveCursor(false); }
	ArrayCtrl& AutoHideSb(bool b = true)               { sb.AutoHide(b); return *this; }
	ArrayCtrl& NoAutoHideSb()                          { return AutoHideSb(false); }
	ArrayCtrl& HideSb(bool b = true)                   { sb.Show(!b); return *this; }
	ArrayCtrl& MultiSelect(bool b = true)              { multiselect = b; return *this; }
	bool       IsMultiSelect(bool b = true)            { return multiselect = b; }
	ArrayCtrl& NoBackground(bool b = true)             { nobg = b; Transparent(); Refresh(); return *this; }
	ArrayCtrl& PopUpEx(bool b = true)                  { popupex = b; return *this; }
	ArrayCtrl& NoPopUpEx()                             { return PopUpEx(false); }
	ArrayCtrl& NoFocusSetCursor()                      { focussetcursor = false; return *this; }
	ArrayCtrl& MovingHeader(bool b)                    { header.Moving(b); return *this; }
	ArrayCtrl& NoMovingHeader()                        { return MovingHeader(false); }
	ArrayCtrl& AllSorting();

	ArrayCtrl& ColumnWidths(const char *s);

	ArrayCtrl& SetScrollBarStyle(const ScrollBar::Style& s)   { sb.SetStyle(s); header.SetScrollBarStyle(s); return *this; }
	ArrayCtrl& SetHeaderCtrlStyle(const HeaderCtrl::Style& s) { header.SetStyle(s); return *this; }


	void Reset();

	typedef ArrayCtrl CLASSNAME;

	ArrayCtrl();
	virtual ~ArrayCtrl();
};

class ArrayOption : public Display, public Pte<ArrayOption> {
public:
	typedef ArrayOption CLASSNAME;
	ArrayOption();
	virtual ~ArrayOption();

	virtual void       Paint(Draw& w, const Rect& r, const Value& q, Color ink, Color paper, dword style) const;

	void               Connect(ArrayCtrl& ac, int ii = 0);
	void               Connect(ArrayCtrl& ac, Id id)               { Connect(ac, ac.GetPos(id)); }

	void               Disconnect();

	ArrayCtrl::Column& AddColumn(ArrayCtrl& ac, const char *text = 0, int w = 0);
	ArrayCtrl::Column& AddColumn(ArrayCtrl& ac, Id id, const char *text, int w = 0);

	ArrayOption&       TrueFalse(Value _t, Value _f)               { t = _t; f = _f; return *this; }
	Value              GetFalse() const                            { return f; }
	Value              GetTrue() const                             { return t; }
	ArrayOption&       ThreeState(bool b = true)                   { threestate = b; return *this; }
	ArrayOption&       NoThreeState()                              { return ThreeState(false); }
	bool               IsThreeState() const                        { return threestate; }

	ArrayOption&       HSwitch(bool hs = true)                     { hswitch = hs; return *this; }
	ArrayOption&       NoHSwitch()                                 { return HSwitch(false); }
	bool               IsHSwitch() const                           { return hswitch; }

	ArrayOption&       VSwitch(bool vs = true)                     { vswitch = vs; return *this; }
	ArrayOption&       NoVSwitch()                                 { return VSwitch(false); }
	bool               IsVSwitch() const                           { return vswitch; }

	ArrayOption&       Frame(bool frm = true)                      { frame = frm; return *this; }
	ArrayOption&       NoFrame()                                   { return Frame(false); }
	bool               IsFrame() const                             { return frame; }

	void               Click();

public:
	Callback           WhenAction;

	Callback           operator <<= (Callback cb)                  { return WhenAction = cb; }

private:
	Vector<int>        index;
	ArrayCtrl         *array;
	Value              t, f;
	bool               hswitch, vswitch;
	bool               threestate;
	bool               frame;
};
#line 36 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/DropChoice.h"
void DropEdge_Write(Value);

class PopUpTable : public ArrayCtrl {
public:
	virtual void Deactivate();
	virtual void LeftUp(Point p, dword keyflags);
	virtual bool Key(dword key, int);
	virtual void CancelMode();

protected:
	int          droplines;
	bool         open;

	void         DoClose();

public:
	void         PopUp(Ctrl *owner, int x, int top, int bottom, int width);
	void         PopUp(Ctrl *owner, int width);
	void         PopUp(Ctrl *owner);

	Callback     WhenCancel;
	Callback     WhenSelect;

	PopUpTable&  SetDropLines(int _droplines)          { droplines = _droplines; return *this; }

	void         Normal();

	PopUpTable();
	virtual ~PopUpTable();
};

class DropList : public MultiButton, public Convert {
public:
	virtual void  MouseWheel(Point p, int zdelta, dword keyflags);
	virtual bool  Key(dword key, int);
	virtual void  SetData(const Value& data);
	virtual Value GetData() const;

	virtual Value Format(const Value& q) const;

private:
	PopUpTable         list;
	Index<Value>       key;
	Value              value;
	const Convert     *valueconvert;
	const Display     *valuedisplay;
	bool               displayall;
	bool               dropfocus;
	bool               notnull;
	bool               alwaysdrop;

	void          Select();
	void          Cancel();
	void          Change(int q);
	void          EnableDrop(bool b = true)         { MainButton().Enable(b || alwaysdrop); }
	void          Sync();

	typedef       DropList CLASSNAME;

public:
	typedef MultiButton::Style Style;

	Callback      WhenDrop;

	DropList&     Add(const Value& key, const Value& value);
	DropList&     Add(const Value& value)         { return Add(value, value); }
	void          Remove(int i);
	void          ClearList();
	void          Clear();

	DropList&     AddSeparator();

	void          Drop();

	const Value& operator=(const Value& v)        { SetData(v); return v; }
	operator Value() const                        { return GetData(); }

	void          SetIndex(int i)                 { SetData(GetKey(i)); }
	int           GetIndex() const                { return FindKey(value); }
	void          GoBegin()                       { if(GetCount()) SetIndex(0); }
	void          GoEnd()                         { if(GetCount()) SetIndex(GetCount() - 1); }

	bool          HasKey(const Value& k) const    { return key.Find(k) >= 0; }
	int           FindKey(const Value& k) const   { return key.Find(k); }
	int           Find(const Value& k) const      { return key.Find(k); }
	int           FindValue(const Value& v) const { return list.Find(v); }

	int           GetCount() const                { return key.GetCount(); }
	void          Trim(int n);
	const Value&  GetKey(int i) const             { return key[i]; }

	Value         GetValue(int i) const           { return list.Get(i, 0); }
	Value         GetValue() const;
	void          SetValue(int i, const Value& v);
	void          SetValue(const Value& v);
	Value         operator[](int i) const         { return GetValue(i); }

	void          Adjust();
	void          Adjust(const Value& k);

	const PopUpTable& GetList() const                   { return list; }
	PopUpTable&   ListObject()                          { return list; }

	DropList&     SetDropLines(int d)                   { list.SetDropLines(d); return *this; }
	DropList&     SetConvert(const Convert& cv);
	DropList&     SetDisplay(int i, const Display& d);
	DropList&     SetDisplay(const Display& d);
	DropList&     SetLineCy(int lcy)                    { list.SetLineCy(lcy); return *this; }
	DropList&     SetDisplay(const Display& d, int lcy);
	DropList&     ValueDisplay(const Display& d);
	DropList&     DisplayAll(bool b = true)             { displayall = b; return *this; }
	DropList&     DropFocus(bool b = true)              { dropfocus = b; return *this; }
	DropList&     NoDropFocus()                         { return DropFocus(false); }
	DropList&     AlwaysDrop(bool e = true);
	DropList&     SetStyle(const Style& s)              { MultiButton::SetStyle(s); return *this; }
	DropList&     NotNull(bool b = true)                { notnull = b; return *this; }

	DropList&     SetScrollBarStyle(const ScrollBar::Style& s) { list.SetScrollBarStyle(s); return *this; }

	DropList();
	virtual ~DropList();
};

void Add(DropList& list, const VectorMap<Value, Value>& values);
void Add(MapConvert& convert, const VectorMap<Value, Value>& values);
void Add(DropList& list, const MapConvert& convert);

class DropChoice : public MultiButtonFrame {
protected:
	PopUpTable         list;
	Ctrl              *owner;
	bool               appending;
	bool               dropfocus;
	bool               always_drop;

	void        Select();
	void        Drop();
	void        EnableDrop(bool b);
	void        PseudoPush();

	typedef DropChoice CLASSNAME;

public:
	Callback    WhenDrop;
	Callback    WhenSelect;

	bool        DoKey(dword key);

	void        Clear();
	void        Add(const Value& data);
	void        Serialize(Stream& s);

	int         GetCount() const                      { return list.GetCount(); }
	Value       Get(int i) const                      { return list.Get(i, 0); }

	void        AddHistory(const Value& data, int max = 12);

	void        AddTo(Ctrl& _owner)                   { MultiButtonFrame::AddTo(_owner); owner = &_owner; }
	bool        IsActive() const                      { return IsOpen(); }




	Value       Get() const;
	int         GetIndex() const;

	DropChoice& SetDisplay(int i, const Display& d)   { list.SetDisplay(i, 0, d); return *this; }
	DropChoice& SetDisplay(const Display& d)          { list.ColumnAt(0).SetDisplay(d); return *this; }
	DropChoice& SetLineCy(int lcy)                    { list.SetLineCy(lcy); return *this; }
	DropChoice& SetDisplay(const Display& d, int lcy) { SetDisplay(d); SetLineCy(lcy); return *this; }
	DropChoice& SetDropLines(int n)                   { list.SetDropLines(n); return *this; }
	DropChoice& Appending()                           { appending = true; return *this; }
	DropChoice& AlwaysDrop(bool e = true);
	DropChoice& NoDropFocus()                         { dropfocus = false; return *this; }

	DropChoice& SetScrollBarStyle(const ScrollBar::Style& s) { list.SetScrollBarStyle(s); return *this; }

	DropChoice();

	static bool DataSelect(Ctrl& owner, DropChoice& drop, const String& appends);
};

template <class T>
class WithDropChoice : public T {
public:
	virtual bool   Key(dword key, int repcnt);
	virtual void   MouseEnter(Point p, dword keyflags);
	virtual void   MouseLeave();
	virtual void   GotFocus();
	virtual void   LostFocus();


protected:
	DropChoice      select;
	String          appends;

	void            DoWhenSelect();
	void            DoWhenDrop()                          { WhenDrop(); }

public:
	Callback        WhenDrop;
	Callback        WhenSelect;

	void            ClearList()                           { select.Clear(); }
	void            AddList(const Value& data)            { select.Add(data); }
	void            SerializeList(Stream& s)              { select.Serialize(s); }

	int             GetCount() const                      { return select.GetCount(); }
	Value           Get(int i) const                      { return select.Get(i); }

	void            AddHistory(int max = 12)              { select.AddHistory(this->GetData(), max); }

	MultiButton::SubButton& AddButton()                   { return select.AddButton(); }
	int                     GetButtonCount() const        { return select.GetButtonCount(); }
	MultiButton::SubButton& GetButton(int i)              { return select.GetButton(i); }
	Rect                    GetPushScreenRect() const     { return select.GetPushScreenRect(); }

	const MultiButton::Style& StyleDefault()              { return select.StyleFrame(); }
	WithDropChoice& SetStyle(const MultiButton::Style& s) { select.SetStyle(s); return *this; }

	WithDropChoice& Dropping(bool b = true)               { select.Show(b); return *this; }
	WithDropChoice& NoDropping()                          { return Dropping(false); }
	WithDropChoice& NoDropFocus()                         { select.NoDropFocus(); return *this; }
	WithDropChoice& Appending(const String& s = ", ")     { appends = s; select.Appending(); return *this; }
	WithDropChoice& SetDropLines(int n)                   { select.SetDropLines(n); return *this; }
	WithDropChoice& SetDisplay(int i, const Display& d)   { select.SetDisplay(i, d); return *this; }
	WithDropChoice& SetDisplay(const Display& d)          { select.SetDisplay(d); return *this; }
	WithDropChoice& SetLineCy(int lcy)                    { select.SetLineCy(lcy); return *this; }
	WithDropChoice& SetDisplay(const Display& d, int lcy) { select.SetDisplay(d, lcy); return *this; }
	WithDropChoice& AlwaysDrop(bool b = true)             { select.AlwaysDrop(b); return *this; }

	WithDropChoice();
};

template <class T>
WithDropChoice<T>::WithDropChoice() {
	select.AddTo(*this);
	select.WhenDrop = callback(this, &WithDropChoice::DoWhenDrop);
	select.WhenSelect = callback(this, &WithDropChoice::DoWhenSelect);
	appends = String::GetVoid();
	SetStyle(StyleDefault());
}

template <class T>
bool WithDropChoice<T>::Key(dword key, int repcnt) {
	return select.DoKey(key) || T::Key(key, repcnt);
}

template <class T>
void WithDropChoice<T>::MouseEnter(Point p, dword keyflags)
{
	select.Refresh();
	T::MouseEnter(p, keyflags);
}

template <class T>
void WithDropChoice<T>::MouseLeave()
{
	select.Refresh();
	T::MouseLeave();
}

template <class T>
void WithDropChoice<T>::GotFocus()
{
	select.Refresh();
	T::GotFocus();
}

template <class T>
void WithDropChoice<T>::LostFocus()
{
	select.Refresh();
	T::LostFocus();
}

template <class T>
void WithDropChoice<T>::DoWhenSelect() {
	if(DropChoice::DataSelect(*this, select, appends)) {
		this->SetFocus();
		WhenSelect();
	}
}
#line 37 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/TreeCtrl.h"
class TreeCtrl : public Ctrl {
public:
	virtual void  CancelMode();
	virtual void  Paint(Draw& w);
	virtual void  Layout();
	virtual void  LeftDown(Point p, dword flags);
	virtual void  LeftUp(Point p, dword flags);
	virtual void  LeftDouble(Point p, dword flags);
	virtual void  LeftDrag(Point p, dword keyflags);
	virtual void  RightDown(Point p, dword flags);
	virtual void  MouseWheel(Point p, int zdelta, dword keyflags);
	virtual void  MouseMove(Point, dword);
	virtual bool  Key(dword key, int);
	virtual void  GotFocus();
	virtual void  LostFocus();
	virtual void  ChildGotFocus();
	virtual void  ChildRemoved(Ctrl *);
	virtual void  SetData(const Value& data);
	virtual Value GetData() const;
	virtual void  DragEnter();
	virtual void  DragAndDrop(Point p, PasteClip& d);
	virtual void  DragRepeat(Point p);
	virtual void  DragLeave();

public:
	class Node
	{
		void           Init() { display = 0; size = Null; margin = 2; canopen = false; canselect = true; }

	public:
		Image          image;
		int            margin;
		Value          key;
		Value          value;
		const Display *display;
		Size           size;
		Ptr<Ctrl>      ctrl;
		bool           canopen;
		bool           canselect;

		Node& SetImage(const Image& img)          { image = img; return *this; }
		Node& Set(const Value& v)                 { key = value = v; return *this; }
		Node& Set(const Value& v, const Value& t) { key = v; value = t; return *this; }
		Node& SetDisplay(const Display& d)        { display = &d; return *this; }
		Node& SetSize(Size sz)                    { size = sz; return *this; }
		Node& SetCtrl(Ctrl& _ctrl)                { ctrl = &_ctrl; return *this; }
		Node& CanOpen(bool b = true)              { canopen = b; return *this; }
		Node& CanSelect(bool b)                   { canselect = b; return *this; }

		Node();
		Node(const Image& img, const Value& v);
		Node(const Image& img, const Value& v, const Value& t);
		Node(const Value& v);
		Node(const Value& v, const Value& t);
		Node(Ctrl& ctrl);
		Node(const Image& img, Ctrl& ctrl, int cx = 0, int cy = 0);
	};

private:
	struct Item : Node {
		union {
			int            parent;
			int            freelink;
		};

		bool           free;
		bool           isopen;
		bool           sel;
		Vector<int>    child;
		int            linei;

		Size GetValueSize() const;
		Size GetCtrlSize() const;
		Size GetSize() const;

		Item() { isopen = false; linei = -1; parent = -1; canselect = true; sel = false; free = false; }
	};
	struct Line : Moveable<Line> {
		int  level;
		int  itemi;
		int  ll;
		int  y;
	};

	Array<Item>  item;
	Vector<Line> line;
	int          cursor;
	int          freelist;
	int          levelcx;
	int          anchor;
	int          selectcount;
	bool         nocursor;
	bool         noroot;
	bool         dirty;
	bool         hasctrls;
	bool         multiselect;
	bool         nobg;
	bool         popupex;
	bool         chldlck;
	bool         mousemove;
	bool         accel;

	bool         selclick;
	int          dropitem, dropinsert;
	Point        repoint;
	int          retime;
	Size         treesize;

	ScrollBars   sb;
	Scroller     scroller;
	Display     *display;

	DisplayPopup info;

	struct LineLess {
		bool   operator()(int y, const Line& l) const            { return y < l.y; }
	};

	struct SortOrder;

	const Display *GetStyle(int i, Color& fg, Color& bg, dword& st);
	void   Dirty(int id = 0);
	void   ReLine(int, int, Size&);
	void   RemoveSubtree(int id);
	void   Scroll();
	int    FindLine(int y) const;
	void   RefreshLine(int i, int ex = 0);
	void   RefreshItem(int id, int ex = 0);
	void   SetCursorLineSync(int i);
	void   MoveCursorLine(int c, int incr);
	void   SetCursorLine(int i, bool sc, bool sel, bool cb);
	void   SetCursor(int id, bool sc, bool sel, bool cb);
	void   RemoveCtrls(int itemi);
	void   SyncCtrls(bool add, Ctrl *restorefocus);
	bool   Tab(int d);
	void   Sort0(int id, const ValueOrder& order, bool byvalue);
	void   SortDeep0(int id, const ValueOrder& order, bool byvalue);
	void   GatherOpened(int id, Vector<int>& o);
	void   SelClear(int id);
	void   UpdateSelect();
	void   ShiftSelect(int l1, int l2);
	void   SelectOne0(int id, bool sel, bool cb = false);
	void   DnD(int itemid, int insert);
	bool   DnDInserti(int ii, PasteClip& d, bool bottom);
	bool   DnDInsert(int ii, int py, int q, PasteClip& d);
	void   RefreshSel();
	void   GatherSel(int id, Vector<int>& sel) const;
	void   DoClick(Point p, dword flags, bool down);
	void   SyncInfo();

protected:
	virtual void SetOption(int id);
	void         SyncTree();

public:
	Callback1<int>  WhenOpen;
	Callback1<int>  WhenClose;
	Callback        WhenLeftDouble;
	Callback1<Bar&> WhenBar;
	Callback        WhenSel;

	Callback                        WhenDrag;
	Callback2<int, PasteClip&>      WhenDropItem;
	Callback3<int, int, PasteClip&> WhenDropInsert;
	Callback1<PasteClip&>           WhenDrop;


	Callback        WhenCursor;
	Callback        WhenSelection;

	void   SetRoot(const Node& n);
	void   SetRoot(const Image& img, Value v);
	void   SetRoot(const Image& img, Value v, Value t);
	void   SetRoot(const Image& img, Ctrl& ctrl, int cx = 0, int cy = 0);
	int    Insert(int parentid, int i, const Node& n);
	int    Insert(int parentid, int i);
	int    Insert(int parentid, int i, const Image& img, Value value, bool withopen = false);
	int    Insert(int parentid, int i, const Image& img, Value key, Value value, bool withopen = false);
	int    Insert(int parentid, int i, const Image& img, Ctrl& c, int cx = 0, int cy = 0, bool wo = false);
	int    Add(int parentid, const Node& n);
	int    Add(int parentid);
	int    Add(int parentid, const Image& img, Value value, bool withopen = false);
	int    Add(int parentid, const Image& img, Value key, Value value, bool withopen = false);
	int    Add(int parentid, const Image& img, Ctrl& ctrl, int cx = 0, int cy = 0, bool withopen = false);
	void   Remove(int id);
	void   RemoveChildren(int id);

	void   Swap(int id1, int id2);
	void   SwapChildren(int parentid, int i1, int i2);

	int    GetChildCount(int id) const                         { return item[id].child.GetCount(); }
	int    GetChild(int id, int i) const                       { return item[id].child[i]; }
	int    GetChildIndex(int id, int childid) const;
	int    GetParent(int id) const                             { return item[id].parent; }

	Value  Get(int id) const;
	Value  GetValue(int id) const;
	Value  operator[](int id) const                            { return Get(id); }
	void   Set(int id, Value value);
	void   Set(int id, Value key, Value value);

	int    GetLineCount();
	int    GetItemAtLine(int i);
	int    GetLineAtItem(int id);

	Node   GetNode(int id) const                               { return item[id]; }
	void   SetNode(int id, const Node& n);

	bool   IsOpen(int id) const;
	void   Open(int id, bool open = true);
	void   Close(int id)                                       { Open(id, false); }

	void   OpenDeep(int id, bool open = true);
	void   CloseDeep(int id)                                   { OpenDeep(id, false); }

	void   MakeVisible(int id);

	void   SetCursorLine(int i);
	int    GetCursorLine() const                               { return cursor; }
	void   KillCursor();
	void   SetCursor(int id);
	int    GetCursor() const;
	bool   IsCursor() const                                    { return GetCursor() >= 0; }

	Point  GetScroll() const;
	void   ScrollTo(Point sc);

	Value  Get() const;
	Value  GetValue() const;

	int    Find(Value key);
	bool   FindSetCursor(Value key);

	void   Sort(int id, const ValueOrder& order, bool byvalue = false);
	void   SortDeep(int id, const ValueOrder& order, bool byvalue = false);

	void   Sort(int id, int (*compare)(const Value& v1, const Value& v2) = StdValueCompare,
	            bool byvalue = false);
	void   SortDeep(int id, int (*compare)(const Value& v1, const Value& v2) = StdValueCompare,
	                bool byvalue = false);

	void   SortByValue(int id, const ValueOrder& order);
	void   SortDeepByValue(int id, const ValueOrder& order);

	void   SortByValue(int id, int (*compare)(const Value& v1, const Value& v2) = StdValueCompare);
	void   SortDeepByValue(int id, int (*compare)(const Value& v1, const Value& v2) = StdValueCompare);

	void   Clear();

	void         ClearSelection();
	void         SelectOne(int id, bool sel = true);
	bool         IsSelected(int id) const       { return item[id].sel; }
	bool         IsSel(int id) const;
	int          GetSelectCount() const         { return selectcount; }
	bool         IsSelDeep(int id) const;
	Vector<int>  GetSel() const;
	void         Remove(const Vector<int>& id);
	void         RemoveSelection()              { Remove(GetSel()); }

	void         AdjustAction(int parent, PasteClip& x);
	void         InsertDrop(int parent, int ii, const TreeCtrl& src, PasteClip& x);
	void         InsertDrop(int parent, int ii, PasteClip& d);
	Image        GetDragSample();

	void         StdLeftDouble();

	void         ScrollIntoLine(int i);
	void         CenterLine(int i);

	void         ScrollIntoCursor();
	void         CenterCursor();

	Size         GetTreeSize() const         { return treesize; }

	void   Dump();

	TreeCtrl& NoCursor(bool b = true)        { nocursor = b; if(b) KillCursor(); return *this; }
	TreeCtrl& NoRoot(bool b = true)          { noroot = b; Dirty(); Refresh(); return *this; }
	TreeCtrl& LevelCx(int cx)                { levelcx = cx; Dirty(); return *this; }
	TreeCtrl& MultiSelect(bool b = true)     { multiselect = b; return *this; }
	TreeCtrl& NoBackground(bool b = true)    { nobg = b; Transparent(); Refresh(); return *this; }
	TreeCtrl& PopUpEx(bool b = true)         { popupex = b; return *this; }
	TreeCtrl& NoPopUpEx()                    { return PopUpEx(false); }
	TreeCtrl& MouseMoveCursor(bool m = true) { mousemove = m; return *this; }
	TreeCtrl& Accel(bool a = true)           { accel = a; return *this; }

	TreeCtrl& SetScrollBarStyle(const ScrollBar::Style& s) { sb.SetStyle(s); return *this; }

	typedef TreeCtrl CLASSNAME;

	TreeCtrl();
	~TreeCtrl();
};

int Copy(TreeCtrl& dst, int dstid, int i, const TreeCtrl& src, int srcid);

class OptionTree : public TreeCtrl {
	Vector<Option *> option;
	Array<Option>    aux;

	void SetOption(int i);
	void SetChildren(int id, bool b);

public:
	Callback WhenOption;

	void SetRoot(const Image& img, Option& option, const char *text = 0);
	void SetRoot(Option& option, const char *text = 0);
	void SetRoot(const Image& img, const char *text);
	void SetRoot(const char *text);
	int  Insert(int parent, int i, const Image& img, Option& option, const char *text = 0);
	int  Insert(int parent, int i, Option& option, const char *text = 0);
	int  Insert(int parent, int i, const Image& img, const char *text);
	int  Insert(int parent, int i, const char *text);
	int  Add(int parent, const Image& img, Option& option, const char *text = 0);
	int  Add(int parent, Option& option, const char *text = 0);
	int  Add(int parent, const Image& img, const char *text);
	int  Add(int parent, const char *text);

	int  Get(int id) const                          { return option[id]->Get(); }

	void Clear();

	typedef OptionTree CLASSNAME;

	OptionTree();
	~OptionTree();
};

class PopUpTree : public TreeCtrl {
public:
	typedef PopUpTree CLASSNAME;
	PopUpTree();
	virtual ~PopUpTree();

	void         PopUp(Ctrl *owner, int x, int top, int bottom, int width);
	void         PopUp(Ctrl *owner, int width);
	void         PopUp(Ctrl *owner);

	Callback     WhenCancel;
	Callback     WhenSelect;

	PopUpTree&   MaxHeight(int maxheight_)          { maxheight = maxheight_; return *this; }
	int          GetMaxHeight() const               { return maxheight; }

public:
	virtual void Deactivate();
	virtual void LeftUp(Point p, dword keyflags);
	virtual bool Key(dword key, int);
	virtual void CancelMode();

protected:
	void         DoClose();
	void         OpenClose(int i);

protected:
	int          maxheight;
	Point        showpos;
	int          showwidth;
	bool         up;
	bool         open;
};
#line 38 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/Splitter.h"
class Splitter : public Ctrl {
public:
	virtual void   Layout();
	virtual void   Paint(Draw& draw);
	virtual void   MouseMove(Point p, dword keyflags);
	virtual void   LeftDown(Point p, dword keyflags);
	virtual void   LeftUp(Point p, dword keyflags);
	virtual Image  CursorImage(Point p, dword keyflags);
	virtual void   Serialize(Stream& s);

protected:
	Vector<int> pos;
	Vector<int> mins;
	Vector<int> minpx;
	int         width;
	int         style;
	int         mouseindex;
	bool        vert;
	int         inset;

	int       ClientToPos(Point client) const;
	int       PosToClient(int pos) const;
	int       FindIndex(Point client) const;
	int       GetChildCount() const;
	int       GetMins(int i) const;

public:
	void      Set(Ctrl& l, Ctrl& r);

	Splitter& SetPos(int newpos, int index = 0);
	int       GetPos(int index = 0) const          { return index < pos.GetCount() ? pos[index] : 10000; }

	int       GetCount() const                     { return GetChildCount(); }

	void      Zoom(int i);
	void      NoZoom()                             { Zoom(-1); }
	int       GetZoom() const                      { return style; }

	void      SetMin(int i, int w)                 { mins.At(i, 0) = w; }
	void      SetMinPixels(int i, int w)           { minpx.At(i, 0) = w; }

	void      Add(Ctrl& pane);
	Splitter& operator<<(Ctrl& pane)               { Add(pane); return *this; }

	Splitter& Vert(Ctrl& top, Ctrl& bottom);
	Splitter& Horz(Ctrl& left, Ctrl& right);
	Splitter& Vert()                               { vert = true; Layout(); return *this; }
	Splitter& Horz()                               { vert = false; Layout(); return *this; }
	Splitter& BarWidth(int w);
	bool      IsHorz() const                       { return !vert; }
	bool      IsVert() const                       { return vert; }

	void      Clear();
	void      Reset();

	Splitter();
	virtual ~Splitter();
};

class SplitterFrame : public CtrlFrame, private Ctrl {
public:
	virtual void FrameAdd(Ctrl& parent);
	virtual void FrameRemove();
	virtual void FrameAddSize(Size& sz);
	virtual void FrameLayout(Rect& r);

	virtual void Paint(Draw& draw);
	virtual void LeftDown(Point p, dword keyflags);
	virtual void MouseMove(Point p, dword keyflags);
	virtual void LeftUp(Point p, dword keyflags);
	virtual Image CursorImage(Point p, dword keyflags);

private:
	Point ref;
	Size  parentsize;
	int   type, minsize, sizemin;
	int   size, size0;

	int   BoundSize();

public:
	enum { LEFT, TOP, RIGHT, BOTTOM };

	void Serialize(Stream& s);

	SplitterFrame& Set(Ctrl& c, int size, int type);
	SplitterFrame& Left(Ctrl& c, int size)    { return Set(c, size, LEFT); }
	SplitterFrame& Top(Ctrl& c, int size)     { return Set(c, size, TOP); }
	SplitterFrame& Right(Ctrl& c, int size)   { return Set(c, size, RIGHT); }
	SplitterFrame& Bottom(Ctrl& c, int size)  { return Set(c, size, BOTTOM); }

	SplitterFrame& MinSize(int sz)            { minsize = sz; return *this; }
	SplitterFrame& SizeMin(int sz)            { sizemin = sz; return *this; }

	int  GetType() const                      { return type; }
	int  GetSize() const                      { return size; }
	void SetSize(int sz)                      { size = sz; RefreshParentLayout(); }

	void Show(bool show = true)				  { Ctrl::Show(show); }
	void Hide()								  { Ctrl::Hide(); }
	bool IsShown()							  { return Ctrl::IsShown(); }

	SplitterFrame();
};
#line 39 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/RichText.h"
class RichTextView : public Ctrl {
public:
	virtual void  Paint(Draw& w);
	virtual bool  Key(dword key, int count);
	virtual void  Layout();
	virtual Value GetData() const;
	virtual void  SetData(const Value& v);
	virtual void  MouseWheel(Point p, int zdelta, dword keyflags);
	virtual Image CursorImage(Point p, dword keyflags);
	virtual void  LeftDown(Point p, dword keyflags);
	virtual void  MouseMove(Point p, dword keyflags);
	virtual void  LeftRepeat(Point p, dword keyflags);
	virtual void  RightDown(Point p, dword keyflags);

private:
	Rect          margin;
	Color         background;
	Zoom          zoom;
	int           cx;
	ScrollBar     sb;
	Scroller      scroller;
	RichText      text;
	bool          sizetracking;
	bool          vcenter;
	bool          hldec;
	int           highlight;
	int           sell, selh;
	int           cursor, anchor;

	void          EndSizeTracking();
	void          SetSb();
	void          Scroll();
	Zoom          GetZoom() const;
	int           GetPageCx(bool reduced = false) const;
	int           GetPointPos(Point p) const;
	String        GetLink(int pos, Point p) const;
	Rect          GetPage() const;
	void          RefreshSel();
	void          RefreshRange(int a, int b);

protected:
	enum {
		TIMEID_ENDSIZETRACKING = Ctrl::TIMEID_COUNT,
		TIMEID_COUNT
	};

public:
	Callback1<const String&> WhenLink;

	void            Clear();
	void            Pick( RichText& t);
	void            Pick( RichText& txt, Zoom z);
	void            SetQTF(const char *qtf, Zoom z = Zoom(1, 1), bool scolors = false);
	const RichText& Get() const                               { return text; }
	String          GetQTF(byte cs = 255) const      { return AsQTF(text, cs); }

	int             GetWidth() const                          { return text.GetWidth(); }
	int             GetHeight(int cx) const                   { return text.GetHeight(Zoom(1, 1), cx); }

	int             GetSb() const                             { return sb; }
	void            SetSb(int i)                              { sb = i; }
	int             GetSbTotal() const                        { return sb.GetTotal(); }

	void            GotoLabel(const String& lbl, bool highlight = false);
	void            ClearHighlight()                          { highlight = Null; Refresh(); }

	int             GetLength() const                         { return text.GetLength(); }

	void            Copy();

	void            ScrollUp()                                { sb.PrevLine(); }
	void            ScrollDown()                              { sb.NextLine(); }
	void            ScrollPageUp()                            { sb.PrevPage(); }
	void            ScrollPageDown()                          { sb.NextPage(); }
	void            ScrollEnd()                               { sb.End(); }
	void            ScrollBegin()                             { sb.Begin(); }

	RichTextView&   PageWidth(int cx);
	RichTextView&   SetZoom(Zoom z);
	RichTextView&   Background(Color _color);
	RichTextView&   VCenter(bool b = true);
	RichTextView&   NoVCenter()                               { return VCenter(false); }
	RichTextView&   Margins(const Rect& m);
	RichTextView&   HMargins(int a);
	RichTextView&   VMargins(int a);
	RichTextView&   Margins(int a);
	RichTextView&   NoSb(bool b = true)                       { sb.Hide(); return *this; }
	RichTextView&   AutoHideSb(bool b = true)                 { sb.AutoHide(b); return *this; }
	RichTextView&   HyperlinkDecoration(bool b = true)        { hldec = b; Refresh(); return *this; }
	RichTextView&   NoHyperlinkDecoration()                   { return HyperlinkDecoration(false); }

	void            operator=(const char *qtf)                { SetQTF(qtf); }

	RichTextView&   SetScrollBarStyle(const ScrollBar::Style& s) { sb.SetStyle(s); return *this; }

	typedef RichTextView CLASSNAME;

	RichTextView();
	virtual ~RichTextView();
};

class RichTextCtrl : public RichTextView {
public:
	virtual void  SetData(const Value& v);

public:
	void            SetQTF(const char *qtf, Zoom z = GetRichTextStdScreenZoom()) { RichTextView::SetQTF(qtf, z, true); }
	void            operator=(const char *qtf)                                   { SetQTF(qtf); }
	RichTextCtrl();
};

int Prompt(Callback1<const String&> WhenLink,
           const char *title, const Image& icon, const char *qtf, bool okcancel,
           const char *button1, const char *button2 = 0, const char *button3 = 0,
		   int cx = 0);
int Prompt(const char *title, const Image& icon, const char *qtf, bool okcancel,
           const char *button1, const char *button2 = 0, const char *button3 = 0,
		   int cx = 0);
int Prompt(const char *title, const Image& icon, const char *qtf,
           const char *button1, const char *button2 = 0, const char *button3 = 0,
		   int cx = 0);

void PromptOK(const char *qtf);
int  PromptOKCancel(const char *qtf);
int  PromptYesNo(const char *qtf);
int  PromptYesNoCancel(const char *qtf);
int  PromptRetryCancel(const char *qtf);
int  PromptAbortRetry(const char *qtf);
int  PromptAbortRetryIgnore(const char *qtf);

void Exclamation(const char *qtf);

Image YesButtonImage();
Image NoButtonImage();
Image AbortButtonImage();
Image RetryButtonImage();

void YesButtonImage_Write(Image m);
void NoButtonImage_Write(Image m);
void AbortButtonImage_Write(Image m);
void RetryButtonImage_Write(Image m);

void ShowExc(const Exc& exc);

class HelpWindow : public TopWindow {
public:
	virtual bool Key(dword key, int);

private:
	RichTextView   view;
	TreeCtrl       tree;
	Splitter       tree_view;
	ToolBar        toolbar;
	Zoom           zoom;

	struct Pos : Moveable<Pos> {
		String link;
		int    scy;
	};

	Vector<Pos>    back;
	Vector<Pos>    forward;
	Index<String>  tree_ndx;
	String         topic;
	String         label;

	bool GoTo0(const String& link);
	void Back();
	void Forward();
	void FontSize();
	void Tools(Bar& bar);
	void TreeCursor();
	void SetZoom();
	void Print();
	Pos  GetPos();

public:
	virtual Topic AcquireTopic(const String& topic);
	virtual void  FinishText(RichText& text);
	virtual void  BarEx(Bar& bar);

	void GoTo(const String& link);

	void SetBar();
	void Serialize(Stream& s);

	void ClearTree();
	int  AddTree(int parent, const Image& img, const String& topic, const String& title);
	void SortTree(int id = 0);
	void FinishTree();
	void OpenDeep(int id = 0);

	String GetCurrent() const                     { return topic; }
	String GetCurrentLabel() const                { return label; }

	typedef HelpWindow CLASSNAME;

	HelpWindow();
};



void Print(Draw& w, const RichText& text, const Rect& page, const Vector<int>& pagelist);
void Print(Draw& w, const RichText& text, const Rect& page);
bool Print(const RichText& text, const Rect& page, int currentpage, const char *name = 0);

#line 208 "u:/uppsrc\\CtrlLib/RichText.h"
#line 40 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/TextEdit.h"
class TextCtrl : public Ctrl, protected TextArrayOps {
public:
	virtual void  SetData(const Value& v);
	virtual Value GetData() const;
	virtual void  CancelMode();
	virtual String GetSelectionData(const String& fmt) const;
	virtual void  MiddleDown(Point p, dword flags);

public:
	struct UndoRec {
		int    serial;
		int    pos;
		int    size;
		String text;
		bool   typing;
	};

	struct UndoData {
		int              undoserial;
		BiArray<UndoRec> undo;
		BiArray<UndoRec> redo;

		void Clear()                     { undo.Clear(); redo.Clear(); }
	};

	enum {
		INK_NORMAL,
		INK_DISABLED,
		INK_SELECTED,
		PAPER_NORMAL,
		PAPER_READONLY,
		PAPER_SELECTED,
		COLOR_COUNT,
	};

protected:
	virtual void   DirtyFrom(int line);
	virtual void   SelectionChanged();
	virtual void   ClearLines();
	virtual void   InsertLines(int line, int count);
	virtual void   RemoveLines(int line, int count);
	virtual void   PreInsert(int pos, const WString& text);
	virtual void   PostInsert(int pos, const WString& text);
	virtual void   PreRemove(int pos, int size);
	virtual void   PostRemove(int pos, int size);
	virtual void   SetSb();
	virtual void   PlaceCaret(int newcursor, bool sel = false);
	virtual void   InvalidateLine(int i);

	struct Ln : Moveable<Ln> {
		int    len;
		String text;

		int      GetLength() const       { return len; }
		operator WString() const         { return FromUtf8(text); }

		Ln(const WString& wtext)         { text = ToUtf8(wtext); len = wtext.GetLength(); }
		Ln()                             { len = 0; }
	};

	Vector<Ln>       line;
	int              total;
	int              cline, cpos;
	int              cursor, anchor;
	int              undoserial;
	bool             incundoserial;
	int              undosteps;
	BiArray<UndoRec> undo;
	BiArray<UndoRec> redo;
	int              dirty;
	int              undo_op;
	byte             charset;

	bool             selclick;
	Point            dropcaret;
	bool             isdrag;

	Color            color[COLOR_COUNT];

	bool             processtab;
	bool             nobg;

	void   IncDirty();
	void   DecDirty();
	int    Insert0(int pos, const WString& txt);
	void   Remove0(int pos, int size);
	int    InsertU(int pos, const WString& txt, bool typing = false);
	void   RemoveU(int pos, int size);
	void   Undodo();
	int    Insert(int pos, const WString& txt, bool typing);
	void   DoPaste() { Paste(); }
	void   DoRemoveSelection() { RemoveSelection(); }
	void   RefreshLines(int l1, int l2);

public:
	virtual void   RefreshLine(int i);

	Callback1<Bar&> WhenBar;
	Callback        WhenState;

	void   CachePos(int pos);

	void   Load(Stream& s, byte charset = 0);
	void   Save(Stream& s, byte charset = 0) const;

	int    GetInvalidCharPos(byte charset = 0) const;
	bool   CheckCharset(byte charset = 0) const { return GetInvalidCharPos(charset) < 0; }

	void    Set(const WString& s);
	void    Set(const String& s, byte charset = 0);
	String  Get(byte charset = 0) const;
	String  Get(int pos, int size, byte charset = 0) const;
	WString GetW(int pos, int size) const;
	WString GetW() const                      { return GetW(0, GetLength()); }

	void   ClearDirty();
	bool   IsDirty() const                    { return dirty; }

	void   Clear();

	int    GetLinePos(int& pos) const;
	int    GetPos(int line, int column) const;
	int    GetPos(int line) const             { return GetPos(line, 0); }
	int    GetLine(int pos) const             { return GetLinePos(pos); }

	const String& GetUtf8Line(int i) const    { return line[i].text; }
	WString       GetWLine(int i) const       { return FromUtf8(line[i].text); }
	String        GetEncodedLine(int i, byte charset = 0) const;
	int           GetLineLength(int i) const  { return line[i].GetLength(); }

	int    GetLineCount() const               { return line.GetCount(); }
	int    GetChar(int pos) const;
	int    operator[](int pos) const          { return GetChar(pos); }
	int    GetLength() const                  { return total; }

	int     GetCursor() const                 { return cursor; }
	int     GetCursorLine()                   { return GetLine(GetCursor()); }

	void    SetSelection(int anchor = 0, int cursor = 2147483647);
	bool    IsSelection() const               { return anchor >= 0; }
	bool    GetSelection(int& l, int& h) const;
	String  GetSelection(byte charset = 0) const;
	WString GetSelectionW() const;
	void    ClearSelection();
	bool    RemoveSelection();
	void    SetCursor(int cursor)             { PlaceCaret(cursor); }
	int     Paste(const WString& text);

	int     Insert(int pos, const WString& txt)  { return Insert(pos, txt, false); }
	int     Insert(int pos, const String& txt, byte charset = 0);
	int     Insert(int pos, const char *txt)     { return Insert(pos, WString(txt)); }
	void    Remove(int pos, int size);

	void      NextUndo();
	void      Undo();
	void      Redo();
	bool      IsUndo() const                  { return undo.GetCount(); }
	bool      IsRedo() const                  { return redo.GetCount(); }
	void      ClearUndo()                     { undo.Clear(); redo.Clear(); }
	bool      IsUndoOp() const                { return undo_op; }
	UndoData  PickUndoData();
	void      SetPickUndoData( UndoData& data);

	void      Cut();
	void      Copy();
	void      Paste();
	void      SelectAll();

	void      StdBar(Bar& menu);

	void      SetCharset(byte cs)              { charset = ResolveCharset(cs); }
	byte      GetCharset() const               { return charset; }

	void      SetColor(int i, Color c)         { color[i] = c; Refresh(); }
	Color     GetColor(int i) const            { return color[i]; }

	TextCtrl& UndoSteps(int n)                 { undosteps = n; Undodo(); return *this; }
	TextCtrl& ProcessTab(bool b = true)        { processtab = b; return *this; }
	TextCtrl& NoProcessTab()                   { return ProcessTab(false); }
	TextCtrl& NoBackground(bool b = true)      { nobg = b; Transparent(); Refresh(); return *this; }
	bool      IsProcessTab()                   { return processtab; }

	typedef TextCtrl CLASSNAME;

	TextCtrl();
	virtual ~TextCtrl();
};

class LineEdit : public TextCtrl {
public:
	virtual bool   Key(dword key, int count);
	virtual void   Paint(Draw& w);
	virtual void   LeftDown(Point p, dword flags);
	virtual void   RightDown(Point p, dword flags);
	virtual void   LeftRepeat(Point p, dword keyflags);
	virtual void   LeftDouble(Point p, dword keyflags);
	virtual void   LeftTriple(Point p, dword keyflags);
	virtual void   LeftUp(Point p, dword flags);
	virtual void   LeftDrag(Point p, dword flags);
	virtual void   MouseMove(Point p, dword flags);
	virtual void   MouseWheel(Point, int zdelta, dword);
	virtual Image  CursorImage(Point, dword);
	virtual void   DragAndDrop(Point p, PasteClip& d);
	virtual void   DragRepeat(Point p);
	virtual void   DragLeave();
	virtual void   Layout();
	virtual void   RefreshLine(int i);

protected:
	virtual void  SetSb();
	virtual void  PlaceCaret(int newcursor, bool sel = false);

public:
	struct Highlight : Moveable<Highlight> {
		Color paper;
		Color ink;
		Font  font;
		wchar chr;

		bool operator==(const Highlight& h) const
		     { return paper == h.paper && ink == h.ink && font == h.font; }
	};

	struct EditPos : Moveable<EditPos> {
		int sby;
		int cursor;

		void Serialize(Stream& s);
		void Clear()                      { sby = 0; cursor = 0; }
		EditPos()                         { Clear(); }
	};

protected:
	virtual void  HighlightLine(int line, Vector<Highlight>& h, int pos);
	virtual void  NewScrollPos();

	ScrollBars       sb;
	int              gcolumn;
	int              mpos;


	Font             font;
	CharFilter       filter;
	int              tabsize;
	int              bordercolumn;
	Color            bordercolor;
	bool             nohbar;
	bool             showtabs;
	bool             cutline;
	bool             overwrite;
	Scroller         scroller;
	Point            caretpos;

	void   Paint0(Draw& w);

	void   AlignChar();

	void   MovePage(int dir, bool sel);

	void   PlaceCaret0(Point p);
	int    PlaceCaretNoG(int newcursor, bool sel = false);

	void   Scroll();
	void   SetHBar();
	Rect   DropCaret();
	void   RefreshDropCaret();

	struct RefreshDraw;

public:
	Size   GetFontSize() const;
	int    GetGPos(int ln, int cl) const;
	int    GetMousePos(Point p) const;
	Point  GetColumnLine(int pos) const;
	int    GetColumnLinePos(Point pos) const  { return GetGPos(pos.y, pos.x); }
	Point  GetIndexLine(int pos) const;
	int    GetIndexLinePos(Point pos) const;

	void   ScrollUp()                         { sb.LineUp(); }
	void   ScrollDown()                       { sb.LineDown(); }

	Rect   GetLineScreenRect(int line) const;

	void   TopCursor();
	void   CenterCursor();

	void   MoveUpDown(int n, bool sel = false);

	void   MoveLeft(bool sel = false);
	void   MoveRight(bool sel = false);
	void   MoveUp(bool sel = false);
	void   MoveDown(bool sel = false);
	void   MovePageUp(bool sel = false);
	void   MovePageDown(bool sel = false);
	void   MoveHome(bool sel = false);
	void   MoveEnd(bool sel = false);
	void   MoveTextBegin(bool sel = false);
	void   MoveTextEnd(bool sel = false);

	bool   InsertChar(dword key, int count = 1, bool canoverwrite = false);
	void   DeleteChar();
	void   Backspace();
	void   DeleteLine();
	void   CutLine();

	Point   GetScrollPos() const              { return sb; }
	Size    GetPageSize()                     { return sb.GetPage(); }
	void    SetScrollPos(Point p)             { sb.Set(p); }

	EditPos GetEditPos() const;
	void    SetEditPos(const EditPos& pos);
	void    SetEditPosSb(const LineEdit::EditPos& pos);

	void    ScrollIntoCursor();

	Point   GetCaretPoint() const             { return caretpos; }

	void    Clear();

	void    OverWriteMode(bool o = true)      { overwrite = o; PlaceCaret(cursor, false); }
	bool    IsOverWriteMode() const           { return overwrite; }

	void    RefreshChars(bool (*predicate)(int c));

	LineEdit& TabSize(int n);
	int       GetTabSize() const              { return tabsize; }
	LineEdit& BorderColumn(int col, Color c = SColorFace());
	LineEdit& SetFont(Font f);
	Font      GetFont() const                 { return font; }
	LineEdit& NoHorzScrollbar(bool b = true)  { nohbar = b; ScrollIntoCursor(); return *this; }
	LineEdit& ShowTabs(bool st = true)        { showtabs = st; Refresh(); return *this; }
	bool      IsShowTabs() const              { return showtabs; }
	LineEdit& WithCutLine(bool b)             { cutline = b; return *this; }
	LineEdit& NoCutLine()                     { return WithCutLine(false); }
	LineEdit& SetFilter(int (*f)(int c))      { filter = f; return *this; }

	LineEdit& SetScrollBarStyle(const ScrollBar::Style& s)   { sb.SetStyle(s); return *this; }

	typedef LineEdit CLASSNAME;

	LineEdit();
	virtual ~LineEdit();
};

class DocEdit : public TextCtrl {
public:
	virtual void  Paint(Draw& w);
	virtual void  Layout();
	virtual bool  Key(dword key, int count);
	virtual void  LeftDown(Point p, dword flags);
	virtual void  LeftDouble(Point p, dword keyflags);
	virtual void  LeftTriple(Point p, dword keyflags);
	virtual void  LeftUp(Point p, dword flags);
	virtual void  RightDown(Point p, dword w);
	virtual void  MouseMove(Point p, dword flags);
	virtual void  MouseWheel(Point p, int zdelta, dword keyflags);
	virtual Image CursorImage(Point p, dword keyflags);
	virtual void  GotFocus();
	virtual void  LostFocus();
	virtual void  RefreshLine(int i);
	virtual void  SetSb();

	virtual void  DragAndDrop(Point p, PasteClip& d);
	virtual void  DragRepeat(Point p);
	virtual void  DragLeave();
	virtual void  LeftDrag(Point p, dword flags);

protected:
	virtual void  ClearLines();
	virtual void  InsertLines(int line, int count);
	virtual void  RemoveLines(int line, int count);
	virtual void  PlaceCaret(int pos, bool select = false);
	virtual void  InvalidateLine(int i);

	struct Para : Moveable<Para> {
		int    cx, cy;

		Para()         { cx = -1; }
	};

	Vector<Para> para;
	Font         font;
	int          after;
	CharFilter   filter;
	ScrollBar    sb;
	int          cx;
	bool         updownleave;

	struct Fmt {
		FontInfo      fi;
		int           len;
		Buffer<wchar> text;
		Buffer<int>   width;
		Vector<int>   line;
		int           LineEnd(int i)  {
			return i < line.GetCount() - 1 ? line[i + 1] : len;
		}
	};
	Fmt    Format(const WString& text) const;

	void   Invalidate();
	int    GetHeight(int i);
	void   Scroll();
	void   PlaceCaret(bool scroll);
	int    GetY(int parai);
	int    GetCursorPos(Point p);
	Point  GetCaret(int pos);
	void   VertMove(int delta, bool select, bool scs);
	void   HomeEnd(int x, bool select);
	void   RefreshStyle();
	Rect   DropCaret();
	void   RefreshDropCaret();
	int    GetMousePos(Point p);

public:
	DocEdit&  After(int a)                                   { after = a; RefreshStyle(); return *this; }
	DocEdit&  SetFont(Font f)                                { font = f; RefreshStyle(); return *this; }
	DocEdit&  SetFilter(int (*f)(int c))                     { filter = f; return *this; }
	DocEdit&  AutoHideSb(bool b = true)                      { sb.AutoHide(b); return *this; }
	DocEdit&  UpDownLeave(bool u = true)                     { updownleave = u; return *this; }
	DocEdit&  NoUpDownLeave()                                { return UpDownLeave(false); }
	bool      IsUpDownLeave() const                          { return updownleave; }
	DocEdit&  SetScrollBarStyle(const ScrollBar::Style& s)   { sb.SetStyle(s); return *this; }

	typedef DocEdit CLASSNAME;

	DocEdit();
	virtual ~DocEdit();
};
#line 41 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/SliderCtrl.h"
class SliderCtrl : public Ctrl {
	int           value;
	int           min, max, step;
	bool          round_step;

	int           SliderToClient(int value) const;
	int           ClientToSlider(int x) const;

	int           HoVe(int  x, int  y) const;
	int&          HoVeR(int& x, int& y) const;

public:
	typedef SliderCtrl CLASSNAME;

	Callback 	  WhenSlideFinish;

	SliderCtrl();
	virtual ~SliderCtrl();

	virtual void  Paint(Draw& draw);
	virtual bool  Key(dword key, int repcnt);
	virtual void  LeftDown(Point pos, dword keyflags);
	virtual void  LeftRepeat(Point pos, dword keyflags);
	virtual void  LeftUp(Point pos, dword keyflags);
	virtual void  MouseMove(Point pos, dword keyflags);

	virtual void  SetData(const Value& value);
	virtual Value GetData() const;

	void          Inc();
	void          Dec();

	SliderCtrl&   MinMax(int _min, int _max);
	SliderCtrl&   Range(int max)                  { return MinMax(0, max); }
	int           GetMin() const                  { return min; }
	int           GetMax() const                  { return max; }

	bool          IsVert() const;

	SliderCtrl&   Step(int _step, bool _r = true) { step = _step; round_step = _r; return *this; }
	int           GetStep() const                 { return step; }
	bool          IsRoundStep() const             { return round_step; }
};
#line 42 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/ColumnList.h"
class ColumnList : public Ctrl, private CtrlFrame {
public:
	virtual void  Serialize(Stream& s);
	virtual void  Paint(Draw& w);
	virtual void  Layout();
	virtual Image CursorImage(Point p, dword);
	virtual void  LeftDown(Point p, dword);
	virtual void  LeftUp(Point p, dword);
	virtual void  LeftDouble(Point p, dword);
	virtual void  RightDown(Point p, dword);
	virtual void  LeftDrag(Point p, dword keyflags);
	virtual void  MouseMove(Point p, dword);
	virtual void  MouseLeave();
	virtual void  MouseWheel(Point p, int zdelta, dword keyflags);
	virtual bool  Key(dword key, int count);
	virtual void  GotFocus();
	virtual void  LostFocus();
	virtual void  CancelMode();
	virtual void  DragEnter();
	virtual void  DragAndDrop(Point p, PasteClip& d);
	virtual void  DragRepeat(Point p);
	virtual void  DragLeave();

private:
	virtual void  FrameLayout(Rect& r);
	virtual void  FrameAddSize(Size& sz);
	virtual void  FramePaint(Draw& draw, const Rect& r);

private:
	int        ncl;
	int        cy;
	int        cursor, anchor;
	int        dx;
	int        ci;
	int        mpos;
	ScrollBar  sb;
	Scroller   scroller;
	CtrlFrame *frame;
	int        dropitem;
	bool       insert;
	bool       clickkill;
	bool       nobg;
	bool       popupex;

	bool       selclick;

	DisplayPopup info;

	const Display *display;

	struct Item {
		bool           sel;
		bool           canselect;
		Value          value;
		const Display *display;
	};

	Array<Item> item;
	int         selcount;
	bool        multi;

	struct  ItemOrder;
	friend struct ItemOrder;

	void    SetSb();
	void    Scroll();
	int     GetDragColumn(int x) const;
	int     RoundedCy();
	void    Page(bool down);
	void    PointDown(Point p);
	void    DoClick(Point p, dword flags);
	void    ShiftSelect();
	void    RefreshItem(int i, int ex = 0);
	void    RefreshCursor()                    { RefreshItem(cursor); }
	void    GetItemStyle(int i, Color& ink, Color& paper, dword& style);
	dword   PaintItem(Draw& w, int i, const Rect& r);
	void    SyncInfo();
	void    SetCursor0(int c, bool sel);
	void    UpdateSelect();
	void    RefreshSel();
	void    DoLeftDown(Point p, dword);

	bool    DnDInsert(int i, int py, PasteClip& d, int q);
	void    DnD(int _drop, bool _insert);

public:
	Callback         WhenLeftClick;
	Callback1<Point> WhenLeftClickPos;
	Callback         WhenLeftDouble;
	Callback1<Bar&>  WhenBar;
	Callback         WhenSel;

	Callback                     WhenDrag;
	Callback2<int, PasteClip&>   WhenDropItem;
	Callback2<int, PasteClip&>   WhenDropInsert;
	Callback1<PasteClip&>        WhenDrop;




	Callback         WhenSelection;
	Callback         WhenEnterItem;
	Callback         WhenKillCursor;

	int     GetColumnItems() const;
	int     GetColumnCx(int i = 0) const;
	int     GetPageItems() const;

	int     GetItem(Point p);
	Rect    GetItemRect(int i) const;

	int     GetCursor() const                          { return cursor; }
	void    SetCursor(int c);
	void    KillCursor();
	bool    IsCursor() const                           { return cursor >= 0; }

	int     GetSbPos() const                           { return sb; }
	void    SetSbPos(int y);

	void    SetFrame(CtrlFrame& frame);

	void         Clear();
	void         Add(const Value& val, bool canselect = true);
	void         Add(const Value& val, const Display& display, bool canselect = true);
	int          GetCount() const                     { return item.GetCount();; }
	const Value& Get(int i) const                     { return item[i].value; }
	const Value& operator[](int i) const              { return item[i].value; }

	void         Set(int ii, const Value& val, bool canselect = true);
	void         Set(int ii, const Value& val, const Display& display, bool canselect = true);

	void         Insert(int ii, const Value& val, bool canselect = true);
	void         Insert(int ii, const Value& val, const Display& display, bool canselect = true);
	void         Remove(int ii);

	void         RemoveSelection();

	bool         IsSelection() const                  { return selcount > 0; }
	void         ClearSelection();
	void         SelectOne(int i, bool sel);
	bool         IsSelected(int i) const;
	bool         IsSel(int i) const;

	void         Sort(const ValueOrder& order);

	Image        GetDragSample();

	void         InsertDrop(int ii, const Vector<Value>& data, PasteClip& d, bool self);
	void         InsertDrop(int ii, const ColumnList& src, PasteClip& d);
	void         InsertDrop(int ii, PasteClip& d);

	ColumnList&  Columns(int _n)                      { ncl = _n; Refresh(); return *this; }
	int          GetColumns() const                   { return ncl; }
	ColumnList&  ItemHeight(int _cy)                  { cy = _cy; RefreshLayout(); Refresh(); return *this; }
	int          GetItemHeight() const                { return cy; }
	ColumnList&  RoundSize(bool b = true);
	ColumnList&  NoRoundSize()                        { return RoundSize(false); }
	ColumnList&  ClickKill(bool b = true)             { clickkill = b; return *this; }
	ColumnList&  NoClickKill()                        { return ClickKill(false); }
	ColumnList&  SetDisplay(const Display& d)         { display = &d; return *this; }
	ColumnList&  NoBackground(bool b = true)          { nobg = b; Transparent(); Refresh(); return *this; }
	ColumnList&  Multi(bool b = true)                 { multi = b; return *this; }
	bool         IsMulti() const                      { return multi; }
	ColumnList&  MultiSelect(bool b = true)           { multi = b; return *this; }
	bool         IsMultiSelect() const                { return multi; }
	ColumnList&  PopUpEx(bool b = true)               { popupex = b; return *this; }
	ColumnList&  NoPopUpEx()                          { return PopUpEx(false); }

	ColumnList&  SetScrollBarStyle(const ScrollBar::Style& s) { sb.SetStyle(s); return *this; }

	typedef ColumnList CLASSNAME;

	ColumnList();
	virtual ~ColumnList();
};
#line 43 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/DateTimeCtrl.h"
enum
{
	SUNDAY    = 0,
	MONDAY    = 1,
	TUESDAY   = 2,
	WEDNESDAY = 3,
	THURSDAY  = 4,
	FRIDAY    = 5,
	SATURDAY  = 6
};

class FlatButton : public Pusher {
public:
	Image img;
	Color fg, bg, hl;
	bool left;
	bool drawedge;

	FlatButton();

	void DrawFrame(Draw &w, const Rect &r, Color lc, Color tc, Color rc, Color bc);
	virtual void Paint(Draw &w);
	virtual void MouseEnter(Point p, dword kflags) {
		Refresh();
		Pusher::MouseEnter(p, kflags);
	}
	virtual void MouseLeave() {
		Refresh();
		Pusher::MouseLeave();
	}

	FlatButton& SetImage(const Image &_img) {
		img = _img;
		Refresh();
		return *this;
	}

	FlatButton& SetLeft()           { left = true;  return *this; }
	FlatButton& SetRight() 			{ left = false;	return *this; }
	FlatButton& DrawEdge(bool b) 	{ drawedge = b;	return *this; }
};

class FlatSpin : public Ctrl
{
private:
	FlatButton left;
	FlatButton right;
	String text;
	Size tsz;
	Font font;
	bool selected;
	bool selectable;

public:
	FlatSpin();
	void SetText(const String& s);
	void SetTips(const char *tipl, const char *tipr);
	void SetCallbacks(const Callback &cbl, const Callback& cbr);

	FlatSpin& Selectable(bool b = true);
	int GetWidth(const String& s, bool with_buttons = true);
	void SetFont(const Font& fnt);

	virtual void MouseMove(Point p, dword keyflags);
	virtual void MouseLeave();
	virtual void LeftDown(Point p, dword keyflags);
	virtual void Layout();
	virtual void Paint(Draw& w);
	virtual Image CursorImage(Point p, dword keyflags);

	typedef FlatSpin CLASSNAME;
};

class PopUpCtrl : public Ctrl
{
private:
	bool popup;
public:
	PopUpCtrl() : popup(false) {}

	Callback WhenPopDown;
	Callback WhenDeactivate;
	virtual void Deactivate();
	virtual Size ComputeSize() = 0;
	virtual void Reset() {}

	void PopUp(Ctrl *owner, const Rect& rt);
	Size GetPopUpSize() { return ComputeSize(); }

	bool IsPopUp() const;
	void SetPopUp(bool b = true);
};

class Calendar : public PopUpCtrl
{
public:
	struct Style : ChStyle<Style> {
		Color header;

		Color bgmain;
		Color bgtoday;
		Color bgselect;

		Color fgmain;
		Color fgtoday;
		Color fgselect;
		Color outofmonth;
		Color curdate;
		Color today;
		Color selecttoday;
		Color cursorday;
		Color selectday;
		Color line;
		Color dayname;
		Color week;
		Font font;
	};

protected:
	const Style *style;
	const Style *St() const;

private:
	typedef Calendar CLASSNAME;

	FlatSpin spin_year;
	FlatSpin spin_month;
	FlatSpin spin_all;

	static const int cols = 7;
	static const int rows = 6;

	static const Point nullday;
	int bs;
	int hs;
	int ts;
	float colw;
	float rowh;
	int cw, rh;

	int col;
	int row;
	int lastrow;

	int fh;

	int days[rows][cols];

	Point newday;
	Point oldday;
	Point prevday;
	Point curday, firstday;

	String stoday;
	Size sztoday;
	String curdate;

	bool selall;
	bool istoday;
	bool wastoday;
	bool time_mode;
	bool swap_month_year;
	bool one_button;

	Time view;
	Time today;
	Time sel;

	int first_day;

	void OnMonthLeft();
	void OnMonthRight();
	void OnYearLeft();
	void OnYearRight();

	void UpdateFields();

	bool MouseOnToday(Point p);
	bool MouseOnHeader(Point p);

	virtual void LeftDown(Point p, dword keyflags);
	virtual void MouseMove(Point p, dword keyflags);
	virtual void Paint(Draw &w);
	virtual bool Key(dword key, int count);
	virtual void MouseLeave();
	virtual void State(int reason);
	virtual Image CursorImage(Point p, dword keyflags);

	int& Day(int x, int y) { return days[y][x]; }
	int& Day(Point p) 	   { return days[p.y][p.x]; }
	Point GetDay(Point p);

	void RefreshDay(Point p);
	void RefreshToday();
	void RefreshHeader();
	virtual Size ComputeSize();

public:
	Calendar();
	Callback1<Time &> WhenTime;

	static const Style& StyleDefault();

	void Reset();

	int	 DayOfWeek(int day, int month, int year, int zelleroffset = 2);
	int  WeekOfYear(int day, int month, int year);

	virtual Value GetData() const			{ return sel;          }
	virtual void  SetData(const Value& v)   { time_mode ? SetTime((Time) v) : SetDate((Date) v); }

	Date GetDate() const;
	void SetDate(int y, int m, int d);
	void SetDate(const Date &dt);

	Date GetTime() const;
	void SetTime(int y, int m, int d, int h, int n, int s);
	void SetTime(const Time &tm);

	Date GetCursor() const			   { return view; 				  }
	bool HasCursor() const			   { return view.day != 0;        }

	Date GetView() const			   { return Date(view.year, view.month, view.day ? view.day : 1); }
	void SetView(const Time &v);

	Calendar& SetStyle(const Style& s);
	Calendar& SelectAll(bool b = true)     { selall = b; return *this;       }
	Calendar& NoSelectAll()                { selall = false; return *this;   }
	Calendar& FirstDay(int n = MONDAY)     { first_day = n; return *this;    }
	Calendar& TimeMode(bool b = true)      { time_mode = b; return *this;    }
	Calendar& SwapMonthYear(bool b = true) { swap_month_year = b; return *this; }
	Calendar& OneButton(bool b = true)     { one_button = b; return *this;   }
	Calendar& NoOneButton()                { one_button = false; return *this;   }

	void PopUp(Ctrl *owner, Rect &rt);
};

struct LineCtrl : Ctrl
{
	int pos, real_pos;

	virtual void Paint(Draw& w);
	void SetPos(Point p);
	int GetPos();
	void SetPos(int p);

	virtual void LeftDown(Point p, dword keyflags);
	virtual void MouseMove(Point p, dword keyflags);
	virtual void LeftUp(Point p, dword keyflags);
	LineCtrl();
};

class Clock : public PopUpCtrl
{
public:
	struct Style : ChStyle<Style> {
		Color header;
		Color bgmain;
		Color fgmain;

		Color arrowhl;
		Color arrowhour;
		Color arrowminute;
		Color arrowsecond;

		Font font;
	};

protected:
	const Style *style;
	const Style *St() const;

private:
	FlatSpin spin_hour;
	FlatSpin spin_minute;
	EditIntSpin ed_hour, ed_minute;
	LineCtrl ln_hour, ln_minute;


	Time sel;
	int hs;
	int dir;
	bool accept_time;

	struct Line {
		Point s, e;
	};

	struct MinMax {
		int diff;
		int value;
	};

	Line lines[3];
	Size sz;
	Point cm;
	Point cf;

	int64 cur_time;
	int   cur_line;
	int   prv_line;
	int   cur_hour;
	int   cur_minute;
	int   cur_second;
	int   cur_point;
	int   prv_point;

	bool seconds;
	bool colon;

	void PaintPtr(int n, Draw& w, Point p, double pos, double m, int d, Color color, Point cf);
	void PaintCenteredText(Draw& w, int x, int y, const char *text, Font fnt, Color c);
	void PaintCenteredImage(Draw &w, int x, int y, const Image& img);

	void SetHourEdit();
	void SetMinuteEdit();
	void SetHourLine();
	void SetMinuteLine();
	void SetHourLeft();
	void SetHourRight();
	void SetMinuteLeft();
	void SetMinuteRight();

	MinMax SetMinMax(int v, int min, int max);
	void UpdateFields();
	void UpdateTime();
	int  IncFactor(int dir, int pp, int cp);

	int  GetDir(int prev_point, int cur_point);
	int  GetPointedLine(Point p);
	int  GetPoint(Point p, double tolerance = 4.0);
	bool IsCircle(Point p, Point s, int r);
	bool IsLine(Point s, Point e, Point p, double tolerance = 3.0);
	void CalcSizes();

	void Timer();

public:

	virtual bool Key(dword key, int count);
	virtual void Paint(Draw& w);
	virtual void State(int reason);
	virtual void LeftDown(Point p, dword keyflags);
	virtual void LeftUp(Point p, dword keyflags);
	virtual void MouseMove(Point p, dword keyflags);
	virtual Image CursorImage(Point p, dword keyflags);
	virtual Size ComputeSize();

	virtual Value GetData() const;
	virtual void  SetData(const Value& v);

	Time GetTime() const;
	void SetTime(int h, int n, int s);
	void SetTime(const Time& tm);

	static const Style& StyleDefault();

	void Reset();

	int GetHour() const   { return sel.hour;   }
	int GetMinute() const { return sel.minute; }
	int GetSecond() const { return sel.second; }

	Clock& SetStyle(const Style& s);
	Clock& Seconds(bool b = true)    { seconds = b; return *this; }
	Clock& NoSeconds()               { return Seconds(false); }
	Clock& Colon(bool b = true)      { colon = b; return *this; }
	Clock& NoColon()                 { return Colon(false); }

	Clock();

	typedef Clock CLASSNAME;
};

class CalendarClock : public Ctrl
{
private:
	int mode;

	Size calendar_size;
	Size clock_size;
	Size sz;

public:
	enum {
		MODE_DATE = 0,
		MODE_TIME = 1
	};

	typedef CalendarClock CLASSNAME;

	Calendar calendar;
	Clock clock;

	CalendarClock(int m = MODE_TIME);
	Callback WhenPopDown;

	virtual void Deactivate();
	virtual bool Key(dword key, int count);
	virtual void Layout();

	Size ComputeSize();
	Size GetCalendarClockSize() { return ComputeSize(); }
	void UpdateTime(Time &tm);

	void PopUp(Ctrl *owner, const Rect& rt);
};

template<class T>
class DateTimeCtrl : public T {
	MultiButtonFrame drop;
	CalendarClock cc;

	int mode;

	void OnCalendarChoice() {
		this->SetData(~cc.calendar);
		this->WhenAction();
	}

	void OnClockChoice() {
		this->SetData(~cc.clock);
		this->WhenAction();
	}

	void OnClose() {
		this->SetFocus();
	}

	void OnDrop() {
		if(!this->IsEditable())
			return;

		Size sz = cc.GetCalendarClockSize();

		int width = sz.cx;
		int height = sz.cy;

		Rect rw = Ctrl::GetWorkArea();
		Rect rs = this->GetScreenRect();
		Rect r;
		r.left   = rs.left;
		r.right  = rs.left + width;
		r.top    = rs.bottom;
		r.bottom = rs.bottom + height;

		if(r.bottom > rw.bottom)
		{
			r.top = rs.top - height;
			r.bottom = rs.top;
		}
		if(r.right > rw.right)
		{
			int diff;
			if(rs.right <= rw.right)
				diff = rs.right - r.right;
			else
				diff = rw.right - r.right;

			r.left += diff;
			r.right += diff;
		}
		if(r.left < rw.left)
		{
			int diff = rw.left - r.left;
			r.left += diff;
			r.right += diff;

		}
		cc.PopUp(this, r);
		cc.calendar <<= this->GetData();
		cc.clock <<= this->GetData();
	}

public:
	typedef DateTimeCtrl CLASSNAME;

	DateTimeCtrl(int m) : cc(m) {
		drop.AddTo(*this);
		drop.AddButton().Main() <<= callback(this, &CLASSNAME::OnDrop);
		drop.NoDisplay();
		drop.SetStyle(drop.StyleFrame());
		cc.calendar   <<= callback(this, &CLASSNAME::OnCalendarChoice);
		cc.clock      <<= callback(this, &CLASSNAME::OnClockChoice);
		cc.WhenPopDown  = callback(this, &CLASSNAME::OnClose);
	}

	virtual void GotFocus()  { drop.RefreshFrame(); }
	virtual void LostFocus() { drop.RefreshFrame(); }
	virtual Size GetMinSize() const { return drop.GetMinSize(); }

	DateTimeCtrl& SetCalendarStyle(const Calendar::Style& style)   { cc.calendar.SetStyle(style); return *this;  }
	DateTimeCtrl& SetClockStyle(const Clock::Style& style)         { cc.clock.SetStyle(style); return *this;  }
	DateTimeCtrl& SetButtonStyle(const MultiButton::Style& style)  { drop.SetStyle(style); return *this; }
	DateTimeCtrl& SelectAll(bool b = true)                         { cc.calendar.SelectAll(b); return *this;     }
	DateTimeCtrl& NoSelectAll()     						       { cc.calendar.SelectAll(false); return *this; }
	DateTimeCtrl& Seconds(bool b = true)                           { cc.clock.Seconds(b); return *this; }
	DateTimeCtrl& NoSeconds()                                      { cc.clock.Seconds(false); return *this; }
	DateTimeCtrl& Colon(bool b = true)                             { cc.clock.Colon(b); return *this; }
	DateTimeCtrl& NoColon()                                        { cc.clock.Colon(false); return *this; }
	DateTimeCtrl& SwapMonthYear(bool b = true)                     { cc.calendar.SwapMonthYear(b); return *this; }
	DateTimeCtrl& OneButton(bool b = true)                         { cc.calendar.OneButton(true); return *this; }
	DateTimeCtrl& NoOneButton()                                    { cc.calendar.OneButton(false); return *this; }
};

class DropDate : public DateTimeCtrl<EditDate>
{
public:
	DropDate();
	DropDate& SetDate(int y, int m, int d);
};

class DropTime : public DateTimeCtrl<EditTime>
{
public:
	DropTime();
	DropTime& SetTime(int y, int m, int d, int h, int n, int s);
	DropTime& Seconds(bool b = true)                           { DateTimeCtrl<EditTime>::Seconds(b); EditTime::Seconds(b); return *this; }
	DropTime& NoSeconds()                                      { return Seconds(false); }

};
#line 44 "u:/uppsrc\\CtrlLib/CtrlLib.h"


#line 1 "u:/uppsrc\\CtrlCore/lay.h"







#line 1 "u:/uppsrc\\CtrlLib/Ctrl.lay"
struct EditStringLayout__layid {};






struct ProgressLayout__layid {};





struct CommentLayout__layid {};





struct SimpleSelectLayout__layid {};





struct FileSelectorLayout__layid {};



















struct PaletteLayout__layid {};



















struct PaletteSelectorLayout__layid {};





struct PalCtrlSizeLayout__layid {};








struct KeysLayout__layid {};









struct PrinterLayout__layid {};























#line 9 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/uppsrc\\CtrlLib/Ctrl.lay"
template<class T> struct WithEditStringLayout : public T, public EditStringLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(236, 62); }
	Label lbl;
	EditString text;
	Button ok;
	Button cancel;
};

template<class T> struct WithProgressLayout : public T, public ProgressLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(320, 72); }
	Button stop;

	Label info;
};

template<class T> struct WithCommentLayout : public T, public CommentLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(400, 204); }
	DocEdit text;
	Button ok;
	Button cancel;
};

template<class T> struct WithSimpleSelectLayout : public T, public SimpleSelectLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(172, 184); }
	ArrayCtrl list;
	Button ok;
	Button cancel;
};

template<class T> struct WithFileSelectorLayout : public T, public FileSelectorLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(516, 400); }
	Label dv___0;
	DropList dir;
	Splitter splitter;
	Label filename;
	Label filesize;
	Label filetime;
	Label file_lbl;
	EditString file;
	Label type_lbl;
	DropList type;
	EditString search;
	Label sort_lbl;
	Switch sortext;
	Option readonly;
	Option hidden;
	Button ok;
	Button cancel;
};

template<class T> struct WithPaletteLayout : public T, public PaletteLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(212, 332); }
	TabCtrl palette_tab;
	Label dv___1;
	DataPusher color;
	Button set_transparent;

	Label dv___5;
	EditIntSpin r;
	Label dv___7;
	EditIntSpin g;
	Label dv___9;
	EditIntSpin b;
	Label dv___11;
	EditIntSpin h;
	Label dv___13;
	EditIntSpin s;
	Label dv___15;
	EditIntSpin v;
};

template<class T> struct WithPaletteSelectorLayout : public T, public PaletteSelectorLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(248, 320); }
	Ctrl palette;
	Button ok;
	Button cancel;
};

template<class T> struct WithPalCtrlSizeLayout : public T, public PalCtrlSizeLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(206, 60); }
	Label dv___0;
	EditIntSpin rows;
	Label dv___2;
	EditIntSpin columns;
	Button ok;
	Button cancel;
};

template<class T> struct WithKeysLayout : public T, public KeysLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(540, 388); }
	ArrayCtrl group;
	ArrayCtrl keys;


	Button ok;
	Button cancel;
	Button defaults;
};

template<class T> struct WithPrinterLayout : public T, public PrinterLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(372, 264); }
	LabelBox dv___0;
	Label dv___1;
	DropList printer;
	Label dv___3;
	DropList paper;
	Label dv___5;
	DropList slot;
	Label dv___7;
	DropList npage;
	LabelBox dv___9;
	Switch range;
	EditIntSpin from;
	Label dv___12;
	EditIntSpin to;
	LabelBox dv___14;
	Label dv___15;
	EditIntSpin copies;
	Option collate;
	Button ok;
	Button cancel;
	Switch landscape;
	LabelBox dv___21;
};
#line 23 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/uppsrc\\CtrlLib/Ctrl.lay"
template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, EditStringLayout__layid&) { parent.LayoutId("EditStringLayout");
	layout.lbl.SetLabel(t_GetLngString("Test")).LeftPosZ(4, 68).TopPosZ(4, 19); layout.lbl.LayoutId("lbl"); parent.Add(layout.lbl);
	layout.text.HSizePosZ(68, 4).TopPosZ(4, 19); layout.text.LayoutId("text"); parent.Add(layout.text);
	layout.ok.SetLabel(t_GetLngString("OK")).HCenterPosZ(80, -10).BottomPosZ(4, 22); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).RightPosZ(4, 80).BottomPosZ(4, 22); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, ProgressLayout__layid&) { parent.LayoutId("ProgressLayout");
	layout.stop.SetLabel(t_GetLngString("Cancel")).HCenterPosZ(68, 0).BottomPosZ(4, 24); layout.stop.LayoutId("stop"); parent.Add(layout.stop);
	uts.pi.HSizePosZ(4, 4).TopPosZ(28, 12); uts.pi.LayoutId("pi"); parent.Add(uts.pi);
	layout.info.HSizePosZ(4, 4).TopPosZ(4, 15); layout.info.LayoutId("info"); parent.Add(layout.info);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, CommentLayout__layid&) { parent.LayoutId("CommentLayout");
	layout.text.HSizePosZ(8, 8).VSizePosZ(8, 40); layout.text.LayoutId("text"); parent.Add(layout.text);
	layout.ok.SetLabel(t_GetLngString("OK")).RightPosZ(80, 64).BottomPosZ(8, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).RightPosZ(8, 64).BottomPosZ(8, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, SimpleSelectLayout__layid&) { parent.LayoutId("SimpleSelectLayout");
	layout.list.HSizePosZ(4, 4).VSizePosZ(4, 34); layout.list.LayoutId("list"); parent.Add(layout.list);
	layout.ok.SetLabel(t_GetLngString("OK")).RightPosZ(74, 64).BottomPosZ(4, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).RightPosZ(4, 64).BottomPosZ(4, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, FileSelectorLayout__layid&) { parent.LayoutId("FileSelectorLayout");
	layout.dv___0.SetLabel(t_GetLngString("&Directory")).LeftPosZ(8, 60).TopPosZ(6, 15); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.dir.HSizePosZ(72, 8).TopPosZ(4, 19); layout.dir.LayoutId("dir"); parent.Add(layout.dir);
	layout.splitter.HSizePosZ(8, 8).VSizePosZ(28, 108); layout.splitter.LayoutId("splitter"); parent.Add(layout.splitter);
	layout.filename.HSizePosZ(8, 208).BottomPosZ(88, 16); layout.filename.LayoutId("filename"); parent.Add(layout.filename);
	layout.filesize.RightPosZ(148, 56).BottomPosZ(88, 16); layout.filesize.LayoutId("filesize"); parent.Add(layout.filesize);
	layout.filetime.RightPosZ(8, 136).BottomPosZ(88, 16); layout.filetime.LayoutId("filetime"); parent.Add(layout.filetime);
	layout.file_lbl.SetLabel(t_GetLngString("&File")).LeftPosZ(8, 64).BottomPosZ(67, 15); layout.file_lbl.LayoutId("file_lbl"); parent.Add(layout.file_lbl);
	layout.file.HSizePosZ(76, 8).BottomPosZ(65, 19); layout.file.LayoutId("file"); parent.Add(layout.file);
	layout.type_lbl.SetLabel(t_GetLngString("&Type")).LeftPosZ(8, 64).BottomPosZ(43, 15); layout.type_lbl.LayoutId("type_lbl"); parent.Add(layout.type_lbl);
	layout.type.HSizePosZ(76, 116).BottomPosZ(41, 19); layout.type.LayoutId("type"); parent.Add(layout.type);
	layout.search.RightPosZ(8, 104).BottomPosZ(41, 19); layout.search.LayoutId("search"); parent.Add(layout.search);
	layout.sort_lbl.SetLabel(t_GetLngString("&Sort by")).LeftPosZ(8, 64).BottomPosZ(21, 15); layout.sort_lbl.LayoutId("sort_lbl"); parent.Add(layout.sort_lbl);
	layout.sortext.SetLabel(t_GetLngString("Name\nExtension")).LeftPosZ(76, 84).BottomPosZ(4, 32); layout.sortext.LayoutId("sortext"); parent.Add(layout.sortext);
	layout.readonly.SetLabel(t_GetLngString("Read only")).HSizePosZ(164, 256).BottomPosZ(6, 18); layout.readonly.LayoutId("readonly"); parent.Add(layout.readonly);
	layout.hidden.SetLabel(t_GetLngString("Show hidden")).HSizePosZ(260, 156).BottomPosZ(6, 18); layout.hidden.LayoutId("hidden"); parent.Add(layout.hidden);
	layout.ok.SetLabel(t_GetLngString("Open")).RightPosZ(84, 68).BottomPosZ(8, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).RightPosZ(8, 68).BottomPosZ(8, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, PaletteLayout__layid&) { parent.LayoutId("PaletteLayout");
	layout.palette_tab.HSizePosZ(4, 4).VSizePosZ(4, 82); layout.palette_tab.LayoutId("palette_tab"); parent.Add(layout.palette_tab);
	layout.dv___1.SetLabel(t_GetLngString("Color:")).LeftPosZ(4, 36).BottomPosZ(52, 24); layout.dv___1.LayoutId("dv___1"); parent.Add(layout.dv___1);
	layout.color.HSizePosZ(68, 32).BottomPosZ(54, 22); layout.color.LayoutId("color"); parent.Add(layout.color);
	layout.set_transparent.RightPosZ(4, 18).BottomPosZ(56, 18); layout.set_transparent.LayoutId("set_transparent"); parent.Add(layout.set_transparent);
	uts.fetch_color.RightPosZ(4, 18).BottomPosZ(30, 18); uts.fetch_color.LayoutId("fetch_color"); parent.Add(uts.fetch_color);
	layout.dv___5.SetLabel(t_GetLngString("R:")).LeftPosZ(4, 12).BottomPosZ(29, 19); layout.dv___5.LayoutId("dv___5"); parent.Add(layout.dv___5);
	layout.r.LeftPosZ(16, 40).BottomPosZ(29, 19); layout.r.LayoutId("r"); parent.Add(layout.r);
	layout.dv___7.SetLabel(t_GetLngString("G:")).LeftPosZ(68, 12).BottomPosZ(29, 19); layout.dv___7.LayoutId("dv___7"); parent.Add(layout.dv___7);
	layout.g.LeftPosZ(80, 40).BottomPosZ(29, 19); layout.g.LayoutId("g"); parent.Add(layout.g);
	layout.dv___9.SetLabel(t_GetLngString("B:")).LeftPosZ(130, 12).BottomPosZ(29, 19); layout.dv___9.LayoutId("dv___9"); parent.Add(layout.dv___9);
	layout.b.LeftPosZ(142, 40).BottomPosZ(29, 19); layout.b.LayoutId("b"); parent.Add(layout.b);
	layout.dv___11.SetLabel(t_GetLngString("H:")).LeftPosZ(4, 12).BottomPosZ(5, 19); layout.dv___11.LayoutId("dv___11"); parent.Add(layout.dv___11);
	layout.h.LeftPosZ(16, 40).BottomPosZ(5, 19); layout.h.LayoutId("h"); parent.Add(layout.h);
	layout.dv___13.SetLabel(t_GetLngString("S:")).LeftPosZ(68, 12).BottomPosZ(5, 19); layout.dv___13.LayoutId("dv___13"); parent.Add(layout.dv___13);
	layout.s.LeftPosZ(80, 40).BottomPosZ(5, 19); layout.s.LayoutId("s"); parent.Add(layout.s);
	layout.dv___15.SetLabel(t_GetLngString("V:")).LeftPosZ(130, 12).BottomPosZ(5, 19); layout.dv___15.LayoutId("dv___15"); parent.Add(layout.dv___15);
	layout.v.LeftPosZ(142, 40).BottomPosZ(5, 19); layout.v.LayoutId("v"); parent.Add(layout.v);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, PaletteSelectorLayout__layid&) { parent.LayoutId("PaletteSelectorLayout");
	layout.palette.HSizePosZ(4, 4).VSizePosZ(4, 32); layout.palette.LayoutId("palette"); parent.Add(layout.palette);
	layout.ok.SetLabel(t_GetLngString("OK")).RightPosZ(88, 80).BottomPosZ(4, 22); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).RightPosZ(4, 80).BottomPosZ(4, 22); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, PalCtrlSizeLayout__layid&) { parent.LayoutId("PalCtrlSizeLayout");
	layout.dv___0.SetLabel(t_GetLngString("&Rows:")).LeftPosZ(4, 44).TopPosZ(4, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.rows.LeftPosZ(48, 50).TopPosZ(4, 19); layout.rows.LayoutId("rows"); parent.Add(layout.rows);
	layout.dv___2.SetLabel(t_GetLngString("&Columns:")).LeftPosZ(108, 44).TopPosZ(4, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.columns.LeftPosZ(152, 50).TopPosZ(4, 19); layout.columns.LayoutId("columns"); parent.Add(layout.columns);
	layout.ok.SetLabel(t_GetLngString("OK")).RightPosZ(88, 80).BottomPosZ(4, 22); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).RightPosZ(4, 80).BottomPosZ(4, 22); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, KeysLayout__layid&) { parent.LayoutId("KeysLayout");
	layout.group.LeftPosZ(8, 116).TopPosZ(8, 308); layout.group.LayoutId("group"); parent.Add(layout.group);
	layout.keys.LeftPosZ(132, 400).TopPosZ(8, 308); layout.keys.LayoutId("keys"); parent.Add(layout.keys);
	uts.key[0].LeftPosZ(132, 196).TopPosZ(324, 20); uts.key[0].LayoutId("key[0]"); parent.Add(uts.key[0]);
	uts.key[1].LeftPosZ(332, 196).TopPosZ(324, 20); uts.key[1].LayoutId("key[1]"); parent.Add(uts.key[1]);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(400, 64).TopPosZ(356, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).LeftPosZ(468, 64).TopPosZ(356, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
	layout.defaults.SetLabel(t_GetLngString("Default")).LeftPosZ(8, 64).TopPosZ(324, 24); layout.defaults.LayoutId("defaults"); parent.Add(layout.defaults);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, PrinterLayout__layid&) { parent.LayoutId("PrinterLayout");
	layout.dv___0.SetLabel(t_GetLngString("Printer")).LeftPosZ(8, 356).TopPosZ(4, 68); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.dv___1.SetLabel(t_GetLngString("Printer")).LeftPosZ(16, 92).TopPosZ(20, 20); layout.dv___1.LayoutId("dv___1"); parent.Add(layout.dv___1);
	layout.printer.LeftPosZ(104, 252).TopPosZ(20, 19); layout.printer.LayoutId("printer"); parent.Add(layout.printer);
	layout.dv___3.SetLabel(t_GetLngString("Paper size")).LeftPosZ(16, 88).TopPosZ(44, 20); layout.dv___3.LayoutId("dv___3"); parent.Add(layout.dv___3);
	layout.paper.LeftPosZ(104, 84).TopPosZ(44, 19); layout.paper.LayoutId("paper"); parent.Add(layout.paper);
	layout.dv___5.SetLabel(t_GetLngString("Input slot")).LeftPosZ(196, 72).TopPosZ(44, 20); layout.dv___5.LayoutId("dv___5"); parent.Add(layout.dv___5);
	layout.slot.LeftPosZ(268, 88).TopPosZ(44, 19); layout.slot.LayoutId("slot"); parent.Add(layout.slot);
	layout.dv___7.SetLabel(t_GetLngString("Pages per sheet")).LeftPosZ(188, 104).TopPosZ(192, 20); layout.dv___7.LayoutId("dv___7"); parent.Add(layout.dv___7);
	layout.npage.LeftPosZ(296, 60).TopPosZ(192, 19); layout.npage.LayoutId("npage"); parent.Add(layout.npage);
	layout.dv___9.SetLabel(t_GetLngString("Print range")).LeftPosZ(8, 216).TopPosZ(80, 88); layout.dv___9.LayoutId("dv___9"); parent.Add(layout.dv___9);
	layout.range.SetLabel(t_GetLngString("All pages\nCurrent page\nPages from")).LeftPosZ(16, 196).TopPosZ(100, 60); layout.range.LayoutId("range"); parent.Add(layout.range);
	layout.from.LeftPosZ(100, 52).TopPosZ(132, 19); layout.from.LayoutId("from"); parent.Add(layout.from);
	layout.dv___12.SetLabel(t_GetLngString("to")).LeftPosZ(156, 16).TopPosZ(135, 13); layout.dv___12.LayoutId("dv___12"); parent.Add(layout.dv___12);
	layout.to.LeftPosZ(172, 48).TopPosZ(132, 19); layout.to.LayoutId("to"); parent.Add(layout.to);
	layout.dv___14.SetLabel(t_GetLngString("Copies")).LeftPosZ(232, 132).TopPosZ(80, 88); layout.dv___14.LayoutId("dv___14"); parent.Add(layout.dv___14);
	layout.dv___15.SetLabel(t_GetLngString("Copies")).LeftPosZ(244, 56).TopPosZ(100, 20); layout.dv___15.LayoutId("dv___15"); parent.Add(layout.dv___15);
	layout.copies.LeftPosZ(300, 56).TopPosZ(100, 19); layout.copies.LayoutId("copies"); parent.Add(layout.copies);
	layout.collate.SetLabel(t_GetLngString("Collate")).LeftPosZ(244, 116).TopPosZ(136, 19); layout.collate.LayoutId("collate"); parent.Add(layout.collate);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(232, 64).TopPosZ(232, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).LeftPosZ(300, 64).TopPosZ(232, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
	layout.landscape.SetLabel(t_GetLngString("Portrait\nLandscape")).LeftPosZ(16, 168).TopPosZ(194, 18); layout.landscape.LayoutId("landscape"); parent.Add(layout.landscape);
	layout.dv___21.SetLabel(t_GetLngString("Placement")).LeftPosZ(8, 356).TopPosZ(176, 48); layout.dv___21.LayoutId("dv___21"); parent.Add(layout.dv___21);
};
#line 37 "u:/uppsrc\\CtrlCore/lay.h"







#line 47 "u:/uppsrc\\CtrlLib/CtrlLib.h"

#line 1 "u:/uppsrc\\CtrlLib/Progress.h"
class ProgressIndicator : public Ctrl {
public:
	virtual void   Paint(Draw& draw);
	virtual void   Layout();

public:
	struct Style : ChStyle<Style> {
		bool  classic;
		bool  bound;
		Value vlook, vchunk, hlook, hchunk;
	};

protected:
	int   total, actual;
	int   pxp;
	bool  percent:1;
	const Style *style;
	Color color;

	Size GetMsz();

public:
	void  Set(int actual, int total);
	void  Set(int _actual)                      { Set(_actual, total); }

	void  operator=(int i)                      { Set(i); }
	int   operator++()                          { Set(actual + 1); return actual; }
	int   operator++(int)                       { int i = actual; Set(actual + 1); return i; }
	int   operator+=(int i)                     { Set(actual + i); return actual; }

	operator int()                              { return actual; }

	static const Style& StyleDefault();

	ProgressIndicator& SetTotal(int _total)     { Set(actual, _total); return *this; }
	ProgressIndicator& Percent(bool b = true)   { percent = b; Refresh(); return *this; }
	ProgressIndicator& NoPercent()              { return Percent(false); }
	ProgressIndicator& SetColor(Color c)        { color = c; Refresh(); return *this; }
	ProgressIndicator& SetStyle(const Style& s) { style = &s; Refresh(); return *this; }

	ProgressIndicator();
	virtual ~ProgressIndicator();
};

class Progress : public WithProgressLayout<TopWindow> {
public:
	ProgressIndicator pi;
	virtual void Close();

protected:
	bool     cancel;
	int      total;
	int      pos;
	String   text;
	int      granularity;
	dword    set_time;
	dword    show_time;
	Ctrl    *owner;
	Modality modality;

	void     Setxt();
	void     Init();
	void     Process();

public:
	void     SetOwner(Ctrl *_owner)        { owner = _owner; }

	void     Create();
	void     Cancel();

	void     Set(int pos, int total);
	void     SetPos(int pos);
	void     SetText(const char *s)        { text = s; Setxt(); Sync(); }
	void     SetText(const String& s)      { text = s; Setxt(); Sync(); }
	void     SetTotal(int total);
	void     Step(int steps = 1);
	int      GetPos() const                { return pos; }
	int      GetTotal() const              { return total; }
	String   GetText() const               { return text; }

	bool     Canceled();
	bool     SetCanceled(int pos, int total);
	bool     SetPosCanceled(int pos);
	bool     StepCanceled(int steps = 1);

	void     Reset();

	void     Granularity(int ms)           { granularity = ms; }

	void     AlignText(int align)          { info.SetAlign(align); }

	operator Gate2<int, int>()             { return callback(this, &Progress::SetCanceled); }

	Progress();
	Progress(Ctrl *_owner);
	Progress(const char *txt, int total = 0);
	Progress(Ctrl *_owner, const char *txt, int total = 0);
	virtual ~Progress();
};
#line 49 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/FileSel.h"
Image GetDriveImage(char drive_style);

void DrawFileName(Draw& w, int x, int y, int wcx, int cy, const WString& mname, bool isdir, Font font,
                  Color ink, Color extink, const WString& desc, Font descfont, bool justname);

class FileList : public ColumnList, private Display {
public:
	virtual void  LeftDown(Point p, dword);
	virtual bool  Key(dword key, int count);

	virtual void  Paint(Draw& w, const Rect& r, const Value& q,
		                Color ink, Color paper, dword style) const;
	virtual Size  GetStdSize(const Value& q) const;

public:
	struct File {
		bool   isdir;
		Image  icon;
		String name;
		Font   font;
		Color  ink;
		int64  length;
		Time   time;
		Color  extink;
		String desc;
		Font   descfont;
		Value  data;

		operator const String&() const { return name; }
	};

	class Order {
	public:
		virtual bool operator()(const File& a, const File& b) const = 0;
		virtual ~Order() {}
	};

private:
	int            iconwidth;
	EditField      edit;

	bool           renaming;
	bool           justname;
	bool           accelkey;

	void        UpdateSelect();
	void        Update();
	bool        FindChar(int from, int chr);

	struct FileOrder;

protected:
	enum {
		TIMEID_STARTEDIT = ColumnList::TIMEID_COUNT,
		TIMEID_COUNT
	};

public:
	Callback2<const String&, const String&> WhenRename;

	void        StartEdit();
	void        EndEdit();
	bool        IsEdit() const                       { return edit.IsVisible(); }
	void        OkEdit();

	const File& Get(int i) const;
	const File& operator[](int i) const              { return Get(i); }
	void        Insert(int ii,
	                const String& name, const Image& icon = Null,
		            Font font = StdFont(), Color ink = SColorText(),
	                bool isdir = false, int64 length = 0, Time time = Null, Color extink = Null,
	                const String& desc = Null, Font descfont = Null, Value data = Null);
	void        Add(const String& name, const Image& icon = Null,
		            Font font = StdFont(), Color ink = SColorText(),
	                bool isdir = false, int64 length = 0, Time time = Null, Color extink = Null,
	                const String& desc = Null, Font descfont = Null, Value data = Null);

	String      GetCurrentName() const;

	int         Find(const char *name);
	bool        FindSetCursor(const char *name);

	void        Sort(const Order& order);

	FileList&   IconWidth(int w)                     { iconwidth = w; Refresh(); return *this; }
	int         GetIconWidth() const                 { return iconwidth; }
	FileList&   Renaming(bool b = true)              { renaming = b; return *this; }
	FileList&   JustName(bool b = true)              { justname = b; Refresh(); return *this; }
	FileList&   AccelKey(bool b = true)              { accelkey = b; return *this; }

	typedef FileList CLASSNAME;

	FileList();
	virtual ~FileList();
};

bool Load(FileList& list, const String& dir, const char *patterns, bool dirs = false,
          Callback3<bool, const String&, Image&> WhenIcon = CNULL,
          FileSystemInfo& filesystem = StdFileSystemInfo(), const String& search = String(),
          bool hidden = true);
void SortByName(FileList& list);
void SortByExt(FileList& list);

String DirectoryUp(String& dir, bool basedir = false);

class FileSel : public WithFileSelectorLayout<TopWindow> {
public:
	virtual bool Key(dword key, int count);

private:
	SizeGrip    sizegrip;

	Button      dirup, mkdir, plus, minus, toggle;

protected:
	Vector<String> mask;
	Vector<String> path;
	Vector<String> lru;
	int            lastsby;
	FileSystemInfo *filesystem;

	String         olddir;
	String         basedir;
	int            activetype;
	String         defext;
	Vector<String> fn;

	DisplayCtrl    preview_display;
	Ctrl          *preview;
	FileList       list;

	enum {
		OPEN, SAVEAS, SELECTDIR
	};

	int         mode;
	bool        asking;
	bool        multi;
	bool        rdonly;
	bool        bidname;
	bool        appmodal;

	bool        PatternMatch(const char *fn);
	bool        OpenItem();
	void        OpenItem2()                                  { OpenItem(); }
	void        Open();
	void        DirUp();
	void        MkDir();
	void        Plus();
	void        Minus();
	void        Toggle();
	void        PlusMinus(const char *title, bool sel);
	void        Update();
	void        FileUpdate();
	void        Rename(const String& on, const String& nn);
	void        Choice();
	void        SearchLoad();
	void        Load();
	String      FilePath(const String& fn);
	void        SetDir(const String& dir);
	String      GetDir();
	void        AddName(Vector<String>& fn, String& o);
	void        Finish();
	bool        Execute(int mode);
	bool        IsMulti()                                     { return multi && mode == OPEN; }
	void        SyncSplitter();
	String      GetMask();

	using       WithFileSelectorLayout<TopWindow>::Title;

public:
	typedef FileSel CLASSNAME;

	Callback3<bool, const String&, Image&> WhenIcon;

	void        Serialize(Stream& s);

	bool        ExecuteOpen(const char *title = 0);
	bool        ExecuteSaveAs(const char *title = 0);

	bool        ExecuteSelectDir(const char *title = 0);

	String Get() const                           { return GetFile(0); }
	void   Set(const String& s);
	void   Set(const Vector<String>& s)          { fn <<= s; bidname = true; }

	operator String() const                      { return Get(); }
	void operator=(const String& s)              { Set(s); }

	String operator~() const                     { return Get(); }
	void operator<<=(const String& s)            { Set(s); }

	int    GetCount() const                      { return fn.GetCount(); }
	String GetFile(int i) const;
	String operator[](int i) const               { return GetFile(i); }
	void   ClearFiles()                          { fn.Clear(); }

	bool   GetReadOnly() const                   { return readonly; }
	String GetActiveDir() const                  { return dir.GetData(); }
	int    GetActiveType() const                 { return activetype; }

	void   Filesystem(FileSystemInfo& fsys)      { filesystem = &fsys;}
	FileSystemInfo& GetFilesystem() const        { return *filesystem; }

	FileSel& Type(const char *name, const char *ext);
	FileSel& AllFilesType();
	FileSel& ActiveDir(const String& d)          { dir <<= d; return *this; }
	FileSel& ActiveType(int i)                   { activetype = i; return *this;  }
	FileSel& DefaultExt(const char *ext)         { defext = ext; return *this; }
	FileSel& Multi(bool b = true)                { multi = b; return *this; }
	FileSel& ReadOnlyOption(bool b = true)       { rdonly = b; return *this; }
	FileSel& MkDirOption(bool b = true)          { mkdir.Show(b); return *this; }
	FileSel& NoMkDirOption()                     { return MkDirOption(false); }
	FileSel& BaseDir(const char *dir)            { basedir = dir; return *this; }
	FileSel& Asking(bool b = true)               { asking = b; return *this; }
	FileSel& NoAsking()                          { return Asking(false); }
	FileSel& EditFileName(bool b)                { file.SetEditable(b); return *this; }
	FileSel& NoEditFileName()                    { return EditFileName(false); }
	FileSel& AppModal(bool b = true)             { appmodal = b; return *this; }
	FileSel& NoAppModal()                        { return AppModal(false); }
	FileSel& Preview(Ctrl& ctrl);
	FileSel& Preview(const Display& d);

	FileSel();
	virtual ~FileSel();
};
#line 50 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/CtrlUtil.h"
void Animate(Ctrl& c, const Rect& target, int type = -1);
void Animate(Ctrl& c, int x, int y, int cx, int cy, int type = -1);

bool CtrlLibDisplayError(const Value& ev);

bool EditText(String& s, const char *title, const char *label, int (*filter)(int), int maxlen = 0);
bool EditText(String& s, const char *title, const char *label, int maxlen = 0);

bool EditText(WString& s, const char *title, const char *label, int (*filter)(int), int maxlen = 0);
bool EditText(WString& s, const char *title, const char *label, int maxlen = 0);

void Show2(Ctrl& ctrl1, Ctrl& ctrl, bool show = true);
void Hide2(Ctrl& ctrl1, Ctrl& ctrl);


void UpdateFile(const char *filename);
void SelfUpdate();
bool SelfUpdateSelf();
#line 20 "u:/uppsrc\\CtrlLib/CtrlUtil.h"

void WindowsList();
void WindowsMenu(Bar& bar);

class DelayCallback : public Pte<DelayCallback> {
	Callback target;
	int      delay;

public:
	void     Invoke();
	void     operator<<=(Callback x)  { target = x; }
	void     SetDelay(int ms)         { delay = ms; }
	Callback Get()                    { return callback(this, &DelayCallback::Invoke); }
	Callback operator~()              { return Get(); }
	operator Callback()               { return Get(); }

	DelayCallback()                   { delay = 2000; }
	~DelayCallback()                  { KillTimeCallback(this); }
};


struct Win32PrintDlg_;
#line 43 "u:/uppsrc\\CtrlLib/CtrlUtil.h"



class PrinterJob {

	One<Win32PrintDlg_> pdlg;
#line 50 "u:/uppsrc\\CtrlLib/CtrlUtil.h"



	One<Draw>           draw;
	Vector<int>         page;
	int                 from, to, current;
	bool                landscape;
	String              name;
	String              options;
	bool                Execute0(bool dodlg);

public:
	Draw&               GetDraw();
	operator            Draw&()                         { return GetDraw(); }
	const Vector<int>&  GetPages() const                { return page; }
	int                 operator[](int i) const         { return page[i]; }
	int                 GetPageCount() const            { return page.GetCount(); }

	bool                Execute();

	PrinterJob& Landscape(bool b = true)                { landscape = b; return *this; }
	PrinterJob& MinMaxPage(int minpage, int maxpage);
	PrinterJob& PageCount(int n)                        { return MinMaxPage(0, n - 1); }
	PrinterJob& CurrentPage(int currentpage);

	PrinterJob(const char *name = 0);
	~PrinterJob();
};

#line 80 "u:/uppsrc\\CtrlLib/CtrlUtil.h"






























































class TrayIcon : private Ctrl {
	struct NotifyIconOld {
		dword sz;
		HWND  hwnd;
		dword id;
		dword flags;
		dword message;
		HICON icon;
		char  tip[64];
	};
	struct NotifyIconNew {
		dword sz;
		HWND  hwnd;
		dword id;
		dword flags;
		dword message;
		HICON icon;
		char  tip[128];

		dword state;
		dword statemask;
		char  info[256];
		dword timeout;
		char  title[64];
		dword infoflags;
	};

	Image          icon;
	bool           visible;
	String         tip;
	NotifyIconNew  nid;
	HWND           hwnd;

	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	void Notify(dword msg);
	void DoMenu(Bar& bar);
	void Message(int type, const char *title, const char *text, int timeout = 10);

public:
	virtual void    Menu(Bar& bar);
	virtual void    LeftDown();
	virtual void    LeftUp();
	virtual void    LeftDouble();
	virtual void    BalloonLeftDown();
	virtual void    BalloonShow();
	virtual void    BalloonHide();
	virtual void    BalloonTimeout();

	Callback        WhenLeftDown;
	Callback        WhenLeftUp;
	Callback        WhenLeftDouble;
	Callback1<Bar&> WhenBar;
	Callback        WhenBalloonLeftDown;
	Callback        WhenBalloonShow;
	Callback        WhenBalloonHide;
	Callback        WhenBalloonTimeout;

	void            Show(bool b = true);
	void            Hide()                                 { Show(false); }
	void            Break()                                { EndLoop(0); }
	void            Run()                                  { EventLoop(this); }

	void            Info(const char *title, const char *text, int timeout = 10)    { Message(1, title, text, timeout); }
	void            Warning(const char *title, const char *text, int timeout = 10) { Message(2, title, text, timeout); }
	void            Error(const char *title, const char *text, int timeout = 10)   { Message(3, title, text, timeout); }

	TrayIcon&  Icon(const Image &img);
	TrayIcon&  Tip(const char *text);

	typedef TrayIcon CLASSNAME;

	TrayIcon();
	~TrayIcon();
};

class FileSelector {
protected:
	struct FileType : Moveable<FileType> {
		String name;
		String ext;
	};

	Vector<FileType> type;

	int    activetype;
	String activedir;
	String defext;
	bool   rdonly;
	bool   multi;
	bool   readonly;
	bool   asking;

	Vector<String> filename;

public:
	void Serialize(Stream& s);

	void New()                                   { filename.Clear(); }
	bool IsNew() const                           { return filename.IsEmpty(); }
	bool Execute(bool open, const char *title = 0);
	bool ExecuteOpen(const char *title = 0)   { return Execute(true, title); }
	bool ExecuteSaveAs(const char *title = 0) { return Execute(false, title); }

	String Get() const;
	void  Set(const String& s)                   { filename.At(0) = s; }

	operator String() const                      { return Get(); }
	void operator=(const String& s)              { Set(s); }

	String operator~() const                     { return Get(); }
	void operator<<=(const String& s)            { Set(s); }

	int   GetCount() const                       { return filename.GetCount(); }
	const String& operator[](int i) const        { return filename[i]; }

	bool   GetReadOnly() const                   { return readonly; }
	String GetActiveDir() const                  { return activedir; }

	FileSelector& Type(const char *name, const char *ext);
	FileSelector& AllFilesType();
	FileSelector& ActiveDir(const String& dir)   { activedir = dir; return *this; }
	FileSelector& ActiveType(int i)              { activetype = i; return *this;  }
	FileSelector& DefaultExt(const char *ext)    { defext = ext; return *this; }
	FileSelector& Multi(bool b = true)           { multi = b; return *this; }
	FileSelector& ReadOnlyOption(bool b = true)  { rdonly = b; return *this; }
	FileSelector& Asking(bool b = true)          { asking = b; return *this; }
	FileSelector& NoAsking()                     { return Asking(false); }

	FileSelector();
};

#line 274 "u:/uppsrc\\CtrlLib/CtrlUtil.h"
#line 275 "u:/uppsrc\\CtrlLib/CtrlUtil.h"





class CtrlRetriever {
public:
	struct Item {
		virtual void Retrieve() = 0;
		virtual ~Item() {}
	};

private:
	struct CtrlItem0 : Item {
		Ctrl  *ctrl;
	};

	template <class T>
	struct CtrlItem : CtrlItem0 {
		T     *value;

		virtual void Retrieve()  { *value = ~*ctrl; }
		virtual ~CtrlItem() {}
	};

	Array<Item> item;

public:
	void Put(Item *newitem)                       { item.Add(newitem); }

	template <class T>
	void Put(Ctrl& ctrl, T& val);

	template <class T>
	CtrlRetriever& operator()(Ctrl& ctrl, T& val) { Put(ctrl, val); return *this; }

	void Retrieve();

	Callback operator<<=(Callback cb);
};

template <class T>
void CtrlRetriever::Put(Ctrl& ctrl, T& val)
{
	CtrlItem<T> *m = new CtrlItem<T>();
	m->ctrl = &ctrl;
	m->value = &val;
	ctrl <<= val;
	Put(m);
}

class IdCtrls {
	struct Item {
		Id    id;
		Ctrl *ctrl;
	};
	Array<Item> item;

public:
	void        Add(Id id, Ctrl& ctrl);
	IdCtrls&    operator()(Id id, Ctrl& ctrl)        { Add(id, ctrl); return *this; }
	int         GetCount() const                     { return item.GetCount(); }
	Ctrl&       operator[](int i)                    { return *item[i].ctrl; }
	const Ctrl& operator[](int i) const              { return *item[i].ctrl; }
	Id          operator()(int i) const              { return item[i].id; }
};

void Set(ArrayCtrl& array, int ii, IdCtrls& m);
void Get(ArrayCtrl& array, int ii, IdCtrls& m);

void UpdateFile(String dst, String src);

void MemoryProfileInfo();
#line 51 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 1 "u:/uppsrc\\CtrlLib/Lang.h"



class LNGCtrl : public StaticRect
{
public:
	virtual Value GetData() const;
	virtual void  SetData(const Value& v);

	virtual Size  GetMinSize() const;

private:
	DropList hi;
	DropList lo;

	void LoadLo();
	void Hi();
	void Lo();

public:
	typedef LNGCtrl CLASSNAME;

	LNGCtrl& DropFocus(bool b = true)    { hi.DropFocus(b); lo.DropFocus(b); return *this; }
	LNGCtrl& NoWantFocus()               { hi.NoWantFocus(); lo.NoWantFocus(); return *this; }

	LNGCtrl();
	virtual ~LNGCtrl();
};

#line 31 "u:/uppsrc\\CtrlLib/Lang.h"
#line 52 "u:/uppsrc\\CtrlLib/CtrlLib.h"

#line 1 "u:/uppsrc\\CtrlLib/Ch.h"
void ChStdSkin();
void ChClassicSkin();
void ChHostSkin();
#line 54 "u:/uppsrc\\CtrlLib/CtrlLib.h"

};

#line 58 "u:/uppsrc\\CtrlLib/CtrlLib.h"
#line 5 "u:/uppsrc\\Report/Report.h"
#line 1 "u:/uppsrc\\RichText/RichText.h"











































































































































































































































































































































































































































































#line 6 "u:/uppsrc\\Report/Report.h"

namespace Upp {


#line 1 "u:/uppsrc\\CtrlCore/lay.h"







#line 1 "u:/uppsrc\\Report/Report.lay"
struct ReportWindowLayout__layid {};










#line 9 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/uppsrc\\Report/Report.lay"
template<class T> struct WithReportWindowLayout : public T, public ReportWindowLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(340, 276); }

	LabelBox dv___1;
	Label lbl;
	LabelBox dv___3;
	Switch sw;
	Option numbers;
	Button pdf;
	Button cancel;
};

#line 23 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/uppsrc\\Report/Report.lay"
template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, ReportWindowLayout__layid&) { parent.LayoutId("ReportWindowLayout");
	uts.pg.HSizePosZ(6, 104).VSizePosZ(3, 4); uts.pg.LayoutId("pg"); parent.Add(uts.pg);
	layout.dv___1.SetLabel(t_GetLngString("Page")).RightPosZ(8, 88).TopPosZ(0, 44); layout.dv___1.LayoutId("dv___1"); parent.Add(layout.dv___1);
	layout.lbl.SetLabel(t_GetLngString("1 / 1")).RightPosZ(16, 72).TopPosZ(12, 28); layout.lbl.LayoutId("lbl"); parent.Add(layout.lbl);
	layout.dv___3.SetLabel(t_GetLngString("Sideways")).RightPosZ(8, 88).TopPosZ(48, 88); layout.dv___3.LayoutId("dv___3"); parent.Add(layout.dv___3);
	layout.sw.SetLabel(t_GetLngString("&1 page\n&2 pages\n&4 pages\n&8 pages")).RightPosZ(12, 76).TopPosZ(66, 70); layout.sw.LayoutId("sw"); parent.Add(layout.sw);
	layout.numbers.SetLabel(t_GetLngString("Page &numbers")).RightPosZ(8, 88).TopPosZ(142, 18); layout.numbers.LayoutId("numbers"); parent.Add(layout.numbers);
	layout.pdf.SetLabel(t_GetLngString("PDF export..")).RightPosZ(8, 88).TopPosZ(168, 24); layout.pdf.LayoutId("pdf"); parent.Add(layout.pdf);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).RightPosZ(8, 88).BottomPosZ(4, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

#line 37 "u:/uppsrc\\CtrlCore/lay.h"







#line 11 "u:/uppsrc\\Report/Report.h"

class Report : public DrawingDraw, public PageDraw {
public:
	virtual Draw& Info();
	virtual Draw& Page(int i);

private:
	Array<Drawing> page;
	int            pagei;
	int            y;
	String         header, footer;
	int            headercy, headerspc, footercy, footerspc;
	Point          mg;

	void    Flush();
	String  FormatHF(const char *s, int pageno);
	int     GetHeightHF(const char *s);
	void    PaintHF(Draw& w, int y, const char *qtf, int i);
	void    StartPage(int i);
	void    RestartPage();

public:
	int                   GetCount()                  { Flush(); return page.GetCount(); }
	Drawing               GetPage(int i)              { Flush(); return page[i]; }
	Drawing               operator[](int i)           { return GetPage(i); }
	const Array<Drawing>& GetPages()                  { Flush(); return page; }

	void                  Clear();

	Rect                  GetPageRect();
	Size                  GetPageSize()               { return GetPageRect().Size(); }

	void                  SetY(int _y)                { y = _y; }
	int                   GetY() const                { return y; }

	void                  NewPage()                   { Page(pagei + 1); }

	void                  Put(const RichText& txt);
	void                  Put(const char *qtf);
	Report&               operator<<(const char *qtf) { Put(qtf); return *this; }

	Point                 GetMargins() const          { return mg; }

	Report&               SetPageSize(Size sz);
	Report&               SetPageSize(int cx, int cy) { return SetPageSize(Size(cx, cy)); }
	Report&               Landscape();
	Report&               Margins(int top, int left)  { mg.x = top; mg.y = left; return *this; }
	Report&               Header(const char *qtf, int spc = 150);
	Report&               Footer(const char *qtf, int spc = 150);
	Report&               NoHeader()                  { return Header(0, 0); }
	Report&               NoFooter()                  { return Footer(0, 0); }

	Report();
	Report(int cx, int cy);
	Report(const Size &sz);
};

class ReportView : public Ctrl {
public:
	virtual void Paint(Draw& w);
	virtual void Layout();
	virtual bool Key(dword key, int);
	virtual void LeftDown(Point p, dword);
	virtual void MouseWheel(Point, int zdelta, dword);

protected:
	ScrollBar sb;
	Report   *report;
	Image     page[64];
	int       pagei[64];
	Size      pagesize;
	int       vsize;

	int       pm;
	int       pvn;
	bool      numbers;
	int       pages;

	Image     GetPage(int i);

	void      Init();
	void      Sb();
	void      Numbers()               { Refresh(); }
	Size      GetReportSize();

public:
	Callback  WhenGoPage;

	enum Pages {
		PG1, PG2, PG4, PG16
	};
	ReportView& Pages(int pags)       { pages = pags; Layout(); return *this; }
	ReportView& Numbers(bool nums)    { numbers = nums; Refresh(); return *this; }

	void      Set(Report& report);
	int       GetFirst() const        { return sb / pagesize.cy * pvn; }

	void      ScrollInto(int toppage, int top, int bottompage, int bottom);

	typedef ReportView CLASSNAME;

	ReportView();
};

class ReportWindow : public WithReportWindowLayout<TopWindow> {
	void Pages()   { pg.Pages(~sw); }
	void Numbers() { pg.Numbers(numbers); }
	void GoPage()  { sw <<= ReportView::PG1; Pages(); }
	void Pdf();

	Array<Button>         button;
	Report               *report;

public:
	ReportView pg;

	typedef ReportWindow CLASSNAME;

	static void SetPdfRoutine(String (*pdf)(const Report& report, int margin));

	void SetButton(int i, const char *label, int id);

	int  Perform(Report& report, int zoom = 100, const char *caption = t_GetLngString("Report"));

	ReportWindow();
};

String Pdf(Report& report);
bool   DefaultPrint(Report& r, int i, const char *_name = t_GetLngString("Report"));
bool   Print(Report& r, int i, const char *name = t_GetLngString("Report"));
bool   Perform(Report& r, const char *name = t_GetLngString("Report"));

};

#line 146 "u:/uppsrc\\Report/Report.h"
#line 9 "u:/idisapp\\IdisMisc/IdisMisc.h"

using namespace Upp;

#line 1 "u:/uppsrc\\DocTypes/DocTypes.h"







#line 1 "u:/uppsrc\\Draw/Draw.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 9 "u:/uppsrc\\DocTypes/DocTypes.h"
#line 1 "u:/uppsrc\\RichText/RichText.h"











































































































































































































































































































































































































































































#line 10 "u:/uppsrc\\DocTypes/DocTypes.h"
#line 1 "u:/uppsrc\\CtrlLib/CtrlLib.h"

























































#line 11 "u:/uppsrc\\DocTypes/DocTypes.h"

namespace Upp {

enum { DOC_SCREEN_ZOOM = 140 };

class ParaTypo {
public:
	struct Part {
		Font   font;
		Color  color;
		int    overhang;
		int    ascent;
		int    descent;
		int    external;
		void  *voidptr;
		int    width;

		FontInfo Set(Font font, Color color);
	};


protected:
	int         total;
	Alignment   align;
	int         pgcx;
	const char *textbeg;
	int         minascent;
	int         mindescent;
	int         minexternal;

	int         len;
	const char *text;
	int        *width;
	Part      **info;
	int         cx;
	int         ascent;
	int         descent;
	int         external;
	int         nspc;
	bool        last;

	void Begin(const char *c, int *w, Part **ii) { text = c; width = w; info = ii; nspc = cx = 0; }

	int Align();

	virtual bool PutAligned(int lm);
	virtual bool Put();
	virtual bool PutRaw();

public:
	void SetMin(int ma, int md, int me)   { minascent = ma; mindescent = md, minexternal = me; }
	bool Format(Alignment align, int len, char *text, int *width, Part **info, int cx);
	ParaTypo()                            { minascent = mindescent = minexternal = 0; }
};

inline int DocZoom(int zoom, int val)     { return (zoom * val) >> 10; }
inline int DocZoomLn(int zoom, int val)   { return val ? max(DocZoom(zoom, val), 1) : 0; }

struct ValueRect : Moveable<ValueRect> {
	Value value;
	Rect  rect;
};

class Table;

class Paragraph : Moveable<Paragraph>, DeepCopyOption<Paragraph> {
public:
	struct Style {
		Alignment align;
		int       before, lm, rm, indent, after;
		int       bulletindent;
		Color     bulletcolor;
		Size      bulletsize;
		PaintRect bullet;
		void      Init();
	};

	struct Part : Moveable<Part> {
		Font      font;
		int       delta;
		Color     color;
		String    text;
		Size      sz;
		PaintRect pr;
		Value     value;

		Part() { delta = 0; }
	};

	struct PaintInfo {
		int       yl;
		int       ypos;

		PaintInfo()            { yl = 0; }
	};

protected:
	int          length;
	Vector<Part> part;
	Font         parafont;
	Style        style;

	class        ParaPaint;
	class        ParaAngle;
	class        ParaHeight;
	class        ParaRect;

public:
	static PaintRect& StdBullet();
	static PaintRect& WhiteBullet();
	static PaintRect& BoxBullet();
	static PaintRect& WhiteBoxBullet();

	Paragraph&  Cat(const String& s, Font font, Color color, const Value& val, int delta = 0);
	Paragraph&  Cat(const PaintRect& pr, int cx, int cy, const Value& val, Color color = Black);

	Paragraph&  Cat(const String& s, Font font, Color color = Black, int delta = 0);
	Paragraph&  Cat(const char *s, Font font, Color color = Black, int delta = 0);
	Paragraph&  Cat(const PaintRect& pr, int cx, int cy = 0, Color color = Black) { return Cat(pr, cx, cy, Null, color); }
	Paragraph&  Cat(const PaintRect& pr, Size sz, Color color = Black)            { return Cat(pr, sz.cx, sz.cy, color); }
	Paragraph&  Cat(const PaintRect& pr, Color color = Black)                     { return Cat(pr, pr.GetStdSize(), color); }

	Paragraph&  Cat(const Paragraph& p);

	Paragraph&  Align(Alignment a)   { style.align = a; return *this; }
	Paragraph&  Left()               { style.align = ALIGN_LEFT; return *this; }
	Paragraph&  Right()              { style.align = ALIGN_RIGHT; return *this; }
	Paragraph&  Center()             { style.align = ALIGN_CENTER; return *this; }
	Paragraph&  Justify()            { style.align = ALIGN_JUSTIFY; return *this; }
	Paragraph&  Lm(int x)            { style.lm = x; return *this; }
	Paragraph&  Rm(int x)            { style.rm = x; return *this; }
	Paragraph&  Indent(int x)        { style.indent = x; return *this; }

	Paragraph&  Bullet(const PaintRect& r = Paragraph::StdBullet(), int indent = 150,
		               Size size = Size(0, 0), Color color = Black);

	Alignment   GetAlign() const                { return style.align; }
	int         GetLm() const                   { return style.lm; }
	int         GetRm() const                   { return style.rm; }
	int         GetIndent() const               { return style.indent; }
	int         GetBulletIndent() const         { return style.bulletindent; }
	PaintRect   GetBullet() const               { return style.bullet; }

	Paragraph&  Before(int x)                   { style.before = x; return *this; }
	Paragraph&  After(int x)                    { style.after = x; return *this; }

	int         GetBefore() const               { return style.before; }
	int         GetAfter() const                { return style.after; }

	const Style& GetStyle() const               { return style; }
	void         SetStyle(const Style& s)       { style = s; }
	void         CopyStyle(const Paragraph& s)  { SetStyle(s.GetStyle()); }

	int         GetLength() const               { return length; }
	int         GetCount() const                { return part.GetCount(); }
	const Part *GetParts() const                { return part.Begin(); }

	bool        Format(ParaTypo& pfmt, int cx, int coef = 1024) const;

	int         GetHeight(int zoom, int cx) const;
	bool        Paint(int zoom, Draw& w, int x, int y, int cx, int ymax, PaintInfo& pi,
		              Color paper = SWhite) const;
	int         Paint(int zoom, Draw& w, int x, int y, int cx, Color paper = SWhite) const;
	void        Paint(int zoom, int angle, Draw& w, int x, int y, int cx) const;

	int         GetHeight(int cx) const;
	bool        Paint(Draw& w, int x, int y, int cx, int ymax, PaintInfo& pi,
		              Color paper = White) const;
	int         Paint(Draw& w, int x, int y, int cx, Color paper = White) const;

	void        GetValueRects(int zoom, Draw& w, int x, int& y, int cx,
		                      Vector<ValueRect>& vr) const;

	int         GetWidth(int zoom) const;
	int         GetWidth() const                { return GetWidth(1024); }

	void        Clear();
	void        SetParaFont(Font f)             { parafont = f; }
	Font        GetParaFont() const             { return parafont; }

	Paragraph(const Paragraph& p, int);
	Paragraph();
};

class TableCell : Moveable<TableCell>, DeepCopyOption<TableCell> {
public:
	struct Style {
		int       ratio;
		int       leftwidth, topwidth, rightwidth, bottomwidth;
		int       leftspace, topspace, rightspace, bottomspace;
		Color     paper;
		Alignment align;

		void Init();
	};

	struct PaintInfo {
		int       yl;

		PaintInfo()        { yl = 0; }
	};

protected:
	Array<Paragraph> par;
	Style            style;
	bool             keep;
	int              span;
	PaintRect        paintrect;

public:
	Paragraph&  Par()                            { return par.Top(); }
	const Paragraph&  Par() const                { return par.Top(); }
	operator    Paragraph&()                     { return par.Top(); }
	operator    const Paragraph&() const         { return par.Top(); }

	int               GetCount() const           { return par.GetCount(); }
	Paragraph&        operator[](int i)          { return par[i]; }
	const Paragraph&  operator[](int i) const    { return par[i]; }

	TableCell& NewPar();

	TableCell& Cat(const String& s, Font f, Color c = Black) { Par().Cat(s, f, c); return *this; }
	TableCell& Cat(const char *s, Font f, Color c = Black)   { Par().Cat(s, f, c); return *this; }
	TableCell& Cat(const PaintRect& pr, int cx, int cy = 0)  { Par().Cat(pr, cx, cy); return *this; }
	TableCell& Cat(const PaintRect& pr, Size sz)             { Par().Cat(pr, sz); return *this; }
	TableCell& Cat(const PaintRect& pr)                      { Par().Cat(pr); return *this; }

	TableCell& Align(Alignment a)                     { Par().Align(a); return *this; }
	TableCell& Left()                                 { Par().Left(); return *this; }
	TableCell& Right()                                { Par().Right(); return *this; }
	TableCell& Center()                               { Par().Center(); return *this; }
	TableCell& Justify()                              { Par().Justify(); return *this; }
	TableCell& Before(int x)                          { Par().Before(x); return *this; }
	TableCell& After(int x)                           { Par().After(x); return *this; }
	TableCell& Lm(int x)                              { Par().Lm(x); return *this; }
	TableCell& Rm(int x)                              { Par().Rm(x); return *this; }
	TableCell& Indent(int x)                          { Par().Indent(x); return *this; }

	TableCell& Paper(Color color)                     { style.paper = color; return *this; }

	TableCell& VertAlign(Alignment a)   { style.align = a; return *this; }
	TableCell& Top()                    { style.align = ALIGN_TOP; return *this; }
	TableCell& VertCenter()             { style.align = ALIGN_CENTER; return *this; }
	TableCell& Bottom()                 { style.align = ALIGN_BOTTOM; return *this; }

	TableCell& Ratio(int w)             { style.ratio = w; return *this; }

	TableCell& Keep(bool b = true)      { keep = b; return *this; }
	TableCell& NoKeep()                 { return Keep(false); }

	TableCell& Span(int n)              { span = n; return *this; }

	TableCell& LeftWidth(int x)   { style.leftwidth = x; return *this; }
	TableCell& TopWidth(int x)    { style.topwidth = x; return *this; }
	TableCell& RightWidth(int x)  { style.rightwidth = x; return *this; }
	TableCell& BottomWidth(int x) { style.bottomwidth = x; return *this; }
	TableCell& FrameWidth(int x)  { return LeftWidth(x).TopWidth(x).RightWidth(x).BottomWidth(x); }

	TableCell& LeftSpace(int x)   { style.leftspace = x; return *this; }
	TableCell& TopSpace(int x)    { style.topspace = x; return *this; }
	TableCell& RightSpace(int x)  { style.rightspace = x; return *this; }
	TableCell& BottomSpace(int x) { style.bottomspace = x; return *this; }
	TableCell& FrameSpace(int x)  { return LeftSpace(x).TopSpace(x).RightSpace(x).BottomSpace(x); }

	Alignment  GetVertAlign()           { return style.align; }

	int   GetRatio() const              { return style.ratio; }

	dword GetPaper() const              { return style.paper; }

	int   GetLeftWidth(int x) const     { return style.leftwidth; }
	int   GetTopWidth(int x) const      { return style.topwidth; }
	int   GetRightWidth(int x) const    { return style.rightwidth; }
	int   GetBottomWidth(int x) const   { return style.bottomwidth; }

	int   GetLeftSpace(int x) const     { return style.leftspace; }
	int   GetTopSpace(int x) const      { return style.topspace; }
	int   GetRightSpace(int x) const    { return style.rightspace; }
	int   GetBottomSpace(int x) const   { return style.bottomspace; }

	bool  IsKeep() const                { return keep; }

	int   GetSpan() const               { return span; }

	const Paragraph::Style& GetParStyle() const { return Par().GetStyle(); }
	void  SetStyle(const Paragraph::Style& s)   { Par().SetStyle(s); }
	void  CopyStyle(const Paragraph& s)         { Par().CopyStyle(s); }

	const Style& GetStyle() const             { return style; }
	void  SetStyle(const Style& s)            { style = s; }
	void  CopyStyle(const TableCell& s)       { SetStyle(s.GetStyle()); }
	void  ClearStyle()                        { style.Init(); }

	int   GetHeight(int zoom, int cx) const;
	bool  Paint(int zoom, Draw& w, int x, int y, int cx, int cy, int pcy, Color color,
		        PaintInfo& pi) const;
	void  GetValueRects(int zoom, Draw& w, int x, int y, int cx, int cy, int pcy,
		                Vector<ValueRect>& vr) const;
	int   GetWidth(int zoom) const;

	void  Qtf(const char *s);
	void  SetPaintRect(const PaintRect& c)   { paintrect = c; }

	TableCell& operator=(const char *s)      { Qtf(s); return *this; }
	TableCell& operator=(const PaintRect& c) { paintrect = c; return *this; }

	void  Clear()                            { par.Clear(); par.Add(); keep = false;
	                                           span = 1; style.Init(); }
	TableCell(const TableCell& c, int);
	TableCell();
};

int GetTotalRatio(const Array<TableCell>& row);
int GetColumnWidth(const Array<TableCell>& row, int j, int cx, int tratio);

class Table : Moveable<Table>, DeepCopyOption<Table> {
public:
	struct Style {
		int   before;
		int   after;
		int   lm;
		int   rm;
		int   framewidth;
		Color framecolor;
		int   headerrows;
		int   breakcy;
		int   breakpgcy;

		void Init();
	};

	struct PaintInfo {
		int         line;
		int         oline;
		int         ypos;
		Vector<int> yl;

		PaintInfo()      { line = 0; oline = -1; }
	};

protected:
	Vector< Array<TableCell> > cell;
	Style style;

	struct Cell : Moveable<Cell> {
		Size         size;
		int          span;
		int          spanh;
		bool         paint;
	};

	struct Line : Moveable<Line> {
		int          height;
		bool         keep;
		int          span;
		Vector<Cell> cell;
	};

	Line GetLine(int zoom, int i, int tcx, const Vector<int> *yl) const;
	int  Span(Vector<Line>& line) const;
	void FrameTab(int zoom, Draw& w, bool was, int x, int y, int yp, int cx) const;
	void DrawLine(int zoom, Draw& w, int x, int y, int i, const Line& ln, int ymax,
				  Vector<int> *yl) const;
	void PaintLines(int zoom, Draw& w, int x, int& y, int i, const Vector<Line>& line,
		            Vector<int> *yl) const;
	bool KeepLine(int i) const;

	void RectLine(int zoom, Draw& w, int x, int y, int i, const Line& ln,
				  Vector<ValueRect>& vr) const;
	void RectLines(int zoom, Draw& w, int x, int y, int i, const Vector<Line>& line,
				   Vector<ValueRect>& vr) const;

public:
	operator const Vector< Array<TableCell> >& () const { return cell; }
	TableCell& operator()(int i, int j);
	const Array<TableCell>& operator[](int i) const  { return cell[i]; }
	const Array<TableCell>& LastRow() const { return cell.Top(); }

	Table&     AddRow();
	TableCell& AddCell(bool inheritstyle = true);
	TableCell& LastCell()                    { return cell.Top().Top(); }
	const TableCell& LastCell() const        { return cell.Top().Top(); }

	Table& Before(int x)                     { style.before = x; return *this; }
	Table& After(int x)                      { style.after = x; return *this; }
	Table& Lm(int x)                         { style.lm = x; return *this; }
	Table& Rm(int x)                         { style.rm = x; return *this; }
	Table& FrameWidth(int x)                 { style.framewidth = x; return *this; }
	Table& FrameColor(Color color)           { style.framecolor = color; return *this; }
	Table& HeaderRows(int n)                 { style.headerrows = n; return *this; }
	Table& NoHeaderRows()                    { return HeaderRows(0); }
	Table& Breaks(int bcy, int bpcy)         { style.breakcy = bcy; style.breakpgcy = bpcy;
	                                           return *this; }

	int    GetBefore() const                 { return style.before; }
	int    GetAfter() const                  { return style.after; }
	int    GetLm() const                     { return style.lm; }
	int    GetRm() const                     { return style.rm; }
	int    GetFrameWidth() const             { return style.framewidth; }
	Color  GetFrameColor() const             { return style.framecolor; }
	int    GetHeaderRows() const             { return style.headerrows; }
	int    GetBreaksCy() const               { return style.breakcy; }
	int    GetBreaksPgCy() const             { return style.breakpgcy; }

	const Style& GetStyle() const            { return style; }
	void         SetStyle(const Style& s)    { style = s; }
	void         CopyStyle(const Table& s)   { SetStyle(s.GetStyle()); }

	int         GetRows() const              { return cell.GetCount(); }

	int         GetHeight(int zoom, int cx) const;
	bool        Paint(int zoom, Draw& w, int x, int y, int cx,
		              int ymax, PaintInfo& pi) const;
	int         Paint(int zoom, Draw& w, int x, int y, int cx) const;
	void        GetValueRects(int zoom, Draw& w, int x, int& y, int cx,
		                      Vector<ValueRect>& vr) const;

	int         GetHeight(int cx) const;
	bool        Paint(Draw& w, int x, int y, int cx,
		              int ymax, PaintInfo& pi) const;
	int         Paint(Draw& w, int x, int y, int cx) const;

	int         GetWidth(int zoom) const;
	int         GetWidth() const             { return GetWidth(1024); }

	void        Clear()                      { cell.Clear(); style.Init(); }

	Table(const Table& tab, int);
	Table();
};

class Document : Moveable<Document>, DeepCopyOption<Document> {
public:
	class Cache {
		int zoom;
		int cx;
		Vector<int> cy;

		friend class Document;

	public:
		void     Clear()           { cy.Clear(); cx = Null; }
		void     SetModify(int i)  { if(i < cy.GetCount()) cy[i] = Null; }
		Cache()                    { cx = Null; }
	};

protected:
	enum Type { PARAGRAPH, TABLE };
	struct Item : Moveable<Item>, DeepCopyOption<Item> {
		Type  type;
		Table data;

		Item() {}
		Item(const Item& s, int) : data(s.data, 1), type(s.type) {}
	};

	Vector<Item>     item;

	int               GetHeight(int zoom, int i, int cx, Cache& cache) const;
	void              Qtf0(const char *s, bool append, byte charset);

public:
	Table&            AddTable();
	Paragraph&        AddParagraph();
	void              Cat(const Paragraph& p);

	void              Clear()                     { item.Clear(); }

	int               GetCount() const            { return item.GetCount(); }

	bool              IsParagraph(int i) const    { return item[i].type == PARAGRAPH; }
	const Paragraph&  GetParagraph(int i) const   { return item[i].data.LastCell().Par(); }

	bool              IsTable(int i) const        { return item[i].type == TABLE; }
	const Table&      GetTable(int i) const       { return item[i].data; }

	int               GetHeight(int zoom, int cx) const;
	int               Paint(int zoom, Draw& w, int x, int y, int cx, Color paper = SWhite) const;
	Vector<ValueRect> GetValueRects(int zoom, Draw& w, int x, int y, int cx) const;
	int               GetWidth(int zoom) const;

	int               GetHeight(int cx) const           { return GetHeight(1024, cx); }
	int               Paint(Draw& w, int x, int y, int cx, Color paper = White) const {
		                return Paint(1024, w, x, y, cx, paper); }
	int               GetWidth() const                    { return GetWidth(1024); }

	int               GetHeight(int zoom, int cx, Cache& cache) const;
	void              Paint(int zoom, Draw& w, int x, int y, int cx, int cy, int y0,
		                    Cache& cache, Color paper = SWhite) const;

	void              Qtf(const char *s, byte charset = 0)       { Qtf0(s, false, charset); }
	void              AppendQtf(const char *s, byte charset = 0) { Qtf0(s, true, charset); }
	Document&         operator=(const char *s);
	Document&         operator|=(const char *s);

	Document(const Document&, int);
	Document();
	Document(const char *qtf);
};

























































































class QtfParser {
public:
	enum Code { END, PARAGRAPH, TABLE, PAGE };
	enum Type { NORMAL, SUPERSCRIPT, SUBSCRIPT };

protected:
	const char   *term;
	struct State : public Paragraph::Style, Moveable<State> {
		Font    font;
		int     type;
		Color   color;
		String  value;

		State() { type = 0; }
	};
	State         state;
	Array<State>  stack;
	Paragraph     paragraph;
	Table         table;
	Code          ender;
	bool          inraw;
	byte          charset;

	void       Init();
	int        GetNumber();
	Color      GetColor();
	String     GetString();
	void       Picture(int type);
	void       Flush(String& text);
	void       Celln(int& a, int& b);
	bool       IsTable()              { return table.GetRows(); }
	Paragraph& Par();
	TableCell& Cell()                 { return table.LastCell(); }
	bool       Term(char c1, char c2) { return term[0] == c1 && term[1] == c2; }
	bool       Term2(char c)          { return term[0] == c && term[1] == c; }
	bool       Key(char c)            { if(*term == c) { term++; return true; } return false; }
	bool       Key(char c1, char c2)  { if(Term(c1, c2)) { term += 2; return true; } return false; }
	bool       Key2(char c)           { return Key(c, c); }
	Code       Error(const char *s);

public:
	void SetStyle(const Paragraph::Style& s)          { (Paragraph::Style&)state = s; }

	void Set(const char *s, byte charset = 0)         { term = s; inraw = false; ender = END; }
	Code Parse();

	const Paragraph& GetParagraph()                   { return paragraph; }
	const Table&     GetTable()                       { return table; }

	Paragraph        PickParagraph()                  { return paragraph; }
	Table            PickTable()                      { return table; }

	void operator=(const char *s)                     { Set(s); }

	QtfParser()                                       { Init(); }
	QtfParser(const char *text, byte charset = 0)     { Init(); Set(text); }
};

String AsQtf(const Document& text);

class DocOut {
public:
	virtual void Put(const Paragraph& paragraph) = 0;
	virtual void Put(const Table& table) = 0;
	virtual void Page() = 0;

	void    Put(const Document& doc);
	void    Qtf(const char *s);

	DocOut& operator<<(const Paragraph& paragraph)    { Put(paragraph); return *this; }
	DocOut& operator<<(const Table& table)            { Put(table); return *this; }
	DocOut& operator<<(const Document& doc)           { Put(doc); return *this; }
	DocOut& operator<<(const char *qtf)               { Qtf(qtf); return *this; }
};

class RtfDocOut : public DocOut {
public:
	virtual void Put(const Paragraph& paragraph);
	virtual void Put(const Table& table);
	virtual void Page();

protected:
	Index<dword> color;
	String rtf;
	int    pgcx;
	bool   page;
	double imagescale;

	struct VSpan;

	static inline int Dow(int q)          { return q * 12 / 5; }

	void PutColor(const char *cmd, dword color);
	void PutPicture(const Drawing& iw, Size sz);
	void Border(const char *cmd, int width, dword color);
	void PutPara(const Paragraph& p, bool par = true, bool table = false,
		         int ls = 0, int rs = 0, int ts = 0, int bs = 0);

public:
	String Get();

	void   SetPageWidth(int cx)           { pgcx = cx; }
	void   ImageScale(double d)           { imagescale = d; }

	void   Clear();

	RtfDocOut();



};

};

#line 1 "u:\\uppsrc\\doctypes\\Report.h"
namespace Upp {


#line 1 "u:/uppsrc\\CtrlCore/lay.h"







#line 1 "u:/uppsrc\\DocTypes/Report.lay"
struct ReportLayout__layid {};









#line 9 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/uppsrc\\DocTypes/Report.lay"
template<class T> struct WithReportLayout : public T, public ReportLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(268, 276); }

	Label lbl;
	LabelBox dv___2;
	Switch sw;
	Option numbers;
	Button pdf;
	Button cancel;
};

#line 23 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/uppsrc\\DocTypes/Report.lay"
template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, ReportLayout__layid&) { parent.LayoutId("ReportLayout");
	uts.pg.HSizePosZ(6, 108).VSizePosZ(3, 4); uts.pg.LayoutId("pg"); parent.Add(uts.pg);
	layout.lbl.SetLabel(t_GetLngString("1 / 1")).RightPosZ(6, 96).TopPosZ(3, 26); layout.lbl.LayoutId("lbl"); parent.Add(layout.lbl);
	layout.dv___2.SetLabel(t_GetLngString("Sideways")).RightPosZ(8, 88).TopPosZ(42, 94); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.sw.SetLabel(t_GetLngString("&1 page\n&2 pages\n&4 pages\n&8 pages")).RightPosZ(12, 76).TopPosZ(60, 72); layout.sw.LayoutId("sw"); parent.Add(layout.sw);
	layout.numbers.SetLabel(t_GetLngString("Page &numbers")).RightPosZ(4, 92).TopPosZ(146, 18); layout.numbers.LayoutId("numbers"); parent.Add(layout.numbers);
	layout.pdf.SetLabel(t_GetLngString("PDF export..")).RightPosZ(12, 80).TopPosZ(172, 24); layout.pdf.LayoutId("pdf"); parent.Add(layout.pdf);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).RightPosZ(12, 80).BottomPosZ(8, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

#line 37 "u:/uppsrc\\CtrlCore/lay.h"







#line 5 "u:\\uppsrc\\doctypes\\Report.h"

class DocReport : public DrawingDraw, public DocOut {
public:
	virtual void    Put(const Paragraph& p);
	virtual void    Put(const Table& p);
	virtual void    Page();

	struct RValueRect : public ValueRect {
		int toppage;
		int bottompage;
	};

protected:
	String          name;
	Array<RValueRect> vr;
	Array<Drawing>  page;
	Size            pgsz;
	Size            size;
	Drawing         header;
	Drawing         footer;
	String          qtfheader;
	String          qtffooter;
	int             ylim, lm;
	int             pgn, pgnx, pgny, pageno;
	const char     *pgnformat;
	Font            pgnfont;
	QtfParser       parser;
	RtfDocOut       rtf;

	bool            dortf;
	bool            valrects;

	int             ypos;

	struct TableSet;

	void          StartPage();
	void          EndPage();
	String        HFormat(const char *s);
	bool          Print0(int page, const char *name);
	void          AddVR(const Vector<ValueRect>& v);

	friend class ReportDlg;

public:
	Callback      WhenNewPage;

	void          NextPage();

	DocReport&       SetPageSize(int cx, int cy);
	DocReport&       SetPageSize(Size sz);
	DocReport&       SetPageno(int x, int y, const char *format = "%d",
		                    Font font = Roman(-100), int fp = 1);
	DocReport&       SetPageNo(int pageno);
	DocReport&       SetHeader(const Drawing& h);
	DocReport&       SetFooter(const Drawing& f);

	DocReport&       Landscape()                         {	return SetPageSize(pgsz.cy, pgsz.cx); }


	int           GetPageNo() const                   { return pageno; }

	DocReport&       SetHeader(const char *qtf);
	DocReport&       SetFooter(const char *qtf);

	Size          GetPageSize() const                 { return pgsz; }
	Size          GetSize() const                     { return size; }
	String        GetHeader() const                   { return qtfheader; }
	String        GetFooter() const                   { return qtffooter; }

	int           GetYPos() const                     { return ypos; }
	void          SetYPos(int y)                      { ypos = y; }
	void          AddYPos(int dy)                     { ypos += dy; }
	int           GetYLim() const                     { return ylim; }
	int           GetYRest() const                    { return GetYLim() - ypos; }
	void          SetLm(int cx)                       { lm = cx; }

	void          SkipBefore(int cy);
	void          SkipAfter(int cy);

	int           GetCount() const                    { return page.GetCount(); }
	int           GetPageCount() const                { return page.GetCount() + 1; }
	Drawing       GetPage(int i) const                { return page[i]; }
	const Array<Drawing>& GetPages() const            { return page; }
	void          SetCount(int n);

	void          Clear();

	void          KillLastPage();

	void          Finish()                            { EndPage(); }

	bool          Print(int page = 0, const char *name = 0);
	bool          Perform(const char *caption = 0);

	const ValueRect& GetValueRect(int i) const        { return vr[i]; }
	int              GetValueRectCount() const        { return vr.GetCount(); }

	String           GetRtf()                         { return rtf.Get(); }

	DocReport&       Rtf(bool b = true)               { dortf = b; return *this; }
	DocReport&       NoRtf()                          { return Rtf(false); }
	DocReport&       RtfImageScale(double d)          { rtf.ImageScale(d); return *this; }
	DocReport&       ValueRects(bool b = true)        { valrects = true; return *this; }

	DocReport(const char *name = t_GetLngString("DocReport"));
	virtual ~DocReport();
};

String Pdf(const DocReport& report);

class ReportCtrl : public Ctrl {
public:
	virtual void Paint(Draw& w);
	virtual void Layout();
	virtual bool Key(dword key, int);
	virtual void LeftDown(Point p, dword);
	virtual void MouseWheel(Point, int zdelta, dword);

protected:
	ScrollBar sb;
	DocReport   *report;
	Image     page[64];
	int       pagei[64];
	Size      pagesize;
	int       vsize;

	int       pm;
	int       pvn;
	bool      numbers;
	int       pages;

	Image     GetPage(int i);

	void      Init();
	void      Sb();
	void      Numbers()               { Refresh(); }

public:
	Callback  WhenGoPage;

	enum Pages {
		PG1, PG2, PG4, PG16
	};
	ReportCtrl& Pages(int pags)       { pages = pags; Layout(); return *this; }
	ReportCtrl& Numbers(bool nums)    { numbers = nums; Refresh(); return *this; }

	void      Set(DocReport& p);
	int       GetFirst() const        { return sb / max(pagesize.cy * pvn, 1); }

	void      ScrollInto(int toppage, int top, int bottompage, int bottom);
	void      ScrollInto(const DocReport::RValueRect& vr);

	typedef ReportCtrl CLASSNAME;

	ReportCtrl();
};

class ReportDlg : public WithReportLayout<TopWindow> {
	void Pages()   { pg.Pages(~sw); }
	void Numbers() { pg.Numbers(numbers); }
	void GoPage()  { sw <<= ReportCtrl::PG1; Pages(); }
	void Pdf();

	Array<Button>  button;
	DocReport        *report;

public:
	ReportCtrl pg;

	typedef ReportDlg CLASSNAME;

	static void SetPdfRoutine(String (*pdf)(const DocReport& report, int margin));

	void SetButton(int i, const char *label, int id);

	int  Perform(DocReport& report, int zoom = 100, const char *caption = t_GetLngString("DocReport"));

	ReportDlg();
};

void PutQTF(DocReport& r, const char *qtf);

};
#line 714 "u:/uppsrc\\DocTypes/DocTypes.h"
#line 1 "u:\\uppsrc\\doctypes\\QtfCtrl.h"


namespace Upp {

class QtfCtrl : public Ctrl {
public:
	virtual void  Paint(Draw& w);
	virtual void  Layout();
	virtual bool  Key(dword key, int);
	virtual Image CursorImage(Point p, dword keyflags);
	virtual void  LeftUp(Point p, dword keyflags);
	virtual void  MouseWheel(Point p, int zdelta, dword keyflags);

protected:
	Document          doc;
	mutable Document::Cache cache;
	Color             color;
	int               tm, lm, rm, bm;
	int               zoom;
	ScrollBar         sb;
	bool              vcenter;
	Vector<ValueRect> valuerect;

	int      GetHeight() const                    { return GetHeight(GetSize().cx); }
	void     Scroll();
	Value    FindValue(Point p) const;

public:
	Callback1<const Value&> WhenLink;

	QtfCtrl&  SetLabel(const char *text);

	void     Set(const char *qtf);
	void     Set(const Document& _doc);
	void     Pick( Document& _doc);

	int      GetHeight(int cx) const;
	int      GetWidth() const                      { return doc.GetWidth(zoom); }

	const Vector<ValueRect>& GetValueRects() const { return valuerect; }
	int      GetSb() const                         { return sb; }
	void     SetSb(int i)                          { sb = i; }

	const Document& GetDocument() const            { return doc; }

	QtfCtrl& Background(Color _color)  { Transparent(IsNull(color = _color)); Refresh(); return *this; }

	QtfCtrl& VCenter(bool b = true)    { vcenter = b; return *this; }
	QtfCtrl& NoVCenter()               { return VCenter(false); }
	QtfCtrl& Lm(int _lm)               { lm = _lm; Refresh(); return *this; }
	QtfCtrl& Rm(int _rm)               { rm = _rm; Refresh(); return *this; }
	QtfCtrl& Tm(int _tm)               { tm = _tm; Refresh(); return *this; }
	QtfCtrl& Bm(int _bm)               { bm = _bm; Refresh(); return *this; }
	QtfCtrl& HMargins(int a)           { lm = rm = a; Refresh(); return *this; }
	QtfCtrl& VMargins(int a)           { tm = bm = a; Refresh(); return *this; }
	QtfCtrl& Margins(int a)            { lm = rm = tm = bm = a; Refresh(); return *this; }


	int      GetLm() const             { return lm; }
	int      GetTm() const             { return tm; }
	int      GetRm() const             { return rm; }
	int      GetBm() const             { return bm; }

	void     operator=(const char *s)          { Set(s); }
	void     operator=(Document& _doc)         { Pick(_doc); }
	void     operator<<=(const Document& _doc) { Set(_doc); }

	void     Clear()                           { Set(""); }

	QtfCtrl();
	virtual ~QtfCtrl();
};

};
#line 715 "u:/uppsrc\\DocTypes/DocTypes.h"

#line 717 "u:/uppsrc\\DocTypes/DocTypes.h"
#line 13 "u:/idisapp\\IdisMisc/IdisMisc.h"
#line 1 "u:/idisapp\\notes/notes.h"



#line 1 "u:/idisapp\\IdisMisc/IdisMisc.h"
























































































































































































































































































































































































































































































































































































































































































































































































































#line 5 "u:/idisapp\\notes/notes.h"

struct NotesRecord {

	String prijmeni;
	String jmeno;
	String osloveni;

	String mesto;
	String ulice;
	String zeme;
	String psc;

	String organizace;
	String funkce;
	String email;

	String odbor;
	String jednacicislo;
	String rok;
	String zedne;
	String vec;
	String datumdoruceni;
	String poznamka;
	String typpisemnosti;
	String podaciposta;
	String centralnicislo;
	String cj;

	String nsf;

	bool   samostatne;
};

bool   LotusNotes();

void   NotesCreateSpis(const NotesRecord& r);
String GetNotesCj(const NotesRecord& r);
void   SetNotesPdf(const String& ccj, const String& rok, const String& pdf);

#line 45 "u:/idisapp\\notes/notes.h"
#line 14 "u:/idisapp\\IdisMisc/IdisMisc.h"
#line 1 "u:/uppsrc\\RichEdit/RichEdit.h"



#line 1 "u:/uppsrc\\CtrlLib/CtrlLib.h"

























































#line 5 "u:/uppsrc\\RichEdit/RichEdit.h"

namespace Upp {



#line 1 "u:/uppsrc\\Draw/iml_header.h"













class RichEditImg {
public:


	enum {
#line 1 "u:/uppsrc\\RichEdit/RichEdit.iml"
I_RightTab,
I_RightTabTrack,
I_LeftTab,
I_LeftTabTrack,
I_CenterTab,
I_CenterTabTrack,
I_Margin,
I_MarginMixed,
I_MarginTrack,
I_Indent,
I_IndentMixed,
I_IndentTrack,
I_Bold,
I_BoldMixed,
I_Italic,
I_ItalicMixed,
I_Underline,
I_UnderlineMixed,
I_Left,
I_SuperScript,
I_SuperScriptMixed,
I_SubScript,
I_SubScriptMixed,
I_Capitals,
I_CapitalsMixed,
I_Right,
I_Strikeout,
I_StrikeoutMixed,
I_Center,
I_Justify,
I_bullet,
I_boxbullet,
I_firstnumberbullet,
I_numberbullet,
I_print,
I_newpage,
I_InkColor,
I_NullInkColor,
I_PaperColor,
I_ColorA,
I_NullPaperColor,
I_ManageStyles,
I_AdjustUnits,
I_ParaFormat,
I_ToPara,
I_RoundBullet,
I_RoundWhiteBullet,
I_BoxBullet,
I_BoxWhiteBullet,
I_NoneBullet,
I_SpellCheck,
I_TextBullet,
I_FindReplace,
I_GoTo,
I_InsertTable,
I_TableProperties,
I_TableInsertRow,
I_TableRemoveRow,
I_TableInsertColumn,
I_TableRemoveColumn,
I_SplitCell,
I_JoinCell,
I_CellProperties,




















































































#line 20 "u:/uppsrc\\Draw/iml_header.h"
		COUNT
	};



public:
	static Upp::Iml&   Iml();

	static void        Register__()                { Register("RichEditImg", Iml()); }

	static int         Find(const Upp::String& s);
	static int         Find(const char *s);
	static int         GetCount()                  { return Iml().GetCount(); }
	static Upp::String GetId(int i)                { return Iml().GetId(i); }

	static Upp::Image  Get(int i);
	static Upp::Image  Get(const char *s);
	static Upp::Image  Get(const Upp::String& s);

	static void   Set(int i, const Upp::Image& m);
	static void   Set(const char *s, const Upp::Image& m);

	static void   Reset()                     { Iml().Reset(); }



#line 1 "u:/uppsrc\\RichEdit/RichEdit.iml"
static Upp::Image RightTab() { return Get(I_RightTab); }
static Upp::Image RightTabTrack() { return Get(I_RightTabTrack); }
static Upp::Image LeftTab() { return Get(I_LeftTab); }
static Upp::Image LeftTabTrack() { return Get(I_LeftTabTrack); }
static Upp::Image CenterTab() { return Get(I_CenterTab); }
static Upp::Image CenterTabTrack() { return Get(I_CenterTabTrack); }
static Upp::Image Margin() { return Get(I_Margin); }
static Upp::Image MarginMixed() { return Get(I_MarginMixed); }
static Upp::Image MarginTrack() { return Get(I_MarginTrack); }
static Upp::Image Indent() { return Get(I_Indent); }
static Upp::Image IndentMixed() { return Get(I_IndentMixed); }
static Upp::Image IndentTrack() { return Get(I_IndentTrack); }
static Upp::Image Bold() { return Get(I_Bold); }
static Upp::Image BoldMixed() { return Get(I_BoldMixed); }
static Upp::Image Italic() { return Get(I_Italic); }
static Upp::Image ItalicMixed() { return Get(I_ItalicMixed); }
static Upp::Image Underline() { return Get(I_Underline); }
static Upp::Image UnderlineMixed() { return Get(I_UnderlineMixed); }
static Upp::Image Left() { return Get(I_Left); }
static Upp::Image SuperScript() { return Get(I_SuperScript); }
static Upp::Image SuperScriptMixed() { return Get(I_SuperScriptMixed); }
static Upp::Image SubScript() { return Get(I_SubScript); }
static Upp::Image SubScriptMixed() { return Get(I_SubScriptMixed); }
static Upp::Image Capitals() { return Get(I_Capitals); }
static Upp::Image CapitalsMixed() { return Get(I_CapitalsMixed); }
static Upp::Image Right() { return Get(I_Right); }
static Upp::Image Strikeout() { return Get(I_Strikeout); }
static Upp::Image StrikeoutMixed() { return Get(I_StrikeoutMixed); }
static Upp::Image Center() { return Get(I_Center); }
static Upp::Image Justify() { return Get(I_Justify); }
static Upp::Image bullet() { return Get(I_bullet); }
static Upp::Image boxbullet() { return Get(I_boxbullet); }
static Upp::Image firstnumberbullet() { return Get(I_firstnumberbullet); }
static Upp::Image numberbullet() { return Get(I_numberbullet); }
static Upp::Image print() { return Get(I_print); }
static Upp::Image newpage() { return Get(I_newpage); }
static Upp::Image InkColor() { return Get(I_InkColor); }
static Upp::Image NullInkColor() { return Get(I_NullInkColor); }
static Upp::Image PaperColor() { return Get(I_PaperColor); }
static Upp::Image ColorA() { return Get(I_ColorA); }
static Upp::Image NullPaperColor() { return Get(I_NullPaperColor); }
static Upp::Image ManageStyles() { return Get(I_ManageStyles); }
static Upp::Image AdjustUnits() { return Get(I_AdjustUnits); }
static Upp::Image ParaFormat() { return Get(I_ParaFormat); }
static Upp::Image ToPara() { return Get(I_ToPara); }
static Upp::Image RoundBullet() { return Get(I_RoundBullet); }
static Upp::Image RoundWhiteBullet() { return Get(I_RoundWhiteBullet); }
static Upp::Image BoxBullet() { return Get(I_BoxBullet); }
static Upp::Image BoxWhiteBullet() { return Get(I_BoxWhiteBullet); }
static Upp::Image NoneBullet() { return Get(I_NoneBullet); }
static Upp::Image SpellCheck() { return Get(I_SpellCheck); }
static Upp::Image TextBullet() { return Get(I_TextBullet); }
static Upp::Image FindReplace() { return Get(I_FindReplace); }
static Upp::Image GoTo() { return Get(I_GoTo); }
static Upp::Image InsertTable() { return Get(I_InsertTable); }
static Upp::Image TableProperties() { return Get(I_TableProperties); }
static Upp::Image TableInsertRow() { return Get(I_TableInsertRow); }
static Upp::Image TableRemoveRow() { return Get(I_TableRemoveRow); }
static Upp::Image TableInsertColumn() { return Get(I_TableInsertColumn); }
static Upp::Image TableRemoveColumn() { return Get(I_TableRemoveColumn); }
static Upp::Image SplitCell() { return Get(I_SplitCell); }
static Upp::Image JoinCell() { return Get(I_JoinCell); }
static Upp::Image CellProperties() { return Get(I_CellProperties); }




















































































#line 47 "u:/uppsrc\\Draw/iml_header.h"



};












#line 64 "u:/uppsrc\\Draw/iml_header.h"
#line 11 "u:/uppsrc\\RichEdit/RichEdit.h"

class RichRuler : public FrameCtrl<Ctrl> {
public:
	virtual void FrameLayout(Rect& r);
	virtual void FrameAddSize(Size& sz);
	virtual void Paint(Draw& w);
	virtual void LeftDown(Point p, dword);
	virtual void RightDown(Point p, dword);
	virtual void LeftDouble(Point p, dword);
	virtual void MouseMove(Point p, dword);
	virtual void LeftUp(Point, dword);

public:
	struct Marker {
		int   pos, minpos, maxpos;
		Image image;
		bool  top;
		bool  deletable;

		bool operator!=(const Marker& m) {
			return pos != m.pos || minpos != m.minpos || maxpos != m.maxpos ||
			       !image.IsSame(m.image) || top != m.top || deletable != m.deletable;
		}
		Marker() { top = false; deletable = false; }
	};

private:
	int    x0, pgcx, numbers, marks;
	double grid, numbermul;
	Zoom   zoom;

	int    track, pos;
	int    trackdx;
	int    snap;

	Array<Marker> marker;
	int           tabpos;
	int           tabsize;
	int           newtabalign;

public:
	Callback      WhenLeftDouble;
	Callback      WhenLeftDown;
	Callback      WhenRightDown;
	Callback      WhenBeginTrack;
	Callback      WhenTrack;
	Callback      WhenEndTrack;

	void          SetLayout(int x, int pgcx, Zoom zoom, double grid,
	                        int numbers = 2147483647, double numbermul = 1, int marks = 2147483647,
	                        int snap = 32);

	void          Clear();
	void          Set(int i, const Marker& m);
	void          SetCount(int n);
	int           GetCount() const        { return marker.GetCount(); }
	const Marker& operator[](int i)       { return marker[i]; }

	int           FindMarker(Point p);
	int           GetTrack()              { return track; }
	int           GetPos()                { return pos; }

	void          SetTabs(int pos, int size);

	int           GetNewTabAlign()        { return newtabalign; }

	RichRuler();
	virtual ~RichRuler();
};

enum {
	UNIT_DOT,
	UNIT_POINT,
	UNIT_INCH,
	UNIT_MM,
	UNIT_CM,
};

class UnitEdit : public EditField, public Convert {
public:
	virtual Value GetData() const;
	virtual Value Format(const Value& v) const;
	virtual void  SetData(const Value& v);
	virtual bool  Key(dword key, int repcnt);

private:
	SpinButtons spin;
	int         unit;
	bool        sgn;

	static String AsText(double d, int unit);
	static String DotAsText(int dot, int unit);
	void Spin(int delta);
	void Read(double& q, int& u) const;

public:
	UnitEdit& SetUnit(int _unit)                        { unit = _unit; return *this; }
	void      Set(int _unit, int d)                     { unit = _unit; SetData(d); }
	UnitEdit& WithSgn(bool b = true);

	typedef UnitEdit CLASSNAME;

	UnitEdit();
};

struct FontHeight : public WithDropChoice<EditDouble> {
	virtual bool Key(dword key, int);
};


#line 1 "u:/uppsrc\\CtrlCore/lay.h"







#line 1 "u:/uppsrc\\RichEdit/RichEdit.lay"
struct ParaLayout__layid {};











































struct UnitLayout__layid {};










struct SetStyleLayout__layid {};






struct ObjectSizeLayout__layid {};















struct ParaFormatLayout__layid {};





struct StylesLayout__layid {};






















struct RichFindReplaceLayout__layid {};











struct RichLanguageLayout__layid {};





struct CreateTableLayout__layid {};







struct TablePropertiesLayout__layid {};























struct SplitCellLayout__layid {};








struct CellPropertiesLayout__layid {};






























#line 9 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/uppsrc\\RichEdit/RichEdit.lay"
template<class T> struct WithParaLayout : public T, public ParaLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(488, 320); }
	LabelBox dv___0;
	Switch align;
	LabelBox dv___2;
	Label dv___3;
	UnitEdit before;
	Label dv___5;
	UnitEdit after;
	Label dv___7;
	DropList linespacing;
	LabelBox dv___9;
	Option page;
	Option keep;
	Option keepnext;
	Option orphan;
	LabelBox dv___14;
	Label dv___15;
	UnitEdit lm;
	Label dv___17;
	UnitEdit rm;
	Label dv___19;
	UnitEdit indent;
	Label dv___21;
	DropList bullet;
	LabelBox dv___23;
	ArrayCtrl tabs;
	Label dv___25;
	UnitEdit tabsize;
	LabelBox dv___27;
	Label dv___28;
	EditString before_number;
	Label dv___30;
	EditString after_number;
	Option reset_number;








};

template<class T> struct WithUnitLayout : public T, public UnitLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(244, 144); }
	LabelBox dv___0;
	Switch unit;
	Label dv___2;
	ColorPusher showcodes;
	Label dv___4;
	DropList zoom;
	Button ok;
	Button cancel;
};

template<class T> struct WithSetStyleLayout : public T, public SetStyleLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(216, 280); }
	ArrayCtrl style;
	Button newstyle;
	Button ok;
	Button cancel;
};

template<class T> struct WithObjectSizeLayout : public T, public ObjectSizeLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(290, 102); }
	Label dv___0;
	UnitEdit width;
	Label dv___2;
	UnitEdit height;
	Label dv___4;
	EditDoubleNotNullSpin widthp;
	Label dv___6;
	EditDoubleNotNullSpin heightp;
	Label dv___8;
	UnitEdit ydelta;
	Option keepratio;
	Button ok;
	Button cancel;
};

template<class T> struct WithParaFormatLayout : public T, public ParaFormatLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(488, 352); }

	Button ok;
	Button cancel;
};

template<class T> struct WithStylesLayout : public T, public StylesLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(700, 464); }
	ArrayCtrl list;

	Label dv___2;
	DropList face;
	Label dv___4;

	Option italic;
	Option bold;
	Option underline;
	Option strikeout;
	Option capitals;
	Label dv___11;
	ColorPusher ink;
	Label dv___13;
	ColorPusher paper;
	Label dv___15;
	DropList next;
	Button ok;
	Button cancel;
	LabelBox dv___19;
};

template<class T> struct WithRichFindReplaceLayout : public T, public RichFindReplaceLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(264, 128); }
	Label dv___0;
	WithDropChoice<EditString> find;
	Label dv___2;
	WithDropChoice<EditString> replace;
	Option wholeword;
	Option ignorecase;
	Button amend;
	Button ok;
	Button cancel;
};

template<class T> struct WithRichLanguageLayout : public T, public RichLanguageLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(148, 68); }
	LNGCtrl lang;
	Button ok;
	Button cancel;
};

template<class T> struct WithCreateTableLayout : public T, public CreateTableLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(164, 88); }
	Option header;
	Label dv___1;
	EditIntSpin columns;
	Button ok;
	Button cancel;
};

template<class T> struct WithTablePropertiesLayout : public T, public TablePropertiesLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(300, 168); }
	Label dv___0;
	UnitEdit before;
	Label dv___2;
	UnitEdit after;
	Label dv___4;
	UnitEdit lm;
	Label dv___6;
	UnitEdit rm;
	Label dv___8;
	UnitEdit frame;
	Label dv___10;
	ColorPusher framecolor;
	Label dv___12;
	UnitEdit grid;
	Label dv___14;
	ColorPusher gridcolor;
	Option equalize;
	EditString ratios;
	Button destroy;
	Button ok;
	Button cancel;
};

template<class T> struct WithSplitCellLayout : public T, public SplitCellLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(148, 92); }
	Label dv___0;
	EditIntSpin cx;
	Label dv___2;
	EditIntSpin cy;
	Button ok;
	Button cancel;
};

template<class T> struct WithCellPropertiesLayout : public T, public CellPropertiesLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(300, 260); }
	LabelBox dv___0;
	Label dv___1;
	UnitEdit leftb;
	Label dv___3;
	UnitEdit rightb;
	Label dv___5;
	UnitEdit topb;
	Label dv___7;
	UnitEdit bottomb;
	LabelBox dv___9;
	Label dv___10;
	UnitEdit leftm;
	Label dv___12;
	UnitEdit rightm;
	Label dv___14;
	UnitEdit topm;
	Label dv___16;
	UnitEdit bottomm;
	LabelBox dv___18;
	Switch align;
	Label dv___20;
	ColorPusher border;
	Label dv___22;
	ColorPusher color;
	Label dv___24;
	UnitEdit minheight;
	Option keep;
	Button ok;
	Button cancel;
};
#line 23 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/uppsrc\\RichEdit/RichEdit.lay"
template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, ParaLayout__layid&) { parent.LayoutId("ParaLayout");
	layout.dv___0.SetLabel(t_GetLngString("Alignment")).LeftPosZ(8, 100).TopPosZ(8, 88); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.align.SetLabel(t_GetLngString("Left\nCenter\nRight\nJustify")).LeftPosZ(16, 84).TopPosZ(24, 68); layout.align.LayoutId("align"); parent.Add(layout.align);
	layout.dv___2.SetLabel(t_GetLngString("Spacing")).LeftPosZ(116, 176).TopPosZ(8, 88); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.dv___3.SetLabel(t_GetLngString("Before")).LeftPosZ(128, 88).TopPosZ(24, 19); layout.dv___3.LayoutId("dv___3"); parent.Add(layout.dv___3);
	layout.before.LeftPosZ(216, 68).TopPosZ(24, 19); layout.before.LayoutId("before"); parent.Add(layout.before);
	layout.dv___5.SetLabel(t_GetLngString("After")).LeftPosZ(128, 88).TopPosZ(48, 19); layout.dv___5.LayoutId("dv___5"); parent.Add(layout.dv___5);
	layout.after.LeftPosZ(216, 68).TopPosZ(48, 19); layout.after.LayoutId("after"); parent.Add(layout.after);
	layout.dv___7.SetLabel(t_GetLngString("Line spacing")).LeftPosZ(128, 88).TopPosZ(72, 19); layout.dv___7.LayoutId("dv___7"); parent.Add(layout.dv___7);
	layout.linespacing.LeftPosZ(216, 68).TopPosZ(72, 19); layout.linespacing.LayoutId("linespacing"); parent.Add(layout.linespacing);
	layout.dv___9.SetLabel(t_GetLngString("Text flow")).LeftPosZ(300, 180).TopPosZ(8, 88); layout.dv___9.LayoutId("dv___9"); parent.Add(layout.dv___9);
	layout.page.SetLabel(t_GetLngString("Break page before")).LeftPosZ(308, 164).TopPosZ(24, 16); layout.page.LayoutId("page"); parent.Add(layout.page);
	layout.keep.SetLabel(t_GetLngString("Keep together")).LeftPosZ(308, 164).TopPosZ(40, 16); layout.keep.LayoutId("keep"); parent.Add(layout.keep);
	layout.keepnext.SetLabel(t_GetLngString("Keep with next")).LeftPosZ(308, 164).TopPosZ(56, 16); layout.keepnext.LayoutId("keepnext"); parent.Add(layout.keepnext);
	layout.orphan.SetLabel(t_GetLngString("Allow orphans")).LeftPosZ(308, 164).TopPosZ(72, 16); layout.orphan.LayoutId("orphan"); parent.Add(layout.orphan);
	layout.dv___14.SetLabel(t_GetLngString("Indentation")).LeftPosZ(8, 176).TopPosZ(104, 124); layout.dv___14.LayoutId("dv___14"); parent.Add(layout.dv___14);
	layout.dv___15.SetLabel(t_GetLngString("Left margin")).LeftPosZ(16, 88).TopPosZ(124, 19); layout.dv___15.LayoutId("dv___15"); parent.Add(layout.dv___15);
	layout.lm.LeftPosZ(108, 68).TopPosZ(124, 19); layout.lm.LayoutId("lm"); parent.Add(layout.lm);
	layout.dv___17.SetLabel(t_GetLngString("ParaLayout_rm_1_SetLabel\aRight margin")).LeftPosZ(16, 88).TopPosZ(148, 19); layout.dv___17.LayoutId("dv___17"); parent.Add(layout.dv___17);
	layout.rm.LeftPosZ(108, 68).TopPosZ(148, 19); layout.rm.LayoutId("rm"); parent.Add(layout.rm);
	layout.dv___19.SetLabel(t_GetLngString("First line")).LeftPosZ(16, 88).TopPosZ(172, 19); layout.dv___19.LayoutId("dv___19"); parent.Add(layout.dv___19);
	layout.indent.LeftPosZ(108, 68).TopPosZ(172, 19); layout.indent.LayoutId("indent"); parent.Add(layout.indent);
	layout.dv___21.SetLabel(t_GetLngString("Bullet")).LeftPosZ(16, 104).TopPosZ(196, 24); layout.dv___21.LayoutId("dv___21"); parent.Add(layout.dv___21);
	layout.bullet.LeftPosZ(124, 52).TopPosZ(196, 24); layout.bullet.LayoutId("bullet"); parent.Add(layout.bullet);
	layout.dv___23.SetLabel(t_GetLngString("Tabs")).LeftPosZ(192, 288).TopPosZ(104, 124); layout.dv___23.LayoutId("dv___23"); parent.Add(layout.dv___23);
	layout.tabs.AutoHideSb(true).LeftPosZ(200, 272).TopPosZ(120, 72); layout.tabs.LayoutId("tabs"); parent.Add(layout.tabs);
	layout.dv___25.SetLabel(t_GetLngString("Default tab size")).LeftPosZ(200, 196).TopPosZ(200, 20); layout.dv___25.LayoutId("dv___25"); parent.Add(layout.dv___25);
	layout.tabsize.LeftPosZ(404, 68).TopPosZ(200, 19); layout.tabsize.LayoutId("tabsize"); parent.Add(layout.tabsize);
	layout.dv___27.SetLabel(t_GetLngString("Numbering")).LeftPosZ(8, 472).TopPosZ(236, 76); layout.dv___27.LayoutId("dv___27"); parent.Add(layout.dv___27);
	layout.dv___28.SetLabel(t_GetLngString("Before number")).LeftPosZ(16, 100).TopPosZ(252, 20); layout.dv___28.LayoutId("dv___28"); parent.Add(layout.dv___28);
	layout.before_number.LeftPosZ(116, 72).TopPosZ(252, 19); layout.before_number.LayoutId("before_number"); parent.Add(layout.before_number);
	layout.dv___30.SetLabel(t_GetLngString("After number")).LeftPosZ(208, 100).TopPosZ(252, 20); layout.dv___30.LayoutId("dv___30"); parent.Add(layout.dv___30);
	layout.after_number.LeftPosZ(308, 72).TopPosZ(252, 19); layout.after_number.LayoutId("after_number"); parent.Add(layout.after_number);
	layout.reset_number.SetLabel(t_GetLngString("Reset")).LeftPosZ(400, 72).TopPosZ(252, 20); layout.reset_number.LayoutId("reset_number"); parent.Add(layout.reset_number);
	uts.n[0].LeftPosZ(16, 54).TopPosZ(284, 19); uts.n[0].LayoutId("n[0]"); parent.Add(uts.n[0]);
	uts.n[1].LeftPosZ(72, 54).TopPosZ(284, 19); uts.n[1].LayoutId("n[1]"); parent.Add(uts.n[1]);
	uts.n[2].LeftPosZ(128, 54).TopPosZ(284, 19); uts.n[2].LayoutId("n[2]"); parent.Add(uts.n[2]);
	uts.n[3].LeftPosZ(184, 54).TopPosZ(284, 19); uts.n[3].LayoutId("n[3]"); parent.Add(uts.n[3]);
	uts.n[4].LeftPosZ(240, 54).TopPosZ(284, 19); uts.n[4].LayoutId("n[4]"); parent.Add(uts.n[4]);
	uts.n[5].LeftPosZ(296, 54).TopPosZ(284, 19); uts.n[5].LayoutId("n[5]"); parent.Add(uts.n[5]);
	uts.n[6].LeftPosZ(352, 54).TopPosZ(284, 19); uts.n[6].LayoutId("n[6]"); parent.Add(uts.n[6]);
	uts.n[7].LeftPosZ(408, 54).TopPosZ(284, 19); uts.n[7].LayoutId("n[7]"); parent.Add(uts.n[7]);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, UnitLayout__layid&) { parent.LayoutId("UnitLayout");
	layout.dv___0.SetLabel(t_GetLngString("Units")).LeftPosZ(8, 228).TopPosZ(4, 40); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.unit.SetLabel(t_GetLngString("dot\npoint\ninch\nmm\ncm")).LeftPosZ(16, 216).TopPosZ(20, 16); layout.unit.LayoutId("unit"); parent.Add(layout.unit);
	layout.dv___2.SetLabel(t_GetLngString("Reveal codes")).LeftPosZ(12, 76).TopPosZ(55, 13); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.showcodes.LeftPosZ(92, 144).TopPosZ(52, 19); layout.showcodes.LayoutId("showcodes"); parent.Add(layout.showcodes);
	layout.dv___4.SetLabel(t_GetLngString("Zoom")).LeftPosZ(12, 76).TopPosZ(80, 19); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.zoom.LeftPosZ(92, 144).TopPosZ(80, 19); layout.zoom.LayoutId("zoom"); parent.Add(layout.zoom);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(104, 64).TopPosZ(112, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).LeftPosZ(172, 64).TopPosZ(112, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, SetStyleLayout__layid&) { parent.LayoutId("SetStyleLayout");
	layout.style.AutoHideSb(true).LeftPosZ(8, 200).TopPosZ(8, 232); layout.style.LayoutId("style"); parent.Add(layout.style);
	layout.newstyle.SetLabel(t_GetLngString("New")).LeftPosZ(8, 64).TopPosZ(248, 24); layout.newstyle.LayoutId("newstyle"); parent.Add(layout.newstyle);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(76, 64).TopPosZ(248, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).LeftPosZ(144, 64).TopPosZ(248, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, ObjectSizeLayout__layid&) { parent.LayoutId("ObjectSizeLayout");
	layout.dv___0.SetLabel(t_GetLngString("Wi&dth:")).LeftPosZ(4, 54).TopPosZ(4, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.width.LeftPosZ(58, 80).TopPosZ(4, 19); layout.width.LayoutId("width"); parent.Add(layout.width);
	layout.dv___2.SetLabel(t_GetLngString("H&eight:")).LeftPosZ(148, 58).TopPosZ(4, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.height.LeftPosZ(206, 80).TopPosZ(4, 19); layout.height.LayoutId("height"); parent.Add(layout.height);
	layout.dv___4.SetLabel(t_GetLngString("&Width (%):")).LeftPosZ(4, 54).TopPosZ(26, 19); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.widthp.LeftPosZ(58, 80).TopPosZ(26, 19); layout.widthp.LayoutId("widthp"); parent.Add(layout.widthp);
	layout.dv___6.SetLabel(t_GetLngString("Height (%):")).LeftPosZ(148, 58).TopPosZ(26, 19); layout.dv___6.LayoutId("dv___6"); parent.Add(layout.dv___6);
	layout.heightp.LeftPosZ(206, 80).TopPosZ(26, 19); layout.heightp.LayoutId("heightp"); parent.Add(layout.heightp);
	layout.dv___8.SetLabel(t_GetLngString("&Descent:")).LeftPosZ(148, 58).TopPosZ(48, 19); layout.dv___8.LayoutId("dv___8"); parent.Add(layout.dv___8);
	layout.ydelta.LeftPosZ(206, 80).TopPosZ(48, 19); layout.ydelta.LayoutId("ydelta"); parent.Add(layout.ydelta);
	layout.keepratio.SetLabel(t_GetLngString("Keep aspect ratio")).LeftPosZ(4, 104).BottomPosZ(6, 18); layout.keepratio.LayoutId("keepratio"); parent.Add(layout.keepratio);
	layout.ok.SetLabel(t_GetLngString("OK")).RightPosZ(78, 64).BottomPosZ(4, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).RightPosZ(4, 64).BottomPosZ(4, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, ParaFormatLayout__layid&) { parent.LayoutId("ParaFormatLayout");
	uts.para.LeftPosZ(0, 488).TopPosZ(0, 320); uts.para.LayoutId("para"); parent.Add(uts.para);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(348, 64).TopPosZ(320, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).LeftPosZ(416, 64).TopPosZ(320, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, StylesLayout__layid&) { parent.LayoutId("StylesLayout");
	layout.list.AutoHideSb(true).LeftPosZ(8, 196).TopPosZ(8, 448); layout.list.LayoutId("list"); parent.Add(layout.list);
	uts.para.LeftPosZ(204, 496).TopPosZ(0, 320); uts.para.LayoutId("para"); parent.Add(uts.para);
	layout.dv___2.SetLabel(t_GetLngString("Font")).LeftPosZ(224, 52).TopPosZ(348, 20); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.face.LeftPosZ(280, 172).TopPosZ(349, 19); layout.face.LayoutId("face"); parent.Add(layout.face);
	layout.dv___4.SetLabel(t_GetLngString("Height")).LeftPosZ(476, 104).TopPosZ(348, 20); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	uts.height.LeftPosZ(580, 64).TopPosZ(348, 19); uts.height.LayoutId("height"); parent.Add(uts.height);
	layout.italic.SetLabel(t_GetLngString("Italic")).LeftPosZ(224, 64).TopPosZ(377, 18); layout.italic.LayoutId("italic"); parent.Add(layout.italic);
	layout.bold.SetLabel(t_GetLngString("Bold")).LeftPosZ(224, 64).TopPosZ(396, 18); layout.bold.LayoutId("bold"); parent.Add(layout.bold);
	layout.underline.SetLabel(t_GetLngString("Underline")).LeftPosZ(292, 76).TopPosZ(376, 18); layout.underline.LayoutId("underline"); parent.Add(layout.underline);
	layout.strikeout.SetLabel(t_GetLngString("Strikeout")).LeftPosZ(292, 74).TopPosZ(396, 18); layout.strikeout.LayoutId("strikeout"); parent.Add(layout.strikeout);
	layout.capitals.SetLabel(t_GetLngString("Capitals")).LeftPosZ(372, 88).TopPosZ(376, 18); layout.capitals.LayoutId("capitals"); parent.Add(layout.capitals);
	layout.dv___11.SetLabel(t_GetLngString("Ink")).LeftPosZ(476, 104).TopPosZ(372, 20); layout.dv___11.LayoutId("dv___11"); parent.Add(layout.dv___11);
	layout.ink.LeftPosZ(580, 92).TopPosZ(372, 19); layout.ink.LayoutId("ink"); parent.Add(layout.ink);
	layout.dv___13.SetLabel(t_GetLngString("Paper")).LeftPosZ(476, 104).TopPosZ(396, 20); layout.dv___13.LayoutId("dv___13"); parent.Add(layout.dv___13);
	layout.paper.LeftPosZ(580, 92).TopPosZ(396, 19); layout.paper.LayoutId("paper"); parent.Add(layout.paper);
	layout.dv___15.SetLabel(t_GetLngString("Style of next paragraph")).LeftPosZ(212, 152).TopPosZ(436, 20); layout.dv___15.LayoutId("dv___15"); parent.Add(layout.dv___15);
	layout.next.LeftPosZ(368, 132).TopPosZ(436, 19); layout.next.LayoutId("next"); parent.Add(layout.next);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(560, 64).TopPosZ(432, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).LeftPosZ(628, 64).TopPosZ(432, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
	layout.dv___19.SetLabel(t_GetLngString("Character")).LeftPosZ(212, 472).TopPosZ(328, 96); layout.dv___19.LayoutId("dv___19"); parent.Add(layout.dv___19);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, RichFindReplaceLayout__layid&) { parent.LayoutId("RichFindReplaceLayout");
	layout.dv___0.SetLabel(t_GetLngString("&Find:")).LeftPosZ(4, 46).TopPosZ(4, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.find.HSizePosZ(50, 4).TopPosZ(4, 19); layout.find.LayoutId("find"); parent.Add(layout.find);
	layout.dv___2.SetLabel(t_GetLngString("&Replace:")).LeftPosZ(4, 46).TopPosZ(28, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.replace.HSizePosZ(50, 4).TopPosZ(28, 19); layout.replace.LayoutId("replace"); parent.Add(layout.replace);
	layout.wholeword.SetLabel(t_GetLngString("&Whole word")).LeftPosZ(4, 256).TopPosZ(56, 18); layout.wholeword.LayoutId("wholeword"); parent.Add(layout.wholeword);
	layout.ignorecase.SetLabel(t_GetLngString("&Ignore case")).LeftPosZ(4, 256).TopPosZ(76, 18); layout.ignorecase.LayoutId("ignorecase"); parent.Add(layout.ignorecase);
	layout.amend.SetLabel(t_GetLngString("&Replace")).LeftPosZ(4, 72).BottomPosZ(4, 24); layout.amend.LayoutId("amend"); parent.Add(layout.amend);
	layout.ok.SetLabel(t_GetLngString("Find")).RightPosZ(72, 64).BottomPosZ(4, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).RightPosZ(4, 64).BottomPosZ(4, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, RichLanguageLayout__layid&) { parent.LayoutId("RichLanguageLayout");
	layout.lang.LeftPosZ(8, 128).TopPosZ(8, 20); layout.lang.LayoutId("lang"); parent.Add(layout.lang);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(8, 64).TopPosZ(36, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).LeftPosZ(76, 64).TopPosZ(36, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, CreateTableLayout__layid&) { parent.LayoutId("CreateTableLayout");
	layout.header.SetLabel(t_GetLngString("Header")).LeftPosZ(8, 128).TopPosZ(8, 15); layout.header.LayoutId("header"); parent.Add(layout.header);
	layout.dv___1.SetLabel(t_GetLngString("Number of columns")).LeftPosZ(8, 100).TopPosZ(28, 19); layout.dv___1.LayoutId("dv___1"); parent.Add(layout.dv___1);
	layout.columns.Min(1).Max(20).NotNull(true).LeftPosZ(112, 44).TopPosZ(28, 19); layout.columns.LayoutId("columns"); parent.Add(layout.columns);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(24, 64).TopPosZ(56, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).LeftPosZ(92, 64).TopPosZ(56, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, TablePropertiesLayout__layid&) { parent.LayoutId("TablePropertiesLayout");
	layout.dv___0.SetLabel(t_GetLngString("Before")).LeftPosZ(8, 60).TopPosZ(8, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.before.LeftPosZ(72, 68).TopPosZ(8, 19); layout.before.LayoutId("before"); parent.Add(layout.before);
	layout.dv___2.SetLabel(t_GetLngString("After")).LeftPosZ(160, 60).TopPosZ(8, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.after.LeftPosZ(224, 68).TopPosZ(8, 19); layout.after.LayoutId("after"); parent.Add(layout.after);
	layout.dv___4.SetLabel(t_GetLngString("Left margin")).LeftPosZ(8, 60).TopPosZ(32, 19); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.lm.LeftPosZ(72, 68).TopPosZ(32, 20); layout.lm.LayoutId("lm"); parent.Add(layout.lm);
	layout.dv___6.SetLabel(t_GetLngString("Right margin")).LeftPosZ(160, 60).TopPosZ(32, 19); layout.dv___6.LayoutId("dv___6"); parent.Add(layout.dv___6);
	layout.rm.LeftPosZ(224, 68).TopPosZ(32, 19); layout.rm.LayoutId("rm"); parent.Add(layout.rm);
	layout.dv___8.SetLabel(t_GetLngString("Frame")).LeftPosZ(8, 60).TopPosZ(56, 19); layout.dv___8.LayoutId("dv___8"); parent.Add(layout.dv___8);
	layout.frame.LeftPosZ(72, 68).TopPosZ(56, 19); layout.frame.LayoutId("frame"); parent.Add(layout.frame);
	layout.dv___10.SetLabel(t_GetLngString("color")).LeftPosZ(160, 56).TopPosZ(56, 19); layout.dv___10.LayoutId("dv___10"); parent.Add(layout.dv___10);
	layout.framecolor.LeftPosZ(224, 68).TopPosZ(56, 19); layout.framecolor.LayoutId("framecolor"); parent.Add(layout.framecolor);
	layout.dv___12.SetLabel(t_GetLngString("Grid")).LeftPosZ(8, 60).TopPosZ(80, 19); layout.dv___12.LayoutId("dv___12"); parent.Add(layout.dv___12);
	layout.grid.LeftPosZ(72, 68).TopPosZ(80, 19); layout.grid.LayoutId("grid"); parent.Add(layout.grid);
	layout.dv___14.SetLabel(t_GetLngString("color")).LeftPosZ(160, 56).TopPosZ(80, 19); layout.dv___14.LayoutId("dv___14"); parent.Add(layout.dv___14);
	layout.gridcolor.LeftPosZ(224, 68).TopPosZ(80, 19); layout.gridcolor.LayoutId("gridcolor"); parent.Add(layout.gridcolor);
	layout.equalize.SetLabel(t_GetLngString("Equalize")).LeftPosZ(8, 64).TopPosZ(108, 20); layout.equalize.LayoutId("equalize"); parent.Add(layout.equalize);
	layout.ratios.LeftPosZ(72, 220).TopPosZ(108, 19); layout.ratios.LayoutId("ratios"); parent.Add(layout.ratios);
	layout.destroy.SetLabel(t_GetLngString("Remove table")).LeftPosZ(8, 96).TopPosZ(136, 24); layout.destroy.LayoutId("destroy"); parent.Add(layout.destroy);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(160, 64).TopPosZ(136, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).LeftPosZ(228, 64).TopPosZ(136, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, SplitCellLayout__layid&) { parent.LayoutId("SplitCellLayout");
	layout.dv___0.SetLabel(t_GetLngString("Horizontal")).LeftPosZ(8, 60).TopPosZ(8, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.cx.LeftPosZ(76, 44).TopPosZ(8, 19); layout.cx.LayoutId("cx"); parent.Add(layout.cx);
	layout.dv___2.SetLabel(t_GetLngString("Vertical")).LeftPosZ(8, 60).TopPosZ(32, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.cy.LeftPosZ(76, 44).TopPosZ(32, 19); layout.cy.LayoutId("cy"); parent.Add(layout.cy);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(8, 64).TopPosZ(60, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).LeftPosZ(76, 64).TopPosZ(60, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, CellPropertiesLayout__layid&) { parent.LayoutId("CellPropertiesLayout");
	layout.dv___0.SetLabel(t_GetLngString("Borders")).LeftPosZ(12, 132).TopPosZ(8, 116); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.dv___1.SetLabel(t_GetLngString("Left")).LeftPosZ(20, 40).TopPosZ(24, 19); layout.dv___1.LayoutId("dv___1"); parent.Add(layout.dv___1);
	layout.leftb.LeftPosZ(64, 68).TopPosZ(24, 19); layout.leftb.LayoutId("leftb"); parent.Add(layout.leftb);
	layout.dv___3.SetLabel(t_GetLngString("Right")).LeftPosZ(20, 40).TopPosZ(48, 19); layout.dv___3.LayoutId("dv___3"); parent.Add(layout.dv___3);
	layout.rightb.LeftPosZ(64, 68).TopPosZ(48, 19); layout.rightb.LayoutId("rightb"); parent.Add(layout.rightb);
	layout.dv___5.SetLabel(t_GetLngString("Top")).LeftPosZ(20, 40).TopPosZ(72, 19); layout.dv___5.LayoutId("dv___5"); parent.Add(layout.dv___5);
	layout.topb.LeftPosZ(64, 68).TopPosZ(72, 19); layout.topb.LayoutId("topb"); parent.Add(layout.topb);
	layout.dv___7.SetLabel(t_GetLngString("Bottom")).LeftPosZ(20, 40).TopPosZ(96, 19); layout.dv___7.LayoutId("dv___7"); parent.Add(layout.dv___7);
	layout.bottomb.LeftPosZ(64, 68).TopPosZ(96, 19); layout.bottomb.LayoutId("bottomb"); parent.Add(layout.bottomb);
	layout.dv___9.SetLabel(t_GetLngString("Margins")).LeftPosZ(152, 144).TopPosZ(8, 116); layout.dv___9.LayoutId("dv___9"); parent.Add(layout.dv___9);
	layout.dv___10.SetLabel(t_GetLngString("Left")).LeftPosZ(160, 52).TopPosZ(24, 19); layout.dv___10.LayoutId("dv___10"); parent.Add(layout.dv___10);
	layout.leftm.LeftPosZ(216, 68).TopPosZ(24, 19); layout.leftm.LayoutId("leftm"); parent.Add(layout.leftm);
	layout.dv___12.SetLabel(t_GetLngString("Right")).LeftPosZ(160, 52).TopPosZ(48, 19); layout.dv___12.LayoutId("dv___12"); parent.Add(layout.dv___12);
	layout.rightm.LeftPosZ(216, 68).TopPosZ(48, 19); layout.rightm.LayoutId("rightm"); parent.Add(layout.rightm);
	layout.dv___14.SetLabel(t_GetLngString("Top")).LeftPosZ(160, 52).TopPosZ(72, 19); layout.dv___14.LayoutId("dv___14"); parent.Add(layout.dv___14);
	layout.topm.LeftPosZ(216, 68).TopPosZ(72, 19); layout.topm.LayoutId("topm"); parent.Add(layout.topm);
	layout.dv___16.SetLabel(t_GetLngString("Bottom")).LeftPosZ(160, 52).TopPosZ(96, 19); layout.dv___16.LayoutId("dv___16"); parent.Add(layout.dv___16);
	layout.bottomm.LeftPosZ(216, 68).TopPosZ(96, 19); layout.bottomm.LayoutId("bottomm"); parent.Add(layout.bottomm);
	layout.dv___18.SetLabel(t_GetLngString("Align")).LeftPosZ(12, 132).TopPosZ(128, 76); layout.dv___18.LayoutId("dv___18"); parent.Add(layout.dv___18);
	layout.align.SetLabel(t_GetLngString("Top\nCenter\nBottom")).LeftPosZ(20, 72).TopPosZ(148, 52); layout.align.LayoutId("align"); parent.Add(layout.align);
	layout.dv___20.SetLabel(t_GetLngString("Border")).LeftPosZ(156, 76).TopPosZ(156, 19); layout.dv___20.LayoutId("dv___20"); parent.Add(layout.dv___20);
	layout.border.LeftPosZ(232, 64).TopPosZ(156, 19); layout.border.LayoutId("border"); parent.Add(layout.border);
	layout.dv___22.SetLabel(t_GetLngString("Background")).LeftPosZ(156, 76).TopPosZ(180, 19); layout.dv___22.LayoutId("dv___22"); parent.Add(layout.dv___22);
	layout.color.LeftPosZ(232, 64).TopPosZ(180, 19); layout.color.LayoutId("color"); parent.Add(layout.color);
	layout.dv___24.SetLabel(t_GetLngString("Minimal height")).LeftPosZ(156, 76).TopPosZ(132, 19); layout.dv___24.LayoutId("dv___24"); parent.Add(layout.dv___24);
	layout.minheight.LeftPosZ(232, 64).TopPosZ(132, 19); layout.minheight.LayoutId("minheight"); parent.Add(layout.minheight);
	layout.keep.SetLabel(t_GetLngString("Keep with next line")).LeftPosZ(12, 284).TopPosZ(212, 19); layout.keep.LayoutId("keep"); parent.Add(layout.keep);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(164, 64).TopPosZ(232, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).LeftPosZ(232, 64).TopPosZ(232, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};
#line 37 "u:/uppsrc\\CtrlCore/lay.h"







#line 122 "u:/uppsrc\\RichEdit/RichEdit.h"

class RichEdit : public Ctrl, private TextArrayOps {
public:
	virtual void  Layout();
	virtual void  Paint(Draw& w);
	virtual bool  Key(dword key, int count);
	virtual void  LeftDown(Point p, dword flags);
	virtual void  MiddleDown(Point p, dword flags);
	virtual void  LeftUp(Point p, dword flags);
	virtual void  LeftDrag(Point p, dword flags);
	virtual void  RightDown(Point p, dword flags);
	virtual void  LeftDouble(Point p, dword flags);
	virtual void  LeftTriple(Point p, dword flags);
	virtual void  MouseMove(Point p, dword flags);
	virtual void  LeftRepeat(Point p, dword flags);
	virtual void  MouseWheel(Point p, int zdelta, dword keyflags);
	virtual void  CancelMode();
	virtual Image CursorImage(Point p, dword flags);
	virtual Value GetData() const;
	virtual void  SetData(const Value& v);
	virtual void  Serialize(Stream& s);
	virtual void  DragAndDrop(Point p, PasteClip& d);
	virtual void  DragRepeat(Point p);
	virtual void  DragLeave();
	virtual String GetSelectionData(const String& fmt) const;


private:
	Size                     p_size;
	bool                     sizetracking;
	ScrollBar                sb;
	Scroller                 scroller;
	RichRuler                ruler;
	RichText                 text;
	RichText::FormatInfo     formatinfo;
	int                      cursor, anchor;
	RichCaret                cursorc;
	RichPos                  cursorp;
	RichPos                  anchorp;
	int                      tablesel;
	Rect                     cells;
	int                      gx;
	int                      oselh, osell;
	int                      objectpos;
	Rect                     objectrect;
	RichHotPos               tabmove;
	int                      mpos;
	int                      undosteps;
	Rect                     dropcaret;
	bool                     selclick;
	DropList                 face;
	FontHeight               height;
	DataPusher               hyperlink;
	DataPusher               label;
	DataPusher               indexentry;
	FrameRight<Button>       gotolabel, gotoentry;
	MultiButton::SubButton  *setstyle;
	PopUpTable               gototable;
	ColorButton              ink, paper;
	ToolButton               adjustunits;
	DropList                 style;
	DropList                 language;
	Size                     pagesz;
	String                   footer;
	bool                     nolinks;
	bool                     overwrite;
	bool                     useraction, modified;
	static int               fixedlang;

	WithRichFindReplaceLayout<TopWindow> findreplace;

	bool                     found, notfoundfw;

	VectorMap<String, Value> vars;

	int                      unit;
	Color                    showcodes;
	int                      zoom;
	bool                     spellcheck;
	bool                     paintcarect;

	int                      undoserial;
	bool                     incundoserial;

	static int fh[];

	struct UndoRec {
		int     serial;
		int     cursor;

		virtual void     Apply(RichText& txt) = 0;
		virtual UndoRec *GetRedo(const RichText& txt) = 0;

		UndoRec *Serial(int s) { serial = s; return this; }

		virtual ~UndoRec() {}
	};

	struct UndoInsert : UndoRec {
		int                  pos;
		int                  length;
		bool                 typing;

		virtual void     Apply(RichText& txt);
		virtual UndoRec *GetRedo(const RichText& txt);

		UndoInsert(int pos, int length, bool typing = false);
	};

	struct UndoRemove : UndoRec {
		int                  pos;
		RichText             text;

		virtual void     Apply(RichText& txt);
		virtual UndoRec *GetRedo(const RichText& txt);

		UndoRemove(const RichText& txt, int pos, int length);
	};

	struct UndoFormat : UndoRec {
		int                 pos;
		int                 length;
		RichText::Formating format;

		virtual void     Apply(RichText& txt);
		virtual UndoRec *GetRedo(const RichText& txt);

		UndoFormat(const RichText& txt, int pos, int length);
	};

	struct UndoStyle : UndoRec {
		Uuid                 id;
		RichStyle            style;

		virtual void     Apply(RichText& txt);
		virtual UndoRec *GetRedo(const RichText& txt);

		UndoStyle(const RichText& txt, const Uuid& id);
	};

	struct UndoStyles : UndoRec {
		RichStyles           styles;

		virtual void     Apply(RichText& txt);
		virtual UndoRec *GetRedo(const RichText& txt);

		UndoStyles(const RichText& txt);
	};

	struct UndoTableFormat : UndoRec {
		int                 table;
		RichTable::Format   format;

		virtual void     Apply(RichText& txt);
		virtual UndoRec *GetRedo(const RichText& txt);

		UndoTableFormat(const RichText& txt, int table);
	};

	struct UndoCreateTable : UndoRec {
		int              table;

		virtual void     Apply(RichText& txt);
		virtual UndoRec *GetRedo(const RichText& txt);

		UndoCreateTable(int table) : table(table) {}
	};

	struct UndoDestroyTable : UndoRec {
		int              pos;
		RichTable        table;

		virtual void     Apply(RichText& txt);
		virtual UndoRec *GetRedo(const RichText& txt);

		UndoDestroyTable(const RichText& txt, int pos);
	};

	struct UndoRemoveParaSpecial : UndoRec {
		int              table;
		bool             before;
		RichPara::Format format;

		virtual void     Apply(RichText& txt);
		virtual UndoRec *GetRedo(const RichText& txt);

		UndoRemoveParaSpecial(const RichText& txt, int table, bool before);
	};

	struct UndoInsertParaSpecial : UndoRec {
		int              table;
		bool             before;

		virtual void     Apply(RichText& txt);
		virtual UndoRec *GetRedo(const RichText& txt);

		UndoInsertParaSpecial(int table, bool before) : table(table), before(before) {}
	};

	struct UndoTable : UndoRec {
		int             table;
		RichTable       copy;

		virtual void     Apply(RichText& txt);
		virtual UndoRec *GetRedo(const RichText& txt);

		UndoTable(const RichText& txt, int table);
	};

	BiArray<UndoRec> undo;
	Array<UndoRec>   redo;

	Rect       GetTextRect() const;
	Size       GetZoomedPage() const;
	int        GetPosY(PageY py) const;
	void       GetPagePoint(Point p, PageY& py, int& x);
	int        GetX(int x);
	int        GetSnapX(int x);
	PageY      GetPageY(int y) const;
	int        GetNearestPos(int x, PageY py);
	void       SetSb();
	void       Scroll();
	Rect       PlaceCaret();
	void       FinishNF();
	void       Finish();
	void       ReadFormat();
	void       ShowFormat();
	int        GetMousePos(Point p);
	RichHotPos GetHotPos(Point p);
	int        GetHotSpot(Point p) const;
	Rect       GetObjectRect(int pos) const;
	void       FixObjectRect();

	void       SetObjectPos(int pos);
	void       AdjustObjectSize();
	void       SetObjectPercent(int p);
	void       SetObjectYDelta(int pt);
	void       SetFace();
	void       SetHeight();

	bool       SelBeg(bool select);
	bool       SelEnd(bool select);
	void       SelCell(int dx, int dy);

	void       Limit(int& pos, int& count);
	bool       InvalidRange(int c1, int c2);
	void       NextUndo()                 { undoserial += incundoserial; incundoserial = false; }
	void       AddUndo(UndoRec *undo);

	void       BeginRulerTrack();
	void       RulerTrack();
	void       IndentMark();
	void       HighLightTab(int r);
	void       TabAdd(int align);
	void       AddTab();
	void       TabMenu();

	void       Hyperlink();
	void       Label();
	void       IndexEntry();
	void       GotoLbl();
	void       GotoEntry();
	void       GotoType(int type, Ctrl& l);
	void       Goto();

	void       SetInk();
	void       SetPaper();
	void       SetLanguage();
	void       Language();
	void       SetupLanguage( Vector<int>& lng);

	void       SetBullet(int bullet);

	void       SetupRuler();

	void       ReadStyles();

	void       SetStyle();

	void       EndSizeTracking();

	RichObject GetObjectA() const;
	void       ReplaceObject(const RichObject& obj);

	static bool   IsW(int c);
	static void   SetupFaceList(DropList& face);

	void Insert(int pos, const RichText& text, bool typing = false);
	void Remove(int pos, int len, bool joinnext = false);
	void SaveFormat(int pos, int count);
	void SaveFormat();
	void ModifyFormat(int pos, const RichText::FormatInfo& fi, int count);
	void SetParaFormat(dword paravalid);

	void SaveStylesUndo();
	void SaveStyleUndo(const Uuid& id);

	bool CursorKey(dword key, int count);

	void ApplyFormat(dword charvalid, dword paravalid = 0);

	void MoveNG(int newpos, bool select);
	void MoveUpDown(int dir, bool select, int firststep = 0);
	void MovePageUpDown(int dir, bool select);
	void MoveWordRight(bool select);
	void MoveWordLeft(bool select);
	void MoveHomeEnd(int dir, bool select);

	void InsertLine();

	void Bold();
	void Italic();
	void Underline();
	void Strikeout();
	void Capitals();
	void SetScript(int script);

	void AlignLeft();
	void AlignRight();
	void AlignCenter();
	void AlignJustify();

	void Style();

	void ParaFormat();
	void ToPara();

	void SetupUnits();
	void SpellCheck();

	void    AddUserDict();
	WString GetWordAtCursor();

	Rect     GetCaretRect(const RichCaret& pr) const;
	Rect     GetCaretRect() const;

	void     SaveTableFormat(int table);
	void     SaveTable(int table);
	void     InsertTable();
	void     DestroyTable();
	void     TableProps();
	bool     RemoveSpecial(int ll, int hh, bool back);
	bool     InsertLineSpecial();
	void     TableInsertRow();
	void     TableRemoveRow();
	void     TableInsertColumn();
	void     TableRemoveColumn();
	void     SplitCell();
	void     JoinCell();
	void     CellProperties();

	void     OpenFindReplace();
	void     CloseFindReplace();
	int      FindPos();
	RichText ReplaceText();
	void     Find();
	void     Replace();
	void     FindReplaceAddHistory();

	void     Reset();

	void     DoRefreshBar();
	void     RefreshBar();

	bool     Accept(PasteClip& d, RichText& clip);
	void     ClipPaste(RichText& clip);
	bool     InSelection(int& c) const;
	void     RefreshDropCaret();

	static bool   SpellWord(const wchar *wrd, int len, int lang);
	static void   SpellerAdd(const WString& w, int lang);

protected:
	enum {
		TIMEID_ENDSIZETRACKING = Ctrl::TIMEID_COUNT,
		TIMEID_REFRESHBAR,
		TIMEID_COUNT
	};

public:
	static double DotToPt(int dot);
	static int    PtToDot(double pt);
	static Bits   SpellParagraph(const RichPara& p);
	static void   FixedLang(int lang)              { fixedlang = lang; }

	Callback                     WhenRefreshBar;
	Callback                     WhenStartEvaluating;
	Callback2<String&, WString&> WhenHyperlink;
	Callback1<String&>           WhenLabel;

	void   SerializeSettings(Stream& s);

	Zoom   GetZoom() const;

	int    GetCursor() const                       { return cursor; }
	int    GetAnchor() const                       { return anchor; }

	void     Select(int pos, int count);
	bool     IsSelection() const;
	bool     GetSelection(int& l, int& h) const;
	RichText GetSelection(int maxlen = 2147483647) const;
	void     SetSelection(int l, int h)            { Select(l, h - l); }
	bool     RemoveSelection(bool joinnext = false);
	void     CancelSelection();

	void   BeginOp()                               { NextUndo(); }

	int                  GetLength() const         { return text.GetLength(); }
	void                 PasteText(const RichText& text);
	void                 RemoveText(int count);
	RichText             CopyText(int pos, int count) const;
	RichText::FormatInfo GetFormatInfo() const     { return formatinfo; }
	void                 ApplyFormatInfo(const RichText::FormatInfo& fi);
	int                  GetChar(int pos) const    { return text[pos]; }
	int                  operator[](int pos) const { return text[pos]; }

	void   Undo();
	void   Redo();

	void   ScrollToCursor()                     { Finish(); }

	void   Move(int newpos, bool select = false);

	void   Copy();
	void   Cut();
	void   Paste();
	void   InsertObject(int type);

	void   Styles();

	bool   Print();
	void   DoPrint()                             { Print(); }

	void   StyleTool(Bar& bar, int width = 120);
	void   FaceTool(Bar& bar, int width = 130);
	void   HeightTool(Bar& bar, int width = 50);
	void   BoldTool(Bar& bar, dword key = K_CTRL_B);
	void   ItalicTool(Bar& bar, dword key = K_CTRL_I);
	void   UnderlineTool(Bar& bar, dword key = K_CTRL_U);
	void   StrikeoutTool(Bar& bar, dword key = 0);
	void   CapitalsTool(Bar& bar, dword key = 0);
	void   SuperscriptTool(Bar& bar, dword key = 0);
	void   SubscriptTool(Bar& bar, dword key = 0);
	void   InkTool(Bar& bar);
	void   PaperTool(Bar& bar);
	void   LanguageTool(Bar& bar, int width = HZoom(60));
	void   HyperlinkTool(Bar& bar, int width = 180);
	void   SpellCheckTool(Bar& bar);
	void   IndexEntryTool(Bar& bar, int width = 80);

	void   LeftTool(Bar& bar, dword key = K_CTRL_L);
	void   RightTool(Bar& bar, dword key = K_CTRL_R);
	void   CenterTool(Bar& bar, dword key = K_CTRL_E);
	void   JustifyTool(Bar& bar, dword key = K_CTRL_J);
	void   RoundBulletTool(Bar& bar, dword key = 0);
	void   RoundWhiteBulletTool(Bar& bar, dword key = 0);
	void   BoxBulletTool(Bar& bar, dword key = 0);
	void   BoxWhiteBulletTool(Bar& bar, dword key = 0);
	void   TextBulletTool(Bar& bar, dword key = 0);
	void   ParaFormatTool(Bar& bar, dword key = 0);
	void   LabelTool(Bar& bar, int width = 80);
	void   ToParaTool(Bar& bar, dword key = K_CTRL_K);

	void   UndoTool(Bar& bar, dword key = K_CTRL_Z);
	void   RedoTool(Bar& bar, dword key = K_SHIFT_CTRL_Z);
	void   CutTool(Bar& bar, dword key = K_CTRL_X);
	void   CopyTool(Bar& bar, dword key = K_CTRL_C);
	void   PasteTool(Bar& bar, dword key = K_CTRL_V);
	void   ObjectTool(Bar& bar, dword key = 0);
	void   FindReplaceTool(Bar& bar, dword key = K_CTRL_F);

	void   InsertTableTool(Bar& bar, dword key = K_CTRL_F12);
	void   TablePropertiesTool(Bar& bar, dword key = K_SHIFT_F12);
	void   InsertTableRowTool(Bar& bar, dword key = 0);
	void   RemoveTableRowTool(Bar& bar, dword key = 0);
	void   InsertTableColumnTool(Bar& bar, dword key = 0);
	void   RemoveTableColumnTool(Bar& bar, dword key = 0);
	void   SplitJoinCellTool(Bar& bar, dword key = 0);
	void   CellPropertiesTool(Bar& bar, dword key = 0);

	void   PrintTool(Bar& bar, dword key = K_CTRL_P);

	void   FontTools(Bar& bar);
	void   ParaTools(Bar& bar);
	void   EditTools(Bar& bar);
	void   TableTools(Bar& bar);

	void   DefaultBar(Bar& bar, bool extended = true);

	void            EvaluateFields()               { WhenStartEvaluating(); text.EvaluateFields(vars); }

	void            GotoLabel(const String& lbl);

	void            Clear();
	void            Pick( RichText& t);
	void            SetQTF(const char *qtf)               { Pick(ParseQTF(qtf)); }
	const RichText& Get() const                           { return text; }
	String          GetQTF(byte cs = 255) const  { return AsQTF(text, cs); }
	void            ApplyStylesheet(const RichText& r);
	void            SetPage(const Size& sz)               { pagesz = sz; Finish(); }
	Size            GetPage()                             { return pagesz; }

	void            NoRuler()                             { RemoveFrame(ruler); }

	RichEdit&       FontFaces(const Vector<int>& face);
	RichEdit&       ShowCodes(Color c)                    { showcodes = c; Refresh(); return *this; }
	RichEdit&       Unit(int u)                           { unit = u; Refresh(); return *this; }
	RichEdit&       SpellCheck(bool b)                    { spellcheck = b; Refresh(); return *this; }
	RichEdit&       SetZoom(int z)                        { zoom = z; Refresh(); return *this; }

	struct UndoInfo {
		int              undoserial;
		BiArray<UndoRec> undo;
		Array<UndoRec>   redo;
	};

	struct PosInfo {
		int cursor;
		int anchor;
		int sbpos;

		void Serialize(Stream& s)  { int version = 0; s / version % cursor % anchor % sbpos; }
	};

	UndoInfo PickUndoInfo();
	void     SetPickUndoInfo( UndoInfo& f);

	PosInfo  GetPosInfo() const;
	void     SetPosInfo(const PosInfo& pos);

	void     SetFooter(const String& s)                   { footer = s; }
	void     PrintNoLinks(bool b = true)                  { nolinks = b; }

	typedef RichEdit CLASSNAME;

	RichEdit();
	virtual ~RichEdit();
};

class RichEditWithToolBar : public RichEdit {
	ToolBar  toolbar;
	bool     extended;
	void RefreshBar();
	void TheBar(Bar& bar);

public:
	RichEditWithToolBar& Extended(bool b = true) { extended = b; return *this; }
	RichEditWithToolBar& NoExtended()            { return Extended(false); }

	typedef RichEditWithToolBar CLASSNAME;

	RichEditWithToolBar();
};

};

#line 679 "u:/uppsrc\\RichEdit/RichEdit.h"
#line 15 "u:/idisapp\\IdisMisc/IdisMisc.h"

typedef Report NewReport;


#line 1 "u:/uppsrc\\Oracle/Oracle7.h"



#line 1 "u:/uppsrc\\Sql/Sql.h"



#line 1 "u:/idisapp\\Core/Core.h"






























































































































































































































































































































































































































































































































#line 5 "u:/uppsrc\\Sql/Sql.h"

namespace Upp {








#line 16 "u:/uppsrc\\Sql/Sql.h"

#line 1 "u:\\uppsrc\\sql\\Sqlexp.h"
enum {
	ORACLE    = 1,
	SQLITE3   = 2,
	MY_SQL    = 4,
	MSSQL     = 8,
	PGSQL     = 16,
	FIREBIRD  = 32,
	DB2       = 64,
};

class SqlBool;
class SqlVal;
class SqlSet;



struct FieldOperator {
	String table;

	void Table(const char *name)                           { table = name; }

	virtual void Field(Ref f);
	virtual void Field(const char *name, Ref f);

	FieldOperator& operator()(const char *name, Ref f)     { Field(name, f); return *this; }
	FieldOperator& operator()(const String& name, Ref f)   { Field(name, f); return *this; }
	FieldOperator& operator()(Id id, Ref f)                { Field(~id, f); return *this; }
	FieldOperator& operator()(const char *name, bool& b);
	FieldOperator& operator()(const String& name, bool& b) { return (*this)(~name, b); }
	FieldOperator& operator()(Id id, bool& b)              { return (*this)(~id, b); }

	FieldOperator();
	virtual ~FieldOperator();
};

typedef Callback1<FieldOperator&> Fields;

struct FieldDumper : public FieldOperator {
	String s;
	virtual void Field(const char *name, Ref f);
};

template <class T>
String DumpFields(T& s) {
	FieldDumper dump;
	s.FieldLayout(dump);
	return dump.s;
}

void td_scalar(SqlSet& set, const String& prefix, const char *x);
void td_array(SqlSet& set, const String& prefix, const char *x, int cnt);
void td_var(SqlSet& set, const String& prefix, const char *x, SqlSet (*f)(const String&));
void td_shrink(String *array, int cnt);



class SqlCase {
	String s;

public:
	SqlCase(byte cond, const String& text);
	SqlCase operator()(byte cond, const String& text);

	String operator()(const String& text);
	String operator()();
};

String SqlCompile(byte dialect, const String& s);

String SqlFormat(int x);
String SqlFormat(double x);
String SqlFormat(int64 x);
String SqlFormat(const char *s, int len);
String SqlFormat(const char *s);
String SqlFormat(const String& x);
String SqlFormat(Date x);
String SqlFormat(Time x);
String SqlFormat(const Value& x);

class SqlCol : Moveable<SqlCol> {
	String name;
public:
	String        ToString() const          { return name; }
	const String& operator~() const         { return name; }

	SqlCol        As(const char *as) const;

	SqlCol(const String& name) : name(name) {}
};

class SqlId : Moveable<SqlId> {
protected:
	Id id;

public:
	bool          IsEqual(SqlId b) const     { return id == b.id; }
	bool          IsEqual(Id b) const        { return id == b; }
	bool          IsNull() const             { return id.IsNull(); }

	operator      Id() const                 { return id; }
	String        ToString() const           { return id.ToString(); }
	String        operator~() const          { return ToString(); }

	SqlCol        Of(SqlId id) const;
	SqlId         As(const char *as) const;
	SqlId         As(SqlId id) const         { return As(~~id); }
	SqlId         operator [] (int i) const;
	SqlId         operator&(const SqlId& s) const;

	SqlId()                                  {}
	SqlId(const char *s) : id(s)             {}
	SqlId(const String& s) : id(s)           {}
	SqlId(Id id) : id(id)                    {}
};



class SqlS : Moveable<SqlS> {
protected:
	String text;
	byte   priority;

public:
	enum PRIORITY {
		EMPTY    =   0,
		LOW      =  20,
		SETOP    =  50,
		SET      = 100,
		LOR      = 120,
		LAND     = 130,
		TRUEVAL  = 135,
		FALSEVAL = 136,
		COMP     = 140,
		ADD      = 150,
		MUL      = 160,
		UNARY    = 170,
		FN       = 180,
		HIGH     = 200,
		NULLVAL  = 250,
	};

	String        operator()() const;
	String        operator()(int at) const;
	const String& operator~() const         { return text; }
	bool          IsEmpty() const           { return priority == EMPTY; }

	SqlS()                                  : priority(EMPTY) {}
	SqlS(const char *s, int pr)             : text(s), priority(pr) {}
	SqlS(const String& s, int pr)           : text(s), priority(pr) {}
	SqlS(const SqlS& a, const char *op, const SqlS& b, int pr, int prb);
	SqlS(const SqlS& a, const char *op, const SqlS& b, int pr);
};

class SqlVal : public SqlS, Moveable<SqlVal> {
public:
	void SetNull()                          { text = "NULL"; priority = NULLVAL; }
	void SetHigh(const String& s)           { text = s; priority = HIGH; }
	bool IsNull() const                     { return priority == NULLVAL; }

	SqlVal()                                {}
	SqlVal(const String& s, int pr)         : SqlS(s, pr) {}
	SqlVal(const SqlS& a, const char *o, const SqlS& b, int pa, int pb)
		                                    : SqlS(a, o, b, pa, pb) {}
	SqlVal(const SqlS& a, const char *o, const SqlS& b, int p)
		                                    : SqlS(a, o, b, p) {}

	SqlVal(int x);
	SqlVal(int64 x);
	SqlVal(double x);
	SqlVal(const String& x);
	SqlVal(const char *x);
	SqlVal(Date x);
	SqlVal(Time x);
	SqlVal(const Value& x);
	SqlVal(const Nuller&);
	SqlVal(SqlId id);
	SqlVal(const SqlId& (*id)());
	SqlVal(SqlCol id);
};

SqlVal operator-(const SqlVal& a);
SqlVal operator+(const SqlVal& a, const SqlVal& b);
SqlVal operator-(const SqlVal& a, const SqlVal& b);
SqlVal operator*(const SqlVal& a, const SqlVal& b);
SqlVal operator/(const SqlVal& a, const SqlVal& b);
SqlVal operator%(const SqlVal& a, const SqlVal& b);
SqlVal operator|(const SqlVal& a, const SqlVal& b);

SqlVal& operator+=(SqlVal& a, const SqlVal& b);
SqlVal& operator-=(SqlVal& a, const SqlVal& b);
SqlVal& operator*=(SqlVal& a, const SqlVal& b);
SqlVal& operator/=(SqlVal& a, const SqlVal& b);
SqlVal& operator%=(SqlVal& a, const SqlVal& b);
SqlVal& operator|=(SqlVal& a, const SqlVal& b);

SqlVal SqlFunc(const char* name, const SqlVal& a);
SqlVal SqlFunc(const char* name, const SqlVal& a, const SqlVal& b);
SqlVal SqlFunc(const char* name, const SqlVal& a, const SqlVal& b, const SqlVal& c);
SqlVal SqlFunc(const char* nm, const SqlVal& a, const SqlVal& b, const SqlVal& c, const SqlVal& d);
SqlVal SqlFunc(const char* name, const SqlSet& set);

SqlVal Decode(const SqlVal& exp, const SqlSet& variants);
SqlVal Distinct(const SqlVal& exp);
SqlSet Distinct(const SqlSet& columns);
SqlVal All(const SqlVal& exp);
SqlSet All(const SqlSet& columns);
SqlVal SqlAll();
SqlVal Count(const SqlVal& exp);
SqlVal SqlCountRows();
SqlVal Descending(const SqlVal& exp);

SqlVal SqlMax(const SqlVal& a);
SqlVal SqlMin(const SqlVal& a);
SqlVal SqlSum(const SqlVal& a);

SqlVal Avg(const SqlVal& a);
SqlVal Stddev(const SqlVal& a);
SqlVal Variance(const SqlVal& a);

SqlVal Greatest(const SqlVal& a, const SqlVal& b);
SqlVal Least(const SqlVal& a, const SqlVal& b);

SqlVal ConvertCharset(const SqlVal& exp, const SqlVal& charset);
SqlVal ConvertAscii(const SqlVal& exp);
SqlVal Upper(const SqlVal& exp);
SqlVal Lower(const SqlVal& exp);
SqlVal Length(const SqlVal& exp);
SqlVal UpperAscii(const SqlVal& exp);
SqlVal Substr(const SqlVal& a, const SqlVal& b);
SqlVal Substr(const SqlVal& a, const SqlVal& b, const SqlVal& c);
SqlVal Instr(const SqlVal& a, const SqlVal& b);
SqlVal Wild(const char* s);

SqlVal SqlDate(const SqlVal& year, const SqlVal& month, const SqlVal& day);
SqlVal AddMonths(const SqlVal& date, const SqlVal& months);
SqlVal LastDay(const SqlVal& date);
SqlVal MonthsBetween(const SqlVal& date1, const SqlVal& date2);
SqlVal NextDay(const SqlVal& date);

SqlVal Cast(const char* type, const SqlId& a);

SqlVal SqlNvl(const SqlVal& a);
inline SqlVal Nvl(const SqlVal& a)     { return SqlNvl(SqlVal(a)); }
inline SqlVal Nvl(const SqlCol& a)     { return SqlNvl(SqlVal(a)); }
inline SqlVal Nvl(const SqlId& a)      { return SqlNvl(SqlVal(a)); }

SqlVal SqlNvl(const SqlVal& a, const SqlVal& b);
inline SqlVal Nvl(const SqlVal& a, const SqlVal& b) { return SqlNvl(SqlVal(a), SqlVal(b)); }
inline SqlVal Nvl(const SqlVal& a, const SqlCol& b) { return SqlNvl(SqlVal(a), SqlVal(b)); }
inline SqlVal Nvl(const SqlVal& a, const SqlId& b)  { return SqlNvl(SqlVal(a), SqlVal(b)); }
inline SqlVal Nvl(const SqlCol& a, const SqlVal& b) { return SqlNvl(SqlVal(a), SqlVal(b)); }
inline SqlVal Nvl(const SqlCol& a, const SqlCol& b) { return SqlNvl(SqlVal(a), SqlVal(b)); }
inline SqlVal Nvl(const SqlCol& a, const SqlId& b)  { return SqlNvl(SqlVal(a), SqlVal(b)); }
inline SqlVal Nvl(const SqlId& a, const SqlVal& b)  { return SqlNvl(SqlVal(a), SqlVal(b)); }
inline SqlVal Nvl(const SqlId& a, const SqlCol& b)  { return SqlNvl(SqlVal(a), SqlVal(b)); }
inline SqlVal Nvl(const SqlId& a, const SqlId& b)   { return SqlNvl(SqlVal(a), SqlVal(b)); }

SqlVal Prior(SqlId a);

SqlVal NextVal(SqlId a);
SqlVal CurrVal(SqlId a);
SqlVal OuterJoin(SqlCol col);

inline SqlVal operator++(SqlId a)           { return NextVal(a); }

SqlVal SqlRowNum();

SqlVal SqlArg();

class SqlBool : public SqlS, Moveable<SqlBool> {
public:
	void     SetTrue();
	void     SetFalse();
	void     SetBool(bool b);

	bool     IsTrue()  const                { return priority == TRUEVAL; }
	bool     IsFalse() const                { return priority == FALSEVAL; }
	bool     IsBool()  const                { return IsTrue() || IsFalse(); }
	bool     AsBool()  const                { ; return IsTrue(); }

	SqlBool(const String& s, int pr)        : SqlS(s, pr) {}
	SqlBool(const SqlS& a, const char *o, const SqlS& b, int pa, int pb)
		                                    : SqlS(a, o, b, pa, pb) {}
	SqlBool(const SqlS& a, const char *o, const SqlS& b, int p)
		                                    : SqlS(a, o, b, p) {}

	static SqlBool True()                   { return SqlBool(true); }
	static SqlBool False()                  { return SqlBool(false); }

	SqlBool()                               {}
	SqlBool(bool b)                         { SetBool(b); }
};

SqlBool        operator!(const SqlBool& a);

SqlBool        operator<(const SqlVal& a, const SqlVal& b);
SqlBool        operator<=(const SqlVal& a, const SqlVal& b);
SqlBool        operator>=(const SqlVal& a, const SqlVal& b);
SqlBool        operator>(const SqlVal& a, const SqlVal& b);
SqlBool        operator==(const SqlVal& a, const SqlVal& b);
SqlBool        operator!=(const SqlVal& a, const SqlVal& b);

SqlBool        operator||(const SqlBool& a, const SqlBool& b);
SqlBool        operator&&(const SqlBool& a, const SqlBool& b);
SqlBool        operator- (const SqlBool& a, const SqlBool& b);
SqlBool        operator|=(SqlBool& a, const SqlBool& b);
SqlBool        operator&=(SqlBool& a, const SqlBool& b);

SqlBool        SqlIsNull(const SqlVal& a);
SqlBool        NotNull(const SqlVal& a);

inline SqlBool IsNull(const SqlId& a)  { return SqlIsNull(a); }
inline SqlBool IsNull(const SqlVal& a) { return SqlIsNull(a); }
inline SqlBool IsNull(const SqlCol& a) { return SqlIsNull(a); }

SqlBool        Like(const SqlVal& a, const SqlVal& b);
SqlBool        NotLike(const SqlVal& a, const SqlVal& b);

SqlBool        Between(const SqlVal& a, const SqlVal& low, const SqlVal& high);
SqlBool        NotBetween(const SqlVal&a, const SqlVal& low, const SqlVal& high);

SqlBool        In(const SqlVal& a, const SqlSet& b);
SqlBool        NotIn(const SqlVal& a, const SqlSet& b);
SqlBool        Exists(const SqlSet& set);
SqlBool        NotExists(const SqlSet& set);

SqlBool        LikeUpperAscii(const SqlVal& a, const SqlVal& b);

SqlBool        LeftJoin(SqlVal v1, SqlVal v2);
SqlBool        RightJoin(SqlVal v1, SqlVal v2);

SqlBool        Join(SqlId tab1, SqlId tab2, SqlId key);
SqlBool        LeftJoin(SqlId tab1, SqlId tab2, SqlId key);
SqlBool        RightJoin(SqlId tab1, SqlId tab2, SqlId key);

SqlBool        SqlFirstRow();

inline SqlBool operator==(const SqlVal& a, const SqlSet& b) { return In(a, b); }
inline SqlBool operator!=(const SqlVal& a, const SqlSet& b) { return NotIn(a, b); }

inline const SqlVal& operator+(const SqlVal& a) { return a; }



class Sql;



SqlSet operator|(const SqlSet& s1, const SqlSet& s2);
SqlSet operator&(const SqlSet& s1, const SqlSet& s2);
SqlSet operator-(const SqlSet& s1, const SqlSet& s2);

class SqlSet : Moveable<SqlSet> {
protected:
	String text;
	byte   priority;

public:
	enum PRIORITY {
		SETOP    =  50,
		SET      = 100,
	};

	String           operator~() const;
	String           operator()() const;
	String           operator()(int at) const;
	bool             IsEmpty() const                { return text.IsEmpty(); }

	SqlSet&          Cat(const SqlVal& val);
	SqlSet&          Cat(const SqlSet& set);
	SqlSet&          operator|=(const SqlVal& val)  { return Cat(val); }

	SqlSet&          operator|=(const SqlSet& set)  { return *this = *this | set; }
	SqlSet&          operator&=(const SqlSet& set)  { return *this = *this & set; }
	SqlSet&          operator-=(const SqlSet& set)  { return *this = *this - set; }

	void             Clear()                                { text.Clear(); }

	SqlSet() {}
	explicit SqlSet(const SqlVal& p0);


	SqlSet(const SqlVal& p0, const SqlVal& p1); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30, const SqlVal& p31); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30, const SqlVal& p31, const SqlVal& p32); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30, const SqlVal& p31, const SqlVal& p32, const SqlVal& p33); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30, const SqlVal& p31, const SqlVal& p32, const SqlVal& p33, const SqlVal& p34); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30, const SqlVal& p31, const SqlVal& p32, const SqlVal& p33, const SqlVal& p34, const SqlVal& p35); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30, const SqlVal& p31, const SqlVal& p32, const SqlVal& p33, const SqlVal& p34, const SqlVal& p35, const SqlVal& p36); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30, const SqlVal& p31, const SqlVal& p32, const SqlVal& p33, const SqlVal& p34, const SqlVal& p35, const SqlVal& p36, const SqlVal& p37); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30, const SqlVal& p31, const SqlVal& p32, const SqlVal& p33, const SqlVal& p34, const SqlVal& p35, const SqlVal& p36, const SqlVal& p37, const SqlVal& p38); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30, const SqlVal& p31, const SqlVal& p32, const SqlVal& p33, const SqlVal& p34, const SqlVal& p35, const SqlVal& p36, const SqlVal& p37, const SqlVal& p38, const SqlVal& p39); SqlSet(const SqlVal& p0, const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30, const SqlVal& p31, const SqlVal& p32, const SqlVal& p33, const SqlVal& p34, const SqlVal& p35, const SqlVal& p36, const SqlVal& p37, const SqlVal& p38, const SqlVal& p39, const SqlVal& p40);;

	explicit SqlSet(Fields nfields);

	SqlSet(const String& s, PRIORITY p)   { text = s; priority = p; }
};

class SqlSetC : public SqlSet {
public:
	SqlSetC(const String& s)      { text = s; priority = SET; }
	SqlSetC(const char* s)        { text = s; priority = SET; }
};

class SqlStatement {
	String text;

public:
	SqlStatement() {}
	explicit SqlStatement(const String& s) : text(s) {}

	String Get(int dialect) const;
	String GetText() const                           { return text; }
	bool   IsEmpty() const                           { return text.IsEmpty(); }
	operator bool() const                            { return !IsEmpty(); }


	bool  Execute(Sql& cursor) const;
	void  Force(Sql& cursor) const;
	Value Fetch(Sql& cursor) const;
	bool  Execute() const;
	void  Force() const;
	Value Fetch() const;
};

class SqlSelect {
	String  text;

public:
	operator bool() const                             { return text.GetCount(); }

	SqlSelect& Hint(const char *hint);

	SqlSelect& Get();
	SqlSelect& From(const SqlSet& set);
	SqlSelect& From(SqlId table);
	SqlSelect& From(SqlId table1, SqlId table2);
	SqlSelect& From(SqlId table1, SqlId table2, SqlId table3);
	SqlSelect& From(const SqlVal& a)                  { return From(SqlSet(a)); }

	SqlSelect& InnerJoin(SqlId table);
	SqlSelect& LeftJoin(SqlId table);
	SqlSelect& RightJoin(SqlId table);
	SqlSelect& FullJoin(SqlId table);

	SqlSelect& Where(const SqlBool& exp);
	SqlSelect& On(const SqlBool& exp);
	SqlSelect& StartWith(const SqlBool& exp);
	SqlSelect& ConnectBy(const SqlBool& exp);
	SqlSelect& GroupBy(const SqlSet& columnset);
	SqlSelect& Having(const SqlBool& exp);
	SqlSelect& OrderBy(const SqlSet& columnset);
	SqlSelect& ForUpdate();
	SqlSelect& NoWait();

	SqlSelect& GroupBy(SqlVal a)                      { return GroupBy(SqlSet(a)); }
	SqlSelect& GroupBy(SqlVal a, SqlVal b)            { return GroupBy(SqlSet(a, b)); }
	SqlSelect& GroupBy(SqlVal a, SqlVal b, SqlVal c)  { return GroupBy(SqlSet(a, b, c)); }
	SqlSelect& OrderBy(SqlVal a)                      { return OrderBy(SqlSet(a)); }
	SqlSelect& OrderBy(SqlVal a, SqlVal b)            { return OrderBy(SqlSet(a, b)); }
	SqlSelect& OrderBy(SqlVal a, SqlVal b, SqlVal c)  { return OrderBy(SqlSet(a, b, c)); }
	SqlSelect& Limit(int limit);
	SqlSelect& Limit(int64 offset, int limit);
	SqlSelect& Offset(int64 offset);

	operator SqlSet() const                           { return SqlSet(text, SqlSet::SETOP); }
	operator SqlStatement() const                     { return SqlStatement(text); }

	SqlSelect(Fields f);
	SqlSelect(const SqlSet& s)                        { text = ~s; }
	SqlSelect()                                       {}

	bool IsEmpty()                                    { return text.IsEmpty(); }

	SqlSelect& operator|=(const SqlSelect& s2);
	SqlSelect& operator&=(const SqlSelect& s2);
	SqlSelect& operator-=(const SqlSelect& s2);


	bool  Execute(Sql& sql) const                     { return SqlStatement(*this).Execute(sql); }
	void  Force(Sql& sql) const                       { return SqlStatement(*this).Force(sql); }
	Value Fetch(Sql& sql) const                       { return SqlStatement(*this).Fetch(sql); }
	bool  Execute() const                             { return SqlStatement(*this).Execute(); }
	void  Force() const                               { return SqlStatement(*this).Force(); }
	Value Fetch() const                               { return SqlStatement(*this).Fetch(); }
};

SqlSelect operator|(const SqlSelect& s1, const SqlSelect& s2);
SqlSelect operator&(const SqlSelect& s1, const SqlSelect& s2);
SqlSelect operator-(const SqlSelect& s1, const SqlSelect& s2);

inline SqlSelect Select(const SqlSet& set)  { return SqlSelect(set); }
inline SqlSelect Select(Fields f)           { return SqlSelect(f); }


SqlSelect Select(const SqlVal& p1); SqlSelect Select(const SqlVal& p1, const SqlVal& p2); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30, const SqlVal& p31); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30, const SqlVal& p31, const SqlVal& p32); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30, const SqlVal& p31, const SqlVal& p32, const SqlVal& p33); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30, const SqlVal& p31, const SqlVal& p32, const SqlVal& p33, const SqlVal& p34); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30, const SqlVal& p31, const SqlVal& p32, const SqlVal& p33, const SqlVal& p34, const SqlVal& p35); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30, const SqlVal& p31, const SqlVal& p32, const SqlVal& p33, const SqlVal& p34, const SqlVal& p35, const SqlVal& p36); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30, const SqlVal& p31, const SqlVal& p32, const SqlVal& p33, const SqlVal& p34, const SqlVal& p35, const SqlVal& p36, const SqlVal& p37); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30, const SqlVal& p31, const SqlVal& p32, const SqlVal& p33, const SqlVal& p34, const SqlVal& p35, const SqlVal& p36, const SqlVal& p37, const SqlVal& p38); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30, const SqlVal& p31, const SqlVal& p32, const SqlVal& p33, const SqlVal& p34, const SqlVal& p35, const SqlVal& p36, const SqlVal& p37, const SqlVal& p38, const SqlVal& p39); SqlSelect Select(const SqlVal& p1, const SqlVal& p2, const SqlVal& p3, const SqlVal& p4, const SqlVal& p5, const SqlVal& p6, const SqlVal& p7, const SqlVal& p8, const SqlVal& p9, const SqlVal& p10, const SqlVal& p11, const SqlVal& p12, const SqlVal& p13, const SqlVal& p14, const SqlVal& p15, const SqlVal& p16, const SqlVal& p17, const SqlVal& p18, const SqlVal& p19, const SqlVal& p20, const SqlVal& p21, const SqlVal& p22, const SqlVal& p23, const SqlVal& p24, const SqlVal& p25, const SqlVal& p26, const SqlVal& p27, const SqlVal& p28, const SqlVal& p29, const SqlVal& p30, const SqlVal& p31, const SqlVal& p32, const SqlVal& p33, const SqlVal& p34, const SqlVal& p35, const SqlVal& p36, const SqlVal& p37, const SqlVal& p38, const SqlVal& p39, const SqlVal& p40);;

class SqlDelete {
	String text;

public:
	SqlDelete& Where(const SqlBool& b);

	operator SqlStatement() const                     { return SqlStatement(text); }

	SqlDelete(SqlVal table);


	bool  Execute(Sql& sql) const                     { return SqlStatement(*this).Execute(sql); }
	void  Force(Sql& sql) const                       { return SqlStatement(*this).Force(sql); }
	Value Fetch(Sql& sql) const                       { return SqlStatement(*this).Fetch(sql); }
	bool  Execute() const                             { return SqlStatement(*this).Execute(); }
	void  Force() const                               { return SqlStatement(*this).Force(); }
	Value Fetch() const                               { return SqlStatement(*this).Fetch(); }
};

inline SqlDelete Delete(SqlVal table) { return SqlDelete(table); }

class SqlInsert {
	SqlId   table;
	SqlId   keycolumn;
	SqlVal  keyvalue;
	SqlSet  set1;
	SqlSet  set2;
	SqlSet  from;
	SqlBool where;

public:
	void Column(SqlId column, SqlVal val);
	void Column(SqlId column)                        { Column(column, column); }
	SqlInsert& operator()(SqlId column, SqlVal val)  { Column(column, val); return *this; }
	SqlInsert& operator()(SqlId column)              { Column(column, column); return *this; }
	SqlInsert& operator()(Fields f);
	SqlInsert& From(SqlId from);
	SqlInsert& From(SqlSet _from)                    { from = _from; return *this; }
	SqlInsert& From(SqlVal from)                     { return From(SqlSet(from)); }
	SqlInsert& Where(SqlBool w)                      { where = w; return *this; }

	SqlId    GetTable() const                        { return table; }
	SqlId    GetKeyColumn() const                    { return keycolumn; }
	SqlVal   GetKeyValue() const                     { return keyvalue; }

	operator SqlStatement() const;
	operator bool() const                            { return !set1.IsEmpty(); }

	SqlInsert(SqlId table) : table(table) {}
	SqlInsert(SqlId table, SqlSet set1, SqlSet set2) : table(table), set1(set1), set2(set2) {}
	SqlInsert(Fields f);


	bool  Execute(Sql& sql) const                     { return SqlStatement(*this).Execute(sql); }
	void  Force(Sql& sql) const                       { return SqlStatement(*this).Force(sql); }
	Value Fetch(Sql& sql) const                       { return SqlStatement(*this).Fetch(sql); }
	bool  Execute() const                             { return SqlStatement(*this).Execute(); }
	void  Force() const                               { return SqlStatement(*this).Force(); }
	Value Fetch() const                               { return SqlStatement(*this).Fetch(); }
};

inline SqlInsert Insert(SqlId table)                  { return SqlInsert(table); }
inline SqlInsert Insert(Fields f)                     { return SqlInsert(f); }

class SqlUpdate {
	SqlId   table;
	SqlSet  set;
	SqlBool where;

public:
	void Column(SqlId column, SqlVal val);
	SqlUpdate& operator()(SqlId column, SqlVal val)  { Column(column, val); return *this; }
	SqlUpdate& operator()(Fields f);
	SqlUpdate& Where(SqlBool w)                      { where = w; return *this; }

	operator SqlStatement() const;

	operator bool() const                            { return !set.IsEmpty(); }

	SqlUpdate(SqlId table) : table(table) {}
	SqlUpdate(Fields f);


	bool  Execute(Sql& sql) const                     { return SqlStatement(*this).Execute(sql); }
	void  Force(Sql& sql) const                       { return SqlStatement(*this).Force(sql); }
	Value Fetch(Sql& sql) const                       { return SqlStatement(*this).Fetch(sql); }
	bool  Execute() const                             { return SqlStatement(*this).Execute(); }
	void  Force() const                               { return SqlStatement(*this).Force(); }
	Value Fetch() const                               { return SqlStatement(*this).Fetch(); }
};

inline SqlUpdate Update(SqlId table)                  { return SqlUpdate(table); }
inline SqlUpdate Update(Fields f)                     { return SqlUpdate(f); }
#line 18 "u:/uppsrc\\Sql/Sql.h"
#line 1 "u:\\uppsrc\\sql\\Sqls.h"
bool SqlToBool(const String& s);
bool SqlToBool(const Value& v);
const String& BoolToSql(bool b);

class SqlSession;


class ActivityStatus {
public:
	enum {
		NONE,
		FETCHING,
		END_FETCHING,
		EXECUTING,
		END_EXECUTING,
		EXECUTING_ERROR
	};
private:
	String error;
	int    error_code_number;
	String error_code_string;
	String statement;
	int    status;
	int    time;

public:
	ActivityStatus& Error(const String& s)       { error = s;             return *this; }
	ActivityStatus& ErrorCode(const String& s)   { error_code_string = s; return *this; }
	ActivityStatus& ErrorCode(int n)             { error_code_number = n; return *this; }
	ActivityStatus& Statement(const String& s)   { statement = s;         return *this; }
	ActivityStatus& SetStatus(int s)             { status = s;            return *this; }
	ActivityStatus& Time(int n)                  { time = n;              return *this; }

	String          GetStatement() const         { return statement;         }
	String          GetError() const             { return error;             }
	int             GetErrorCode() const         { return error_code_number; }
	String          GetErrorCodeString() const   { return error_code_string; }
	int             GetStatus() const            { return status;            }
	int             GetTime() const              { return time;              }

	bool            operator == (int s) const    { return status == s;       }
	bool            operator != (int s) const    { return status != s;       }
};

class SqlExc : public Exc {
public:

	SqlExc();
#line 50 "u:\\uppsrc\\sql\\Sqls.h"
	SqlExc(const SqlSession& session);
	SqlExc(const Sql& sql);
	SqlExc(const String& desc) : Exc(desc) {}
	SqlExc(const char *desc) : Exc(desc) {}

	void SetSessionError(const SqlSession& session);
};

class SqlRaw : public String, AssignValueTypeNo<SqlRaw, 34> {
public:
	operator Value() const              { return RawValue<SqlRaw>(*this); }
	SqlRaw(const Value& q)
		: String(IsString(q) ? String(q) : String(RawValue<SqlRaw>::Extract(q))) {}
	SqlRaw(const String& s) : String(s) {}
	SqlRaw() {}
};

struct SqlColumnInfo : Moveable<SqlColumnInfo> {
	String      name;
	int         type;
	int         width;
	int         precision;
	int         scale;
	bool        nullable;
};

class SqlConnection {
protected:
	friend class Sql;
	friend class SqlSession;

	virtual void        SetParam(int i, const Value& r) = 0;
	virtual bool        Execute() = 0;
	virtual int         GetRowsProcessed() const;
	virtual Value       GetInsertedId() const;
	virtual bool        Fetch() = 0;
	virtual void        GetColumn(int i, Ref r) const = 0;
	virtual void        Cancel() = 0;
	virtual SqlSession& GetSession() const = 0;
	virtual String      GetUser() const;
	virtual String      ToString() const = 0;

	SqlConnection();
	virtual            ~SqlConnection();

	int                    starttime;
	String                 statement;
	Vector<SqlColumnInfo>  info;
	int                    fetchrows;
	int                    longsize;
	bool                   parse;
};




class SqlSource {
protected:
	virtual SqlConnection *CreateConnection() = 0;
	virtual ~SqlSource() {}
	friend class Sql;
};


class Sql {
protected:
	SqlConnection  *cn;

	friend class SqlSession;

	Value       Select0(const String& what);
	void        Assign(SqlSource& src);
	void        Detach();
	enum _NULLSQL { NULLSQL };
	Sql(_NULLSQL) { cn = 0; }

public:
	String Compile(const SqlStatement& s);

	void   Clear();

	void   SetParam(int i, const Value& val);
	void   SetStatement(const String& s);
	void   SetStatement(const SqlStatement& s)         { SetStatement(Compile(s)); }

	bool   Execute();
	void   ExecuteX();
	bool   Run()                                       { return Execute(); }
	void   RunX()                                      { ExecuteX(); }

	bool   Execute(const String& s);
	void   ExecuteX(const String& s);

	bool   Execute(const SqlStatement& s)              { return Execute(Compile(s)); }
	void   ExecuteX(const SqlStatement& s)             { ExecuteX(Compile(s)); }


	bool Run(Value p1); bool Run(Value p1, Value p2); bool Run(Value p1, Value p2, Value p3); bool Run(Value p1, Value p2, Value p3, Value p4); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37, Value p38); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37, Value p38, Value p39); bool Run(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37, Value p38, Value p39, Value p40);



	void RunX(Value p1); void RunX(Value p1, Value p2); void RunX(Value p1, Value p2, Value p3); void RunX(Value p1, Value p2, Value p3, Value p4); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37, Value p38); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37, Value p38, Value p39); void RunX(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37, Value p38, Value p39, Value p40);


	bool Execute(const String& s, Value p1); bool Execute(const String& s, Value p1, Value p2); bool Execute(const String& s, Value p1, Value p2, Value p3); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37, Value p38); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37, Value p38, Value p39); bool Execute(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37, Value p38, Value p39, Value p40);


	void ExecuteX(const String& s, Value p1); void ExecuteX(const String& s, Value p1, Value p2); void ExecuteX(const String& s, Value p1, Value p2, Value p3); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37, Value p38); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37, Value p38, Value p39); void ExecuteX(const String& s, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37, Value p38, Value p39, Value p40);

	bool   Fetch();


	bool Fetch(Ref p1); bool Fetch(Ref p1, Ref p2); bool Fetch(Ref p1, Ref p2, Ref p3); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19, Ref p20); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19, Ref p20, Ref p21); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19, Ref p20, Ref p21, Ref p22); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19, Ref p20, Ref p21, Ref p22, Ref p23); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19, Ref p20, Ref p21, Ref p22, Ref p23, Ref p24); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19, Ref p20, Ref p21, Ref p22, Ref p23, Ref p24, Ref p25); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19, Ref p20, Ref p21, Ref p22, Ref p23, Ref p24, Ref p25, Ref p26); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19, Ref p20, Ref p21, Ref p22, Ref p23, Ref p24, Ref p25, Ref p26, Ref p27); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19, Ref p20, Ref p21, Ref p22, Ref p23, Ref p24, Ref p25, Ref p26, Ref p27, Ref p28); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19, Ref p20, Ref p21, Ref p22, Ref p23, Ref p24, Ref p25, Ref p26, Ref p27, Ref p28, Ref p29); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19, Ref p20, Ref p21, Ref p22, Ref p23, Ref p24, Ref p25, Ref p26, Ref p27, Ref p28, Ref p29, Ref p30); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19, Ref p20, Ref p21, Ref p22, Ref p23, Ref p24, Ref p25, Ref p26, Ref p27, Ref p28, Ref p29, Ref p30, Ref p31); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19, Ref p20, Ref p21, Ref p22, Ref p23, Ref p24, Ref p25, Ref p26, Ref p27, Ref p28, Ref p29, Ref p30, Ref p31, Ref p32); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19, Ref p20, Ref p21, Ref p22, Ref p23, Ref p24, Ref p25, Ref p26, Ref p27, Ref p28, Ref p29, Ref p30, Ref p31, Ref p32, Ref p33); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19, Ref p20, Ref p21, Ref p22, Ref p23, Ref p24, Ref p25, Ref p26, Ref p27, Ref p28, Ref p29, Ref p30, Ref p31, Ref p32, Ref p33, Ref p34); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19, Ref p20, Ref p21, Ref p22, Ref p23, Ref p24, Ref p25, Ref p26, Ref p27, Ref p28, Ref p29, Ref p30, Ref p31, Ref p32, Ref p33, Ref p34, Ref p35); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19, Ref p20, Ref p21, Ref p22, Ref p23, Ref p24, Ref p25, Ref p26, Ref p27, Ref p28, Ref p29, Ref p30, Ref p31, Ref p32, Ref p33, Ref p34, Ref p35, Ref p36); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19, Ref p20, Ref p21, Ref p22, Ref p23, Ref p24, Ref p25, Ref p26, Ref p27, Ref p28, Ref p29, Ref p30, Ref p31, Ref p32, Ref p33, Ref p34, Ref p35, Ref p36, Ref p37); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19, Ref p20, Ref p21, Ref p22, Ref p23, Ref p24, Ref p25, Ref p26, Ref p27, Ref p28, Ref p29, Ref p30, Ref p31, Ref p32, Ref p33, Ref p34, Ref p35, Ref p36, Ref p37, Ref p38); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19, Ref p20, Ref p21, Ref p22, Ref p23, Ref p24, Ref p25, Ref p26, Ref p27, Ref p28, Ref p29, Ref p30, Ref p31, Ref p32, Ref p33, Ref p34, Ref p35, Ref p36, Ref p37, Ref p38, Ref p39); bool Fetch(Ref p1, Ref p2, Ref p3, Ref p4, Ref p5, Ref p6, Ref p7, Ref p8, Ref p9, Ref p10, Ref p11, Ref p12, Ref p13, Ref p14, Ref p15, Ref p16, Ref p17, Ref p18, Ref p19, Ref p20, Ref p21, Ref p22, Ref p23, Ref p24, Ref p25, Ref p26, Ref p27, Ref p28, Ref p29, Ref p30, Ref p31, Ref p32, Ref p33, Ref p34, Ref p35, Ref p36, Ref p37, Ref p38, Ref p39, Ref p40);

	bool   Fetch(Vector<Value>& row);

	bool   Fetch(Fields fields);

	int    GetRowsProcessed() const                    { return cn->GetRowsProcessed(); }

	int    GetColumns() const;

	void   GetColumn(int i, Ref r) const;
	Value  operator[](int i) const;
	Value  operator[](SqlId colid) const;
	const SqlColumnInfo& GetColumnInfo(int i) const    { return cn->info[i]; }
	Vector<Value> GetRow() const;
	operator Vector<Value>() const                     { return GetRow(); }
	void   Get(Fields fields);

	void        SetFetchRows(int nrows)                { cn->fetchrows = nrows; }
	void        SetLongSize(int lsz)                   { cn->longsize = lsz; }

	void        Cancel()                               { cn->Cancel(); }

	Value       Select(const String& what);


	Value Select(const String& what, Value p1); Value Select(const String& what, Value p1, Value p2); Value Select(const String& what, Value p1, Value p2, Value p3); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37, Value p38); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37, Value p38, Value p39); Value Select(const String& what, Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37, Value p38, Value p39, Value p40);


	bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30, const char *c31, const Value& v31); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30, const char *c31, const Value& v31, const char *c32, const Value& v32); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30, const char *c31, const Value& v31, const char *c32, const Value& v32, const char *c33, const Value& v33); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30, const char *c31, const Value& v31, const char *c32, const Value& v32, const char *c33, const Value& v33, const char *c34, const Value& v34); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30, const char *c31, const Value& v31, const char *c32, const Value& v32, const char *c33, const Value& v33, const char *c34, const Value& v34, const char *c35, const Value& v35); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30, const char *c31, const Value& v31, const char *c32, const Value& v32, const char *c33, const Value& v33, const char *c34, const Value& v34, const char *c35, const Value& v35, const char *c36, const Value& v36); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30, const char *c31, const Value& v31, const char *c32, const Value& v32, const char *c33, const Value& v33, const char *c34, const Value& v34, const char *c35, const Value& v35, const char *c36, const Value& v36, const char *c37, const Value& v37); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30, const char *c31, const Value& v31, const char *c32, const Value& v32, const char *c33, const Value& v33, const char *c34, const Value& v34, const char *c35, const Value& v35, const char *c36, const Value& v36, const char *c37, const Value& v37, const char *c38, const Value& v38); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30, const char *c31, const Value& v31, const char *c32, const Value& v32, const char *c33, const Value& v33, const char *c34, const Value& v34, const char *c35, const Value& v35, const char *c36, const Value& v36, const char *c37, const Value& v37, const char *c38, const Value& v38, const char *c39, const Value& v39); bool Insert(const char *tb, const char *c0, const Value& v0, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30, const char *c31, const Value& v31, const char *c32, const Value& v32, const char *c33, const Value& v33, const char *c34, const Value& v34, const char *c35, const Value& v35, const char *c36, const Value& v36, const char *c37, const Value& v37, const char *c38, const Value& v38, const char *c39, const Value& v39, const char *c40, const Value& v40);


	bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30, SqlId c31, const Value& v31); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30, SqlId c31, const Value& v31, SqlId c32, const Value& v32); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30, SqlId c31, const Value& v31, SqlId c32, const Value& v32, SqlId c33, const Value& v33); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30, SqlId c31, const Value& v31, SqlId c32, const Value& v32, SqlId c33, const Value& v33, SqlId c34, const Value& v34); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30, SqlId c31, const Value& v31, SqlId c32, const Value& v32, SqlId c33, const Value& v33, SqlId c34, const Value& v34, SqlId c35, const Value& v35); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30, SqlId c31, const Value& v31, SqlId c32, const Value& v32, SqlId c33, const Value& v33, SqlId c34, const Value& v34, SqlId c35, const Value& v35, SqlId c36, const Value& v36); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30, SqlId c31, const Value& v31, SqlId c32, const Value& v32, SqlId c33, const Value& v33, SqlId c34, const Value& v34, SqlId c35, const Value& v35, SqlId c36, const Value& v36, SqlId c37, const Value& v37); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30, SqlId c31, const Value& v31, SqlId c32, const Value& v32, SqlId c33, const Value& v33, SqlId c34, const Value& v34, SqlId c35, const Value& v35, SqlId c36, const Value& v36, SqlId c37, const Value& v37, SqlId c38, const Value& v38); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30, SqlId c31, const Value& v31, SqlId c32, const Value& v32, SqlId c33, const Value& v33, SqlId c34, const Value& v34, SqlId c35, const Value& v35, SqlId c36, const Value& v36, SqlId c37, const Value& v37, SqlId c38, const Value& v38, SqlId c39, const Value& v39); bool Insert(SqlId tb, SqlId c0, const Value& v0, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30, SqlId c31, const Value& v31, SqlId c32, const Value& v32, SqlId c33, const Value& v33, SqlId c34, const Value& v34, SqlId c35, const Value& v35, SqlId c36, const Value& v36, SqlId c37, const Value& v37, SqlId c38, const Value& v38, SqlId c39, const Value& v39, SqlId c40, const Value& v40);


	bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30, const char *c31, const Value& v31); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30, const char *c31, const Value& v31, const char *c32, const Value& v32); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30, const char *c31, const Value& v31, const char *c32, const Value& v32, const char *c33, const Value& v33); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30, const char *c31, const Value& v31, const char *c32, const Value& v32, const char *c33, const Value& v33, const char *c34, const Value& v34); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30, const char *c31, const Value& v31, const char *c32, const Value& v32, const char *c33, const Value& v33, const char *c34, const Value& v34, const char *c35, const Value& v35); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30, const char *c31, const Value& v31, const char *c32, const Value& v32, const char *c33, const Value& v33, const char *c34, const Value& v34, const char *c35, const Value& v35, const char *c36, const Value& v36); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30, const char *c31, const Value& v31, const char *c32, const Value& v32, const char *c33, const Value& v33, const char *c34, const Value& v34, const char *c35, const Value& v35, const char *c36, const Value& v36, const char *c37, const Value& v37); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30, const char *c31, const Value& v31, const char *c32, const Value& v32, const char *c33, const Value& v33, const char *c34, const Value& v34, const char *c35, const Value& v35, const char *c36, const Value& v36, const char *c37, const Value& v37, const char *c38, const Value& v38); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30, const char *c31, const Value& v31, const char *c32, const Value& v32, const char *c33, const Value& v33, const char *c34, const Value& v34, const char *c35, const Value& v35, const char *c36, const Value& v36, const char *c37, const Value& v37, const char *c38, const Value& v38, const char *c39, const Value& v39); bool Update(const char *tb, const char *k, const Value& kv, const char *c1, const Value& v1, const char *c2, const Value& v2, const char *c3, const Value& v3, const char *c4, const Value& v4, const char *c5, const Value& v5, const char *c6, const Value& v6, const char *c7, const Value& v7, const char *c8, const Value& v8, const char *c9, const Value& v9, const char *c10, const Value& v10, const char *c11, const Value& v11, const char *c12, const Value& v12, const char *c13, const Value& v13, const char *c14, const Value& v14, const char *c15, const Value& v15, const char *c16, const Value& v16, const char *c17, const Value& v17, const char *c18, const Value& v18, const char *c19, const Value& v19, const char *c20, const Value& v20, const char *c21, const Value& v21, const char *c22, const Value& v22, const char *c23, const Value& v23, const char *c24, const Value& v24, const char *c25, const Value& v25, const char *c26, const Value& v26, const char *c27, const Value& v27, const char *c28, const Value& v28, const char *c29, const Value& v29, const char *c30, const Value& v30, const char *c31, const Value& v31, const char *c32, const Value& v32, const char *c33, const Value& v33, const char *c34, const Value& v34, const char *c35, const Value& v35, const char *c36, const Value& v36, const char *c37, const Value& v37, const char *c38, const Value& v38, const char *c39, const Value& v39, const char *c40, const Value& v40);


	bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30, SqlId c31, const Value& v31); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30, SqlId c31, const Value& v31, SqlId c32, const Value& v32); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30, SqlId c31, const Value& v31, SqlId c32, const Value& v32, SqlId c33, const Value& v33); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30, SqlId c31, const Value& v31, SqlId c32, const Value& v32, SqlId c33, const Value& v33, SqlId c34, const Value& v34); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30, SqlId c31, const Value& v31, SqlId c32, const Value& v32, SqlId c33, const Value& v33, SqlId c34, const Value& v34, SqlId c35, const Value& v35); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30, SqlId c31, const Value& v31, SqlId c32, const Value& v32, SqlId c33, const Value& v33, SqlId c34, const Value& v34, SqlId c35, const Value& v35, SqlId c36, const Value& v36); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30, SqlId c31, const Value& v31, SqlId c32, const Value& v32, SqlId c33, const Value& v33, SqlId c34, const Value& v34, SqlId c35, const Value& v35, SqlId c36, const Value& v36, SqlId c37, const Value& v37); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30, SqlId c31, const Value& v31, SqlId c32, const Value& v32, SqlId c33, const Value& v33, SqlId c34, const Value& v34, SqlId c35, const Value& v35, SqlId c36, const Value& v36, SqlId c37, const Value& v37, SqlId c38, const Value& v38); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30, SqlId c31, const Value& v31, SqlId c32, const Value& v32, SqlId c33, const Value& v33, SqlId c34, const Value& v34, SqlId c35, const Value& v35, SqlId c36, const Value& v36, SqlId c37, const Value& v37, SqlId c38, const Value& v38, SqlId c39, const Value& v39); bool Update(SqlId tb, SqlId k, const Value& kv, SqlId c1, const Value& v1, SqlId c2, const Value& v2, SqlId c3, const Value& v3, SqlId c4, const Value& v4, SqlId c5, const Value& v5, SqlId c6, const Value& v6, SqlId c7, const Value& v7, SqlId c8, const Value& v8, SqlId c9, const Value& v9, SqlId c10, const Value& v10, SqlId c11, const Value& v11, SqlId c12, const Value& v12, SqlId c13, const Value& v13, SqlId c14, const Value& v14, SqlId c15, const Value& v15, SqlId c16, const Value& v16, SqlId c17, const Value& v17, SqlId c18, const Value& v18, SqlId c19, const Value& v19, SqlId c20, const Value& v20, SqlId c21, const Value& v21, SqlId c22, const Value& v22, SqlId c23, const Value& v23, SqlId c24, const Value& v24, SqlId c25, const Value& v25, SqlId c26, const Value& v26, SqlId c27, const Value& v27, SqlId c28, const Value& v28, SqlId c29, const Value& v29, SqlId c30, const Value& v30, SqlId c31, const Value& v31, SqlId c32, const Value& v32, SqlId c33, const Value& v33, SqlId c34, const Value& v34, SqlId c35, const Value& v35, SqlId c36, const Value& v36, SqlId c37, const Value& v37, SqlId c38, const Value& v38, SqlId c39, const Value& v39, SqlId c40, const Value& v40);

	bool        Insert(Fields nf);
	bool        Insert(Fields nf, const char *table);
	bool        Insert(Fields nf, SqlId table);

	bool        Update(Fields nf);
	bool        Update(Fields nf, const char *table);
	bool        Update(Fields nf, SqlId table);

	bool        Delete(const char *table, const char *key, const Value& keyval);
	bool        Delete(SqlId table, SqlId key, const Value& keyval);

	String      ToString() const                       { return cn->ToString(); }

	bool   operator*(const SqlStatement& q)            { return Execute(q); }
	Sql&   operator&(const SqlStatement& q)            { ExecuteX(q); return *this; }
	Value  operator%(const SqlStatement& q)            { return Select0(Compile(q)); }

	SqlSession& GetSession() const                     { return cn->GetSession(); }
	int    GetDialect() const;

	Value  GetInsertedId() const                       { return cn->GetInsertedId(); }

	String GetUser() const                             { return cn->GetUser(); }

	enum ERRORCLASS {
		ERROR_UNSPECIFIED,
		CONNECTION_BROKEN,
	};

	void   SetError(String error, String stmt, int code = 0, const char *scode = 0, ERRORCLASS clss = ERROR_UNSPECIFIED);
	String GetLastError() const;
	String GetErrorStatement() const;
	int    GetErrorCode() const;
	String GetErrorCodeString() const;
	ERRORCLASS GetErrorClass() const;
	void   ClearError();

	void   Begin();
	void   Commit();
	void   Rollback();
	int    GetTransactionLevel();

	String Savepoint();
	void   RollbackTo(const String& savepoint);

	bool   IsOpen();

	bool   WasError() const;

	Sql(SqlSource&);

	Sql();
	Sql(const char *stmt);
	Sql(const SqlStatement& s);
#line 257 "u:\\uppsrc\\sql\\Sqls.h"
	Sql(const char *stmt, SqlSource& session);
	Sql(const SqlStatement& s, SqlSource& session);
	Sql(SqlConnection *connection);
	~Sql();
};


struct AppSql : Sql {
	void   operator=(SqlSource& s) { Assign(s); }
	void   Detach()                { Sql::Detach(); }
	AppSql() : Sql(NULLSQL) {}
};
AppSql& AppCursor();



#line 274 "u:\\uppsrc\\sql\\Sqls.h"

struct StatementExecutor {
	virtual bool Execute(const String& stmt) = 0;
	virtual ~StatementExecutor() {}
};

typedef bool (*RunScript)(const String& text, StatementExecutor& executor, Gate2<int, int> progress_canceled);

class SqlSession : public SqlSource {
protected:
	virtual SqlConnection        *CreateConnection();

	friend class Sql;

	Stream                       *trace;
	bool                          logerrors;
	bool                          tracetime;
	bool                          usrlog;
	int                           traceslow;
	int                           dialect;

	String                        lasterror;
	String                        errorstatement;
	int                           errorcode_number;
	String                        errorcode_string;
	Sql::ERRORCLASS               errorclass;

	ActivityStatus                status;

public:
	virtual void                  Begin();
	virtual void                  Commit();
	virtual void                  Rollback();
	virtual int                   GetTransactionLevel() const;

	virtual String                Savepoint();
	virtual void                  RollbackTo(const String& savepoint);

	virtual bool                  IsOpen() const;

	virtual RunScript             GetRunScript() const;

	virtual Vector<String>        EnumUsers();
	virtual Vector<String>        EnumDatabases();
	virtual Vector<String>        EnumTables(String database);
	virtual Vector<String>        EnumViews(String database);
	virtual Vector<String>        EnumSequences(String database);
	virtual Vector<SqlColumnInfo> EnumColumns(String database, String table);
	virtual Vector<String>        EnumPrimaryKey(String database, String table);
	virtual String                EnumRowID(String database, String table);
	virtual Vector<String>        EnumReservedWords();

	SqlSession&                   Dialect(int q)                          { dialect = q; return *this; }
	int                           GetDialect() const                      { ; return dialect; }

	void                          SetTrace(Stream& s = VppLog())          { trace = &s; }
	Stream                       *GetTrace() const                        { return trace; }
	void                          KillTrace()                             { trace = 0; }

	void                          TraceTime(bool b = true)                { tracetime = b; }
	bool                          IsTraceTime() const                     { return tracetime; }

	SqlSession&                   LogErrors(bool b = true)                { logerrors = true; return *this; }
	SqlSession&                   UsrLog(bool b = true)                   { usrlog = true; return *this; }
	SqlSession&                   TraceSlow(int ms = 5000)                { traceslow = ms; return *this; }

	bool                          WasError() const                        { return !GetLastError().IsEmpty(); }

	void                          SetError(String error, String stmt, int code = 0, const char * scode = 0, Sql::ERRORCLASS clss = Sql::ERROR_UNSPECIFIED);
	String                        GetLastError() const                    { return lasterror; }
	String                        GetErrorStatement() const               { return errorstatement; }
	int                           GetErrorCode() const                    { return errorcode_number; }
	String                        GetErrorCodeString() const              { return errorcode_string; }
	Sql::ERRORCLASS               GetErrorClass() const                   { return errorclass; }
	void                          ClearError();

	String                        GetUser()                               { return Sql(*this).GetUser(); }

	operator                      bool() const                            { return IsOpen(); }

	SqlSession();
	virtual ~SqlSession();

	ActivityStatus&               GetStatus()                             { return status; }
	void                          PassStatus(int s)                       { WhenDatabaseActivity(status.SetStatus(s)); }

	Callback1<const ActivityStatus&> WhenDatabaseActivity;
};

class OciConnection;

struct StdStatementExecutor : StatementExecutor {
	StdStatementExecutor(SqlSession& session) : cursor(session) {}
	virtual bool Execute(const String& stmt);
	Sql cursor;
};


StatementExecutor& SQLStatementExecutor();
#line 374 "u:\\uppsrc\\sql\\Sqls.h"


	typedef Sql        QSql;
	typedef SqlSession QSession;
#line 379 "u:\\uppsrc\\sql\\Sqls.h"
#line 19 "u:/uppsrc\\Sql/Sql.h"
#line 1 "u:\\uppsrc\\sql\\SqlSchema.h"









class SqlSchema {
protected:
	Vector<String> script;
	String         schemaname;
	String         prefix;
	String         table;
	String         table_suffix;
	String         type;
	String         column;
	bool           firstcolumn;
	String         attribute;
	int            items;
	int            dialect;

	int            maxidlen;

public:
	virtual void FlushColumn();
	virtual void FlushTable();

	void Object(const char *text, const char *drop);

	void Table(const char *name);
	void TableSuffix(const char *suffix);
	void Column(const char *type, const char *name);
	void ColumnArray(const char *type, const char *name, int items);
	void Attribute(const char *attr, const char *drop);
	void InlineAttribute(const char *attr);
	void EndTable()                                        { FlushTable(); }

	void Config(const char *config, const char *drop);
	void Upgrade(const char *text);

	String  CurrentTable() const;
	String  CurrentColumn() const                          { return column; }
	String  CurrentType() const                            { return Expand(type); }
	String  Expand(const char *txt, int i = Null) const;

	enum {
		SCHEMA, DROPSCHEMA, ATTRIBUTES, DROPATTRIBUTES, UPGRADE, DROPUPGRADE, CONFIG, DROPCONFIG
	};

	String& Script(int si);
	String  Script(int si) const;

	String& Schema();
	String& SchemaDrop();
	String& Attributes();
	String& AttributesDrop();
	String& Upgrade();
	String& UpgradeDrop();
	String& Config();
	String& ConfigDrop();

	String  NormalFileName(int i, const char *dir = 0, const char *name = 0) const;
	bool    ScriptChanged(int i, const char *dir = 0, const char *name = 0) const;
	bool    UpdateNormalFile(int i, const char *dir = 0, const char *name = 0) const;
	void    SaveNormal(const char *dir = 0, const char *name = 0) const;

	void Var(void (*type)(SqlSchema& s), const char *name);

	SqlSchema& SchemaName(String sch)                          { schemaname = sch; return *this; }
	SqlSchema& MaxIDLen(int n)                                 { maxidlen = n; return *this; }

	int        GetDialect() const                              { return dialect; }


	SqlSchema(int dialect = AppCursor().GetDialect());


#line 81 "u:\\uppsrc\\sql\\SqlSchema.h"
	virtual ~SqlSchema() {}
};

void operator*(SqlSchema& schema, const SqlInsert& insert);

template <class T>
inline void SqlSchemaInitClear(T& a) {}

template <class T>
inline void SqlSchemaInitClear(T *a, int n) {
	while(n--)
		SqlSchemaInitClear(*a++);
}

inline void SqlSchemaInitClear(int& a)    { a = Null; }
inline void SqlSchemaInitClear(double& a) { a = Null; }
inline void SqlSchemaInitClear(int64& a)  { a = Null; }
inline void SqlSchemaInitClear(bool& a)   { a = false; }

template <class T>
inline void SqlSchemaClear(T& a)          { a = Null; }

inline void SqlSchemaClear(bool& a)       { a = false; }

template <class T>
inline void SqlSchemaClear(T *a, int n) {
	while(n--)
		SqlSchemaClear(*a++);
}
#line 20 "u:/uppsrc\\Sql/Sql.h"

};

#line 24 "u:/uppsrc\\Sql/Sql.h"
#line 5 "u:/uppsrc\\Oracle/Oracle7.h"
#line 1 "u:\\uppsrc\\oracle\\OraCommon.h"



class OciSqlConnection;


namespace Upp {

Date        OciDecodeDate(const byte data[7]);
bool        OciEncodeDate(byte data[7], Date d);
Time        OciDecodeTime(const byte data[7]);
bool        OciEncodeTime(byte data[7], Time t);

const char *OciParseString(const char *s);
String      OciParseStringError(const char *s);
String      OciParseRefError(const char *s);

int         OciParse(const char *statement, String& out, OciSqlConnection *conn, SqlSession *session);
Sql::ERRORCLASS OciErrorClass(int errcode);

class SqlSequence : public ValueGen {
	SqlId       ssq;
	SqlId&      seq;
	SqlSession *session;

public:
	virtual Value  Get();

	Value operator++()                                                  { return Get(); }

	void Set(SqlId id, SqlSession& s)                                   { ssq = id; session = &s; }


	void Set(SqlId id)                                                  { ssq = id; session = 0; }
	SqlSequence(const char *name) : ssq(name), seq(ssq)                 { session = 0; }
	SqlSequence(SqlId& seq) : seq(seq)                                  { session = 0; }
#line 38 "u:\\uppsrc\\oracle\\OraCommon.h"
	SqlSequence(const char *name, SqlSession& s) : ssq(name), seq(ssq)  { session = &s; }
	SqlSequence(SqlId& seq, SqlSession& s) : seq(seq)                   { session = &s; }
	SqlSequence() : seq(ssq)                                            { session = 0; }
};


bool OraclePerformScript(const String& text, StatementExecutor& se = SQLStatementExecutor(), Gate2<int, int> progress_canceled = false);


#line 48 "u:\\uppsrc\\oracle\\OraCommon.h"

Vector<String> OracleSchemaUsers(Sql& cursor);
Vector<String> OracleSchemaTables(Sql& cursor, String database);
Vector<String> OracleSchemaViews(Sql& cursor, String database);
Vector<String> OracleSchemaSequences(Sql& cursor, String database);
Vector<String> OracleSchemaPrimaryKey(Sql& cursor, String database, String table);
String         OracleSchemaRowID(Sql& cursor, String database, String table);
Vector<String> OracleSchemaReservedWords();

const int ORA_BLOB_V = -1;
const int ORA_CLOB_V = -2;

class OracleRef {
public:
	OracleRef(int ora_vtype = VOID_V) : ora_vtype(ora_vtype) {}
	OracleRef(const Value& v) : ora_vtype(IsValue(v) ? ValueTo<OracleRef>(v).ora_vtype : VOID_V) {}

	operator    Value () const                { return RawToValue(*this); }
	static bool IsValue(const Value& v)       { return IsTypeRaw<OracleRef>(v); }

	const char *Parse(const char *stmt);
	int         GetType() const               { return ora_vtype; }

	int         GetOraType() const;
	int         GetMaxLen() const;

private:
	int         ora_vtype;
};

class OciSqlConnection : public SqlConnection {
	friend int OciParse(const char *statement, String& out, OciSqlConnection *conn, SqlSession *session);

protected:
	virtual void SetParam(int i, OracleRef ref) = 0;
};

};

#line 88 "u:\\uppsrc\\oracle\\OraCommon.h"
#line 6 "u:/uppsrc\\Oracle/Oracle7.h"
#line 1 "u:\\uppsrc\\oracle\\OciCommon.h"




namespace Upp {
struct OCIEnv;
struct OCIServer;
struct OCISession;
struct OCIStmt;
struct OCIBind;
struct OCIDefine;
struct OCISnapshot;
struct OCIParam;
};


typedef void dvoid;
typedef int sword;
typedef int sb4;
typedef Upp::dword uword;
typedef Upp::dword ub4;
typedef short sb2;
typedef Upp::word ub2;
typedef signed char sb1;
typedef Upp::byte ub1;
typedef Upp::byte OraText;
enum
{

	OCI_THREADED   = 0x01,
	OCI_OBJECT     = 0x02,
	OCI_EVENTS     = 0x04,
	OCI_RESERVED1  = 0x08,
	OCI_SHARED     = 0x10,
	OCI_RESERVED2  = 0x20,

	OCI_NO_UCB     = 0x40,
	OCI_NO_MUTEX   = 0x80,

	OCI_SHARED_EXT = 0x100,
	OCI_CACHE      = 0x200,

	OCI_DEFAULT      = 0x00,
	OCI_DATA_AT_EXEC = 0x02,

	OCI_HTYPE_FIRST                = 1,
	OCI_HTYPE_ENV                  = 1,
	OCI_HTYPE_ERROR                = 2,
	OCI_HTYPE_SVCCTX               = 3,
	OCI_HTYPE_STMT                 = 4,
	OCI_HTYPE_BIND                 = 5,
	OCI_HTYPE_DEFINE               = 6,
	OCI_HTYPE_DESCRIBE             = 7,
	OCI_HTYPE_SERVER               = 8,
	OCI_HTYPE_SESSION              = 9,
	OCI_HTYPE_TRANS                = 10,
	OCI_HTYPE_COMPLEXOBJECT        = 11,
	OCI_HTYPE_SECURITY             = 12,
	OCI_HTYPE_SUBSCRIPTION         = 13,
	OCI_HTYPE_DIRPATH_CTX          = 14,
	OCI_HTYPE_DIRPATH_COLUMN_ARRAY = 15,
	OCI_HTYPE_DIRPATH_STREAM       = 16,
	OCI_HTYPE_PROC                 = 17,
	OCI_HTYPE_LAST                 = 17,


	SQLT_CHR = 1,
	SQLT_NUM = 2,
	SQLT_INT = 3,
	SQLT_FLT = 4,
	SQLT_STR = 5,
	SQLT_VNU = 6,
	SQLT_PDN = 7,
	SQLT_LNG = 8,
	SQLT_VCS = 9,
	SQLT_NON = 10,
	SQLT_RID = 11,
	SQLT_DAT = 12,
	SQLT_VBI = 15,
	SQLT_BIN = 23,
	SQLT_LBI = 24,
	SQLT_UIN = 68,
	SQLT_SLS = 91,
	SQLT_LVC = 94,
	SQLT_LVB = 95,
	SQLT_AFC = 96,
	SQLT_AVC = 97,
	SQLT_CUR = 102,
	SQLT_RDD = 104,
	SQLT_LAB = 105,
	SQLT_OSL = 106,

	SQLT_NTY = 108,
	SQLT_REF = 110,
	SQLT_CLOB = 112,
	SQLT_BLOB = 113,
	SQLT_BFILEE = 114,
	SQLT_CFILEE = 115,
	SQLT_RSET = 116,
	SQLT_NCO = 122,
	SQLT_VST = 155,
	SQLT_ODT = 156,


	SQLT_DATE = 184,
	SQLT_TIME = 185,
	SQLT_TIME_TZ = 186,
	SQLT_TIMESTAMP = 187,
	SQLT_TIMESTAMP_TZ = 188,
	SQLT_INTERVAL_YM = 189,
	SQLT_INTERVAL_DS = 190,
	SQLT_TIMESTAMP_LTZ = 232,



	SQLT_FILE = SQLT_BFILEE,
	SQLT_CFILE = SQLT_CFILEE,
	SQLT_BFILE = SQLT_BFILEE,

	OCI_DTYPE_FIRST = 50,
	OCI_DTYPE_LOB = 50,
	OCI_DTYPE_SNAP = 51,
	OCI_DTYPE_RSET = 52,
	OCI_DTYPE_PARAM = 53,
	OCI_DTYPE_ROWID = 54,
	OCI_DTYPE_COMPLEXOBJECTCOMP = 55,

	OCI_DTYPE_FILE = 56,
	OCI_DTYPE_AQENQ_OPTIONS = 57,
	OCI_DTYPE_AQDEQ_OPTIONS = 58,
	OCI_DTYPE_AQMSG_PROPERTIES = 59,
	OCI_DTYPE_AQAGENT = 60,
	OCI_DTYPE_LOCATOR = 61,
	OCI_DTYPE_INTERVAL_YM = 62,
	OCI_DTYPE_INTERVAL_DS = 63,
	OCI_DTYPE_AQNFY_DESCRIPTOR = 64,
	OCI_DTYPE_DATE = 65,
	OCI_DTYPE_TIME = 66,
	OCI_DTYPE_TIME_TZ = 67,
	OCI_DTYPE_TIMESTAMP = 68,
	OCI_DTYPE_TIMESTAMP_TZ = 69,
	OCI_DTYPE_TIMESTAMP_LTZ = 70,
	OCI_DTYPE_UCB = 71,
	OCI_DTYPE_LAST = 71,

	OCI_V7_SYNTAX  = 2,
	OCI_V8_SYNTAX  = 3,
	OCI_NTV_SYNTAX = 1,

	OCI_STMT_SELECT  = 1,
	OCI_STMT_UPDATE  = 2,
	OCI_STMT_DELETE  = 3,
	OCI_STMT_INSERT  = 4,
	OCI_STMT_CREATE  = 5,
	OCI_STMT_DROP    = 6,
	OCI_STMT_ALTER   = 7,
	OCI_STMT_BEGIN   = 8,
	OCI_STMT_DECLARE = 9,

	OCI_BATCH_MODE             = 0x01,
	OCI_EXACT_FETCH            = 0x02,
	OCI_KEEP_FETCH_STATE       = 0x04,
	OCI_SCROLLABLE_CURSOR      = 0x08,
	OCI_DESCRIBE_ONLY          = 0x10,
	OCI_COMMIT_ON_SUCCESS      = 0x20,
	OCI_NON_BLOCKING           = 0x40,
	OCI_BATCH_ERRORS           = 0x80,
	OCI_PARSE_ONLY             = 0x100,
	OCI_EXACT_FETCH_RESERVED_1 = 0x200,
	OCI_SHOW_DML_WARNINGS      = 0x400,

	OCI_SUCCESS              = 0,
	OCI_SUCCESS_WITH_INFO    = 1,
	OCI_RESERVED_FOR_INT_USE = 200,
	OCI_NO_DATA              = 100,
	OCI_ERROR                = -1,
	OCI_INVALID_HANDLE       = -2,
	OCI_NEED_DATA            = 99,
	OCI_STILL_EXECUTING      = -3123,
	OCI_CONTINUE             = -24200,

	SQLCS_IMPLICIT = 1,
	SQLCS_NCHAR    = 2,
	SQLCS_EXPLICIT = 3,
	SQLCS_FLEXIBLE = 4,
	SQLCS_LIT_NULL = 5,

	OCI_FETCH_NEXT       = 0x02,
	OCI_FETCH_FIRST      = 0x04,
	OCI_FETCH_LAST       = 0x08,
	OCI_FETCH_PRIOR      = 0x10,
	OCI_FETCH_ABSOLUTE   = 0x20,
	OCI_FETCH_RELATIVE   = 0x40,
	OCI_FETCH_RESERVED_1 = 0x80,

	OCI_ONE_PIECE    = 0,
	OCI_FIRST_PIECE  = 1,
	OCI_NEXT_PIECE   = 2,
	OCI_LAST_PIECE   = 3,

	OCI_ATTR_DATA_SIZE     = 1,
	OCI_ATTR_DATA_TYPE     = 2,
	OCI_ATTR_NAME          = 4,
	OCI_ATTR_PRECISION     = 5,
	OCI_ATTR_SCALE         = 6,
	OCI_ATTR_ROW_COUNT     = 9,
	OCI_ATTR_PREFETCH_ROWS = 11,
	OCI_ATTR_STMT_TYPE     = 24,
	OCI_ATTR_PARAM_COUNT   = 18,

	OCI_ATTR_ENV           = 5,
	OCI_ATTR_SERVER        = 6,
	OCI_ATTR_SESSION       = 7,

	OCI_ATTR_USERNAME      = 22,
	OCI_ATTR_PASSWORD      = 23,

	OCI_CRED_RDBMS         = 1,

	OCI_LM_DEF = 0,
	OCI_LM_NBL = 1,

	OCI_STRING_MAXLEN = 4000,
};



#line 229 "u:\\uppsrc\\oracle\\OciCommon.h"

#line 231 "u:\\uppsrc\\oracle\\OciCommon.h"

struct cda_head {
    sb2          v2_rc;
    ub2          ft;
    ub4          rpc;
    ub2          peo;
    ub1          fc;
    ub1          rcs1;
    ub2          rc;
    ub1          wrn;
    ub1          rcs2;
    sword        rcs3;
    struct {
        struct {
           ub4    rcs4;
           ub2    rcs5;
           ub1    rcs6;
        } rd;
        ub4    rcs7;
        ub2    rcs8;
    } rid;
    sword        ose;
    ub1		 chk;
    dvoid        *rcsp;
};

struct cda_def {
    sb2          v2_rc;
    ub2          ft;
    ub4          rpc;
    ub2          peo;
    ub1          fc;
    ub1          rcs1;
    ub2          rc;
    ub1          wrn;
    ub1          rcs2;
    sword        rcs3;
    struct {
        struct {
           ub4    rcs4;
           ub2    rcs5;
           ub1    rcs6;
        } rd;
        ub4    rcs7;
        ub2    rcs8;
    } rid;
    sword        ose;
    ub1		 chk;
    dvoid        *rcsp;
    ub1          rcs9[64 - sizeof (struct cda_head)];
};

typedef sb4 (*OCICallbackInBind)(dvoid *ictxp, Upp::OCIBind *bindp, ub4 iter,
	ub4 index, dvoid **bufpp, ub4 *alenp,
	ub1 *piecep, dvoid **indp);

typedef sb4 (*OCICallbackOutBind)(dvoid *octxp, Upp::OCIBind *bindp, ub4 iter,
	ub4 index, dvoid **bufpp, ub4 **alenp,
	ub1 *piecep, dvoid **indp,
	ub2 **rcodep);

#line 293 "u:\\uppsrc\\oracle\\OciCommon.h"
#line 7 "u:/uppsrc\\Oracle/Oracle7.h"

namespace Upp {




#line 1 "u:/idisapp\\Core/dli_header.h"

#line 1 "u:/idisapp\\Core/dli.h"
#pragma BLITZ_APPROVE















#line 18 "u:/idisapp\\Core/dli.h"






#line 25 "u:/idisapp\\Core/dli.h"
#line 26 "u:/idisapp\\Core/dli.h"










#line 37 "u:/idisapp\\Core/dli.h"








struct T_OCI7{
	T_OCI7();

	Upp::String       GetLibName() const        { return libname; }
	void              SetLibName(const char *n) { if(handle) Free(); libname = n; checked = false; }

	bool              Load();
	bool              Load(const char *n)       { SetLibName(n); return Load(); }
	void              Force();
	void              Free();

	operator          bool ()      { return handle; }

#line 1 "u:/uppsrc\\Oracle/Oci7.dli"






typedef int ( obindps_type) (struct cda_def *cursor, ub1 opcode, OraText *sqlvar, int sqlvl, ub1 *pvctx, int progvl, int ftype, int scale, short *indp, word *alen, word *arcode, int pv_skip, int ind_skip, int alen_skip, int rc_skip, dword maxsiz, dword *cursiz, OraText *fmt, int fmtl, int fmtt); obindps_type *obindps;

typedef int ( obreak_type) (struct cda_def *lda); obreak_type *obreak;
typedef int ( ocan_type) (struct cda_def *cursor); ocan_type *ocan;
typedef int ( oclose_type) (struct cda_def *cursor); oclose_type *oclose;
typedef int ( ocof_type) (struct cda_def *lda); ocof_type *ocof;
typedef int ( ocom_type) (struct cda_def *lda); ocom_type *ocom;
typedef int ( ocon_type) (struct cda_def *lda); ocon_type *ocon;






typedef int ( odefinps_type) (struct cda_def *cursor, ub1 opcode, int pos,ub1 *bufctx, int bufl, int ftype, int scale, short *indp, OraText *fmt, int fmtl, int fmtt, word *rlen, word *rcode, int pv_skip, int ind_skip, int alen_skip, int rc_skip); odefinps_type *odefinps;






typedef int ( odessp_type) (struct cda_def *cursor, OraText *objnam, size_t onlen, ub1 *rsv1, size_t rsv1ln, ub1 *rsv2, size_t rsv2ln, word *ovrld, word *pos, word *level, OraText **argnam, word *arnlen, word *dtype, ub1 *defsup, ub1* mode, dword *dtsiz, short *prec, short *scale, ub1 *radix, dword *spare, dword *arrsiz); odessp_type *odessp;



typedef int ( odescr_type) (struct cda_def *cursor, int pos, int *dbsize, short *dbtype, sb1 *cbuf, int *cbufl, int *dsize, short *prec, short *scale, short *nullok); odescr_type *odescr;

typedef int ( oerhms_type) (struct cda_def *lda, short rcode, OraText *buf, int bufsiz); oerhms_type *oerhms;
typedef int ( oermsg_type) (short rcode, OraText *buf); oermsg_type *oermsg;
typedef int ( oexec_type) (struct cda_def *cursor); oexec_type *oexec;
typedef int ( oexfet_type) (struct cda_def *cursor, dword nrows, int cancel, int exact); oexfet_type *oexfet;
typedef int ( oexn_type) (struct cda_def *cursor, int iters, int rowoff); oexn_type *oexn;
typedef int ( ofen_type) (struct cda_def *cursor, int nrows); ofen_type *ofen;
typedef int ( ofetch_type) (struct cda_def *cursor); ofetch_type *ofetch;

typedef int ( oflng_type) (struct cda_def *cursor, int pos, ub1 *buf, int bufl, int dtype, dword *retl, int offset); oflng_type *oflng;

typedef int ( ogetpi_type) (struct cda_def *cursor, ub1 *piecep, dvoid **ctxpp, dword *iterp, dword *indexp); ogetpi_type *ogetpi;
typedef int ( oopt_type) (struct cda_def *cursor, int rbopt, int waitopt); oopt_type *oopt;
typedef int ( opinit_type) (dword mode); opinit_type *opinit;

typedef int ( olog_type) (struct cda_def *lda, ub1* hda, OraText *uid, int uidl, OraText *pswd, int pswdl, OraText *conn, int connl, dword mode); olog_type *olog;
typedef int ( ologof_type) (struct cda_def *lda); ologof_type *ologof;

typedef int ( oopen_type) (struct cda_def *cursor, struct cda_def *lda, OraText *dbn, int dbnl, int arsize, OraText *uid, int uidl); oopen_type *oopen;
typedef int ( oparse_type) (struct cda_def *cursor, OraText *sqlstm, int sqllen, int defflg, dword lngflg); oparse_type *oparse;
typedef int ( orol_type) (struct cda_def *lda); orol_type *orol;
typedef int ( osetpi_type) (struct cda_def *cursor, ub1 piece, dvoid *bufp, dword *lenp); osetpi_type *osetpi;

typedef int ( onbset_type) (struct cda_def *lda ); onbset_type *onbset;
typedef int ( onbtst_type) (struct cda_def *lda ); onbtst_type *onbtst;
typedef int ( onbclr_type) (struct cda_def *lda ); onbclr_type *onbclr;
typedef int ( ognfd_type) (struct cda_def *lda, dvoid *fdp); ognfd_type *ognfd;




typedef int ( obndra_type) (struct cda_def *cursor, OraText *sqlvar, int sqlvl, ub1 *progv, int progvl, int ftype, int scale, short *indp, word *alen, word *arcode, dword maxsiz, dword *cursiz, OraText *fmt, int fmtl, int fmtt); obndra_type *obndra;


typedef int ( obndrn_type) (struct cda_def *cursor, int sqlvn, ub1 *progv, int progvl, int ftype, int scale, short *indp, OraText *fmt, int fmtl, int fmtt); obndrn_type *obndrn;


typedef int ( obndrv_type) (struct cda_def *cursor, OraText *sqlvar, int sqlvl, ub1 *progv, int progvl, int ftype, int scale, short *indp, OraText *fmt, int fmtl, int fmtt); obndrv_type *obndrv;


typedef int ( odefin_type) (struct cda_def *cursor, int pos, ub1 *buf, int bufl, int ftype, int scale, short *indp, OraText *fmt, int fmtl, int fmtt, word *rlen, word *rcode); odefin_type *odefin;
#line 59 "u:/idisapp\\Core/dli.h"
private:
	Upp::String       libname;
	DLLHANDLE         handle;
	bool              checked;
};






T_OCI7& OCI7();
T_OCI7& OCI7_();

#line 74 "u:/idisapp\\Core/dli.h"







































































































#line 178 "u:/idisapp\\Core/dli.h"

















#line 3 "u:/idisapp\\Core/dli_header.h"
#line 14 "u:/uppsrc\\Oracle/Oracle7.h"

class OCI7Connection;

void OCI7SetDllPath(String oci7_path, T_OCI7& oci7 = OCI7_());

class Oracle7 : public SqlSession {
public:
	virtual void                  Begin();
	virtual void                  Commit();
	virtual void                  Rollback();

	virtual String                Savepoint();
	virtual void                  RollbackTo(const String& savepoint);

	virtual bool                  IsOpen() const;

	virtual RunScript             GetRunScript() const          { return &OraclePerformScript; }

	virtual Vector<String>        EnumUsers();
	virtual Vector<String>        EnumDatabases();
	virtual Vector<String>        EnumTables(String database);
	virtual Vector<String>        EnumViews(String database);
	virtual Vector<String>        EnumSequences(String database);
	virtual Vector<String>        EnumPrimaryKey(String database, String table);
	virtual String                EnumRowID(String database, String table);
	virtual Vector<String>        EnumReservedWords();

public:
	T_OCI7&                       oci7;

protected:
	virtual SqlConnection        *CreateConnection();

protected:
	friend class OCI7Connection;

	Link<OCI7Connection> clink;
	bool                 connected;
	byte                 lda[256];
	byte                 hda[512];
	String               user;
	int                  level;
	bool                 autocommit;
	int                  tmode;

	String         Spn();
	void           SetSp();
	String         GetErrorMsg(int code) const;
	void           PreExec();
	void           PostExec();

public:
	bool Open(const String& s);
	void Close();

	enum TransactionMode {
		NORMAL,
		ORACLE
	};

	void    SetTransactionMode(int mode)            { tmode = mode; }

	Oracle7(T_OCI7& oci7 = OCI7_());
	~Oracle7();
};

typedef Oracle7 OracleSession;

};

#line 85 "u:/uppsrc\\Oracle/Oracle7.h"
#line 20 "u:/idisapp\\IdisMisc/IdisMisc.h"



























#line 1 "u:/uppsrc\\SqlCtrl/SqlCtrl.h"



#line 1 "u:/uppsrc\\Sql/Sql.h"























#line 5 "u:/uppsrc\\SqlCtrl/SqlCtrl.h"
#line 1 "u:/uppsrc\\CtrlLib/CtrlLib.h"

























































#line 6 "u:/uppsrc\\SqlCtrl/SqlCtrl.h"


namespace Upp {

int  SqlError(const char *text, const char *error, const char *statement, bool retry = false);
int  SqlError(const char *text, const SqlSession& session, bool retry = false);
int  SqlError(const char *text, const Sql& sql = AppCursor(), bool retry = false);


int  SqlError(HWND parent, const char *text, const char *error, const char *statement, bool retry = false);
int  SqlError(HWND parent, const char *text, const SqlSession& session, bool retry = false);
int  SqlError(HWND parent, const char *text, const Sql& sql = AppCursor(), bool retry = false);
#line 19 "u:/uppsrc\\SqlCtrl/SqlCtrl.h"

bool   DisplayError(const SqlSession& session, const char *msg = 0);
bool   ShowError(SqlSession& session, const char *msg = 0);
bool   ErrorRollback(SqlSession& session, const char *emsg = 0);
bool   OkCommit(SqlSession& session, const char *emsg = 0);

bool   DisplayError(const Sql& sql, const char *msg = 0);
bool   ShowError(Sql& sql, const char *msg = 0);
bool   ErrorRollback(Sql& sql, const char *emsg = 0);
bool   OkCommit(Sql& sql, const char *emsg = 0);


bool   DisplayError(const char *msg = 0);
bool   ShowError(const char *msg = 0);
bool   ErrorRollback(const char *emsg = 0);
bool   OkCommit(const char *emsg = 0);
#line 36 "u:/uppsrc\\SqlCtrl/SqlCtrl.h"

void SqlLoad(MapConvert& cv, Sql& sql);
void SqlLoad(MapConvert& cv, const SqlSelect& set, SqlSession& ss = AppCursor().GetSession());

void operator*=(MapConvert& cv, const SqlSelect& set);
#line 42 "u:/uppsrc\\SqlCtrl/SqlCtrl.h"

void SqlLoad(DropList& dl, Sql& sql);
void SqlLoad(DropList& dl, const SqlSelect& set, SqlSession& ss = AppCursor().GetSession());

void operator*=(DropList& cv, const SqlSelect& set);
#line 48 "u:/uppsrc\\SqlCtrl/SqlCtrl.h"

class SqlOption : public Option {
public:
	virtual void   SetData(const Value& data);
	virtual Value  GetData() const;
};

class SqlArray : public ArrayCtrl {
public:
	virtual void  SetData(const Value& v);
	virtual Value GetData() const;
	virtual bool  Accept();

protected:
	virtual bool  UpdateRow();
	virtual void  RejectRow();

private:
	SqlSession *ssn;
	SqlId       table;
	Value       fkv;
	SqlId       fk;
	SqlBool     where;
	SqlSet      orderby;
	int         querytime;
	int         count;
	int64       offset;
	bool        lateinsert;
	bool        goendpostquery;
	bool        autoinsertid;

	SqlBool     GetWhere();

	SqlSession& Session()                                  { return ssn ? *ssn : AppCursor().GetSession(); }


#line 85 "u:/uppsrc\\SqlCtrl/SqlCtrl.h"

	bool        PerformInsert();
	bool        PerformDelete();

	void      Inserting();

public:
	Callback  WhenPostQuery;

	void      StdBar(Bar& menu);
	bool      CanInsert() const;
	void      StartInsert();
	void      StartDuplicate();
	void      DoRemove();

	void      SetSession(SqlSession& _session)             { ssn = &_session; }

	void      Join(SqlId fk, ArrayCtrl& master);
	void      Join(ArrayCtrl& master);

	void      Query();
	void      AppendQuery(SqlBool where);
	void      Query(SqlBool where)                         { SetWhere(where); Query(); }
	void      ReQuery();

	void      Limit(int _offset, int _count)               { offset = _offset; count = _count; }
	void      Limit(int count)                             { Limit(0, count); }

	SqlArray& SetTable(SqlId _table)                       { table = _table; return *this; }
	SqlArray& SetWhere(SqlBool _where)                     { where = _where; return *this;  }
	SqlArray& SetOrderBy(SqlSet _orderby)                  { orderby = _orderby; return *this; }
	SqlArray& SetOrderBy(const SqlVal& a)                  { return SetOrderBy(SqlSet(a)); }
	SqlArray& SetOrderBy(const SqlVal& a, const SqlVal& b) { return SetOrderBy(SqlSet(a, b)); }
	SqlArray& SetOrderBy(const SqlVal& a, const SqlVal& b, const SqlVal& c)
	                                                       { return SetOrderBy(SqlSet(a, b, c)); }
	SqlArray& GoEndPostQuery(bool b = true)                { goendpostquery = b; return *this; }
	SqlArray& AutoInsertId(bool b = true)                  { autoinsertid = b; return *this; }
	SqlArray& AppendingAuto()                              { Appending(); return AutoInsertId(); }

	void      Clear();
	void      Reset();

	typedef   SqlArray CLASSNAME;

	SqlArray();
};

class SqlCtrls {
	struct Item {
		SqlId id;
		Ctrl *ctrl;
	};
	Array<Item> item;

public:
	void      Add(SqlId id, Ctrl& ctrl);
	SqlCtrls& operator()(SqlId id, Ctrl& ctrl)       { Add(id, ctrl); return *this; }
	SqlSet    Set() const;
	operator  SqlSet() const                         { return Set(); }
	void      Read(Sql& sql);
	bool      Fetch(Sql& sql);

	bool      Fetch()                                { return Fetch(AppCursor()); }
#line 149 "u:/uppsrc\\SqlCtrl/SqlCtrl.h"
	bool      Load(Sql& sql, SqlSelect set)          { sql * set; return Fetch(sql); }

	bool      Load(SqlSelect set)                    { return Load(AppCursor(), set); }
#line 153 "u:/uppsrc\\SqlCtrl/SqlCtrl.h"
	bool      Load(Sql& sql, SqlId table, SqlBool where);

	bool      Load(SqlId table, SqlBool where);
#line 157 "u:/uppsrc\\SqlCtrl/SqlCtrl.h"
	void      Insert(SqlInsert& insert) const;
	void      Update(SqlUpdate& update) const;
	void      UpdateModified(SqlUpdate& update) const;
	SqlInsert Insert(SqlId table) const;
	SqlUpdate Update(SqlId table) const;
	SqlUpdate UpdateModified(SqlId table) const;
	bool      Accept();
	void      ClearModify();
	bool      IsModified();
	void      Enable(bool b = true);
	void      Disable()                              { Enable(false); }
	void      SetNull();
	Callback  operator<<=(Callback cb);

	int         GetCount() const                     { return item.GetCount(); }
	Ctrl&       operator[](int i)                    { return *item[i].ctrl; }
	const Ctrl& operator[](int i) const              { return *item[i].ctrl; }
	SqlId       operator()(int i) const              { return item[i].id; }

	void      Reset()                                { item.Clear(); }
};

class SqlDetail : public StaticRect {
public:
	virtual void  SetData(const Value& v);
	virtual Value GetData() const;
	virtual bool  Accept();

private:
	SqlSession *ssn;
	SqlCtrls    ctrls;
	SqlId       table;
	Value       fkval;
	SqlId       fk;
	bool        present;
	bool        autocreate;


	SqlSession& Session()                          { return ssn ? *ssn : AppCursor().GetSession(); }


#line 199 "u:/uppsrc\\SqlCtrl/SqlCtrl.h"

	void        Query();

public:
	Callback    WhenPostQuery;

	bool        IsPresent() const                  { return present; }
	bool        Create();
	bool        Delete();

	void        SetSession(SqlSession& _session)   { ssn = &_session; }

	SqlDetail&  Add(SqlId id, Ctrl& ctrl);
	SqlDetail&  operator()(SqlId id, Ctrl& ctrl)   { return Add(id, ctrl); }

	SqlDetail&  Join(SqlId fk, ArrayCtrl& master);
	SqlDetail&  Join(ArrayCtrl& master);
	SqlDetail&  SetTable(SqlId _table)             { table = _table; return *this; }
	SqlDetail&  AutoCreate(bool b = true)          { autocreate = b; return *this; }

	void        Reset();

	SqlDetail();
};

void        SQLCommander(SqlSession& session);

inline void SQLCommander() { SQLCommander(AppCursor().GetSession()); }
#line 228 "u:/uppsrc\\SqlCtrl/SqlCtrl.h"
void        SQLObjectTree(SqlSession& session = AppCursor().GetSession());

};

#line 233 "u:/uppsrc\\SqlCtrl/SqlCtrl.h"
#line 48 "u:/idisapp\\IdisMisc/IdisMisc.h"
#line 1 "u:/uppsrc\\Oracle/Oracle7.h"




















































































#line 49 "u:/idisapp\\IdisMisc/IdisMisc.h"

using namespace Upp;

#line 1 "u:/uppsrc\\TCore/TCore.h"



#line 1 "u:/uppsrc\\Web/Web.h"



#line 1 "u:/idisapp\\Core/Core.h"






























































































































































































































































































































































































































































































































#line 5 "u:/uppsrc\\Web/Web.h"





#line 1 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"




























#line 30 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 38 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"



#line 42 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"
















#line 59 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"



#line 63 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"











#line 75 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"
#line 76 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


extern "C" {
#line 80 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"




typedef unsigned char   u_char;
typedef unsigned short  u_short;
typedef unsigned int    u_int;
typedef unsigned long   u_long;
typedef unsigned __int64 u_int64;






typedef UINT_PTR        SOCKET;











#line 108 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"

typedef struct fd_set {
        u_int fd_count;
        SOCKET  fd_array[64];
} fd_set;

extern int __stdcall  __WSAFDIsSet(SOCKET, fd_set  *);






































struct timeval {
        long    tv_sec;
        long    tv_usec;
};




















































struct  hostent {
        char     * h_name;
        char     *  * h_aliases;
        short   h_addrtype;
        short   h_length;
        char     *  * h_addr_list;

};





struct  netent {
        char     * n_name;
        char     *  * n_aliases;
        short   n_addrtype;
        u_long  n_net;
};

struct  servent {
        char     * s_name;
        char     *  * s_aliases;




        short   s_port;
        char     * s_proto;
#line 239 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"
};

struct  protoent {
        char     * p_name;
        char     *  * p_aliases;
        short   p_proto;
};




























































































struct in_addr {
        union {
                struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { u_short s_w1,s_w2; } S_un_w;
                u_long S_addr;
        } S_un;












};
#line 358 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







































struct sockaddr_in {
        short   sin_family;
        u_short sin_port;
        struct  in_addr sin_addr;
        char    sin_zero[8];
};




typedef struct WSAData {
        WORD                    wVersion;
        WORD                    wHighVersion;







        char                    szDescription[256+1];
        char                    szSystemStatus[128+1];
        unsigned short          iMaxSockets;
        unsigned short          iMaxUdpDg;
        char  *              lpVendorInfo;
#line 423 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"
} WSADATA,  * LPWSADATA;






































































#line 495 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"































































struct sockaddr {
        u_short sa_family;
        char    sa_data[14];
};



















struct sockaddr_storage {
    short ss_family;
    char __ss_pad1[((sizeof(__int64)) - sizeof (short))];



    __int64 __ss_align;
    char __ss_pad2[(128 - (sizeof (short) + ((sizeof(__int64)) - sizeof (short)) + (sizeof(__int64))))];



};





struct sockproto {
        u_short sp_family;
        u_short sp_protocol;
};



































struct  linger {
        u_short l_onoff;
        u_short l_linger;
};










































































































































































































































































































#line 940 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"











typedef struct _OVERLAPPED *    LPWSAOVERLAPPED;











































#line 996 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"






typedef struct _WSABUF {
    u_long      len;
    char  *  buf;
} WSABUF,  * LPWSABUF;

#line 1 "d:\\sdk\\Microsoft SDK\\include\\qos.h"

























typedef ULONG   SERVICETYPE;





























































typedef struct _flowspec
{
    ULONG       TokenRate;
    ULONG       TokenBucketSize;
    ULONG       PeakBandwidth;
    ULONG       Latency;
    ULONG       DelayVariation;
    SERVICETYPE ServiceType;
    ULONG       MaxSduSize;
    ULONG       MinimumPolicedSize;

} FLOWSPEC, *PFLOWSPEC, * LPFLOWSPEC;































typedef struct  {

    ULONG   ObjectType;
    ULONG   ObjectLength;


} QOS_OBJECT_HDR, *LPQOS_OBJECT_HDR;




































typedef struct _QOS_SD_MODE {

    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            ShapeDiscardMode;

} QOS_SD_MODE, *LPQOS_SD_MODE;















typedef struct _QOS_SHAPING_RATE {

    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            ShapingRate;

} QOS_SHAPING_RATE, *LPQOS_SHAPING_RATE;


#line 204 "d:\\sdk\\Microsoft SDK\\include\\qos.h"
#line 1008 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"

typedef struct _QualityOfService
{
    FLOWSPEC      SendingFlowspec;
    FLOWSPEC      ReceivingFlowspec;
    WSABUF        ProviderSpecific;
} QOS,  * LPQOS;


















typedef unsigned int             GROUP;







typedef struct _WSANETWORKEVENTS {
       long lNetworkEvents;
       int iErrorCode[10];
} WSANETWORKEVENTS,  * LPWSANETWORKEVENTS;















typedef struct _WSAPROTOCOLCHAIN {
    int ChainLen;



    DWORD ChainEntries[7];
} WSAPROTOCOLCHAIN,  * LPWSAPROTOCOLCHAIN;



typedef struct _WSAPROTOCOL_INFOA {
    DWORD dwServiceFlags1;
    DWORD dwServiceFlags2;
    DWORD dwServiceFlags3;
    DWORD dwServiceFlags4;
    DWORD dwProviderFlags;
    GUID ProviderId;
    DWORD dwCatalogEntryId;
    WSAPROTOCOLCHAIN ProtocolChain;
    int iVersion;
    int iAddressFamily;
    int iMaxSockAddr;
    int iMinSockAddr;
    int iSocketType;
    int iProtocol;
    int iProtocolMaxOffset;
    int iNetworkByteOrder;
    int iSecurityScheme;
    DWORD dwMessageSize;
    DWORD dwProviderReserved;
    CHAR   szProtocol[255+1];
} WSAPROTOCOL_INFOA,  * LPWSAPROTOCOL_INFOA;
typedef struct _WSAPROTOCOL_INFOW {
    DWORD dwServiceFlags1;
    DWORD dwServiceFlags2;
    DWORD dwServiceFlags3;
    DWORD dwServiceFlags4;
    DWORD dwProviderFlags;
    GUID ProviderId;
    DWORD dwCatalogEntryId;
    WSAPROTOCOLCHAIN ProtocolChain;
    int iVersion;
    int iAddressFamily;
    int iMaxSockAddr;
    int iMinSockAddr;
    int iSocketType;
    int iProtocol;
    int iProtocolMaxOffset;
    int iNetworkByteOrder;
    int iSecurityScheme;
    DWORD dwMessageSize;
    DWORD dwProviderReserved;
    WCHAR  szProtocol[255+1];
} WSAPROTOCOL_INFOW,  * LPWSAPROTOCOL_INFOW;




typedef WSAPROTOCOL_INFOA WSAPROTOCOL_INFO;
typedef LPWSAPROTOCOL_INFOA LPWSAPROTOCOL_INFO;
#line 1121 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"























































































typedef
int
(__stdcall * LPCONDITIONPROC)(
     LPWSABUF lpCallerId,
     LPWSABUF lpCallerData,
      LPQOS lpSQOS,
      LPQOS lpGQOS,
     LPWSABUF lpCalleeId,
     LPWSABUF lpCalleeData,
     GROUP  * g,
     DWORD_PTR dwCallbackData
    );

typedef
void
(__stdcall * LPWSAOVERLAPPED_COMPLETION_ROUTINE)(
     DWORD dwError,
     DWORD cbTransferred,
     LPWSAOVERLAPPED lpOverlapped,
     DWORD dwFlags
    );







typedef enum _WSACOMPLETIONTYPE {
    NSP_NOTIFY_IMMEDIATELY = 0,
    NSP_NOTIFY_HWND,
    NSP_NOTIFY_EVENT,
    NSP_NOTIFY_PORT,
    NSP_NOTIFY_APC,
} WSACOMPLETIONTYPE, *PWSACOMPLETIONTYPE,  * LPWSACOMPLETIONTYPE;

typedef struct _WSACOMPLETION {
    WSACOMPLETIONTYPE Type;
    union {
        struct {
            HWND hWnd;
            UINT uMsg;
            WPARAM context;
        } WindowMessage;
        struct {
            LPWSAOVERLAPPED lpOverlapped;
        } Event;
        struct {
            LPWSAOVERLAPPED lpOverlapped;
            LPWSAOVERLAPPED_COMPLETION_ROUTINE lpfnCompletionProc;
        } Apc;
        struct {
            LPWSAOVERLAPPED lpOverlapped;
            HANDLE hPort;
            ULONG_PTR Key;
        } Port;
    } Parameters;
} WSACOMPLETION, *PWSACOMPLETION,  *LPWSACOMPLETION;













typedef struct sockaddr SOCKADDR;
typedef struct sockaddr *PSOCKADDR;
typedef struct sockaddr  *LPSOCKADDR;

typedef struct sockaddr_storage SOCKADDR_STORAGE;
typedef struct sockaddr_storage *PSOCKADDR_STORAGE;
typedef struct sockaddr_storage  *LPSOCKADDR_STORAGE;




































































#line 1355 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"

































#line 1389 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"








typedef struct _SOCKET_ADDRESS {
    LPSOCKADDR lpSockaddr ;
    INT iSockaddrLength ;
} SOCKET_ADDRESS, *PSOCKET_ADDRESS,  * LPSOCKET_ADDRESS ;




typedef struct _CSADDR_INFO {
    SOCKET_ADDRESS LocalAddr ;
    SOCKET_ADDRESS RemoteAddr ;
    INT iSocketType ;
    INT iProtocol ;
} CSADDR_INFO, *PCSADDR_INFO,  * LPCSADDR_INFO ;
#line 1412 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"




typedef struct _SOCKET_ADDRESS_LIST {
    INT             iAddressCount;
    SOCKET_ADDRESS  Address[1];
} SOCKET_ADDRESS_LIST,  * LPSOCKET_ADDRESS_LIST;




typedef struct _AFPROTOCOLS {
    INT iAddressFamily;
    INT iProtocol;
} AFPROTOCOLS, *PAFPROTOCOLS, *LPAFPROTOCOLS;








typedef enum _WSAEcomparator
{
    COMP_EQUAL = 0,
    COMP_NOTLESS
} WSAECOMPARATOR, *PWSAECOMPARATOR, *LPWSAECOMPARATOR;

typedef struct _WSAVersion
{
    DWORD           dwVersion;
    WSAECOMPARATOR  ecHow;
}WSAVERSION, *PWSAVERSION, *LPWSAVERSION;

typedef struct _WSAQuerySetA
{
    DWORD           dwSize;
    LPSTR           lpszServiceInstanceName;
    LPGUID          lpServiceClassId;
    LPWSAVERSION    lpVersion;
    LPSTR           lpszComment;
    DWORD           dwNameSpace;
    LPGUID          lpNSProviderId;
    LPSTR           lpszContext;
    DWORD           dwNumberOfProtocols;
    LPAFPROTOCOLS   lpafpProtocols;
    LPSTR           lpszQueryString;
    DWORD           dwNumberOfCsAddrs;
    LPCSADDR_INFO   lpcsaBuffer;
    DWORD           dwOutputFlags;
    LPBLOB          lpBlob;
} WSAQUERYSETA, *PWSAQUERYSETA, *LPWSAQUERYSETA;
typedef struct _WSAQuerySetW
{
    DWORD           dwSize;
    LPWSTR          lpszServiceInstanceName;
    LPGUID          lpServiceClassId;
    LPWSAVERSION    lpVersion;
    LPWSTR          lpszComment;
    DWORD           dwNameSpace;
    LPGUID          lpNSProviderId;
    LPWSTR          lpszContext;
    DWORD           dwNumberOfProtocols;
    LPAFPROTOCOLS   lpafpProtocols;
    LPWSTR          lpszQueryString;
    DWORD           dwNumberOfCsAddrs;
    LPCSADDR_INFO   lpcsaBuffer;
    DWORD           dwOutputFlags;
    LPBLOB          lpBlob;
} WSAQUERYSETW, *PWSAQUERYSETW, *LPWSAQUERYSETW;





typedef WSAQUERYSETA WSAQUERYSET;
typedef PWSAQUERYSETA PWSAQUERYSET;
typedef LPWSAQUERYSETA LPWSAQUERYSET;
#line 1493 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


































typedef enum _WSAESETSERVICEOP
{
    RNRSERVICE_REGISTER=0,
    RNRSERVICE_DEREGISTER,
    RNRSERVICE_DELETE
} WSAESETSERVICEOP, *PWSAESETSERVICEOP, *LPWSAESETSERVICEOP;





typedef struct _WSANSClassInfoA
{
    LPSTR   lpszName;
    DWORD   dwNameSpace;
    DWORD   dwValueType;
    DWORD   dwValueSize;
    LPVOID  lpValue;
}WSANSCLASSINFOA, *PWSANSCLASSINFOA, *LPWSANSCLASSINFOA;
typedef struct _WSANSClassInfoW
{
    LPWSTR  lpszName;
    DWORD   dwNameSpace;
    DWORD   dwValueType;
    DWORD   dwValueSize;
    LPVOID  lpValue;
}WSANSCLASSINFOW, *PWSANSCLASSINFOW, *LPWSANSCLASSINFOW;





typedef WSANSCLASSINFOA WSANSCLASSINFO;
typedef PWSANSCLASSINFOA PWSANSCLASSINFO;
typedef LPWSANSCLASSINFOA LPWSANSCLASSINFO;
#line 1563 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"

typedef struct _WSAServiceClassInfoA
{
    LPGUID              lpServiceClassId;
    LPSTR               lpszServiceClassName;
    DWORD               dwCount;
    LPWSANSCLASSINFOA   lpClassInfos;
}WSASERVICECLASSINFOA, *PWSASERVICECLASSINFOA, *LPWSASERVICECLASSINFOA;
typedef struct _WSAServiceClassInfoW
{
    LPGUID              lpServiceClassId;
    LPWSTR              lpszServiceClassName;
    DWORD               dwCount;
    LPWSANSCLASSINFOW   lpClassInfos;
}WSASERVICECLASSINFOW, *PWSASERVICECLASSINFOW, *LPWSASERVICECLASSINFOW;





typedef WSASERVICECLASSINFOA WSASERVICECLASSINFO;
typedef PWSASERVICECLASSINFOA PWSASERVICECLASSINFO;
typedef LPWSASERVICECLASSINFOA LPWSASERVICECLASSINFO;
#line 1587 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"

typedef struct _WSANAMESPACE_INFOA {
    GUID                NSProviderId;
    DWORD               dwNameSpace;
    BOOL                fActive;
    DWORD               dwVersion;
    LPSTR               lpszIdentifier;
} WSANAMESPACE_INFOA, *PWSANAMESPACE_INFOA, *LPWSANAMESPACE_INFOA;
typedef struct _WSANAMESPACE_INFOW {
    GUID                NSProviderId;
    DWORD               dwNameSpace;
    BOOL                fActive;
    DWORD               dwVersion;
    LPWSTR              lpszIdentifier;
} WSANAMESPACE_INFOW, *PWSANAMESPACE_INFOW, *LPWSANAMESPACE_INFOW;





typedef WSANAMESPACE_INFOA WSANAMESPACE_INFO;
typedef PWSANAMESPACE_INFOA PWSANAMESPACE_INFO;
typedef LPWSANAMESPACE_INFOA LPWSANAMESPACE_INFO;
#line 1611 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"




__declspec(dllimport)
SOCKET
 __stdcall
accept(
     SOCKET s,
     struct sockaddr  * addr,
      int  * addrlen
    );
#line 1624 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"









#line 1634 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
bind(
     SOCKET s,
     const struct sockaddr  * name,
     int namelen
    );
#line 1645 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"









#line 1655 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
closesocket(
     SOCKET s
    );
#line 1664 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 1672 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
connect(
     SOCKET s,
     const struct sockaddr  * name,
     int namelen
    );
#line 1683 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"









#line 1693 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
ioctlsocket(
     SOCKET s,
     long cmd,
      u_long  * argp
    );
#line 1704 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"









#line 1714 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
getpeername(
     SOCKET s,
     struct sockaddr  * name,
      int  * namelen
    );
#line 1725 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"









#line 1735 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
getsockname(
     SOCKET s,
     struct sockaddr  * name,
      int  * namelen
    );
#line 1746 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"









#line 1756 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
getsockopt(
     SOCKET s,
     int level,
     int optname,
     char  * optval,
      int  * optlen
    );
#line 1769 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"











#line 1781 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
u_long
 __stdcall
htonl(
     u_long hostlong
    );
#line 1790 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 1798 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
u_short
 __stdcall
htons(
     u_short hostshort
    );
#line 1807 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 1815 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
unsigned long
 __stdcall
inet_addr(
     const char  * cp
    );
#line 1824 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 1832 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
char  *
 __stdcall
inet_ntoa(
     struct in_addr in
    );
#line 1841 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 1849 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
listen(
     SOCKET s,
     int backlog
    );
#line 1859 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"








#line 1868 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
u_long
 __stdcall
ntohl(
     u_long netlong
    );
#line 1877 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 1885 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
u_short
 __stdcall
ntohs(
     u_short netshort
    );
#line 1894 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 1902 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
recv(
     SOCKET s,
     char  * buf,
     int len,
     int flags
    );
#line 1914 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"










#line 1925 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
recvfrom(
     SOCKET s,
     char  * buf,
     int len,
     int flags,
     struct sockaddr  * from,
      int  * fromlen
    );
#line 1939 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"












#line 1952 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
select(
     int nfds,
      fd_set  * readfds,
      fd_set  * writefds,
      fd_set  *exceptfds,
     const struct timeval  * timeout
    );
#line 1965 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"











#line 1977 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
send(
     SOCKET s,
     const char  * buf,
     int len,
     int flags
    );
#line 1989 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"










#line 2000 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
sendto(
     SOCKET s,
     const char  * buf,
     int len,
     int flags,
     const struct sockaddr  * to,
     int tolen
    );
#line 2014 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"












#line 2027 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
setsockopt(
     SOCKET s,
     int level,
     int optname,
     const char  * optval,
     int optlen
    );
#line 2040 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"











#line 2052 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
shutdown(
     SOCKET s,
     int how
    );
#line 2062 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"








#line 2071 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
SOCKET
 __stdcall
socket(
     int af,
     int type,
     int protocol
    );
#line 2082 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"









#line 2092 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"




__declspec(dllimport)
struct hostent  *
 __stdcall
gethostbyaddr(
     const char  * addr,
     int len,
     int type
    );
#line 2105 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"









#line 2115 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
struct hostent  *
 __stdcall
gethostbyname(
     const char  * name
    );
#line 2124 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 2132 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
gethostname(
     char  * name,
     int namelen
    );
#line 2142 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"








#line 2151 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
struct servent  *
 __stdcall
getservbyport(
     int port,
     const char  * proto
    );
#line 2161 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"








#line 2170 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
struct servent  *
 __stdcall
getservbyname(
     const char  * name,
     const char  * proto
    );
#line 2180 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"








#line 2189 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
struct protoent  *
 __stdcall
getprotobynumber(
     int number
    );
#line 2198 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 2206 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
struct protoent  *
 __stdcall
getprotobyname(
     const char  * name
    );
#line 2215 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 2223 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"




__declspec(dllimport)
int
 __stdcall
WSAStartup(
     WORD wVersionRequested,
     LPWSADATA lpWSAData
    );
#line 2235 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"








#line 2244 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSACleanup(
    void
    );
#line 2253 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 2261 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
void
 __stdcall
WSASetLastError(
     int iError
    );
#line 2270 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 2278 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSAGetLastError(
    void
    );
#line 2287 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 2295 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
BOOL
 __stdcall
WSAIsBlocking(
    void
    );
#line 2304 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 2312 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSAUnhookBlockingHook(
    void
    );
#line 2321 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 2329 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
FARPROC
 __stdcall
WSASetBlockingHook(
     FARPROC lpBlockFunc
    );
#line 2338 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 2346 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSACancelBlockingCall(
    void
    );
#line 2355 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 2363 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
HANDLE
 __stdcall
WSAAsyncGetServByName(
     HWND hWnd,
     u_int wMsg,
     const char  * name,
     const char  * proto,
     char  * buf,
     int buflen
    );
#line 2377 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"












#line 2390 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
HANDLE
 __stdcall
WSAAsyncGetServByPort(
     HWND hWnd,
     u_int wMsg,
     int port,
     const char  * proto,
     char  * buf,
     int buflen
    );
#line 2404 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"












#line 2417 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
HANDLE
 __stdcall
WSAAsyncGetProtoByName(
     HWND hWnd,
     u_int wMsg,
     const char  * name,
     char  * buf,
     int buflen
    );
#line 2430 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"











#line 2442 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
HANDLE
 __stdcall
WSAAsyncGetProtoByNumber(
     HWND hWnd,
     u_int wMsg,
     int number,
     char  * buf,
     int buflen
    );
#line 2455 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"











#line 2467 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
HANDLE
 __stdcall
WSAAsyncGetHostByName(
     HWND hWnd,
     u_int wMsg,
     const char  * name,
     char  * buf,
     int buflen
    );
#line 2480 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"











#line 2492 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
HANDLE
 __stdcall
WSAAsyncGetHostByAddr(
     HWND hWnd,
     u_int wMsg,
     const char  * addr,
     int len,
     int type,
     char  * buf,
     int buflen
    );
#line 2507 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"













#line 2521 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSACancelAsyncRequest(
     HANDLE hAsyncTaskHandle
    );
#line 2530 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 2538 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSAAsyncSelect(
     SOCKET s,
     HWND hWnd,
     u_int wMsg,
     long lEvent
    );
#line 2550 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"










#line 2561 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"




__declspec(dllimport)
SOCKET
 __stdcall
WSAAccept(
     SOCKET s,
     struct sockaddr  * addr,
      LPINT addrlen,
     LPCONDITIONPROC lpfnCondition,
     DWORD_PTR dwCallbackData
    );
#line 2576 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"











#line 2588 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
BOOL
 __stdcall
WSACloseEvent(
     HANDLE hEvent
    );
#line 2597 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 2605 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSAConnect(
     SOCKET s,
     const struct sockaddr  * name,
     int namelen,
     LPWSABUF lpCallerData,
     LPWSABUF lpCalleeData,
     LPQOS lpSQOS,
     LPQOS lpGQOS
    );
#line 2620 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"













#line 2634 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
HANDLE
 __stdcall
WSACreateEvent(
    void
    );
#line 2643 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 2651 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSADuplicateSocketA(
     SOCKET s,
     DWORD dwProcessId,
     LPWSAPROTOCOL_INFOA lpProtocolInfo
    );
__declspec(dllimport)
int
 __stdcall
WSADuplicateSocketW(
     SOCKET s,
     DWORD dwProcessId,
     LPWSAPROTOCOL_INFOW lpProtocolInfo
    );




#line 2674 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"
#line 2675 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"





















#line 2697 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSAEnumNetworkEvents(
     SOCKET s,
     HANDLE hEventObject,
     LPWSANETWORKEVENTS lpNetworkEvents
    );
#line 2708 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"









#line 2718 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSAEnumProtocolsA(
     LPINT lpiProtocols,
     LPWSAPROTOCOL_INFOA lpProtocolBuffer,
      LPDWORD lpdwBufferLength
    );
__declspec(dllimport)
int
 __stdcall
WSAEnumProtocolsW(
     LPINT lpiProtocols,
     LPWSAPROTOCOL_INFOW lpProtocolBuffer,
      LPDWORD lpdwBufferLength
    );




#line 2741 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"
#line 2742 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"





















#line 2764 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSAEventSelect(
     SOCKET s,
     HANDLE hEventObject,
     long lNetworkEvents
    );
#line 2775 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"









#line 2785 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
BOOL
 __stdcall
WSAGetOverlappedResult(
     SOCKET s,
     LPWSAOVERLAPPED lpOverlapped,
     LPDWORD lpcbTransfer,
     BOOL fWait,
     LPDWORD lpdwFlags
    );
#line 2798 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"











#line 2810 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
BOOL
 __stdcall
WSAGetQOSByName(
     SOCKET s,
     LPWSABUF lpQOSName,
     LPQOS lpQOS
    );
#line 2821 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"









#line 2831 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSAHtonl(
     SOCKET s,
     u_long hostlong,
     u_long  * lpnetlong
    );
#line 2842 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"









#line 2852 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSAHtons(
     SOCKET s,
     u_short hostshort,
     u_short  * lpnetshort
    );
#line 2863 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"









#line 2873 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSAIoctl(
     SOCKET s,
     DWORD dwIoControlCode,
     LPVOID lpvInBuffer,
     DWORD cbInBuffer,
     LPVOID lpvOutBuffer,
     DWORD cbOutBuffer,
     LPDWORD lpcbBytesReturned,
     LPWSAOVERLAPPED lpOverlapped,
     LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#line 2890 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"















#line 2906 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
SOCKET
 __stdcall
WSAJoinLeaf(
     SOCKET s,
     const struct sockaddr  * name,
     int namelen,
     LPWSABUF lpCallerData,
     LPWSABUF lpCalleeData,
     LPQOS lpSQOS,
     LPQOS lpGQOS,
     DWORD dwFlags
    );
#line 2922 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"














#line 2937 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSANtohl(
     SOCKET s,
     u_long netlong,
     u_long  * lphostlong
    );
#line 2948 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"









#line 2958 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSANtohs(
     SOCKET s,
     u_short netshort,
     u_short  * lphostshort
    );
#line 2969 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"









#line 2979 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSARecv(
     SOCKET s,
      LPWSABUF lpBuffers,
     DWORD dwBufferCount,
     LPDWORD lpNumberOfBytesRecvd,
      LPDWORD lpFlags,
     LPWSAOVERLAPPED lpOverlapped,
     LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#line 2994 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"













#line 3008 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSARecvDisconnect(
     SOCKET s,
     LPWSABUF lpInboundDisconnectData
    );
#line 3018 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"








#line 3027 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSARecvFrom(
     SOCKET s,
      LPWSABUF lpBuffers,
     DWORD dwBufferCount,
     LPDWORD lpNumberOfBytesRecvd,
      LPDWORD lpFlags,
     struct sockaddr  * lpFrom,
      LPINT lpFromlen,
     LPWSAOVERLAPPED lpOverlapped,
     LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#line 3044 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"















#line 3060 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
BOOL
 __stdcall
WSAResetEvent(
     HANDLE hEvent
    );
#line 3069 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 3077 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSASend(
     SOCKET s,
     LPWSABUF lpBuffers,
     DWORD dwBufferCount,
     LPDWORD lpNumberOfBytesSent,
     DWORD dwFlags,
     LPWSAOVERLAPPED lpOverlapped,
     LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#line 3092 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"













#line 3106 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSASendDisconnect(
     SOCKET s,
     LPWSABUF lpOutboundDisconnectData
    );
#line 3116 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"








#line 3125 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
int
 __stdcall
WSASendTo(
     SOCKET s,
     LPWSABUF lpBuffers,
     DWORD dwBufferCount,
     LPDWORD lpNumberOfBytesSent,
     DWORD dwFlags,
     const struct sockaddr  * lpTo,
     int iTolen,
     LPWSAOVERLAPPED lpOverlapped,
     LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#line 3142 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"















#line 3158 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
BOOL
 __stdcall
WSASetEvent(
     HANDLE hEvent
    );
#line 3167 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 3175 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
SOCKET
 __stdcall
WSASocketA(
     int af,
     int type,
     int protocol,
     LPWSAPROTOCOL_INFOA lpProtocolInfo,
     GROUP g,
     DWORD dwFlags
    );
__declspec(dllimport)
SOCKET
 __stdcall
WSASocketW(
     int af,
     int type,
     int protocol,
     LPWSAPROTOCOL_INFOW lpProtocolInfo,
     GROUP g,
     DWORD dwFlags
    );




#line 3204 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"
#line 3205 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"



























#line 3233 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
DWORD
 __stdcall
WSAWaitForMultipleEvents(
     DWORD cEvents,
     const HANDLE  * lphEvents,
     BOOL fWaitAll,
     DWORD dwTimeout,
     BOOL fAlertable
    );
#line 3246 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"











#line 3258 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
INT
 __stdcall
WSAAddressToStringA(
         LPSOCKADDR          lpsaAddress,
         DWORD               dwAddressLength,
         LPWSAPROTOCOL_INFOA lpProtocolInfo,
      LPSTR             lpszAddressString,
      LPDWORD             lpdwAddressStringLength
    );
__declspec(dllimport)
INT
 __stdcall
WSAAddressToStringW(
         LPSOCKADDR          lpsaAddress,
         DWORD               dwAddressLength,
         LPWSAPROTOCOL_INFOW lpProtocolInfo,
      LPWSTR             lpszAddressString,
      LPDWORD             lpdwAddressStringLength
    );




#line 3285 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"
#line 3286 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"

























#line 3312 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
INT
 __stdcall
WSAStringToAddressA(
         LPSTR               AddressString,
         INT                 AddressFamily,
         LPWSAPROTOCOL_INFOA lpProtocolInfo,
        LPSOCKADDR          lpAddress,
      LPINT               lpAddressLength
    );
__declspec(dllimport)
INT
 __stdcall
WSAStringToAddressW(
         LPWSTR              AddressString,
         INT                 AddressFamily,
         LPWSAPROTOCOL_INFOW lpProtocolInfo,
        LPSOCKADDR          lpAddress,
      LPINT               lpAddressLength
    );




#line 3339 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"
#line 3340 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"

























#line 3366 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"





__declspec(dllimport)
INT
 __stdcall
WSALookupServiceBeginA(
      LPWSAQUERYSETA lpqsRestrictions,
      DWORD          dwControlFlags,
     LPHANDLE       lphLookup
    );
__declspec(dllimport)
INT
 __stdcall
WSALookupServiceBeginW(
      LPWSAQUERYSETW lpqsRestrictions,
      DWORD          dwControlFlags,
     LPHANDLE       lphLookup
    );




#line 3392 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"
#line 3393 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"





















#line 3415 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
INT
 __stdcall
WSALookupServiceNextA(
         HANDLE           hLookup,
         DWORD            dwControlFlags,
      LPDWORD          lpdwBufferLength,
        LPWSAQUERYSETA   lpqsResults
    );
__declspec(dllimport)
INT
 __stdcall
WSALookupServiceNextW(
         HANDLE           hLookup,
         DWORD            dwControlFlags,
      LPDWORD          lpdwBufferLength,
        LPWSAQUERYSETW   lpqsResults
    );




#line 3440 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"
#line 3441 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"























#line 3465 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
INT
 __stdcall
WSANSPIoctl(
      HANDLE           hLookup,
      DWORD            dwControlCode,
      LPVOID           lpvInBuffer,
      DWORD            cbInBuffer,
     LPVOID           lpvOutBuffer,
      DWORD            cbOutBuffer,
     LPDWORD          lpcbBytesReturned,
      LPWSACOMPLETION  lpCompletion
    );
#line 3481 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"














#line 3496 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
INT
 __stdcall
WSALookupServiceEnd(
     HANDLE  hLookup
    );
#line 3505 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 3513 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
INT
 __stdcall
WSAInstallServiceClassA(
      LPWSASERVICECLASSINFOA   lpServiceClassInfo
    );
__declspec(dllimport)
INT
 __stdcall
WSAInstallServiceClassW(
      LPWSASERVICECLASSINFOW   lpServiceClassInfo
    );




#line 3532 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"
#line 3533 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"

















#line 3551 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
INT
 __stdcall
WSARemoveServiceClass(
      LPGUID  lpServiceClassId
    );
#line 3560 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"







#line 3568 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
INT
 __stdcall
WSAGetServiceClassInfoA(
      LPGUID  lpProviderId,
      LPGUID  lpServiceClassId,
      LPDWORD  lpdwBufSize,
     LPWSASERVICECLASSINFOA lpServiceClassInfo
    );
__declspec(dllimport)
INT
 __stdcall
WSAGetServiceClassInfoW(
      LPGUID  lpProviderId,
      LPGUID  lpServiceClassId,
      LPDWORD  lpdwBufSize,
     LPWSASERVICECLASSINFOW lpServiceClassInfo
    );




#line 3593 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"
#line 3594 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"























#line 3618 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
INT
 __stdcall
WSAEnumNameSpaceProvidersA(
      LPDWORD              lpdwBufferLength,
        LPWSANAMESPACE_INFOA lpnspBuffer
    );
__declspec(dllimport)
INT
 __stdcall
WSAEnumNameSpaceProvidersW(
      LPDWORD              lpdwBufferLength,
        LPWSANAMESPACE_INFOW lpnspBuffer
    );




#line 3639 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"
#line 3640 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"



















#line 3660 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
INT
 __stdcall
WSAGetServiceClassNameByClassIdA(
          LPGUID  lpServiceClassId,
         LPSTR lpszServiceClassName,
       LPDWORD lpdwBufferLength
    );
__declspec(dllimport)
INT
 __stdcall
WSAGetServiceClassNameByClassIdW(
          LPGUID  lpServiceClassId,
         LPWSTR lpszServiceClassName,
       LPDWORD lpdwBufferLength
    );




#line 3683 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"
#line 3684 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"





















#line 3706 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
INT
 __stdcall
WSASetServiceA(
     LPWSAQUERYSETA lpqsRegInfo,
     WSAESETSERVICEOP essoperation,
     DWORD dwControlFlags
    );
__declspec(dllimport)
INT
 __stdcall
WSASetServiceW(
     LPWSAQUERYSETW lpqsRegInfo,
     WSAESETSERVICEOP essoperation,
     DWORD dwControlFlags
    );




#line 3729 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"
#line 3730 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"





















#line 3752 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


__declspec(dllimport)
INT
 __stdcall
WSAProviderConfigChange(
      LPHANDLE lpNotificationHandle,
     LPWSAOVERLAPPED lpOverlapped,
     LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#line 3763 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"









#line 3773 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"


typedef struct sockaddr_in SOCKADDR_IN;
typedef struct sockaddr_in *PSOCKADDR_IN;
typedef struct sockaddr_in  *LPSOCKADDR_IN;

typedef struct linger LINGER;
typedef struct linger *PLINGER;
typedef struct linger  *LPLINGER;

typedef struct in_addr IN_ADDR;
typedef struct in_addr *PIN_ADDR;
typedef struct in_addr  *LPIN_ADDR;

typedef struct fd_set FD_SET;
typedef struct fd_set *PFD_SET;
typedef struct fd_set  *LPFD_SET;

typedef struct hostent HOSTENT;
typedef struct hostent *PHOSTENT;
typedef struct hostent  *LPHOSTENT;

typedef struct servent SERVENT;
typedef struct servent *PSERVENT;
typedef struct servent  *LPSERVENT;

typedef struct protoent PROTOENT;
typedef struct protoent *PPROTOENT;
typedef struct protoent  *LPPROTOENT;

typedef struct timeval TIMEVAL;
typedef struct timeval *PTIMEVAL;
typedef struct timeval  *LPTIMEVAL;








































}
#line 3848 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"



#line 3852 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"





#line 3858 "d:\\sdk\\Microsoft SDK\\include\\winsock2.h"
#line 11 "u:/uppsrc\\Web/Web.h"
#line 12 "u:/uppsrc\\Web/Web.h"
typedef int socklen_t;


















#line 32 "u:/uppsrc\\Web/Web.h"

namespace Upp {

#line 1 "u:\\uppsrc\\web\\util.h"



bool          IsSameTextFile(const char *p, const char *q);
String        StringSample(const char *s, int limit);
String        FormatIP(dword _ip);
String        UrlEncode(String s);
String        UrlEncode(String s, const char *specials);
String        UrlDecode(String s);
String        GetRandomIdent(int length);
String        OtpEncode(String password, String otp_key);
String        EncryptString(String password, String otp_key);
String        BinHexEncode(const char *b, const char *e);
inline String BinHexEncode(String data)           { return BinHexEncode(data.Begin(), data.End()); }
String        BinHexDecode(const char *b, const char *e);
inline String BinHexDecode(String data)           { return BinHexDecode(data.Begin(), data.End()); }
String        Base64Encode(const char *b, const char *e);
inline String Base64Encode(String data)           { return Base64Encode(data.Begin(), data.End()); }
String        Base64Decode(const char *b, const char *e);
inline String Base64Decode(String data)           { return Base64Decode(data.Begin(), data.End()); }
String        ASCII85Encode(const byte *p, int length);
inline String ASCII85Encode(String s)             { return ASCII85Encode(s, s.GetLength()); }
String        ASCII85Decode(const byte *p, int length);
inline String ASCII85Decode(String s)             { return ASCII85Decode(s, s.GetLength()); }
dword         AddCRC(dword crc, const byte *data, int count);
inline dword  AddCRC(dword crc, String s)         { return AddCRC(crc, s, s.GetLength()); }
inline dword  GetCRC(const byte *data, int count) { return AddCRC(0x80000000, data, count); }
inline dword  GetCRC(String s)                    { return AddCRC(0x80000000, s, s.GetLength()); }
int           LocateLine(String old_file, int old_line, String new_file);
void          AppVersion(const char *ver);
String        MD5Digest(const char *text, int length);
inline String MD5Digest(String s)                 { return MD5Digest(s.Begin(), s.GetLength()); }



class RefBase
{
public:
	RefBase()
	{
		refcount = 0;



	}

	RefBase(const RefBase& rb)
	{
		refcount = 0;



	}

	virtual ~RefBase()
	{
		;
	}

	void           AddRef() const      { if(this) AtomicInc(refcount); }
	int            GetRefCount() const { return AtomicXAdd(refcount, 0); }
	void           Release() const     { if(this && !AtomicDec(refcount)) delete this; }




private:
	mutable Atomic refcount;





private:
	RefBase&    operator = (const RefBase& rb) { ; return *this; }
};

template <class T>
class RefCon : Moveable< RefCon<T> >
{
public:
	RefCon(const Nuller& = Null) : t(0) {}
	RefCon(const T *t);
	RefCon(const RefCon<T>& rp);
	~RefCon();

	void            Clear()                                { if(t) { t->Release(); t = 0; } }
	bool            IsNullInstance() const                 { return !t; }

	RefCon<T>&      operator = (const RefCon<T>& rp);

	bool            operator ! () const                    { return !t; }
	const T        *Get() const                            { return t; }
	const T        *operator ~ () const                    { return t; }
	const T        *operator -> () const                   { ; return t; }
	const T&        operator * () const                    { ; return *t; }

	String          ToString() const                       { return t ? AsString(*t) : String("NULL"); }

	friend bool     operator == (RefCon<T> a, RefCon<T> b) { return a.t == b.t; }
	friend bool     operator != (RefCon<T> a, RefCon<T> b) { return a.t != b.t; }
	friend unsigned GetHashValue(RefCon<T> r)              { return GetHashValue(r.t); }

protected:
	const T        *t;
};

template <class T>
RefCon<T>::RefCon(const T *t)
: t(t)
{
	t->AddRef();




}

template <class T>
RefCon<T>::RefCon(const RefCon<T>& rp)
: t(rp.t)
{ t->AddRef(); }

template <class T>
RefCon<T>::~RefCon()
{




	t->Release();
}

template <class T>
RefCon<T>& RefCon<T>::operator = (const RefCon<T>& rp)
{
	const T *old = t;
	t = rp.t;
	t->AddRef();




	old->Release();
	return *this;
}

template <class T>
class RefPtr : public RefCon<T>, public Moveable< RefPtr<T> >
{
public:
	RefPtr(const Nuller& = Null)                 {}
	RefPtr(T *t) : RefCon<T>(t)                  {}
	RefPtr(const RefPtr<T>& rp) : RefCon<T>(rp)  {}

	RefPtr<T>&  operator = (const RefPtr<T>& rp) { RefCon<T>::operator = (rp); return *this; }

	T          *Get() const                      { return const_cast<T *>(this->t); }
	T          *operator ~ () const              { return Get(); }
	T          *operator -> () const             { ; return Get(); }
	T&          operator * () const              { ; return *Get(); }
};

template <class T>
class RefValueRep : public RawValueRep<T>
{
public:
	RefValueRep(T v) : RawValueRep<T>(v) {}

	virtual bool       IsNull() const                { return this->v == 0; }
	virtual unsigned   GetHashValue() const          { return (unsigned)~this->v; }
	virtual bool       IsEqual(const Value::Void *p);
	virtual String     AsString()                    { return !!this->v ? Upp::AsString(*this->v) : String(Null); }

	static const RawValueRep<T> *Cast(const Value::Void *p)
	{ ; return (const RawValueRep<T> *)p; }
};

template <class T>
bool RefValueRep<T>::IsEqual(const Value::Void *p)
{
	const RawValueRep<T> *cast = dynamic_cast<const RawValueRep<T> *>(p);
	return cast && cast->Get() == this->v;
}

template <class T>
class RefPCValue : public Value
{
protected:
	typedef RefValueRep<T> Rep;

public:
	RefPCValue(T x) : Value(new Rep(x)) {}
	static T Get(const Value& v)       { return Upp::IsNull(v) ? 0 : Rep::Cast(v.GetVoidPtr())->Get(); }
	static T Extract(const Value& v)   { return Upp::IsNull(v) ? 0 : Rep::Cast(v.GetVoidPtr())->Get(); }
};

template <class T>
inline Value RefConToValue(RefCon<T> p)        { return RefPCValue< RefCon<T> >(p); }

template <class T>
inline Value RefPtrToValue(RefPtr<T> p)        { return RefPCValue< RefPtr<T> >(p); }

class HttpQuery
{
private:
	class Data : public RefBase
	{
	public:
		Data() {}
		Data(const Data& d) : map(d.map, 0) {}

		VectorMap<String, String> map;
	};

public:
	HttpQuery(const Nuller& = Null) : data(Empty())    {}
	explicit HttpQuery(String url) { data = Empty(); SetURL(url); }

	void                   Serialize(Stream& stream);

	String                 GetHidden() const;
	String                 GetQuery(bool empty = false) const;
	String                 GetQuery(HttpQuery patch, bool empty = false) const;

	void                   Clear()                                            { data = Empty(); }

	bool                   IsEmpty() const                                    { return data -> map.IsEmpty(); }
	bool                   IsEmpty(String key) const;

	int                    GetCount() const                                   { return data -> map.GetCount(); }
	int                    Find(String key) const                             { return data -> map.Find(key); }
	String                 GetKey(int i) const                                { return data -> map.GetKey(i); }
	String                 GetValue(int i) const                              { return data -> map[i]; }
	bool                   IsInternal(int i) const;

	void                   Get(String key, Ref p1) const;
	HttpQuery&             SetValue(String key, Value v);
	HttpQuery&             Set(String key, String value);
	HttpQuery&             SetRaw(String key, String value);

	bool                   GetBool(String key) const;
	bool                   GetBool(String key, bool dflt) const;
	HttpQuery&             SetBool(String key, bool b);

	int                    GetInt(String key) const;
	int                    GetInt(String key, int min, int max, int dflt = 0) const;
	HttpQuery&             SetInt(String key, int i);

	double                 GetDouble(String key) const;
	double                 GetDouble(String key, double min, double max, double dflt = Null) const;
	HttpQuery&             SetDouble(String key, double f);

	String                 GetString(String key) const;
	String                 GetString(String key, String dflt) const;
	HttpQuery&             SetString(String key, String s)                    { return Set(key, s); }

	Date                   GetDate(String key) const;
	Date                   GetDate(String key, Date dflt) const               { return Nvl(GetDate(key), dflt); }
	HttpQuery&             SetDate(String key, Date d);

	Time                   GetTime(String key) const;
	Time                   GetTime(String key, Time dflt) const               { return Nvl(GetTime(key), dflt); }
	HttpQuery&             SetTime(String key, Time t);

	Color                  GetColor(String key) const;
	Color                  GetColor(String key, Color dflt) const             { return Nvl(GetColor(key), dflt); }
	HttpQuery&             SetColor(String key, Color c);

	HttpQuery&             Set(HttpQuery query);
	HttpQuery&             SetURL(String url);

	HttpQuery&             Remove(String key);
	HttpQuery&             Remove(const Vector<String>& keys);
	HttpQuery&             Remove(const Vector<Id>& keys);

	String                 ToString() const;

private:
	static RefPtr<Data>    Empty();
	void                   Clone() { if(data -> GetRefCount() > 1) data = new Data(*data); }

private:
	RefPtr<Data>           data;
};

#line 288 "u:\\uppsrc\\web\\util.h"
#line 36 "u:/uppsrc\\Web/Web.h"
#line 1 "u:\\uppsrc\\web\\html.h"







String      ToHtml(const char *s);

class HtmlTag;

class Htmls : public String, Moveable<Htmls> {
public:
	bool   IsNullInstance() const { return IsEmpty(); }

	Htmls& Text(const char *s);
	Htmls& Quote(const char *text);

	Htmls& Color(class Color color);
	Htmls& Percent(double d);

	Htmls& Color(const char *name, class Color color);
	Htmls& Percent(const char *name, double d);

	Htmls& Attr(const char *attr);
	Htmls& Attr(const char *attr, const char *s);
	Htmls& Attr(const char *attr, String s);
	Htmls& Attr(const char *attr, int i);
	Htmls& Attr(const char *attr, double d);
	Htmls& Attr(const char *attr, Date date);
	Htmls& Attr(const char *attr, Value v);

	Htmls& Attp(const char *attr, double val_or_percent);
	Htmls& Atth(const char *attr, const char *href);

	Htmls& Tag(const char *tag);
	Htmls& Gat();

	Htmls& Cat(const HtmlTag& tag);
	Htmls& Cat(String s)              { String::Cat(s); return *this; }
	Htmls& Cat(const char *s)         { String::Cat(s); return *this; }
	Htmls& Cat(char c)                { String::Cat(c); return *this; }
	Htmls& Cat(const char *s, int n)  { String::Cat(s, n); return *this; }

	Htmls& Nbsp();
	Htmls& Br();
	Htmls& Hr();
	Htmls& Lf();

	Htmls(const char *s) : String(s) {}
	Htmls(const String& s) : String(s) {}
	Htmls() {}
	Htmls(const Nuller&) {}
};

class HtmlTag : Moveable<HtmlTag> {
protected:
	Htmls  tag;
	String end;

public:
	HtmlTag&      Text(const char *s)                        { tag.Text(s); return *this; }
	HtmlTag&      Quote(const char *s)                       { tag.Quote(s); return *this; }

	HtmlTag&      Percent(double d)                          { tag.Percent(d); return *this; }

	HtmlTag&      Color(const char *name, class Color color) { tag.Color(name, color); return *this; }
	HtmlTag&      Percent(const char *name, double d)        { tag.Percent(name, d); return *this; }

	HtmlTag&      Attr(const char *attr)                     { tag.Attr(attr); return *this; }
	HtmlTag&      Attr(const char *attr, const char *v)      { tag.Attr(attr, v); return *this; }
	HtmlTag&      Attr(const char *attr, String v)           { tag.Attr(attr, v); return *this; }
	HtmlTag&      Attr(const char *attr, int v)              { tag.Attr(attr, v); return *this; }
	HtmlTag&      Attr(const char *attr, double v)           { tag.Attr(attr, v); return *this; }
	HtmlTag&      Attr(const char *attr, Date v)             { tag.Attr(attr, v); return *this; }
	HtmlTag&      Attr(const char *attr, const Value& v)     { tag.Attr(attr, v); return *this; }

	HtmlTag&      Attp(const char *attr, double vp)          { tag.Attp(attr, vp); return *this; }
	HtmlTag&      Atth(const char *attr, const char *href)   { tag.Atth(attr, href); return *this; }

	HtmlTag&      Type(const char *s);

	HtmlTag&      Name(const char *s);
	HtmlTag&      Name(String id);

	HtmlTag&      Data(const char *v);
	HtmlTag&      Data(String v);
	HtmlTag&      Data(double d);
	HtmlTag&      Data(Value v);

	HtmlTag&      ReadOnly();
	HtmlTag&      Multiple();
	HtmlTag&      Selected();

	HtmlTag&      Align(Alignment align);
	HtmlTag&      Left();
	HtmlTag&      Right();
	HtmlTag&      Center();

	HtmlTag&      VAlign(Alignment align);
	HtmlTag&      Top();
	HtmlTag&      VCenter();
	HtmlTag&      Bottom();

	HtmlTag&      HotKey(char c);

	HtmlTag&      Size(int c);
	HtmlTag&      Size(int cx, int cy);

	HtmlTag&      Color(class Color color);
	HtmlTag&      BorderColor(class Color color);
	HtmlTag&      BgColor(class Color color);

	HtmlTag&      Face(const char *s);
	HtmlTag&      Border(int i);
	HtmlTag&      CellSpacing(int i);
	HtmlTag&      CellPadding(int i);

	HtmlTag&      Width(double d);
	HtmlTag&      Height(double d);

	HtmlTag&      RowSpan(int i);
	HtmlTag&      ColSpan(int i);

	HtmlTag&      Class(const char *s);
	HtmlTag&      DataFld(const char *s);
	HtmlTag&      DataSrc(const char *s);
	HtmlTag&      Href(const char *s);
	HtmlTag&      HtmlId(const char *s);
	HtmlTag&      Lang(const char *s);
	HtmlTag&      Language(const char *s);
	HtmlTag&      JavaScript();
	HtmlTag&      VbScript();
	HtmlTag&      Methods(const char *s);
	HtmlTag&      Rel(const char *s);
	HtmlTag&      Rev(const char *s);
	HtmlTag&      Style(const char *s);
	HtmlTag&      TabIndex(int i);
	HtmlTag&      Target(const char *s);
	HtmlTag&      TargetBlank();
	HtmlTag&      TargetParent();
	HtmlTag&      TargetSelf();
	HtmlTag&      TargetTop();
	HtmlTag&      Title(const char *s);
	HtmlTag&      Urn(const char *s);
	HtmlTag&      Alt(const char *s);
	HtmlTag&      Coords(const char *s);
	HtmlTag&      NoHref();
	HtmlTag&      Shape(const char *s);
	HtmlTag&      ShapeCirc();
	HtmlTag&      ShapePoly();
	HtmlTag&      ShapeRect();
	HtmlTag&      Balance(double v);
	HtmlTag&      Loop(int i);
	HtmlTag&      Volume(double v);
	HtmlTag&      Src(const char *s);
	HtmlTag&      Alink(class Color c);
	HtmlTag&      Vlink(class Color c);
	HtmlTag&      Link(class Color c);
	HtmlTag&      Background(const char *s);

	HtmlTag&      OnClick(const char *js);

	Htmls         GetTag() const;
	Htmls         GetEndTag() const;

	void          Combine(const HtmlTag& tag);

	Htmls         ApplyTo(String s) const;
	Htmls         ApplyTo(const char *s) const;

	HtmlTag&      PairTag(const char *s);
	HtmlTag&      SingleTag(const char *s);

	HtmlTag       operator()() const                         { return *this; }
	Htmls         operator~() const                          { return ApplyTo(Null); }
	operator      Htmls() const                              { return ApplyTo(Null); }
	String        ToString() const                           { return ApplyTo(Null); }

	const Htmls&  Tag() const                                { return tag; }
	Htmls&        Tag()                                      { return tag; }

	const String& End() const                                { return end; }
	String&       End()                                      { return end; }

	bool          IsEmpty() const                            { return tag.IsEmpty(); }

	HtmlTag(const char *s);
	HtmlTag() {}
};

HtmlTag HtmlSingleTag(const char *s);
HtmlTag HtmlInput(const char *type, const char *name = 0);
HtmlTag HtmlEdit(String name);
HtmlTag HtmlEdit(String name, int size, int maxlength = 256,
                 const char *defaultValue = 0, bool password = false);

HtmlTag HtmlHidden(String name, Value val);
HtmlTag HtmlHidden(const char *name, Value val);
HtmlTag HtmlHidden(Value val);

HtmlTag HtmlSubmit(const char *text);

HtmlTag HtmlSelect(String name);
Htmls   HtmlOption(Value val, const char *text, bool selected = false);

HtmlTag HtmlTable();
HtmlTag HtmlRow();
HtmlTag HtmlCell();

HtmlTag HtmlHeader(const char *title, String css = Null, const char *other = 0);



HtmlTag HtmlLink(const char *link);

Htmls   HtmlBlock(Htmls html, double width,
				              double left, double top = 0, double right = 0, double bottom = 0,
				              Alignment align = ALIGN_LEFT);

inline Htmls& operator<<(Htmls& s, const HtmlTag& tag) { s.Cat(tag); return s; }
inline Htmls& operator<<(Htmls& s, const Htmls& v)     { s.Cat(v); return s; }
inline Htmls& operator<<(Htmls& s, String v)           { s.Cat(v); return s; }
inline Htmls& operator<<(Htmls& s, const char *v)      { s.Cat(v); return s; }

inline Htmls& operator+=(Htmls& s, const HtmlTag& tag) { s.Cat(tag); return s; }

Htmls operator+(const HtmlTag& tag1, const HtmlTag& tag2);
Htmls operator+(const String& s, const HtmlTag& tag);
Htmls operator+(const HtmlTag& tag, const String& s);
Htmls operator+(const char *s, const HtmlTag& tag);
Htmls operator+(const HtmlTag& tag, const char *s);

HtmlTag operator/(const HtmlTag& t1, const HtmlTag& t2);
HtmlTag& operator/=(HtmlTag& tag, const HtmlTag& s);

inline Htmls operator/(const HtmlTag& tag, String s)         { return tag.ApplyTo(s); }
inline Htmls operator/(const HtmlTag& tag, const char *s)    { return tag.ApplyTo(s); }




HtmlTag        operator % (const HtmlTag& t1, const HtmlTag& t2);
Htmls          operator % (const HtmlTag& tag, const char *s);
inline Htmls   operator % (const HtmlTag& tag, String s)     { return tag % ~s; }



inline HtmlTag HtmlBold()    { return HtmlTag("B"); }
inline HtmlTag HtmlItalic()  { return HtmlTag("I"); }
inline HtmlTag HtmlBig()     { return HtmlTag("BIG"); }



HtmlTag        HtmlFontColor(Color c);
HtmlTag        HtmlFontSize(int s);



inline Htmls   ToHtml(String s)   { return ToHtml(~s); }
HtmlTag        HtmlLink(const char *link, const char *target);
HtmlTag        HtmlImg(String src, String alt = "");

Htmls          HtmlTextArea(String id, Size size, const char *defaultValue = 0);

HtmlTag        HtmlButton(String id, const char *text);
HtmlTag        HtmlWarn(Color color = LtRed);
HtmlTag        HtmlPackedTable();
HtmlTag        HtmlForm(String action, bool multipart = false, String method = "POST");

Htmls          HtmlCheck(String name, bool on);
Htmls          HtmlUpload(String name);

HtmlTag        HtmlTCell();
HtmlTag        HtmlRowCell();
HtmlTag        HtmlRowTCell();

Htmls          HtmlMenu(bool active, const char *text, const char *url, int wd = 0);
HtmlTag        HtmlDialog(int width = -100);
Htmls          HtmlHead(String title, const char *charset = "windows-1250");
Htmls          HtmlPage(String title, const Htmls& body, Color bgcolor = White, const char *charset = "windows-1250");
Htmls          HtmlTitlePage(String title, const Htmls& body, Color bgcolor = White, const char *charset = "windows-1250");

HtmlTag HtmlLine();
HtmlTag HtmlPara();
HtmlTag HtmlCourier(int size);
HtmlTag HtmlArial(int size);
HtmlTag HtmlRoman(int size);
HtmlTag HtmlCourier();
HtmlTag HtmlArial();
HtmlTag HtmlRoman();
HtmlTag HtmlFntSize(int size);

#line 295 "u:\\uppsrc\\web\\html.h"
#line 37 "u:/uppsrc\\Web/Web.h"

#line 1 "u:\\uppsrc\\web\\socket.h"


static const int DEFAULT_CONNECT_TIMEOUT = 5000;

static const int SOCKKIND_STD = 1;

class Socket : Moveable<Socket>
{
public:
	class Data
	{
	public:
		Data();
		virtual ~Data() { CloseRaw(0); }

		bool                    Open(bool is_blocking);
		bool                    OpenServer(int port, bool nodelay, int listen_count, bool is_blocking);
		bool                    OpenClient(const char *host, int port, bool nodelay, dword *my_addr, int timeout, bool is_blocking);
		bool                    IsOpen() const     { return socket != (SOCKET)(~0); }
		bool                    CloseRaw(int timeout_msec);

		bool                    IsEof() const          { return is_eof && leftover.IsEmpty(); }
		bool                    IsError() const        { return is_error; }
		void                    SetError()             { is_error = true; }
		void                    ClearError()           { is_error = false; }
		void                    SetSockError(String context);

		void                    NoDelay();
		void                    Linger(int msecs);
		void                    Block(bool b = true);
		void                    Reuse();


		void                    StopWrite();

		virtual int             GetKind() const        { return SOCKKIND_STD; }

		virtual bool            Peek(int timeout_msec, bool write);
		virtual int             Read(void *buf, int amount);
		virtual int             Write(const void *buf, int amount);
		virtual bool            Accept(Socket& socket, dword *ipaddr, bool nodelay, int timeout_msec);
		virtual bool            Close(int timeout_msec);
		virtual Value           GetInfo(String info) const;

	public:
		SOCKET                  socket;
		String                  leftover;
		bool                    is_blocking;
		bool                    is_error;
		bool                    is_eof;

		int                     fake_error;
#line 54 "u:\\uppsrc\\web\\socket.h"

	protected:
		SOCKET                  AcceptRaw(dword *ipaddr, int timeout_msec);
		void                    Attach(SOCKET socket, bool nodelay, bool is_blocking);
		void                    SetSockResError(String context);
	};

	Socket() {}
	Socket(One<Data> data) : data(data) {}

	static void     Init();

	void            Attach(One<Data> d)                      { data = d; }
	void            Clear()                                  { data.Clear(); }

	bool            IsOpen() const                           { return !!data; }

	bool            IsEof() const                            { return !data || data->IsEof(); }
	bool            IsError() const                          { return data->IsError(); }
	void            ClearError()                             { data->ClearError(); }

	SOCKET          GetSocket() const                        { return IsOpen() ? data->socket : (SOCKET)(~0); }
	int             GetNumber() const                        { return (int)GetSocket(); }

	int             GetKind() const                          { return data->GetKind(); }
	Value           GetInfo(String info) const               { return data->GetInfo(info); }

	bool            Accept(Socket& socket, dword *ipaddr = 0, bool nodelay = true, int timeout_msec = DEFAULT_CONNECT_TIMEOUT) { return data->Accept(socket, ipaddr, nodelay, timeout_msec); }
	bool            Close(int msecs_timeout = 0);

	void            NoDelay()                                { data->NoDelay(); }
	void            Linger(int msecs)                        { data->Linger(msecs); }
	void            NoLinger()                               { data->Linger(Null); }
	void            Block(bool b = true)                     { data->Block(b); }
	void            NoBlock()                                { data->Block(false); }
	void            Reuse()                                  { data->Reuse(); }

	static bool     Wait(const Vector<SOCKET>& read, const Vector<SOCKET>& write, int timeout_msec);
	static bool     Wait(const Vector<Socket *>& read, const Vector<Socket *>& write, int timeout_msec);

	bool            Peek(int timeout_msec = 0)               { return data->Peek(timeout_msec, false); }
	bool            PeekWrite(int timeout_msec = 0)          { return data->Peek(timeout_msec, true); }
	bool            PeekAbort(int timeout_msec = 0);
	String          PeekCount(int count, int timeout_msec = Null);
	String          PeekUntil(char term, int timeout_msec = Null, int maxlen = 1000000);

	int             ReadRaw(void *buffer, int maxlen)        { return data->Read(buffer, maxlen); }
	String          Read(int timeout_msec = Null, int maxlen = 1000000);
	int             ReadCount(void *buffer, int count, int timeout_msec = Null);
	String          ReadCount(int count, int timeout_msec = Null);
	String          ReadUntil(char term, int timeout_msec = Null, int maxlen = 1000000);
	String          ReadUntil(Gate1<int> term, int& termchar, int timeout = Null, int maxlen = 1000000);
	void            UnRead(const void *buffer, int len);
	void            UnRead(String data)                      { UnRead(data.Begin(), data.GetLength()); }

	int             WriteRaw(const void *buffer, int maxlen) { return data->Write(buffer, maxlen); }
	int             WriteWait(const char *s, int length, int timeout_msec);
	void            Write(const char *s, int length)         { WriteWait(s, length, Null); }
	void            Write(String s)                          { Write(s.Begin(), s.GetLength()); }

	void            StopWrite()                              { data->StopWrite(); }

	static String   GetHostName();

	static String   GetErrorText();
	static void     SetErrorText(String text);
	static void     ClearErrorText()                         { SetErrorText(Null); }
	static void     SetSockError(const char *context)        { SetSockError((SOCKET)(~0), context); }
	static void     SetSockError(SOCKET socket, const char *context);
	static void     SetSockError(SOCKET socket, const char *context, const char *errordesc);


	static int      GetErrorCode()                           { return WSAGetLastError(); }






#line 134 "u:\\uppsrc\\web\\socket.h"

private:
	One<Data>       data;
};


class SocketEvent : public Event {
public:
	SocketEvent() {}

	void     Read(Socket& socket);
	void     Write(Socket& socket);
	void     Accept(Socket& socket);
	void     Select(Socket& socket, int fd_flags);
};
#line 150 "u:\\uppsrc\\web\\socket.h"

bool ServerSocket(Socket& socket, int port, bool nodelay = true, int listen_count = 5, bool is_blocking = true);
bool ClientSocket(Socket& socket, const char *host, int port, bool nodelay = true, dword *my_addr = 0, int timeout = DEFAULT_CONNECT_TIMEOUT, bool is_blocking = true);
#line 39 "u:/uppsrc\\Web/Web.h"
#line 1 "u:\\uppsrc\\web\\httpsrv.h"
String MIMECharsetName(byte charset);

inline String HttpContentType(String type)                  { return "Content-Type: " + type + "\r\n"; }

inline String HttpTextHtml(String encoding)                 { return "text/html; charset=" + encoding; }
inline String HttpTextHtml(byte charset = 0)  { return HttpTextHtml(MIMECharsetName(charset)); }

inline String HttpTextPlain(String encoding)                { return "text/plain; charset=" + encoding; }

inline String HttpTextPlain(byte charset = 0) { return HttpTextPlain(MIMECharsetName(charset)); }
inline String HttpTextXml()                                 { return "text/xml"; }
inline String HttpImage(String format)                      { return "image/" + format; }
inline String HttpImageGif()                                { return "image/gif"; }
inline String HttpImageJpg()                                { return "image/jpeg"; }
inline String HttpImagePng()                                { return "image/png"; }
inline String HttpBinary()                                  { return "application/octet-stream"; }

class HttpServer;

class HttpRequest
{
	friend class HttpServer;

public:
	HttpRequest(HttpServer& server,  Socket& socket, HttpQuery query);

	HttpServer&   GetServer()                              { return server; }
	Socket&       GetSocket()                              { return socket; }

	Event&        GetEvent()                               { return event; }
#line 32 "u:\\uppsrc\\web\\httpsrv.h"
	HttpQuery     GetQuery() const                         { return query; }

	bool          IsLogging() const;
	void          LogTime(const char *s, int level);
	int           GetDuration() const;

	void          Write(String header, String body, int result_code, String result_text);
	void          Write(String header, String body);
	void          Write(String body)                       { Write(Null, body); }
	void          Redirect(String url);
	void          Error(String err);

private:
	HttpServer&   server;
	Socket        socket;

	SocketEvent   event;
#line 50 "u:\\uppsrc\\web\\httpsrv.h"
	HttpQuery     query;
	dword         request_ticks;
};

class HttpServer
{
public:
	HttpServer();

	bool               Open(int port, int listen_count = 5);
	bool               Reopen();
	void               Close();

	bool               IsOpen() const                 { return socket.IsOpen(); }
	bool               IsError() const                { return socket.IsError(); }
	int                GetPort() const                { return server_port; }
	Socket&            GetSocket()                    { return socket; }
	Socket&            GetConnSocket()                { return connection; }

	Event&             GetEvent()                     { return sock_event; }
	Event&             GetConnEvent()                 { return conn_event; }
#line 72 "u:\\uppsrc\\web\\httpsrv.h"

	void               Logging(const char *log = 0, int max_log_size = 500000);
	void               NoLogging()                    { logfile = Null; }
	bool               IsLogging() const              { return !logfile.IsEmpty(); }
	void               Log(const char *s, int level);
	void               LogTime(const char *s, int level);
	HttpServer&        operator << (const char *s)    { Log(s, 0); return *this; }

	static HttpServer *Wait(const Vector<HttpServer *>& list, int msec);
	bool               Wait(int msec);
	void               GetReadSockets(Vector<Socket *>& sockets);
	void               GetWriteSockets(Vector<Socket *>& sockets);

	void               GetWaitEvents(Vector<Event *>& events);
#line 87 "u:\\uppsrc\\web\\httpsrv.h"
	One<HttpRequest>   GetRequest();

	Time               GetStartTime() const           { return start_time; }
	double             GetHitCount() const            { return hit_count; }
	double             GetResponseTime() const        { return total_response_msec; }
	double             GetAvgTime() const;
	double             GetAvgLagTime() const;
	double             GetElapsedTime() const;

	String             GetDefaultHeader() const       { return default_header; }
	void               DefaultHeader(String h)        { default_header = h; }

	int                GetMaxPostSize() const         { return max_post_size; }
	void               MaxPostSize(int size)          { max_post_size = size; }

	int                GetMaxRequestTime() const      { return max_request_time; }
	void               MaxRequestTime(int time)       { max_request_time = time; }

	bool               IsShowQuery() const            { return show_headers; }
	void               ShowQuery(bool sh = true)      { show_headers = sh; }

	void               AddRequest(int duration_msec);
	void               ReadPostData(Socket& socket, HttpQuery& query);

	void               AddWrite(Socket socket, String data);
	bool               DelayedWrite();
	bool               IsDelayedWrite() const;

public:
	Callback2<String, int> WhenLog;

private:
	bool               Accept();

private:
	Socket             socket;
	Socket             connection;

	SocketEvent        sock_event;
	SocketEvent        conn_event;
#line 128 "u:\\uppsrc\\web\\httpsrv.h"
	class SocketWrite
	{
	public:
		SocketWrite(Socket socket, String data, int ticks = 0);

	public:
		Socket      socket;

		SocketEvent sock_event;
#line 138 "u:\\uppsrc\\web\\httpsrv.h"
		String      data;
		int         done;
		int         ticks;
	};
	Array<SocketWrite> delayed_writes;

	int                server_port;
	dword              ipaddr;
	String             default_header;
	String             logfile;
	int                max_log_size;
	enum { DEFAULT_MAX_POST_SIZE = 1000000 };
	int                max_post_size;
	enum { DEFAULT_MAX_REQUEST_TIME = 60000 };
	int                max_request_time;
	bool               show_headers;

	int                request_time;
	int                request_state;
	enum { RS_FIRST, RS_SAPI, RS_GET_HEADERS, RS_POST_HEADERS, RS_POST_DATA };
	String             first_line;
	String             sapi_request;
	int                sapi_length;
	int                request_version;
	String             header_line;
	int                headers_length;
	int                post_length;
	String             post_data;
	HttpQuery          request_query;

	Time               start_time;
	double             hit_count;
	double             total_response_msec;

	enum { TRAILER = 10 };
	dword              trailing_times[TRAILER];
	dword              trailing_sum;
	int                trailing_count;
};

inline bool   HttpRequest::IsLogging() const { return server.IsLogging(); }

inline String GetHttpPath(HttpQuery query)  { return query.GetString("$$PATH"); }
inline String GetHttpQuery(HttpQuery query) { return query.GetString("$$QUERY"); }
String        GetHttpURI(HttpQuery query);
void          GetHttpPostData(HttpQuery& query, String data);
String        GetHttpQueryDump(HttpQuery query);
String        GetHttpErrorPage(HttpQuery query, String err, bool show_query);
#line 40 "u:/uppsrc\\Web/Web.h"
#line 1 "u:\\uppsrc\\web\\httpcli.h"



class HttpClient
{
public:
	HttpClient();

	HttpClient&  TimeoutMsecs(int t)              { timeout_msecs = t; return *this; }
	HttpClient&  MaxHeaderSize(int m)             { max_header_size = m; return *this; }
	HttpClient&  MaxContentSize(int m)            { max_content_size = m; return *this; }

	HttpClient&  Host(String h)                   { host = h; return *this; }
	HttpClient&  Port(int p)                      { port = p; return *this; }
	HttpClient&  Path(String p)                   { path = p; return *this; }
	HttpClient&  User(String u, String p)         { username = u; password = p; return *this; }
	HttpClient&  URL(const char *url);
	HttpClient&  KeepAlive(bool k)                { keepalive = k; return *this; }
	HttpClient&  Proxy(String h, int p)           { proxy_host = h; proxy_port = p; return *this; }
	HttpClient&  Proxy(const char *url);
	HttpClient&  ProxyAuth(String u, String p)    { proxy_username = u; proxy_password = p; return *this; }

	HttpClient&  Headers(String h)                { client_headers = h; return *this; }
	HttpClient&  ClearHeaders()                   { return Headers(Null); }
	HttpClient&  AddHeaders(String h)             { client_headers.Cat(h); return *this; }

	HttpClient&  StdHeaders(bool sh)              { std_headers = sh; return *this; }
	HttpClient&  NoStdHeaders()                   { return StdHeaders(false); }
	HttpClient&  Accept(String a)                 { accept = a; return *this; }
	HttpClient&  Agent(String a)                  { agent = a; return *this; }

	HttpClient&  Method(int m)                    { method = m; return *this; }
	HttpClient&  Get()                            { return Method(METHOD_GET); }
	HttpClient&  Post()                           { return Method(METHOD_POST); }
	HttpClient&  Head()                           { return Method(METHOD_HEAD); }

	HttpClient&  PostData(String pd)              { postdata = pd; return *this; }

	String       Execute(Gate2<int, int> progress = false);
	String       ExecuteRedirect(int max_redirect = DEFAULT_MAX_REDIRECT,
		int retries = DEFAULT_RETRIES, Gate2<int, int> progress = false);

	bool         IsError() const                  { return !IsNull(error); }
	String       GetError() const                 { return error; }
	bool         IsAborted() const                { return aborted; }

	int          GetStatusCode() const            { return status_code; }
	String       GetStatusLine() const            { return status_line; }
	String       GetHeaders() const               { return server_headers; }

	bool         IsRedirect() const               { return is_redirect; }
	String       GetRedirectURL() const           { return redirect_url; }

	void         Close()                          { socket.Close(); }

public:
	Socket       socket;
	bool         keepalive;
	bool         aborted;
	String       error;

	int          timeout_msecs;
	int          max_header_size;
	int          max_content_size;

	String       host;
	int          port;
	bool         is_post;
	bool         std_headers;
	int          method;
	String       proxy_host;
	int          proxy_port;
	String       proxy_username;
	String       proxy_password;
	String       path;
	String       username;
	String       password;
	String       client_headers;
	String       accept;
	String       agent;
	String       postdata;

	int          status_code;
	String       status_line;
	String       server_headers;

	bool         is_redirect;
	String       redirect_url;

	enum {
		DEFAULT_PORT             = 80,
		DEFAULT_TIMEOUT_MSECS    = 120000,
		DEFAULT_MAX_HEADER_SIZE  = 1000000,
		DEFAULT_MAX_CONTENT_SIZE = 10000000,
		DEFAULT_MAX_REDIRECT     = 5,
		DEFAULT_RETRIES          = 3,
	};

	enum {
		METHOD_GET,
		METHOD_POST,
		METHOD_HEAD,
	};

private:
	String       ReadUntilProgress(char until, int start_time, int end_time, Gate2<int, int> progress);
};

String HttpClientGet(String url, String *server_headers = 0, String *error = 0,
	Gate2<int, int> progress = false, int timeout = HttpClient::DEFAULT_TIMEOUT_MSECS,
	int max_redirect = HttpClient::DEFAULT_MAX_REDIRECT, int retries = HttpClient::DEFAULT_RETRIES);

String HttpClientGet(String url, String username, String password,
	String *server_headers = 0, String *error = 0,
	Gate2<int, int> progress = false, int timeout = HttpClient::DEFAULT_TIMEOUT_MSECS,
	int max_redirect = HttpClient::DEFAULT_MAX_REDIRECT, int retries = HttpClient::DEFAULT_RETRIES);

String HttpClientGet(String url, String proxy,
	String *server_headers = 0, String *error = 0,
	Gate2<int, int> progress = false, int timeout = HttpClient::DEFAULT_TIMEOUT_MSECS,
	int max_redirect = HttpClient::DEFAULT_MAX_REDIRECT, int retries = HttpClient::DEFAULT_RETRIES);

String HttpClientGet(String url, String proxy, String username, String password,
	String *server_headers = 0, String *error = 0,
	Gate2<int, int> progress = false, int timeout = HttpClient::DEFAULT_TIMEOUT_MSECS,
	int max_redirect = HttpClient::DEFAULT_MAX_REDIRECT, int retries = HttpClient::DEFAULT_RETRIES);

#line 129 "u:\\uppsrc\\web\\httpcli.h"
#line 41 "u:/uppsrc\\Web/Web.h"
#line 1 "u:\\uppsrc\\web\\auth.h"
class WebUser
{
public:
	WebUser(String name = Null, String pass = Null, String args = Null)
		: name(name), pass(pass), args(args) {}

	void                   Serialize(Stream& stream);


	static String          CheckToken(String token);
	static String          CreateToken(String args);
	static void            DeleteToken(String token);


	static void            SetMap(const Array<WebUser>& map);
	static Array<WebUser>  GetMap();
	static void            SerializeMap(String& s, bool write);
	static void            ClearMap();

	void                   SetUser() const;
	String                 GetArgs() const;

	static String          Login(const HttpQuery& map, String& args,
		const char *isapi_name = 0, bool *save_cfg = 0);

public:
	String                 name;
	String                 pass;
	String                 args;
};
#line 42 "u:/uppsrc\\Web/Web.h"
#line 1 "u:\\uppsrc\\web\\smtp.h"
class SmtpMail
{
public:
	enum AS { TO, CC, BCC };

	SmtpMail();

	SmtpMail&      Host(String h)                 { host = h; return *this; }
	SmtpMail&      Port(int p)                    { port = p; return *this; }
	SmtpMail&      From(String f)                 { from = f; return *this; }
	SmtpMail&      To(String t, AS a = TO)        { to.Add(t); as.Add(a); return *this; }
	SmtpMail&      Text(String t, String m = Null) { text.Add(t); mime.Add(m); return *this; }
	SmtpMail&      NoHeader()                     { no_header = true; return *this; }
	SmtpMail&      NoHeaderSep()                  { no_header_sep = true; return *this; }
	SmtpMail&      ReplyTo(String r)              { reply_to = r; return *this; }
	SmtpMail&      TimeSent(Time t)               { time_sent = t; return *this; }
	SmtpMail&      Subject(String s)              { subject = s; return *this; }
	SmtpMail&      Transcript(bool t = true)      { transcript = t; return *this; }
	SmtpMail&      AttachFile(const char *filename, const char *mime = 0);
	SmtpMail&      Attach(const char *name, String data, const char *mime = 0);

	bool           Send();

	String         GetError() const          { return error; }
	String         GetTranscript() const     { return transcript_text; }

private:
	struct Attachment
	{
		String name;
		String file;
		String mime;
		String data;
	};

	String         host;
	int            port;
	String         from;
	Vector<String> to;
	Vector<char>   as;
	Vector<String> text;
	Vector<String> mime;
	bool           transcript;
	Array<Attachment> attachments;


	bool           no_header;
	bool           no_header_sep;
	Time           time_sent;
	String         reply_to;
	String         subject;


	String         error;
	String         transcript_text;
};
#line 43 "u:/uppsrc\\Web/Web.h"
#line 1 "u:\\uppsrc\\web\\sproc.h"
class SlaveProcess
{
public:
	SlaveProcess() {}
	virtual ~SlaveProcess() {}

	virtual void Kill() = 0;
	virtual bool IsRunning() = 0;
	virtual void Write(String s) = 0;
	virtual bool Read(String& s) = 0;
	virtual int  GetExitCode() = 0;
	virtual void Detach() {};

private:
	SlaveProcess(const SlaveProcess& sp);
	void         operator = (const SlaveProcess& sp);
};

One<SlaveProcess> StartLocalProcess(const char *cmdline, const char *envptr = 0);
One<SlaveProcess> StartRemoteProcess(const char *host, int port, const char *cmdline, const char *envptr = 0, int timeout = Null);
One<SlaveProcess> StartProcess(const char *cmdline, const char *envptr = 0, int timeout = Null);
#line 44 "u:/uppsrc\\Web/Web.h"

};

#line 48 "u:/uppsrc\\Web/Web.h"
#line 5 "u:/uppsrc\\TCore/TCore.h"




#line 1 "u:\\uppsrc\\tcore\\template.h"
namespace Upp {


























































template <class T>
void SerializeRaw(Stream& stream, T& object)
{
	stream.SerializeRaw((byte *)&object, sizeof(object));
}

template <class T>
void SerializeEnum(Stream& stream, T& object)
{
	int o = object;
	stream / o;
	object = T(o);
}

template <class T>
static bool SerializeIn(T& object, String data)
{
	StringStream stream(data);
	stream % object;
	return !stream.IsError();
}

template <class T>
static String SerializeOut(const T& object)
{
	StringStream stream;
	stream % const_cast<T&>(object);
	return stream;
}

template <class T>
class PtrValueRep : public RawValueRep<T *>
{
public:
	PtrValueRep(T *v) : RawValueRep<T *>(v)          {}

	virtual bool       IsNull() const                { return this->v == 0; }
	virtual unsigned   GetHashValue() const          { return (unsigned)this->v; }
	virtual bool       IsEqual(const Value::Void *p);
	virtual String     AsString()                    { return FormatIntHex((int)this->v); }

	static const RawValueRep<T *> *Cast(const Value::Void *p)
	{ ; return (const RawValueRep<T *> *)p; }
};

template <class T>
bool PtrValueRep<T>::IsEqual(const Value::Void *p)
{
	const RawValueRep<T *> *cast = dynamic_cast<const RawValueRep<T *> *>(p);
	return cast && cast->Get() == this->v;
}

template <class T>
class PtrValue : public Value
{
protected:
	typedef PtrValueRep<T> Rep;

public:
	PtrValue(T *x) : Value(new Rep(x)) {}
	T        *Get(const Value& v)       { return ::IsNull(v) ? 0 : Rep::Cast(v.GetVoidPtr())->Get(); }
	static T *Extract(const Value& v)   { return ::IsNull(v) ? 0 : Rep::Cast(v.GetVoidPtr())->Get(); }
};

template <class T>
inline Value PtrToValue(T *p)           { return PtrValue<T>(p); }





template <class T, class I = int>
class TypeMap : Moveable< TypeMap<T, I> > {
public:
	One<T>                    CreateObject(I id) const;
	I                         QueryObject(const T *object) const;

	One<T>                    Copy(const One<T>& object) const;
	void                      Serialize(Stream& stream, One<T>& object) const;
	void                      Serialize(Stream& stream, Array<T>& array) const;


	One<T>                    SerializeIn(const String& string) const;
	String                    SerializeOut(const One<T>& object) const;

	typedef One<T>            (*NewFunc)();

	void                      Register(NewFunc fn, const type_info *ti, I id);

	template <class ST>
	struct NewType {
		static One<T> New() { return new ST; }
	};

	template <class ST>
	void                      RegisterType(I id) { Register(&NewType<ST>::New, &typeid(ST), id); }

public:
	Index<I>                  id_index;
	Vector< One<T> (*)()>     factories;
	Index<const type_info *, PtrHash> type_index;



};

template <class T, class I>
One<T> TypeMap<T, I>::CreateObject(I id) const
{
	if(IsNull(id))
		return 0;
	int f = id_index.Find(id);
	if(f < 0)
		return 0;
	return factories[f]();
}

template <class T, class I>
I TypeMap<T, I>::QueryObject(const T *object) const
{
	if(!object)
		return Null;
	int i = type_index.Find(&typeid(*object));
	return i >= 0 ? id_index[i] : I(Null);
}

template <class T, class I>
One<T> TypeMap<T, I>::Copy(const One<T>& object) const
{
	if(!object)
		return 0;
	return this->SerializeIn(SerializeOut(object));
}

template <class T, class I>
One<T> TypeMap<T, I>::SerializeIn(const String& string) const
{
	One<T> object;
	StringStream strm(string);
	Serialize(strm, object);
	return object;
}

template <class T, class I>
String TypeMap<T, I>::SerializeOut(const One<T>& object) const
{
	StringStream ss;
	Serialize(ss, const_cast<One<T>&>(object));
	return ss;
}

template <class T, class I>
void TypeMap<T, I>::Serialize(Stream& stream, One<T>& object) const
{
	I ID;
	if(stream.IsStoring())
		ID = QueryObject(~object);
	stream / ID;
	if(stream.IsLoading()) {
		object = CreateObject(ID);
		if(object)
			stream % *object;
		else if(!IsNull(ID))
			stream.SetError();
	}
	else if(object)
		stream % *object;
}

template <class T, class I>
void TypeMap<T, I>::Serialize(Stream& stream, Array<T>& array) const
{
	int c = array.GetCount();
	stream % c;
	if(stream.IsStoring()) {
		for(int i = 0; i < c; i++) {
			I ID = QueryObject(&array[i]);
			stream / ID;
			stream % array[i];
		}
	}
	else {
		array.SetCount(c);
		for(int i = 0; i < c; i++) {
			I ID;
			stream / ID;
			One<T> object = CreateObject(ID);
			if(object) {
				array.Add(-object);
				stream % array.Top();
			}
			else {
				stream.SetError();
				return;
			}
		}
	}
}

template <class T, class I>
void TypeMap<T, I>::Register(NewFunc fn, const type_info *ti, I id)
{
	int tx = type_index.Find(ti);
	if(tx >= 0)
		;
	else {
		;
		type_index.Add(ti);
		id_index.Add(id);
		factories.Add() = fn;
	}
}

template <class T>
void StreamOne(Stream& stream, One<T>& one)
{
	bool full = one;
	stream % full;
	if(stream.IsLoading())
		if(full)
			one = new T;
		else
			one = 0;
	if(one)
		stream % *one;
}

template <class T>
One<T> StreamCopyOne(const One<T>& one)
{
	if(!one)
		return 0;
	String aux = SerializeOut(*one);
	One<T> out = new T;
	SerializeIn(*out, aux);
	return out;
}

template <class B>
struct NewableType {
	typedef B *(*Factory)();

	typedef VectorMap<const type_info *, Factory, PtrHash> FactoryMap;

	static FactoryMap& Factories();

	static B          *New(const type_info& t);
	static B          *NewNull(const type_info& t);
	static Factory     GetFactory(const type_info& t);
};

template <class B>
typename NewableType<B>::FactoryMap& NewableType<B>::Factories()
{
	static FactoryMap *pmap = 0;
	if(!pmap)
	{
		static FactoryMap map;
		pmap = &map;
	}
	return *pmap;
}

template <class B>
B *NewableType<B>::New(const type_info& t)
{
	B *ptr = NewNull(t);
	if(ptr == 0)
		throw Exc(NFormat("Objekt '%s' nen registrovn.", t.name()));
	return ptr;
}

template <class B>
B *NewableType<B>::NewNull(const type_info& t)
{
	Factory factory = GetFactory(t);
	return factory ? factory() : 0;
}

template <class B>
typename NewableType<B>::Factory NewableType<B>::GetFactory(const type_info& t)
{
	return Factories().Get(&t, 0);
}

template <class B, class C>
struct RegisterNewableType : NewableType<B>
{
	RegisterNewableType() { typename NewableType<B>::Factory f = CreateObject; this->Factories().FindAdd(&typeid(C), f); }

private:
	static B *CreateObject() { return new C; }
};








class RefMemStat
{
public:
	RefMemStat() {}
	RefMemStat(const RefMemStat& rms, int deep) : alloc_map(rms.alloc_map, 0) {}

	static RefMemStat&             App();

	void                           Add(const String& name, int allocindex);
	void                           Remove(const String& name, int allocindex);

	String                         Format(bool index = false) const;
	String                         FormatDelta(const RefMemStat& old, bool index = false) const;

private:
	VectorMap<String, Index<int> > alloc_map;
};
template class DeepCopyOption<RefMemStat>;












class WeakBase : public Link<WeakBase>
{
public:
	virtual ~WeakBase() { DbgChk(); }
	virtual void Clear() = 0;




	void         DbgChk() const {}
#line 402 "u:\\uppsrc\\tcore\\template.h"

	void         Chk() const;
};

template <class T>
class Upp::RefCon;

template <class T>
class Upp::RefPtr;

class WeakRef;

template <class T>
class WeakCon : public WeakBase
{
	friend class WeakRef;
	friend class Upp::RefCon<T>;

public:
	WeakCon() : ptr(0) {}
	WeakCon(const WeakCon<T>& p)                         { p.Chk(); if(ptr = p.ptr) LinkAfter(ptr); Chk(); }
	WeakCon(const T *p)                                  { if(ptr = const_cast<T *>(p)) LinkAfter(ptr); Chk(); }
	WeakCon(const RefCon<T>& p)                          { if(ptr = const_cast<T *>(~p)) LinkAfter(ptr); Chk(); }
	~WeakCon()                                           { Chk(); }

	operator       RefCon<T> () const                    { return RefCon<T>(ptr); }

	WeakCon<T>&    operator = (const T *p)               { Chk(); Unlink(); if(ptr = const_cast<T *>(p)) LinkAfter(ptr); Chk(); return *this; }
	WeakCon<T>&    operator = (const WeakCon<T>& p)      { Chk(); Unlink(); if(ptr = p.ptr) LinkAfter(ptr); Chk(); return *this; }
	WeakCon<T>&    operator = (const RefCon<T>& p)       { Chk(); Unlink(); if(ptr = p.ptr) LinkAfter(ptr); Chk(); return *this; }

	virtual void   Clear()                               { Chk(); Unlink(); ptr = 0; }
	bool           IsEmpty() const                       { return ptr == 0; }
	bool           operator ! () const                   { return IsEmpty(); }

	const T       *operator ~ () const                   { return ptr; }
	const T&       operator * () const                   { ; return *ptr; }
	const T       *operator -> () const                  { ; return ptr; }

	friend bool     operator == (const WeakCon<T>& a, const WeakCon<T>& b) { return a.ptr == b.ptr; }
	friend bool     operator != (const WeakCon<T>& a, const WeakCon<T>& b) { return a.ptr != b.ptr; }
	friend unsigned GetHashValue(const WeakCon<T>& a)                      { return Upp::GetHashValue(a.ptr); }

protected:
	T              *ptr;
};

template <class T>
class WeakPtr : public WeakCon<T>
{
public:
	WeakPtr() {}
	WeakPtr(const WeakPtr<T>& p) : WeakCon<T>(p)         {}
	WeakPtr(T *p) : WeakCon<T>(p)                        {}
	WeakPtr(const RefPtr<T>& p) : WeakCon<T>(p)          {}

	operator       RefPtr<T> () const                    { return RefPtr<T>(const_cast<T *>(this->ptr)); }

	WeakPtr<T>&    operator = (T *p)                     { this->Chk(); this->Unlink(); if(this->ptr = p) LinkAfter(this->ptr); this->Chk(); return *this; }
	WeakPtr<T>&    operator = (const WeakPtr<T>& p)      { this->Chk(); this->Unlink(); if(this->ptr = p.ptr) LinkAfter(this->ptr); this->Chk(); return *this; }
	WeakPtr<T>&    operator = (const RefPtr<T>& p)       { this->Chk(); this->Unlink(); if(this->ptr = ~p) LinkAfter(this->ptr); this->Chk(); return *this; }

	T             *operator ~ () const                   { return const_cast<T *>(this->ptr); }
	T&             operator * () const                   { ; return *const_cast<T *>(this->ptr); }
	T             *operator -> () const                  { ; return const_cast<T *>(this->ptr); }
};

class WeakRef : public Link<WeakBase>
{
public:
	WeakRef() : refcount(0) {}
	virtual ~WeakRef()                  { ; while(GetNext() != GetPtr()) GetNext()->Clear(); }

	int             GetRefCount() const { return AtomicXAdd(refcount, 0); }
	void            AddRef() const      { if(this) AtomicInc(refcount); }
	void            Release() const     { if(this && !AtomicDec(refcount)) delete this; }

private:
	mutable Atomic  refcount;
};

template <class T>
class VirtualArrayData : public RefBase
{
public:
	virtual ~VirtualArrayData() {}

	virtual void     SetCount(int count) = 0;
	virtual void     SetCountR(int count) = 0;
	virtual int      GetCount() const = 0;
	virtual void     Set(int i, T t) = 0;
	virtual T        Get(int i) const = 0;
};

template <class T>
class VirtualArray : Moveable< VirtualArray<T> >
{
public:
	VirtualArray() {}
	VirtualArray(VirtualArrayData<T> *data) : data(data) {}

	bool             IsNullInstance() const    { return !data; }
	void             SetCount(int count)       { data->SetCount(count); }
	void             SetCountR(int count)      { data->SetCountR(count); }
	int              GetCount() const          { return data->GetCount(); }
	void             Set(int i, T t)           { data->Set(i, t); }
	T                Get(int i) const          { return data->Get(i); }

	T                operator [] (int i) const { ; return Get(i); }
	void             Add(T t)                  { int c = GetCount(); SetCountR(c + 1); Set(c, t); }

	void             Clear()                   { data->SetCount(0); }
	bool             IsEmpty() const           { return data->GetCount() == 0; }

	typedef T        ValueType;

	class ConstIterator
	{
	protected:
		const VirtualArray<T> *cont;
		int                    ii;

	public:
		T              operator*() const       { return (*cont)[ii]; }
		T              operator[](int i) const { return (*cont)[ii + i]; }

		ConstIterator& operator++()           { ++ii; return *this; }
		ConstIterator& operator--()           { --ii; return *this; }
		ConstIterator  operator++(int)        { ConstIterator t = *this; ++ii; return t; }
		ConstIterator  operator--(int)        { ConstIterator t = *this; --ii; return t; }

		ConstIterator& operator+=(int d)      { ii += d; return *this; }
		ConstIterator& operator-=(int d)      { ii -= d; return *this; }

		ConstIterator  operator+(int d) const { return ConstIterator(cont, ii + d); }
		ConstIterator  operator-(int d) const { return ConstIterator(cont, ii - d); }

		int  operator-(const ConstIterator& b) const   { return ii - b.ii; }

		bool operator==(const ConstIterator& b) const  { return ii == b.ii; }
		bool operator!=(const ConstIterator& b) const  { return ii != b.ii; }
		bool operator<(const ConstIterator& b) const   { return ii < b.ii; }
		bool operator>(const ConstIterator& b) const   { return ii > b.ii; }
		bool operator<=(const ConstIterator& b) const  { return ii <= b.ii; }
		bool operator>=(const ConstIterator& b) const  { return ii >= b.ii; }



		ConstIterator()                                { cont = 0; ii = -1; }
		ConstIterator(const VirtualArray<T> *_cont, int ii) : cont(_cont), ii(ii) {}
	};

	ConstIterator    Begin() const             { return ConstIterator(this, 0); }
	ConstIterator    End() const               { return ConstIterator(this, GetCount()); }
	ConstIterator    GetIter(int i) const      { ; return ConstIterator(this, i); }

private:
	RefPtr< VirtualArrayData<T> > data;
};

template <class VT, class ST, int SN = 1024>
class VirtualSegtorArray : public VirtualArrayData<VT>
{
public:
	virtual void   SetCount(int count)  { container.SetCount(count); }
	virtual void   SetCountR(int count) { container.SetCount(count); }
	virtual int    GetCount() const     { return container.GetCount(); }

protected:
	Segtor<ST, SN> container;
};

template <class VT, class ST, int SN = 1024>
class VirtualStdSegtorArray : public VirtualSegtorArray<VT, ST, SN>
{
public:
	virtual void     Set(int i, VT t)   { this->container[i] = t; }
	virtual VT       Get(int i) const   { return this->container[i]; }
};

template <class T>
class VirtualValueArray : public VirtualStdSegtorArray<Value, T>
{
};

};
#line 10 "u:/uppsrc\\TCore/TCore.h"
#line 1 "u:\\uppsrc\\tcore\\util.h"
namespace Upp {


typedef __int64 longlong_t;




#line 10 "u:\\uppsrc\\tcore\\util.h"

Vector<String> SplitCommandLine(const char *cmdline, bool response_files = false);




longlong_t     GetHotKey(byte c, bool ascii_only = false);
longlong_t     GetHotKey(const char *s, bool ascii_only = false);
char           GetHotKeyText(longlong_t hotkey);
String         StripHotText(const char* s);
String         HotTextToSmartText(const char *s);

bool           IsNan(double d);
bool           IsInf(double d);

inline int     abs2         (Size p)             { return p.cx * p.cx + p.cy * p.cy; }
inline int     abs          (Size p)             { return (int)hypot(p.cx, p.cy); }
inline int     MulVector    (Size a, Size b)     { return a.cx * b.cy - a.cy * b.cx; }
inline int     MulScalar    (Size a, Size b)     { return a.cx * b.cx + a.cy * b.cy; }
Point          Transform    (Point pt, const Rect& from_rc, const Rect& to_rc);
Rect           Transform    (const Rect& rc, const Rect& from_rc, const Rect& to_rc, bool normalize = true);

int            PutGetMW(Stream& stream, int value);
int            PutGetIW(Stream& stream, int value);
int            PutGetML(Stream& stream, int value);
int            PutGetIL(Stream& stream, int value);
int64          PutGetM64(Stream& stream, int64 value);
int64          PutGetI64(Stream& stream, int64 value);

inline void    StreamMW(Stream& stream, int& value)  { value = PutGetMW(stream, value); }
inline void    StreamIW(Stream& stream, int& value)  { value = PutGetIW(stream, value); }
inline void    StreamML(Stream& stream, int& value)  { value = PutGetML(stream, value); }
inline void    StreamIL(Stream& stream, int& value)  { value = PutGetIL(stream, value); }
inline void    StreamM64(Stream& stream, int64& value) { value = PutGetM64(stream, value); }
inline void    StreamI64(Stream& stream, int64& value) { value = PutGetI64(stream, value); }
void           StreamID(Stream& stream, double& value);
void           StreamMD(Stream& stream, double& value);
void           StreamIFP(Stream& stream, Pointf& pt);
void           StreamIFR(Stream& stream, Rectf& rect);


String         StringReplace(const String& str, const String& find, const String& replace);
int            StringFind(const String& string, const String& substring, int start_pos = 0);
const char    *StringFind(const char *sbegin, const char *send, const char *subbegin, const char *subend);
String         FromCString(const char *cstring);
bool           HasNlsLetters(WString s);

const Convert& CFormatConvert();


String         GetLocaleInfo(LCTYPE type, LCID locale = (((DWORD)((((DWORD)((WORD )(0x0))) << 16) | ((DWORD)((WORD )((((((WORD )(0x01)) << 10) | (WORD )(0x00))))))))));
#line 62 "u:\\uppsrc\\tcore\\util.h"

String         NlsFormat(int value);
String         NlsFormat(double value, int decimal_places);
String         NlsFormatRel(double value, int relative_places);
String         FormatFraction(double fraction, const char *pattern = "%0nl");

class ConvertNvl : public Convert
{
public:
	ConvertNvl(Value nvl = Value()) : nvl(nvl)     {}

	ConvertNvl&   NullValue(const Value& val)      { nvl = val; return *this; }
	const Value&  GetNullValue() const             { return nvl; }

	virtual Value Format(const Value& value) const { return Nvl(value, nvl); }

protected:
	Value         nvl;
};

class ConvertFraction : public ConvertDouble
{
public:
	ConvertFraction(double minval = DOUBLE_NULL_LIM, double maxval = -DOUBLE_NULL_LIM,
		bool notnull = false, const char *pattern = "%0n")
	: ConvertDouble(minval, maxval, notnull) { Pattern(pattern); }

	virtual Value Format(const Value& value) const;
	virtual Value Scan(const Value& value) const;
	virtual int   Filter(int c) const;
};

const ConvertFraction& StdConvertFraction();

String         FormatIntCsPlural(int i, const char *noun);

inline bool    StdValueLess(Value a, Value b, int language)   { return StdValueCompare(a, b, language) < 0; }
inline bool    StdValueLess0(Value a, Value b)                { return StdValueLess(a, b, 0); }

class NvlConvert : public Convert
{
public:
	NvlConvert(const Value& dflt = Value()) : dflt(dflt) {}
	virtual ~NvlConvert() {}

	NvlConvert&  SetValue(const Value& v)         { dflt = v; return *this;}
	const Value& GetValue() const                 { return dflt; }

	NvlConvert&  operator = (const Value& v)      { dflt = v; return *this; }
	operator const Value& () const                { return dflt; }

	Value        Format(const Value& value) const { return IsNull(value) ? dflt : value; }

private:
	Value        dflt;
};






bool           SaveFileChanges(String fn, String data);
bool           SaveFileBackup(String fn, String data, bool keep_backup = false);
bool           FileFlush(FileStream& fstream);

struct BoolRef : public RefManager
{
	virtual int        GetType()                         { return UNKNOWN_V; }
	virtual Value      GetValue(const void *x)           { return *(const bool *)x ? 1 : 0; }
	virtual void       SetValue(void *x, const Value& v) { *(bool *)x = !Upp::IsNull(v) && (double)v; }
	virtual void       SetNull(void *x)                  { *(bool *)x = false; }

	static RefManager *Manager()                         { static BoolRef m; return &m; }
};

inline Ref BoolAsRef(bool& b) { return Ref(&b, BoolRef::Manager()); }

String     MakePathLower(String path);
String     GetFileOnSystemPath(const char *file);


String     InstallServiceCmd(String service_name, String app_name, String arguments);
#line 146 "u:\\uppsrc\\tcore\\util.h"

class CallbackValueGen : public ValueGen
{
public:
	CallbackValueGen() {}
	CallbackValueGen(Callback1<Value&> cb) : cb(cb) {}

	CallbackValueGen& operator = (Callback1<Value&> _cb) { cb = _cb; return *this; }

	virtual Value Get() { Value v; cb(v); return v; }

	Callback1<Value&> cb;
};

VectorMap<String, String> LoadKeyMap(const char *p);
VectorMap<String, String> LoadKeyMapFile(const char *filename);

const char               *FetchCmdArg(const char *arg, int& i);

inline void GetIL(int *ip, int count, const byte *data)
{

	if(sizeof(int) == 4) {
		memcpy(ip, data, count * 4);
		return;
	}
#line 173 "u:\\uppsrc\\tcore\\util.h"
	for(; --count >= 0; data += 4)
		*ip++ = Peek32le(data);
}

inline void PutIL(Stream& strm, const int *ip, int count)
{

	if(sizeof(int) == 4) {
		strm.Put(ip, count * 4);
		return;
	}
#line 185 "u:\\uppsrc\\tcore\\util.h"
	while(--count)
		strm.PutIL(*ip++);
}

inline void PutIL(Stream& strm, const Vector<int>& i)
{
	PutIL(strm, i.Begin(), i.GetCount());
}

inline void PutIF(Stream& strm, float f)
{
	strm.Put(&f, 4);
}

inline void PutIFP(Stream& stream, const Pointf& pt)
{
	PutIF(stream, (float)pt.x);
	PutIF(stream, (float)pt.y);
}

inline void PutIFR(Stream& stream, const Rectf& rc)
{
	PutIF(stream, (float)rc.left);
	PutIF(stream, (float)rc.top);
	PutIF(stream, (float)rc.right);
	PutIF(stream, (float)rc.bottom);
}

inline void PutID(Stream& strm, double d)
{
	strm.Put(&d, 8);
}

inline void PutIDP(Stream& stream, const Pointf& pt)
{
	PutID(stream, pt.x);
	PutID(stream, pt.y);
}

inline void PutIDR(Stream& stream, const Rectf& rc)
{
	PutID(stream, rc.left);
	PutID(stream, rc.top);
	PutID(stream, rc.right);
	PutID(stream, rc.bottom);
}

inline float PeekIF(const byte *p)
{
	return *(const float *)p;
}

inline Pointf PeekIFP(const byte *p)
{
	return Pointf(PeekIF(p), PeekIF(p + 4));
}

inline Rectf PeekIFR(const byte *p)
{
	return Rectf(PeekIF(p), PeekIF(p + 4), PeekIF(p + 8), PeekIF(p + 12));
}

inline double PeekID(const byte *p)
{
	return *(const double *)p;
}

inline Pointf PeekIDP(const byte *p)
{
	return Pointf(PeekID(p), PeekID(p + 8));
}

inline Rectf PeekIDR(const byte *p)
{
	return Rectf(PeekID(p), PeekID(p + 8), PeekID(p + 16), PeekID(p + 24));
}

String AppendPath(String s, String new_path);
String AppendPathList(String s, String path_list);

inline unsigned CalcGray(byte r, byte g, byte b) { return b * 26 + g * 153 + r * 77; }
inline unsigned CalcGray(const byte *p)          { return p[0] * 26 + p[1] * 153 + p[2] * 77; }
inline unsigned CalcGray(Color c)                { return c.GetB() * 26 + c.GetG() * 153 + c.GetR() * 77; }

};
#line 11 "u:/uppsrc\\TCore/TCore.h"
#line 1 "u:\\uppsrc\\tcore\\setop.h"
namespace Upp {

enum SetOpCode
{
	SET_OP2_NOP,
	SET_OP2_LEFT,
	SET_OP2_RIGHT,
	SET_OP2_LADD,
	SET_OP2_RADD,
	SET_OP2_AND,
	SET_OP2_LSUB,
	SET_OP2_RSUB,
	SET_OP2_XOR,
};

template <> inline unsigned Upp::GetHashValue(const SetOpCode& c) { return c; }

inline void AssertMoveable0(SetOpCode *) {};

template<class V, class I>
Index<V> SetGetIndex(I begin, I end)
{
	Index<V> result;
	while(begin != end)
		result.FindAdd(*begin++);
	return result;
}

template <class C, class I>
C SetLAdd(I begin1, I end1, I begin2, I end2)
{
	typedef typename C::ValueType V;
	C result;
	if(begin1 == end1)
		Append(result, begin2, end2);
	else
	{
		Append(result, begin1, end1);
		if(begin2 != end2)
		{
			Index<V> hash = SetGetIndex<V>(begin1, end1);
			for(; begin2 != end2; begin2++)
				if(hash.Find(*begin2) < 0)
					result.Add(*begin2);
		}
	}
	return result;
}

template <class C, class I>
C SetRAdd(I begin1, I end1, I begin2, I end2)
{
	typedef typename C::ValueType V;
	C result;
	if(begin2 == end2)
		Append(result, begin1, end1);
	else
	{
		if(begin1 != end1)
		{
			Index<V> hash = SetGetIndex<V>(begin2, end2);
			while(begin1 != end1)
			{
				if(hash.Find(*begin1) < 0)
					result.Add(*begin1);
				begin1++;
			}
		}
		Append(result, begin2, end2);
	}
	return result;
}

template <class C, class I>
C SetAnd(I begin1, I end1, I begin2, I end2)
{
	typedef typename C::ValueType V;
	C result;
	int count1 = end1 - begin1;
	int count2 = end2 - begin2;
	if(count1 == 0 || count2 == 0)
		return result;
	if(count1 > count2)
	{
		Index<V> hash = SetGetIndex<V>(begin2, end2);
		while(begin1 != end1)
		{
			if(hash.Find(*begin1) >= 0)
				result.Add(*begin1);
			begin1++;
		}
	}
	else
	{
		Index<V> hash = SetGetIndex<V>(begin1, end1);
		while(begin2 != end2)
		{
			if(hash.Find(*begin2) >= 0)
				result.Add(*begin2);
			begin2++;
		}
	}
	return result;
}

template <class C, class I>
C SetSub(I begin1, I end1, I begin2, I end2)
{
	typedef typename C::ValueType V;
	C result;
	if(begin1 == end1)
		;
	else if(begin2 == end2)
		Append(result, begin1, end1);
	else
	{
		Index<V> hash = SetGetIndex<V>(begin2, end2);
		while(begin1 != end1)
		{
			if(hash.Find(*begin1) < 0)
				result.Add(*begin1);
			begin1++;
		}
	}
	return result;
}

template <class C, class I>
C SetXor(I begin1, I end1, I begin2, I end2)
{
	typedef typename C::ValueType V;
	C result;
	if(begin1 == end1)
		Append(result, begin2, end2);
	else if(begin2 == end2)
		Append(result, begin1, end1);
	else
	{
		Index<V> hash = SetGetIndex<V>(begin2, end2);
		for(I temp = begin1; temp != end1; temp++)
			if(hash.Find(*temp) < 0)
				result.Add(*temp);
		hash = SetGetIndex<V>(begin1, end1);
		while(begin2 != end2)
		{
			if(hash.Find(*begin2) < 0)
				result.Add(*begin2);
			begin2++;
		}
	}
	return result;
}

template <class C, class I>
C SetOperation(I begin1, I end1, I begin2, I end2, SetOpCode op)
{
	C result;
	switch(op)
	{
	default: ;
	case SET_OP2_NOP:    break;
	case SET_OP2_LEFT:   Append(result, begin1, end1); break;
	case SET_OP2_RIGHT:  Append(result, begin2, end2); break;
	case SET_OP2_LADD:   return SetLAdd<C>(begin1, end1, begin2, end2);
	case SET_OP2_RADD:   return SetRAdd<C>(begin1, end1, begin2, end2);
	case SET_OP2_AND:    return SetAnd<C>(begin1, end1, begin2, end2);
	case SET_OP2_LSUB:   return SetSub<C>(begin1, end1, begin2, end2);
	case SET_OP2_RSUB:   return SetSub<C>(begin2, end2, begin1, end1);
	case SET_OP2_XOR:    return SetXor<C>(begin1, end1, begin2, end2);
	}
	return result;
}

template <class T>
T SetOperation(const T& set1, const T& set2, SetOpCode op)
{
	return SetOperation<T>(set1.Begin(), set1.End(), set2.Begin(), set2.End(), op);
}

template <class T> T SetLAdd(const T& set1, const T& set2) { return SetLAdd<T>(set1.Begin(), set1.End(), set2.Begin(), set2.End()); }
template <class T> T SetRAdd(const T& set1, const T& set2) { return SetRAdd<T>(set1.Begin(), set1.End(), set2.Begin(), set2.End()); }
template <class T> T SetAnd (const T& set1, const T& set2) { return SetAnd<T>(set1.Begin(), set1.End(), set2.Begin(), set2.End());  }
template <class T> T SetSub (const T& set1, const T& set2) { return SetSub<T>(set1.Begin(), set1.End(), set2.Begin(), set2.End()); }
template <class T> T SetXor (const T& set1, const T& set2) { return SetXor<T>(set1.Begin(), set1.End(), set2.Begin(), set2.End());  }

};
#line 12 "u:/uppsrc\\TCore/TCore.h"

#line 1 "u:\\uppsrc\\tcore\\globcfg.h"
namespace Upp {

class Configuration;
class ConfigItem;

class ConfigHeading
{
public:
	ConfigHeading();
	ConfigHeading(const char *key, int version, int minor, int major);

	void   Serialize(Stream& stream);
	bool   Matches(const ConfigHeading& heading) const;

public:
	String key;
	int    version;
	int    minor;
	int    major;
};

class ConfigItem : protected ConfigHeading
{
	friend class Configuration;
	friend class ConfigStream;

public:
	ConfigItem();
	ConfigItem(const char *key, int version, int minor, int major,
		Configuration* cfg = 0);

	bool   operator = (const ConfigItem& item);

	void   Prepare(bool storing);
	void   Clear();

	void   Serialize(Stream& stream);

	int    GetVersion() const { return current_version; }

	bool   operator <  (int version) const { return current_version <  version; }
	bool   operator <= (int version) const { return current_version <= version; }
	bool   operator == (int version) const { return current_version == version; }
	bool   operator != (int version) const { return current_version != version; }
	bool   operator >= (int version) const { return current_version >= version; }
	bool   operator >  (int version) const { return current_version >  version; }

protected:
	int    save_version;
	int    current_version;
	String data;
};





class ConfigStream : public StringStream
{
public:
	ConfigStream(ConfigItem& item, bool storing);
	~ConfigStream();

protected:
	ConfigItem& item;
};

template <class T>
bool ConfigureItem(T& object, ConfigItem& item, bool storing)
{
	ConfigStream stream(item, storing);
	if(stream.IsLoading() && stream.IsEof())
	 	return true;
	stream % object;
	return !stream.IsError();
}

template <class T>
inline bool ReadConfigItem(T& object, ConfigItem& item)
{ return ConfigureItem(object, item, false); }

template <class T>
inline bool WriteConfigItem(const T& object, ConfigItem& item)
{ return ConfigureItem(const_cast<T&>(object), item, true); }




class Configuration : protected ConfigHeading
{
public:
	Configuration(const char *key, int version, int minor, int major);

	void                  Add(ConfigItem& item);
	void                  Serialize(Stream& stream);

	static Configuration& Main();

	bool                  IsItemError() const { return item_error; }

protected:
	VectorMap<String, ConfigItem*> items;
	bool                  item_error;
};

};
#line 14 "u:/uppsrc\\TCore/TCore.h"
#line 1 "u:\\uppsrc\\tcore\\xmlparse.h"



namespace Upp {

inline bool CheckXml(const char *s) { return *s == '<' && s[1] == '?' && s[2] == 'x' && s[3] == 'm' && s[4] == 'l'; }

struct XMLTag : DeepCopyOption<XMLTag> {
	XMLTag() {}
	XMLTag(const XMLTag& tag, int deep)
	: name(tag.name), attrib(tag.attrib, deep) {}

	String ToString() const;

	int     Find(String name) const         { return attrib.Find(name); }
	WString operator [] (int i) const       { return attrib[i]; }

	WString Attrib(String name) const       { return attrib.Get(name, Null); }
	int     AttribInt(String name) const    { return ScanInt(attrib.Get(name, Null)); }
	double  AttribDouble(String name) const { return ScanDouble(attrib.Get(name, Null)); }

	String name;
	VectorMap<String, WString> attrib;
};

struct XMLTagTree : XMLTag, DeepCopyOption<XMLTagTree> {
	XMLTagTree() {}
	XMLTagTree(const XMLTagTree& tree, int deep)
	: XMLTag(tree, deep), text(tree.text), subtags(tree.subtags, deep) {}

	String             ToString() const;
	const XMLTagTree&  Tag(String name) const;
	int                Find(String name) const      { return subtags.Find(name); }
	int                FindNext(int i) const        { return subtags.FindNext(i); }
	const XMLTagTree&  operator [] (int i) const    { return subtags[i]; }

	WString text;
	ArrayMap<String, XMLTagTree> subtags;

private:
	void Format(String& output, int indent) const;
};

class XMLParser {
public:
	XMLParser() {}
	XMLParser(Stream& stream, int line = 1) { Open(stream, line); }
	XMLParser(String string, int line = 1)  { Open(string, line); }

	void          Open(Stream& stream, int line = 1);
	void          Open(String string, int line = 1);
	void          Close();

	XMLTagTree    Read();

	enum ENTITY { FIRST = -1, ISEOF, TAG, ENDTAG, TEXT };
	ENTITY        Entity() const            { return current_entity; }
	bool          IsEof() const             { return current_entity == ISEOF; }
	bool          IsTag() const             { return current_entity == TAG; }
	bool          IsEndTag() const          { return current_entity == ENDTAG; }
	bool          IsText() const            { return current_entity == TEXT; }
	ENTITY        Next();
	bool          InLevel(int count);
	bool          NextLevel(int count);
	void          SkipLevel(int count);

	const XMLTag& Tag() const               { return tag_stack.Top(); }
	int           GetCount() const          { return tag_stack.GetCount(); }
	const XMLTag& operator [] (int i) const { return tag_stack[i]; }

	WString       Text() const              { return current_text; }
	int           GetLine() const           { return line_number; }

	void          SelfTest();

private:
	String        GetCharRef();
	bool          FetchLine();
	bool          SkipWhite();
	void          InitOpen(Stream& strm, int line);
	void          Read(XMLTagTree& tree);

private:
	Stream       *input;
	One<Stream>   stringinput;
	String        line_data;
	const char   *line_ptr;
	int           line_number;
	Array<XMLTag> tag_stack;
	Vector<bool>  space_stack;
	ENTITY        current_entity;
	WString       current_text;
	byte          charset;
	bool          loner_tag;
	bool          honor_spaces;
};

XMLTagTree XMLReadTagTree(Stream& stream, int line = 1);
XMLTagTree XMLReadTagTree(String string, int line = 1);

String        ToXml(const char *s, byte charset = 0);

class XmlsTag;

class Xmls : public String, Moveable<Xmls> {
public:
	Xmls(const char *s) : String(s) {}
	Xmls(const String& s) : String(s) {}
	Xmls(const Nuller& = Null) {}

	bool  IsNullInstance() const     { return IsEmpty(); }

	Xmls& Cat()                      { return *this; }

	Xmls& Text(const char *s)        { String::Cat(ToXml(s)); return *this; }
	Xmls& Quote(const char *text)    { Cat('\"'); Cat(ToXml(text)); Cat('\"'); return *this; }

	Xmls& Attr(const char *attr);
	Xmls& Attr(const char *attr, const char *s);
	Xmls& Attr(const char *attr, String s);
	Xmls& Attr(const char *attr, int i);
	Xmls& Attr(const char *attr, double d);
	Xmls& Attr(const char *attr, Date date);
	Xmls& Attr(const char *attr, Value v);

	Xmls& Cat(const XmlsTag& tag);
	Xmls& Cat(String s)              { String::Cat(s); return *this; }
	Xmls& Cat(const char *s)         { String::Cat(s); return *this; }
	Xmls& Cat(char c)                { String::Cat(c); return *this; }
	Xmls& Cat(const char *s, int n)  { String::Cat(s, n); return *this; }
};

class XmlsTag : Moveable<XmlsTag> {
public:
	XmlsTag(const char *s);
	XmlsTag() {}

	XmlsTag&       Text(const char *s)                        { tag.Text(s); return *this; }
	XmlsTag&       Quote(const char *s)                       { tag.Quote(s); return *this; }

	XmlsTag&       Attr(const char *attr)                     { tag.Attr(attr); return *this; }
	XmlsTag&       Attr(const char *attr, const char *v)      { tag.Attr(attr, v); return *this; }
	XmlsTag&       Attr(const char *attr, String v)           { tag.Attr(attr, v); return *this; }
	XmlsTag&       Attr(const char *attr, int v)              { tag.Attr(attr, v); return *this; }
	XmlsTag&       Attr(const char *attr, double v)           { tag.Attr(attr, v); return *this; }
	XmlsTag&       Attr(const char *attr, Date v)             { tag.Attr(attr, v); return *this; }
	XmlsTag&       Attr(const char *attr, Value v)            { tag.Attr(attr, v); return *this; }

	void          Combine(const XmlsTag& tag, bool linebreak);

	Xmls          ApplyTo(const char *s, bool lf = false) const;
	Xmls          ApplyTo(String s, bool lf = false) const   { return ApplyTo(~s, lf); }

	XmlsTag        operator()() const                         { return *this; }
	Xmls          operator~() const                          { return ApplyTo(""); }
	operator      Xmls() const                               { return ApplyTo(""); }
	String        ToString() const                           { return ApplyTo(""); }

	const Xmls&   Tag() const                                { return tag; }
	Xmls&         Tag()                                      { return tag; }

	const String& End() const                                { return end; }
	String&       End()                                      { return end; }

	bool          IsEmpty() const                            { return tag.IsEmpty(); }

protected:
	Xmls          tag;
	String        end;
};

Xmls           Xml10(const char *encoding);
inline Xmls    Xml10(byte charset = 0)                 { return Xml10(MIMECharsetName(charset)); }
Xmls           XmlsComment(const char *text);

inline Xmls&   operator << (Xmls& s, const XmlsTag& tag)             { return s.Cat(tag); }
inline Xmls&   operator << (Xmls& s, const Xmls& v)                  { return s.Cat(v); }
inline Xmls&   operator << (Xmls& s, String v)                       { return s.Cat(v); }
inline Xmls&   operator << (Xmls& s, const char *v)                  { return s.Cat(v); }

inline Xmls    operator + (const XmlsTag& tag1, const XmlsTag& tag2) { Xmls r(tag1); r << tag2; return r; }
inline Xmls    operator + (const String& s, const XmlsTag& tag)      { Xmls r(s); r << tag; return r; }
inline Xmls    operator + (const XmlsTag& tag, const String& s)      { Xmls r(tag); r << s; return r; }
inline Xmls    operator + (const char *s, const XmlsTag& tag)        { Xmls r(s); r << tag; return r; }
inline Xmls    operator + (const XmlsTag& tag, const char *s)        { Xmls r(tag); r << s; return r; }

inline XmlsTag  operator /  (const XmlsTag& t1, const XmlsTag& t2)   { XmlsTag r(t1); r.Combine(t2, false); return r; }
inline XmlsTag& operator /= (XmlsTag& tag, const XmlsTag& s)         { tag.Combine(s, false); return tag; }

inline Xmls    operator / (const XmlsTag& tag, String s)             { return tag.ApplyTo(s, false); }
inline Xmls    operator / (const XmlsTag& tag, const char *s)        { return tag.ApplyTo(s, false); }

inline XmlsTag  operator %  (const XmlsTag& t1, const XmlsTag& t2)   { XmlsTag r(t1); r.Combine(t2, true); return r; }
inline XmlsTag& operator %= (XmlsTag& tag, const XmlsTag& s)         { tag.Combine(s, true); return tag; }

inline Xmls    operator % (const XmlsTag& tag, String s)             { return tag.ApplyTo(s, true); }
inline Xmls    operator % (const XmlsTag& tag, const char *s)        { return tag.ApplyTo(s, true); }

};

#line 202 "u:\\uppsrc\\tcore\\xmlparse.h"
#line 15 "u:/uppsrc\\TCore/TCore.h"
#line 1 "u:\\uppsrc\\tcore\\help.h"
namespace Upp {

class HelpInit
{
public:
	HelpInit(void (*fn)());
	static void Run();
};






String               GetLangIdent(int language);
byte                 GetLangStdCharset(int language);

class HelpTopicInfoDeep
{
public:
	HelpTopicInfoDeep() : added(false), recursed(false) {}

	String             decl_module;
	String             text_folder;

	Callback1<String&> titlefunc;
	Callback1<String&> textfunc;

	bool               added;
	mutable bool       recursed;
};

class HelpTopicInfo : public HelpTopicInfoDeep, MoveableAndDeepCopyOption<HelpTopicInfo>
{
public:
	HelpTopicInfo() {}
	HelpTopicInfo(const HelpTopicInfo& h, int deep)
		: HelpTopicInfoDeep(h), language(h.language, deep)
		, title(h.title, deep), text(h.text, deep), module(h.module, deep) {}

	void               Set(int language, String title, String text, String text_module = Null);
	String             GetTitle(int language) const;
	String             GetText(int language) const;
	String             GetTitle() const;
	String             GetText() const;
	String             GetDefaultTitle() const;
	String             GetDefaultText() const;

	Index<int>         language;
	Vector<String>     title;
	Vector<String>     text;
	Vector<String>     module;
};

bool        operator == (const HelpTopicInfo& a, const HelpTopicInfo& b);
inline bool operator != (const HelpTopicInfo& a, const HelpTopicInfo& b) { return !(a == b); }

typedef ArrayMap<String, HelpTopicInfo> HelpTopicInfoMap;

HelpTopicInfoMap&    HelpTopicMap();
void                 HelpTopicAdd(const char *drl, const char *decl_module, Callback1<String&> titlefunc, Callback1<String&> textfunc);
Vector<String>       HelpTopicEnumSpace();
Vector<String>       HelpTopicEnumNesting(String space = Null);
Vector<String>       HelpTopicEnumDeclModules();
String               HelpTopicTextModule(String decl_module, String drl, int language);
Vector<String>       HelpTopicEnumTextFolders();
int                  HelpTopicGetFolderDirty(String text_folder, const HelpTopicInfoMap& diff);
Vector<int>          HelpTopicEnumLang();
Vector<String>       HelpTopicList(String space = Null, String nesting = Null);
Vector<String>       HelpTopicListTextFolder(String text_folder);
String               HelpTopicSave(Vector<String>& saved_files, String text_folder, HelpTopicInfoMap& diff, String out_folder, bool skip_file_write = false);
void                 HelpTopicLoad(String text_module, String data, Index<String> *topics_loaded = 0);
void                 HelpTopicSet(const char *drl, const char *text_module, int language, const char *title, String text);
void                 HelpTopicSet(const char *space, const char *nesting, const char *topic, const char *text_module, int language, const char *title, String text);
void                 HelpTopicSet(const char *space, const char *nesting, const char *topic, const char *text_module, const char *language, const char *title, String text);
const HelpTopicInfo& HelpTopicGet(String drl);
int                  HelpTopicGetSeq();
void                 HelpTopicTouchSeq();
String               HelpTopicHostDir();
void                 HelpTopicSetHostDir(const char *dir);

String               HelpFormatDPP(const char *space, const char *nesting, const char *topic);
bool                 HelpParseDPP(const char *path, String& space, String& nesting, String& topic);

inline String        HelpAppDPP(const char *topic)    { return HelpFormatDPP("AppDoc", "", topic); }
inline String        HelpHostDPP(const char *topic)   { return HelpFormatDPP("AppDoc", "host", topic); }

typedef void (*HelpAutoIndexProc)(Index<WString>& entries, Vector<String>& drls);

Vector<HelpAutoIndexProc>&       HelpAutoIndexMap();
void                             RegisterHelpAutoIndex(HelpAutoIndexProc haip);















































};
#line 16 "u:/uppsrc\\TCore/TCore.h"

#line 18 "u:/uppsrc\\TCore/TCore.h"
#line 53 "u:/idisapp\\IdisMisc/IdisMisc.h"
#line 1 "u:/uppsrc\\tsql/tsql.h"



#line 1 "u:/uppsrc\\Sql/Sql.h"























#line 5 "u:/uppsrc\\tsql/tsql.h"
#line 1 "u:/uppsrc\\TCore/TCore.h"

















#line 6 "u:/uppsrc\\tsql/tsql.h"








#line 1 "u:\\uppsrc\\tsql\\util.h"
namespace Upp {

void __sqltempl__instantiation__(Gate2<int, int>);





const SqlId& ALL();
const SqlId& QUE();

class SqlBlock
{
public:

	SqlBlock(SqlSession& session = AppCursor().GetSession())
		: session(session), done(false) { session.Begin(); }



#line 22 "u:\\uppsrc\\tsql\\util.h"
	~SqlBlock()                              { if(!done) session.Rollback(); }

	void        Commit()                     { ; done = true; session.Commit(); }
	void        Rollback()                   { ; done = true; session.Rollback(); }
	void        Flush()                      { ; session.Commit(); session.Begin(); }

private:
	SqlSession& session;
	bool        done;
};

void                  SetSchema(const String& schema);
String                GetSchema();
String                SchemaTableName(const String& table);
SqlVal                SchemaTable(const SqlVal& table);

String                GetInsertString(Fields nf, bool optimize = true);
String                GetSchemaInsertString(Fields nf, bool optimize = true);
void                  InsertScript(SqlSchema& schema, Fields nf, bool optimize = true);
void                  InsertSchemaScript(SqlSchema& schema, Fields nf, bool optimize = true);

SqlSelect             SelectTable(Fields nf);
SqlSelect             SelectSchemaTable(Fields nf);
SqlSelect             SelectColumns(Fields nf);

Value                 GetValue(Fields nf, SqlId field);
Ref                   GetRef(Fields nf, SqlId field);
String                GetTableName(Fields nf);

VectorMap<Id, Ref>    GetRefMap(Fields nf, String *tablename = 0);
VectorMap<Id, Value>  GetValueMap(Fields nf, String *tablename = 0);

String                ForceInsertRowid(const SqlInsert& insert, Sql& cursor = AppCursor());
String                ForceInsertRowid(Fields nf, Sql& cursor = AppCursor());
String                ForceInsertRowid(SqlId table, Fields nf, Sql& cursor = AppCursor());
String                ForceSchemaInsertRowid(Fields nf, Sql& cursor = AppCursor());
String                ForceSchemaInsertRowid(SqlId table, Fields nf, Sql& cursor = AppCursor());

void                  ForceInsert(Fields nf, Sql& cursor = AppCursor());
void                  ForceInsert(SqlId table, Fields nf, Sql& cursor = AppCursor());
void                  ForceUpdate(Fields nf, SqlId key, const Value& keyval, Sql& cursor = AppCursor());
void                  ForceUpdate(SqlId table, Fields nf, SqlId key, const Value& keyval, Sql& cursor = AppCursor());
void                  ForceDelete(SqlId table, SqlId key, const Value& keyval, Sql& cursor = AppCursor());
void                  ForceExecute(const String& s, Sql& cursor = AppCursor());
void                  ForceSchemaInsert(Fields nf, Sql& cursor = AppCursor());
void                  ForceSchemaInsert(SqlId table, Fields nf, Sql& cursor = AppCursor());
void                  ForceSchemaUpdate(Fields nf, SqlId key, const Value& keyval, Sql& cursor = AppCursor());
void                  ForceSchemaUpdate(SqlId table, Fields nf, SqlId key, const Value& keyval, Sql& cursor = AppCursor());
void                  ForceSchemaDelete(SqlId table, SqlId key, const Value& keyval, Sql& cursor = AppCursor());

bool                  IsNotEmpty(const SqlSelect& select, Sql& cursor = AppCursor());
bool                  IsNotEmpty(const SqlVal& table, const SqlBool& cond, Sql& cursor = AppCursor());
bool                  IsNotEmpty(const SqlVal& table, SqlId column, const Value& value, Sql& cursor = AppCursor());
bool                  IsNotSchemaEmpty(const SqlVal& table, const SqlBool& cond, Sql& cursor = AppCursor());
bool                  IsNotSchemaEmpty(const SqlVal& table, SqlId column, const Value& value, Sql& cursor = AppCursor());










#line 88 "u:\\uppsrc\\tsql\\util.h"

SqlVal                Alias(const SqlVal& value, const SqlVal& alias);
SqlVal                SchemaAlias(const SqlVal& table, const SqlVal& alias);
SqlVal                SchemaAlias(const SqlVal& table);

inline SqlInsert      InsertSchema(SqlId table) { return SqlInsert(SqlId(SchemaTableName(~table))); }
inline SqlUpdate      UpdateSchema(SqlId table) { return SqlUpdate(SqlId(SchemaTableName(~table))); }
inline SqlDelete      DeleteSchema(SqlId table) { return Delete(SqlId(SchemaTableName(~table))); }







SqlSet                DeleteHint(const char *hint, const SqlVal& table);
SqlSet                DeleteSchemaHint(const char *hint, const SqlVal& table);

VectorMap<String, SqlColumnInfo> Describe(const SqlVal& table, Sql& cursor = AppCursor());
VectorMap<String, SqlColumnInfo> DescribeSchema(const SqlVal& table, Sql& cursor = AppCursor());

int64                 SelectCount(const SqlVal& table, const SqlBool& cond, Sql& cursor);
int64                 SelectSchemaCount(const SqlVal& table, const SqlBool& cond, Sql& cursor);


inline int64          SelectCount(const SqlVal& table, const SqlBool& cond = SqlBool::True())       { return SelectCount(table, cond, AppCursor()); }
inline int64          SelectSchemaCount(const SqlVal& table, const SqlBool& cond = SqlBool::True()) { return SelectSchemaCount(table, cond, AppCursor()); }
#line 116 "u:\\uppsrc\\tsql\\util.h"

Vector<String>        LoadStrColumn(SqlId column, const SqlVal& table, SqlSession& session = AppCursor().GetSession(), bool order = false);
Vector<String>&       SyncStrColumn(Vector<String>& dest, SqlId col, const SqlVal& table, SqlSession& session = AppCursor().GetSession(), bool order = false);
Vector<String>        LoadSchemaStrColumn(SqlId column, const SqlVal& table, SqlSession& session = AppCursor().GetSession(), bool order = false);
Vector<String>&       SyncSchemaStrColumn(Vector<String>& dest, SqlId col, const SqlVal& table, SqlSession& session = AppCursor().GetSession());

SqlVal                GetCsVal(const SqlVal& val);
SqlVal                GetCs(const char *col);
SqlVal                GetCsAsciiVal(const SqlVal& val);
SqlVal                GetCsAscii(const char *col);
SqlBool               LikeSmartWild(const SqlVal& exp, const String& s);

SqlBool               GetTextRange(const String& s1, const String& s2, const SqlVal& exp);
SqlBool               GetNumRange(double min, double max, const SqlVal& exp);
SqlBool               GetDateRange(Date d1, Date d2, const SqlVal& exp, bool force_range = false);
SqlBool               GetTimeRange(Time d1, Time d2, const SqlVal& exp, bool force_range = false);

String                GetYearDayIndex(Date date);
SqlVal                GetYearDayIndex(const SqlVal& date);
SqlBool               GetYearDayRange(const SqlVal& date, Date min, Date max);

};
#line 15 "u:/uppsrc\\tsql/tsql.h"
#line 1 "u:\\uppsrc\\tsql\\template.h"



namespace Upp {

void __sqltempl__instantiation__(Gate2<int, int>);

template <class C>
C& FetchContainer(C& container, Sql& cursor, Gate2<int, int> progress = false)
{
	int done = 0;
	typedef typename C::ValueType VT;
	VT T;
	while(cursor.Fetch(T))
	{
		container.Add(T);
		if(progress(++done, 0))
			throw AbortExc();
	}
	return container;
}

template <class C>
C& FetchContainerExc(C& container, const SqlSelect& set, SqlSession& session = AppCursor().GetSession(), Gate2<int, int> progress = false)
{
	Sql cursor(session);
	set.Force(cursor);
	return FetchContainer(container, cursor, progress);
}

template <class C>
C& FetchContainer(C& container, const SqlSelect& set, SqlSession& session, Gate2<int, int> progress = false)
{
	try
	{
		FetchContainerExc(container, set, session, progress);
	}
	catch(Exc e)
	{

	}
	return container;
}


template <class C>
C& FetchContainer(C& container, const SqlSelect& set, Gate2<int, int> progress = false)
{
	return FetchContainer(container, set, AppCursor().GetSession(), progress);
}
#line 52 "u:\\uppsrc\\tsql\\template.h"

template <class I>
SqlSet SetOf(I begin, I end)
{
	SqlSet set;
	while(begin != end)
	{
		set |= SqlVal(*begin);
		++begin;
	}
	return set;
}

template <class I>
SqlSet ColumnSetOf(I begin, I end)
{
	SqlSet set;
	while(begin != end)
	{
		set |= SqlCol(*begin);
		++begin;
	}
	return set;
}

template <class C>
inline SqlSet SetOf(const C& container)
{
	return SetOf(container.Begin(), container.End());
}

template <class C>
inline SqlSet ColumnSetOf(const C& container)
{
	return ColumnSetOf(container.Begin(), container.End());
}

extern const char *txtFnTSqlTemplateFetchSeqKeyNull();
extern const char *txtFnTSqlTemplateFetchSeqNotFound();

template <class T>
T& FetchSeq(T& data, SqlId key, Value value, SqlId table, Sql& cursor = AppCursor())
{
	if(IsNull(value))
		throw SqlExc(NFormat(txtFnTSqlTemplateFetchSeqKeyNull(), ~table, ~key));
	Select(data).From(table).Where(key == value).Force(cursor);
	if(!cursor.Fetch(data))
		throw SqlExc(NFormat(txtFnTSqlTemplateFetchSeqNotFound(), StdFormat(value), ~table, ~key));
	return data;
}

template <class T>
inline T& FetchSeq(T& data, SqlId key, Value value, Sql& cursor = AppCursor())
{
	return FetchSeq<T>(data, key, value, SqlId(T::TableName), cursor);
}

template <class T>
inline T FetchSeq(SqlId key, Value value, SqlId table, Sql& cursor = AppCursor(), T * = 0)
{
	T temp;
	return FetchSeq(temp, key, value, table, cursor);
}

template <class T>
inline T FetchSeq(SqlId key, Value value, Sql& cursor = AppCursor(), T * = 0)
{
	return FetchSeq<T>(key, value, SqlId(T::TableName), cursor);
}

template <class T>
T& FetchSchemaSeq(T& data, SqlId key, Value value, SqlId table, Sql& cursor = AppCursor())
{
	if(IsNull(value))
		throw SqlExc(NFormat(txtFnTSqlTemplateFetchSeqKeyNull(), ~table, ~key));
	Select(data).From(SchemaAlias((table))).Where(key == value).Force(cursor);
	if(!cursor.Fetch(data))
		throw SqlExc(NFormat(txtFnTSqlTemplateFetchSeqNotFound(), StdFormat(value), ~table));
	return data;
}

template <class T>
inline T& FetchSchemaSeq(T& data, SqlId key, Value value, Sql& cursor = AppCursor())
{
	return FetchSchemaSeq<T>(data, key, value, SqlId(T::TableName), cursor);
}

template <class T>
inline T FetchSchemaSeq(SqlId key, Value value, SqlId table, Sql& cursor = AppCursor(), T * = 0)
{
	T temp;
	return FetchSchemaSeq(temp, key, value, table, cursor);
}

template <class T>
inline T FetchSchemaSeq(SqlId key, Value value, Sql& cursor = AppCursor(), T * = 0)
{
	return FetchSeq<T>(key, value, SqlId(T::TableName), cursor);
}

template <class T>
SqlSelect SelectWhere(SqlBool cond = true, T * = 0)
{
	return Select(T::ColumnSet()).From(SqlCol(T::TableName)).Where(cond);
}

template <class T>
SqlSelect SelectSchemaWhere(SqlBool cond = true, T * = 0)
{
	return Select(T::ColumnSet()).From(SchemaAlias((SqlCol(T::TableName)))).Where(cond);
}

};
#line 16 "u:/uppsrc\\tsql/tsql.h"
#line 1 "u:\\uppsrc\\tsql\\dict.h"











namespace Upp {

enum
{
	SEL = 0x01,
	UPD = 0x02,
	INS = 0x04,
	DEL = 0x08,
};


int         SqlUserGetRightsTo(const char* table);
bool        SqlUserCanWrite(const char* table);
bool        SqlUserCanRead(const char* table);

inline int  SqlUserGetRightsTo(const String& s) { return SqlUserGetRightsTo(~s); }
inline bool SqlUserCanWrite(const String& s)    { return SqlUserCanWrite(~s); }
inline bool SqlUserCanRead(const String& s)     { return SqlUserCanRead(~s); }

inline int  SqlUserGetRightsTo(Id id)           { return SqlUserGetRightsTo(~id); }
inline bool SqlUserCanWrite(Id id)              { return SqlUserCanWrite(~id); }
inline bool SqlUserCanRead(Id id)               { return SqlUserCanRead(~id); }
#line 35 "u:\\uppsrc\\tsql\\dict.h"



struct SqlAnyTable : Moveable<SqlAnyTable>
{
	String       owner;
	String       table;

	SqlAnyTable();
	SqlAnyTable(const char* owner, const char* table);

	SqlAnyTable(const char* table, SqlSession& session = AppCursor().GetSession());


#line 50 "u:\\uppsrc\\tsql\\dict.h"

	bool operator == (const SqlAnyTable& t) const;
	bool operator != (const SqlAnyTable& t) const { return !(*this == t); }

	String       Dot() const;
};



struct SqlAnyColumn : public SqlAnyTable, Moveable<SqlAnyColumn>
{
	String column;

	SqlAnyColumn();

	SqlAnyColumn(const char* column, const char* table_name, SqlSession& session = AppCursor().GetSession());


#line 69 "u:\\uppsrc\\tsql\\dict.h"
	SqlAnyColumn(const char* column, const char* owner, const char* table);
	SqlAnyColumn(const char* column, const SqlAnyTable& table);

	bool operator == (const SqlAnyColumn& c) const;
	bool operator != (const SqlAnyColumn& c) const { return !(*this == c); }

	String DotColumn() const;

};



class SqlUserRights
{
public:
	SqlUserRights(SqlSession& session) : session(&session) {}

	SqlUserRights() : session(0) {}
#line 88 "u:\\uppsrc\\tsql\\dict.h"





	SqlSession&             GetSession() const { return session ? *session : AppCursor().GetSession(); }


#line 97 "u:\\uppsrc\\tsql\\dict.h"

	void                    Clear();

	void                    Sync();

	bool                    HasRole(const char* role);

	int                     GetRightsTo(const char* table);
	bool                    CanRead(const char* table)  { return GetRightsTo(table) & SEL; }
	bool                    CanWrite(const char* table) { return (~GetRightsTo(table) & (SEL | UPD | INS | DEL)) == 0; }

public:
	SqlSession             *session;
	String                  user;
	Index<String>           roles;
	VectorMap<String, char> rights;
	String                  error;
};




extern SqlUserRights& SqlUser();
#line 121 "u:\\uppsrc\\tsql\\dict.h"




class SqlRelocate
{
public:
	enum OPTIONS
	{
		TRY_ALL   = 0x01,
		NO_CANCEL = 0x02,
	};

	SqlRelocate();

	SqlRelocate(const char *table, const char *column)                      { Find(table, column, AppCursor().GetSession()); }
	SqlRelocate(SqlId table, SqlId column)                                  { Find(table, column, AppCursor().GetSession()); }
#line 139 "u:\\uppsrc\\tsql\\dict.h"
	SqlRelocate(const char *table, const char *column, SqlSession& session) { Find(table, column, session); }
	SqlRelocate(SqlId table, SqlId column, SqlSession& session)             { Find(table, column, session); }
	~SqlRelocate();

	void                 Find(const char *table, const char *column, SqlSession& session);
	void                 Find(SqlId table, SqlId column, SqlSession& session);

	void                 Move(int old_seq, int new_seq, int options = 0, Gate2<int, int> progress = false);
	void                 Move(const Vector<int>& old_seq, const Vector<int>& new_seq, int options = 0, Gate2<int, int> progress = false);

	Vector<SqlAnyColumn> GetReferences(int seq) const;

	bool                 IsEmpty() const     { return reference.IsEmpty(); }
	int                  GetCount() const    { return reference.GetCount(); }

	bool                 IsCanceled() const { return canceled; }
	bool                 IsError() const     { return !IsNull(error); }

	const String&        GetError() const    { return error; }

public:
	Vector<SqlAnyColumn> reference;
	Vector<bool>         result;
	String               error;
	bool                 canceled;
	SqlSession          *session;

protected:
	void                 ClearResult();
};




struct SqlIndex : DeepCopyOption<SqlIndex>
{
	String         owner;
	String         index;
	SqlAnyTable    table;
	Vector<String> columns;
	bool           dropped;
	SqlSession    *session;

	SqlIndex();
	SqlIndex(String index, String owner, SqlSession& session) { Open(index, owner, session); }

	SqlIndex(String index, String owner)                      { Open(index, owner, AppCursor().GetSession()); }
#line 187 "u:\\uppsrc\\tsql\\dict.h"
	SqlIndex(const SqlIndex& another, int);
	~SqlIndex();

	void   Open(String index, String owner, SqlSession& session);

	String Dot() const;

	void   Drop();
	void   Create();
};




class SqlIndexMap
{
public:
	SqlIndexMap();
	~SqlIndexMap();

	void AddPick( SqlIndex& index) { map.Add() = index; }
	void Add(const SqlIndex& index) { map.Add(index); }
	void Add(const char* table, SqlSession& session);

	void Add(const char* table) { Add(table, AppCursor().GetSession()); }
#line 213 "u:\\uppsrc\\tsql\\dict.h"

	void Drop(Gate2<int, int> progress = false);
	void Create(Gate2<int, int> progress = false);

public:
	Array<SqlIndex> map;
};


inline SqlIndexMap& operator << (SqlIndexMap& map, const char* table) { map.Add(table); return map; }
#line 224 "u:\\uppsrc\\tsql\\dict.h"



unsigned GetHashValue(const SqlAnyTable& table);
unsigned GetHashValue(const SqlAnyColumn& column);

};
#line 17 "u:/uppsrc\\tsql/tsql.h"

#line 19 "u:/uppsrc\\tsql/tsql.h"
#line 54 "u:/idisapp\\IdisMisc/IdisMisc.h"
#line 1 "u:/idisapp\\BWC/BWC.h"



#line 1 "u:/uppsrc\\TCtrlLib/TCtrlLib.h"



#line 1 "u:/uppsrc\\CtrlLib/CtrlLib.h"

























































#line 5 "u:/uppsrc\\TCtrlLib/TCtrlLib.h"
#line 1 "u:/uppsrc\\DocTypes/DocTypes.h"












































































































































































































































































































































































































































































































































































































































































































































#line 6 "u:/uppsrc\\TCtrlLib/TCtrlLib.h"
#line 1 "u:/uppsrc\\TDraw/TDraw.h"



#line 1 "u:/uppsrc\\Draw/Draw.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 5 "u:/uppsrc\\TDraw/TDraw.h"
#line 1 "u:/uppsrc\\Geom/Geom.h"



#line 1 "u:/idisapp\\Core/Core.h"






























































































































































































































































































































































































































































































































#line 5 "u:/uppsrc\\Geom/Geom.h"

namespace Upp {

#line 1 "u:\\uppsrc\\geom\\geometry.h"


struct Matrixf;

static const double TWOPI = 2 * 3.14159265358979323846;
static const double DEGRAD = 3.14159265358979323846 / 180.0;









inline Pointf fpmin        (Pointf p, Pointf q)               { return Pointf(min(p.x, q.x), min(p.y, q.y)); }
inline Pointf fpmax        (Pointf p, Pointf q)               { return Pointf(max(p.x, q.x), max(p.y, q.y)); }
inline Pointf fpminmax     (Pointf p, Pointf mn, Pointf mx)   { return Pointf(minmax(p.x, mn.x, mx.x), minmax(p.y, mn.y, mx.y)); }

inline double fpmin        (Pointf p)                         { return min(p.x, p.y); }
inline double fpmax        (Pointf p)                         { return max(p.x, p.y); }
inline double fpabsmin     (Pointf p)                         { return min(fabs(p.x), fabs(p.y)); }
inline double fpabsmax     (Pointf p)                         { return max(fabs(p.x), fabs(p.y)); }













inline Pointf Move         (Pointf p, double dx, double dy)   { return Pointf(p.x + dx, p.y + dy); }
inline Pointf Mid          (Pointf p, Pointf q)               { return Pointf((p.x + q.x) / 2, (p.y + q.y) / 2); }
inline Pointf Mid          (Pointf p, Pointf q, double wt)    { return p + (q - p) * wt; }
inline double Squared      (Pointf p)                         { return p.x * p.x + p.y * p.y; }
inline double Squared      (Pointf p, Pointf q)               { return Squared(q - p); }
inline double Length       (Pointf p)                         { return sqrt(Squared(p)); }
Pointf        Length       (Pointf p, double l);
inline Pointf Unit         (Pointf p)                         { return Length(p, 1); }
inline Pointf Rotated      (Pointf p, double a)               { double s = sin(a), c = cos(a); return Pointf(p.x * c - p.y * s, p.x * s + p.y * c); }
inline Pointf Rotated      (Pointf p, double angle, Pointf c) { return c + Rotated(p - c, angle); }
Pointf        Project      (Pointf p, Pointf a, Pointf b);
Pointf        Bezier2      (Pointf a, Pointf b, Pointf c, double t);
double        Bezier2Length(Pointf a, Pointf b, Pointf c, double t);
Sizef         Bezier2Tangent(Pointf a, Pointf b, Pointf c, double t);
Sizef         Orthogonal   (Sizef  p, Sizef against);
Sizef         Orthonormal  (Sizef  p, Sizef against);
Sizef         FarthestAxis (Sizef  p);
inline Pointf Reversed     (Pointf p)                         { return Pointf(-p.x, -p.y); }
inline Pointf ReversedX    (Pointf p)                         { return Pointf(-p.x, p.y); }
inline Pointf ReversedY    (Pointf p)                         { return Pointf(p.x, -p.y); }

inline Pointf Left         (Pointf p)                         { return Pointf(-p.y, p.x); }
inline Pointf Right        (Pointf p)                         { return Pointf(p.y, -p.x); }

inline double Distance     (Pointf p, Pointf q)               { return Length(p - q); }
double        Bearing      (Pointf p);
inline double Bearing      (Pointf p, Pointf c)               { return Bearing(p - c); }
inline bool   Select       (Pointf p, Pointf A, Pointf B)     { return Squared(p - A) < Squared(p - B); }

inline double operator ^   (Pointf p, Pointf q)               { return p.x * q.x + p.y * q.y; }
inline double operator %   (Pointf p, Pointf q)               { return p.x * q.y - p.y * q.x; }
inline double operator |   (Pointf p, Pointf q)               { return Distance(p, q); }

inline Pointf PolarPointf  (double a)                         { return Pointf(cos(a), sin(a)); }
inline Pointf PolarPointf  (double r, double a)               { return Pointf(r * cos(a), r * sin(a)); }
inline Pointf PolarPointf  (Pointf c, double r, double a)     { return Pointf(c.x + r * cos(a), c.y + r * sin(a)); }

inline Point  PointfToPoint(Pointf p)                         { return Point(fround(p.x), fround(p.y)); }
inline Size   PointfToSize (Pointf p)                         { return Size(fround(p.x), fround(p.y)); }









inline Sizef  fpmin        (Sizef p, Sizef q)                 { return Sizef(min(p.cx, q.cx), min(p.cy, q.cy)); }
inline Sizef  fpmax        (Sizef p, Sizef q)                 { return Sizef(max(p.cx, q.cx), max(p.cy, q.cy)); }
inline Sizef  fpminmax     (Sizef p, Sizef mn, Sizef mx)      { return Sizef(minmax(p.cx, mn.cx, mx.cx), minmax(p.cy, mn.cy, mx.cy)); }

inline double fpmin        (Sizef p)                          { return min(p.cx, p.cy); }
inline double fpmax        (Sizef p)                          { return max(p.cx, p.cy); }
inline double AbsMin       (Sizef p)                          { return min(fabs(p.cx), fabs(p.cy)); }
inline double AbsMax       (Sizef p)                          { return max(fabs(p.cx), fabs(p.cy)); }

inline Sizef  Mid          (Sizef p, Sizef q)                 { return Sizef((p.cx + q.cx) / 2, (p.cy + q.cy) / 2); }

inline double Squared      (Sizef p, Sizef q)                 { return Squared(q - p); }

Sizef         Length       (Sizef p, double l);
inline Sizef  Unit         (Sizef p)                          { return Length(p, 1); }
inline Sizef  Reversed     (Sizef s)                          { return Sizef(-s.cx, -s.cy); }
inline Sizef  ReversedX    (Sizef s)                          { return Sizef(-s.cx, s.cy); }
inline Sizef  ReversedY    (Sizef s)                          { return Sizef(s.cx, -s.cy); }
inline Sizef  Abs          (Sizef s)                          { return Sizef(fabs(s.cx), fabs(s.cy)); }
inline Sizef  Left         (Sizef s)                          { return Sizef(-s.cy, s.cx); }
inline Sizef  Right        (Sizef s)                          { return Sizef(s.cy, -s.cx); }

inline Point  SizefToPoint (Sizef s)                          { return Point(fround(s.cx), fround(s.cy)); }
inline Size   SizefToSize  (Sizef s)                          { return Size(fround(s.cx), fround(s.cy)); }









inline Rectf  operator *   (Rectf r, double f)                { return Rectf(r.left * f, r.top * f, r.right * f, r.bottom * f); }
inline Rectf  operator *   (Rectf r, Sizef s)                 { return Rectf(r.left * s.cx, r.top * s.cy, r.right * s.cx, r.bottom * s.cy); }
inline Rectf  operator *   (Rectf r, Pointf p)                { return Rectf(r.left * p.x, r.top * p.y, r.right * p.x, r.bottom * p.y); }
inline Rectf  operator *   (Rectf r, Rectf s)                 { return Rectf(r.left * s.left, r.top * s.top, r.right * s.right, r.bottom * s.bottom); }

inline Rectf  operator /   (Rectf r, double f)                { return Rectf(r.left / f, r.top / f, r.right / f, r.bottom / f); }
inline Rectf  operator /   (Rectf r, Sizef s)                 { return Rectf(r.left / s.cx, r.top / s.cy, r.right / s.cx, r.bottom / s.cy); }
inline Rectf  operator /   (Rectf r, Pointf p)                { return Rectf(r.left / p.x, r.top / p.y, r.right / p.x, r.bottom / p.y); }
inline Rectf  operator /   (Rectf r, Rectf s)                 { return Rectf(r.left / s.left, r.top / s.top, r.right / s.right, r.bottom / s.bottom); }

extern Rectf& SetUnion     (Rectf& rc, Pointf pt);
inline Rectf  GetUnion     (Rectf rc, Pointf pt)              { return SetUnion(rc, pt); }
extern Rectf  GetUnion     (const Array<Pointf>& pt);
extern Rectf& SetMinMaxMove(Rectf& rc, Rectf outer_rc);
inline Rectf  GetMinMaxMove(Rectf rc, Rectf outer_rc)         { return SetMinMaxMove(rc, outer_rc); }
extern double Distance     (Rectf rc, Pointf pt);
inline double Diagonal     (Rectf rc)                         { return Length(rc.Size()); }
inline double Area         (Rectf rc)                         { return rc.Width() * rc.Height(); }
inline Rectf  PointfRectf  (Pointf pt)                        { return Rectf(pt.x, pt.y, pt.x, pt.y); }
inline Rectf  SortRectf    (Pointf p, Pointf q)               { return Rectf(fpmin(p, q), fpmax(p, q)); }
inline Rect   RectfToRect  (Rectf rc)                         { return Rect(fround(rc.left), fround(rc.top), fround(rc.right), fround(rc.bottom)); }

inline Pointf fpminmax     (Pointf p, Rectf rc)               { return Pointf(minmax(p.x, rc.left, rc.right), minmax(p.y, rc.top, rc.bottom)); }




const Matrixf& Matrixf_0();
const Matrixf& Matrixf_1();
const Matrixf& Matrixf_Null();
const Matrixf& Matrixf_MirrorX();
const Matrixf& Matrixf_MirrorY();



struct Matrixf : Moveable<Matrixf>
{
	Pointf x, y, a;

	Matrixf()                                         { *this = Matrixf_1(); }
	Matrixf(const Nuller&) : a(Null)                  {}
	Matrixf(Pointf x, Pointf y, Pointf a = Pointf(0, 0)) : x(x), y(y), a(a) {}
	Matrixf(const Matrixf& (*fn)())                   { *this = fn(); }
	Matrixf(double xx, double xy, double yx, double yy, double ax, double ay)
		: x(xx, xy), y(yx, yy), a(ax, ay) {}

	bool             IsIdentity() const                    { return x.x == 1 && x.y == 0 && y.x == 0 && y.y == 1 && a.x == 0 && a.y == 0; }
	bool             IsZero() const                        { return x.x == 0 && x.y == 0 && y.x == 0 && y.y == 0 && a.x == 0 && a.y == 0; }

	void             Fix(Pointf vector)                    { a = vector - vector.x * x - vector.y * y; }
	Matrixf&         operator *= (const Matrixf& another);

	String           ToString() const;
};



extern Matrixf  MatrixfMove   (Pointf vector);
extern Matrixf  MatrixfRotate (double angle, Pointf fix = Pointf(0, 0));
extern Matrixf  MatrixfScale  (double scale, Pointf fix = Pointf(0, 0));
extern Matrixf  MatrixfScale  (Pointf scale, Pointf fix = Pointf(0, 0));
extern Matrixf  MatrixfScale  (Rectf src, Rectf dest);
extern Matrixf  MatrixfMirror (Pointf A, Pointf B);
extern Matrixf  MatrixfAffine (Pointf src1, Pointf dest1, Pointf src2, Pointf dest2);
extern Matrixf  MatrixfAffine (Pointf src1, Pointf dest1, Pointf src2, Pointf dest2, Pointf src3, Pointf dest3);

extern Matrixf  MatrixfInverse(const Matrixf& mx);
inline double   Determinant   (const Matrixf& mx)                         { return mx.x % mx.y; }
inline bool     IsReversing   (const Matrixf& mx)                         { return Determinant(mx) < 0; }
extern double   MatrixfMeasure(const Matrixf& mx);

template<>
inline bool     IsNull        (const Matrixf& mx)                         { return IsNull(mx.a); }
inline bool     operator ==   (const Matrixf& m1, const Matrixf& m2)      { return m1.x == m2.x && m1.y == m2.y && m1.a == m2.a; }
inline bool     operator !=   (const Matrixf& m1, const Matrixf& m2)      { return !(m1 == m2); }

inline Pointf   operator %    (Pointf vector, const Matrixf& matrix)      { return vector.x * matrix.x + vector.y * matrix.y; }
extern Pointf   operator *    (Pointf point,  const Matrixf& matrix);
extern Pointf   operator /    (Pointf point,  const Matrixf& matrix);
extern Rectf    operator *    (const Rectf& rect, const Matrixf& matrix);
extern Rectf    operator /    (const Rectf& rect, const Matrixf& matrix);

inline Pointf&  operator %=   (Pointf& point, const Matrixf& matrix)      { return point = point % matrix; }
inline Pointf&  operator *=   (Pointf& point, const Matrixf& matrix)      { return point = point * matrix; }

inline Matrixf  operator *    (const Matrixf& m1, const Matrixf& m2)      { return Matrixf(m1) *= m2; }
inline Matrixf  operator /    (const Matrixf& m1, const Matrixf& m2)      { return m1 * MatrixfInverse(m2); }




double          Distance      (Pointf X, Pointf A, Pointf B, double *arg = 0);
double          Distance      (Pointf X, Pointf A, Pointf B, double bulge, double *arg = 0);
double          Distance      (Pointf X, Pointf C, double radius, double *arg = 0);




bool            Crosses       (Rectf R, Pointf A, Pointf B);
bool            Crosses       (Rectf R, Pointf A, Pointf B, double bulge);
bool            Crosses       (Rectf R, Pointf C, double radius);




enum { CMP_OUT = -1, CMP_SECT = 0, CMP_IN = +1 };

int             ContainsPoints(const Array<Pointf>& polygon, const Array<Pointf>& points);
int             ContainsPoints(const Array<Pointf>& polygon, const Vector<int>& polyend, const Array<Pointf>& points);
int             ContainsPoint (const Array<Pointf>& polygon, Pointf pt);
int             ContainsPoint (const Array<Pointf>& polygon, const Vector<int>& polyend, Pointf pt);
int             ContainsPoly  (const Array<Pointf>& chkpoly, const Array<Pointf>& polygon, const Vector<int>& polyend, bool closed);
int             ContainsPoly  (const Array<Pointf>& chkpoly, const Array<Pointf>& polygon, bool closed);



bool            ClipLine      (Pointf& A, Pointf& B, Rectf box);
bool            ClipLine      (Pointf& A, Pointf& B, Rect box);
bool            ClipLine      (Point& A, Point& B, Rect box);



Rectf           GetBoundingBox(const Array<Pointf>& vertices);
Rect            GetBoundingBox(const Point *vertices, int vertex_count);
Rect            GetBoundingBox(const Vector<Point>& vertices);

void            SplitPolygon  (const Point *vertices, int vertex_count, const int *counts, int count_count,
	Vector<Point>& out_vertices, Vector<int>& out_counts, Rect clip = Null, int max_trace_points = 8000);
void            SplitPolygon  (const Vector<Point>& vertices, const Vector<int>& counts,
	Vector<Point>& out_vertices, Vector<int>& out_counts, Rect clip = Null, int max_trace_points = 8000);
void            SplitPolygon  (Array<Pointf>::ConstIterator vertices, int vertex_count, const int *counts, int count_count,
	Array<Pointf>& out_vertices, Vector<int>& out_counts, Rectf clip = Null, int max_trace_points = 8000);
void            SplitPolygon  (const Array<Pointf>& vertices, const Vector<int>& counts,
	Array<Pointf>& out_vertices, Vector<int>& out_counts, Rectf clip = Null, int max_trace_points = 8000);



extern double   Vec_outer_tolerance;
extern double   Vec_tolerance;
extern double   Vec_ang_tolerance;

extern bool     VecTolEq      (double x, double y);
extern bool     VecTolEq      (Pointf a, Pointf b);



class VecLine
{
public:
	VecLine();
	VecLine(Pointf A, Pointf B) : A(A), B(B) {}
	VecLine(double x1, double y1, double x2, double y2) : A(x1, y1), B(x2, y2) {}

	String        ToString() const;

	VecLine&      SetNull();

	double        Length() const { return A | B; }
	Pointf        Mid()    const;
	Pointf        Right()  const;
	Pointf        Left()   const;
	Pointf        Vector() const;

	double        GetArg(Pointf pt) const;
	Pointf        GetPointAt(double arg) const;

	VecLine       Reversed() const;
	VecLine&      SetReversed();

	Pointf        Intersect(VecLine another) const;
	VecLine&      SetClip(Rectf rect);
	VecLine       Clip(Rectf rect) const { return VecLine(*this).Clip(rect); }

	double        Distance(Pointf point, double *arg = 0) const;

	bool          IsNullInstance() const                   { return IsNull(A); }


	static Pointf GetPointAt(Pointf A, Pointf B, double arg);

public:
	Pointf        A, B;
};




inline Pointf  operator & (VecLine l1, VecLine l2)        { return l1.Intersect(l2); }
inline VecLine operator & (VecLine line, Rectf rect)      { return line.Clip(rect); }
inline double  operator | (VecLine ln, Pointf pt)         { return ln.Distance(pt); }
inline double  operator | (Pointf pt, VecLine ln)         { return ln.Distance(pt); }



class VecArc : public VecLine
{
public:
	VecArc();
	VecArc(VecLine line, double bulge = 0) : VecLine(line), bulge(bulge) {}
	VecArc(Pointf A, Pointf B, double bulge = 0) : VecLine(A, B), bulge(bulge) {}
	VecArc(double x1, double y1, double x2, double y2, double bulge = 0)
		: VecLine(x1, y1, x2, y2), bulge(bulge) {}

	String        ToString() const;

	Pointf        ArcMid() const;
	double        ArcLength() const;

	VecArc        Reversed() const;
	VecArc&       SetReversed();

	Pointf        GetPointAt(double t) const;
	Rectf         GetBoundingBox() const;


	static Pointf ArcMid(Pointf P, Pointf Q, double l, double h);
	static double ArcLength(Pointf P, Pointf Q, double l, double h);
	static void   Bisect(Pointf P, Pointf Q, double l, double h,
		Pointf& centre, double& ll, double& hh);
	static Pointf GetPointAt(Pointf P, Pointf Q, double l, double h, double t);

public:
	double        bulge;
};























































class VecArcInfo : public VecArc
{
public:
	VecArcInfo();
	VecArcInfo(Pointf p, Pointf q)                                  { Set(p, q); }
	VecArcInfo(Pointf p, Pointf q, Pointf x)                        { Set(p, q, x); }
	VecArcInfo(Pointf p, Pointf q, double bulge)                    { Set(p, q, bulge); }
	VecArcInfo(Pointf c, double r, double a, double b)              { Set(c, r, a, b); }
	VecArcInfo(Pointf c, double r)                                  { Set(c, r); }
	VecArcInfo(Pointf c, Pointf a, Pointf b, bool anticlockwise)    { Set(c, a, b, anticlockwise); }
	VecArcInfo(const VecArc& arc)                                   { Set(arc); }
	VecArcInfo(const VecArcInfo& arc)                               { *this = arc; }

	String      ToString() const;

	void        Set(Pointf P, Pointf Q);
	void        Set(Pointf P, Pointf Q, Pointf X);
	void        Set(Pointf P, Pointf Q, double bulge);
	void        Set(Pointf C, double r, double a, double b);
	void        Set(Pointf C, double r);
	void        Set(Pointf C, Pointf A, Pointf B, bool anticlockwise);

	void        Set(const VecArc& arc)                              { Set(arc.A, arc.B, arc.bulge); }

	void        Move(Pointf offset);

	bool        IsCircle() const   { return circle; }
	bool        IsCurved() const   { return curved; }
	bool        IsReversed() const { return reversed; }

	double      Length() const;
	Pointf      CentreOfMass() const;

	bool        ContainsBearing(double bearing) const;
	double      Distance(Pointf point, double *arg = 0) const;
	bool        Crosses(Rectf rect) const;
	Pointf      GetPointAt(double t) const;
	double      GetMaxDistance(Pointf point, Pointf *farthest = 0) const;

	double      GetArg(double bearing) const;
	double      GetArg(Pointf point) const;
	VecArcInfo  Subset(double start, double end) const;

	Rectf       GetBoundingBox() const;

	double      GetAngle() const;
	double      GetStartTangent() const;
	double      GetEndTangent() const;
	Pointf      GetStartDir() const;
	Pointf      GetEndDir() const;

	VecArcInfo  Offset(double dist) const;

	VecArcInfo  Reversed() const                                    { return VecArcInfo(*this).SetReversed(); }
	VecArcInfo& SetReversed();

	Pointf      C;
	double      bow;
	double      alpha;
	double      beta;
	double      radius;
	bool        curved;
	bool        reversed;
	bool        circle;
};



class VecIntersection
{
public:
	VecIntersection() { count = 0; }

	void   Mirror();
	bool   Nothing() { count = 0; return false; }
	void   Remove(int index);

	bool   LL(Pointf P1, Pointf Q1, Pointf P2, Pointf Q2);
	bool   LC(Pointf P1, Pointf Q1, Pointf C2, double r2);
	bool   LA(Pointf P1, Pointf Q1, const VecArcInfo& a2);
	bool   CC(Pointf C1, double r1, Pointf C2, double r2);
	bool   CA(Pointf C1, double r1, const VecArcInfo& a2);
	bool   AA(const VecArcInfo& a1, const VecArcInfo& a2);

	bool   IsEmpty() const  { return count == 0; }
	int    GetCount() const { return count; }

public:
	int    count;
	double t[2], u[2];

protected:
	void   CheckBearing(double *hints, const VecArcInfo& a);
};



class VecArcIterator
{
public:
	typedef Callback1<Pointf>     DrawProc;
	typedef Gate2<Pointf, double> ArcProc;

	VecArcIterator(const VecArc& arc, DrawProc _lineto);
	VecArcIterator(Pointf start, Pointf end, double bulge, DrawProc _lineto);

	VecArcIterator& Level(int _level)              { level = _level; return *this; }
	VecArcIterator& Precision(double prec  )       { precision = prec; return *this; }
	VecArcIterator& Clip(Rectf rect, DrawProc _mv) { clip = rect; moveto = _mv; return *this; }
	VecArcIterator& ArcTo(ArcProc _arc)            { arcto = _arc; return *this; }

	void            Go();

public:
	double          arclen;
	int             level;
	double          precision;
	VecArc          arc;
	Rectf           clip;
	DrawProc        moveto;
	DrawProc        lineto;
	ArcProc         arcto;

protected:
	enum
	{
		CF_XL = 001,
		CF_XG = 002,
		CF_YL = 010,
		CF_YG = 020,

		DEFAULT_LEVEL = 10,
	};

	Pointf          last;
	int             last_clip;

	int             GetClip(Pointf point) const;
	void            Recurse(Pointf to, double l, double h, int depth, int next_flclip);
};


#line 9 "u:/uppsrc\\Geom/Geom.h"
#line 1 "u:\\uppsrc\\geom\\fp3.h"



struct Pointf3 : Moveable<Pointf3>
{
public:
	Pointf3() {}
	Pointf3(const Nuller&) : x(Null), y(Null), z(Null) {}
	Pointf3(double x, double y, double z) : x(x), y(y), z(z) {}
	Pointf3(Pointf p, double z = 0) : x(p.x), y(p.y), z(z) {}
	explicit Pointf3(double t) : x(t), y(t), z(t) {}

	void              Serialize(Stream& stream)                    { stream % x % y % z; }

	double            operator [] (int i) const                    { return i == 0 ? x : i == 1 ? y : z; }
	double&           operator [] (int i)                          { return i == 0 ? x : i == 1 ? y : z; }

	Pointf            XY() const                                   { return Pointf(x, y); }
	Pointf            YX() const                                   { return Pointf(y, x); }

	Pointf            YZ() const                                   { return Pointf(y, z); }
	Pointf            ZY() const                                   { return Pointf(y, z); }

	Pointf            XZ() const                                   { return Pointf(x, z); }
	Pointf            ZX() const                                   { return Pointf(z, x); }

	Pointf3&          operator += (Pointf3 p)               { x += p.x; y += p.y; z += p.z; return *this; }
	Pointf3&          operator -= (Pointf3 p)               { x -= p.x; y -= p.y; z -= p.z; return *this; }
	Pointf3&          operator *= (double val)                     { x *= val; y *= val; z *= val; return *this; }
	Pointf3&          operator *= (Pointf3 p)               { x *= p.x; y *= p.y; z *= p.z; return *this; }
	Pointf3&          operator /= (double val)                     { x /= val; y /= val; z /= val; return *this; }
	Pointf3&          operator /= (Pointf3 p)               { x /= p.x; y /= p.y; z /= p.z; return *this; }

public:
	double            x, y, z;
};







inline bool           IsNull(Pointf3 p)                         { return IsNull(p.x); }
inline Pointf3        Nvl(Pointf3 p, Pointf3 q)                 { return !IsNull(p) ? p : q; }
extern String         AsString(const Pointf3& p);

inline bool           operator == (Pointf3 p, Pointf3 q)        { return q.x == p.x && q.y == p.y && q.z == p.z; }
inline bool           operator != (Pointf3 p, Pointf3 q)        { return !(q == p); }

inline Pointf3        operator - (Pointf3 p)                    { return Pointf3(-p.x, -p.y, -p.z); }
inline Pointf3        operator + (Pointf3 p, Pointf3 q)         { return Pointf3(p.x + q.x, p.y + q.y, p.z + q.z); }
inline Pointf3        operator - (Pointf3 p, Pointf3 q)         { return Pointf3(p.x - q.x, p.y - q.y, p.z - q.z); }
inline Pointf3        operator * (Pointf3 p, double val)        { return Pointf3(p.x * val, p.y * val, p.z * val); }
inline Pointf3        operator * (Pointf3 p, Pointf3 q)         { return Pointf3(p.x * q.x, p.y * q.y, p.z * q.z); }
inline Pointf3        operator * (double val, Pointf3 p)        { return Pointf3(p.x * val, p.y * val, p.z * val); }
inline Pointf3        operator / (Pointf3 p, double val)        { return Pointf3(p.x / val, p.y / val, p.z / val); }
inline Pointf3        operator / (Pointf3 p, Pointf3 q)         { return Pointf3(p.x / q.x, p.y / q.y, p.z / q.z); }

inline double         operator ^ (Pointf3 p, Pointf3 q)         { return p.x * q.x + p.y * q.y + p.z * q.z; }
inline Pointf3        operator % (Pointf3 p, Pointf3 q)         { return Pointf3(p.y * q.z - p.z * q.y, p.z * q.x - p.x * q.z, p.x * q.y - p.y * q.x); }

inline Pointf3        Mid(Pointf3 p, Pointf3 q)                 { return Pointf3((p.x + q.x) / 2, (p.y + q.y) / 2, (p.z + q.z) / 2); }
inline Pointf3        Mid(Pointf3 p, Pointf3 q, double w)       { return p + (q - p) * w; }
inline double         Squared(Pointf3 p)                        { return p.x * p.x + p.y * p.y + p.z * p.z; }
inline double         Length(Pointf3 p)                         { return sqrt(Squared(p)); }
extern Pointf3        Length(Pointf3 p, double l);
inline double         Distance(Pointf3 p, Pointf3 q)            { return Length(p - q); }
inline Pointf3        Unit(Pointf3 p)                           { return Length(p, 1.0); }
inline Pointf3        Scale(Pointf3 p, double d, Pointf3 c = Pointf(0, 0)) { return (p - c) * d + c; }
inline double         Determinant(Pointf3 a, Pointf3 b, Pointf3 c) { return (a % b) ^ c; }
extern Pointf3        Bezier2(Pointf3 a, Pointf3 b, Pointf3 c, double t);
extern Pointf3        Orthogonal(Pointf3 v, Pointf3 against);
extern Pointf3        Orthonormal(Pointf3 v, Pointf3 against);
extern Pointf3        FarthestAxis(Pointf3 v);
extern Pointf3        AtLine(Pointf3 a, double ta, Pointf3 b, double tb, double tx, double *ratio = 0);

inline double         GetXYBearing(Pointf3 a)                   { return atan2(a.y, a.x); }
inline double         GetYZBearing(Pointf3 a)                   { return atan2(a.z, a.y); }
inline double         GetZXBearing(Pointf3 a)                   { return atan2(a.x, a.z); }
extern double         Angle(Pointf a, Pointf b);

inline Pointf3        fpmin(Pointf3 p, Pointf3 q)               { return Pointf3(min(p.x, q.x), min(p.y, q.y), min(p.z, q.z)); }
inline Pointf3        fpmax(Pointf3 p, Pointf3 q)               { return Pointf3(max(p.x, q.x), max(p.y, q.y), max(p.z, q.z)); }

inline double         fpmin(Pointf3 p)                          { return min(min(p.x, p.y), p.z); }
inline double         fpmax(Pointf3 p)                          { return max(max(p.x, p.y), p.z); }
inline double         fpabsmin(Pointf3 p)                       { return min(min(fabs(p.x), fabs(p.y)), fabs(p.z)); }
inline double         fpabsmax(Pointf3 p)                       { return max(max(fabs(p.x), fabs(p.y)), fabs(p.z)); }

inline Pointf3        PolarPointf3XY(double angle)              { return Pointf3(cos(angle), sin(angle), 0.0); }
inline Pointf3        PolarPointf3YZ(double angle)              { return Pointf3(0.0, cos(angle), sin(angle)); }
inline Pointf3        PolarPointf3ZX(double angle)              { return Pointf3(sin(angle), 0.0, cos(angle)); }

extern Pointf3        RotateX(Pointf3 v, double angle, Pointf3 centre = Pointf3(0, 0, 0));
extern Pointf3        RotateY(Pointf3 v, double angle, Pointf3 centre = Pointf3(0, 0, 0));
extern Pointf3        RotateZ(Pointf3 v, double angle, Pointf3 centre = Pointf3(0, 0, 0));
extern Pointf3        Rotate(Pointf3 v, Pointf3 axis, double angle, Pointf3 centre = Pointf3(0, 0, 0));

class Plane3
{
public:
	Plane3() {}
	Plane3(double delta, Pointf3 normal) : delta(delta), normal(normal) {}
	Plane3(Pointf3 A, Pointf3 normal) : delta(-(normal ^ A)), normal(normal) {}
	Plane3(Pointf3 A, Pointf3 B, Pointf3 C) { normal = (B - A) % (C - A); delta = -(normal ^ A); }

public:
	double      delta;
	Pointf3     normal;
};

String          AsString(const Plane3& plane);

inline double   Distance(Plane3 plane, Pointf3 point)       { return (point ^ plane.normal) + plane.delta; }
extern double   Intersect(Plane3 p, Pointf3 la, Pointf3 lb);

inline Plane3   operator - (Plane3 p)                              { return Plane3(-p.delta, -p.normal); }

inline Plane3&  operator += (Plane3& p, Pointf3 v)                 { p.delta += v ^ p.normal; return p; }
inline Plane3&  operator -= (Plane3& p, Pointf3 v)                 { p.delta -= v ^ p.normal; return p; }

inline Plane3   operator +  (Plane3 p, Pointf3 v)           { Plane3 r = p; r += v; return r; }
inline Plane3   operator -  (Plane3 p, Pointf3 v)           { Plane3 r = p; r -= v; return r; }

extern Plane3   Unit(Plane3 p);

struct Matrixf3;

const Matrixf3& Matrixf3_0();
const Matrixf3& Matrixf3_1();
const Matrixf3& Matrixf3_Null();
const Matrixf3& Matrixf3_MirrorX();
const Matrixf3& Matrixf3_MirrorY();
const Matrixf3& Matrixf3_MirrorZ();

struct Matrixf3 : Moveable<Matrixf3>
{
	Pointf3 x, y, z, a;

	Matrixf3()                                         { *this = Matrixf3_1(); }
	Matrixf3(const Nuller&) : a(Null)                  {}
	Matrixf3(Pointf3 x, Pointf3 y, Pointf3 z, Pointf3 a = Pointf3(0, 0, 0))
		: x(x), y(y), z(z), a(a) {}
	Matrixf3(const Matrixf3& (*fn)())                  { *this = fn(); }
	Matrixf3(double xx, double xy, double xz,
		double yx, double yy, double yz,
		double zx, double zy, double zz,
		double ax = 0, double ay = 0, double az = 0)
		: x(xx, xy, xz), y(yx, yy, yz), z(zx, zy, zz), a(ax, ay, az) {}

	void             Serialize(Stream& stream);

	bool             IsIdentity() const                    { return x.x == 1 && x.y == 0 && x.z == 0 && y.x == 0 && y.y == 1 && y.z == 0 && z.x == 0 && z.y == 0 && z.z == 1 && a.x == 0 && a.y == 0 && a.z == 0; }
	bool             IsZero() const                        { return x.x == 0 && x.y == 0 && x.z == 0 && y.x == 0 && y.y == 0 && y.z == 0 && z.x == 0 && z.y == 0 && z.z == 0 && a.x == 0 && a.y == 0 && a.z == 0; }
	bool             IsNullInstance() const                { return IsNull(a); }

	Matrixf3&        Fix(const Pointf3& v)                 { a = v - v.x * x - v.y * y - v.z * z; return *this; }
	Matrixf3&        operator *= (const Matrixf3& another);

	Pointf3          CX() const                            { return Pointf3(x.x, y.x, z.x); }
	Pointf3          CY() const                            { return Pointf3(x.y, y.y, z.y); }
	Pointf3          CZ() const                            { return Pointf3(x.z, y.z, z.z); }

	String           ToString() const;
};

inline Matrixf3& operator *= (Matrixf3& m, double d) { m.x *= d; m.y *= d; m.z *= d; m.a *= d; return m; }
inline Matrixf3& operator /= (Matrixf3& m, double d) { m.x /= d; m.y /= d; m.z /= d; m.a /= d; return m; }



extern Matrixf3 Matrixf3Move   (Pointf3 vector);
extern Matrixf3 Matrixf3RotateX(double angle, Pointf3 fix = Pointf3(0, 0, 0));
extern Matrixf3 Matrixf3RotateY(double angle, Pointf3 fix = Pointf3(0, 0, 0));
extern Matrixf3 Matrixf3RotateZ(double angle, Pointf3 fix = Pointf3(0, 0, 0));
extern Matrixf3 Matrixf3Rotate (Pointf3 axis, double angle);
extern Matrixf3 Matrixf3Scale  (double scale, Pointf3 fix = Pointf3(0, 0, 0));
extern Matrixf3 Matrixf3Scale  (Pointf3 scale, Pointf3 fix = Pointf3(0, 0, 0));

extern Matrixf3  Matrixf3Affine(Pointf3 src1, Pointf3 dest1, Pointf3 src2, Pointf3 dest2);
extern Matrixf3  Matrixf3Affine(Pointf3 src1, Pointf3 dest1, Pointf3 src2, Pointf3 dest2,
	Pointf3 src3, Pointf3 dest3);
extern Matrixf3  Matrixf3Affine(Pointf3 src1, Pointf3 dest1, Pointf3 src2, Pointf3 dest2,
	Pointf3 src3, Pointf3 dest3, Pointf3 src4, Pointf3 dest4);

extern Matrixf3 Matrixf3Inverse(const Matrixf3& mx);
extern double   Determinant    (const Matrixf3& mx);
inline bool     IsReversing    (const Matrixf3& mx)                        { return Determinant(mx) < 0; }
extern double   Matrixf3Measure(const Matrixf3& mx);

inline bool     operator ==   (const Matrixf3& m1, const Matrixf3& m2)     { return m1.x == m2.x && m1.y == m2.y && m1.z == m2.z && m1.a == m2.a; }
inline bool     operator !=   (const Matrixf3& m1, const Matrixf3& m2)     { return !(m1 == m2); }

inline Pointf3  operator %    (Pointf3 vector, const Matrixf3& matrix)     { return vector.x * matrix.x + vector.y * matrix.y + vector.z * matrix.z; }
inline Pointf3  operator *    (Pointf3 point,  const Matrixf3& matrix)     { return point % matrix + matrix.a; }

inline Pointf3& operator %=   (Pointf3& point, const Matrixf3& matrix)     { return point = point % matrix; }
inline Pointf3& operator *=   (Pointf3& point, const Matrixf3& matrix)     { return point = point * matrix; }

inline Matrixf3  operator *   (const Matrixf3& m1, const Matrixf3& m2)     { return Matrixf3(m1) *= m2; }
inline Matrixf3  operator /   (const Matrixf3& m1, const Matrixf3& m2)     { return m1 * Matrixf3Inverse(m2); }

extern Plane3 operator * (Plane3 p, const Matrixf3& m);

const double BIGDOUBLE = 1e300;

class Box3
{
public:
	Box3(const Nuller& = Null) { low[0] = Null; }
	Box3(const Pointf3 *n, const double *l, const double *h)
	{
		normal[0] = n[0]; normal[1] = n[1]; normal[2] = n[2];
		low[0] = l[0]; low[1] = l[1]; low[2] = l[2];
		high[0] = h[0]; high[1] = h[1]; high[2] = h[2];
	}

	Plane3  GetMinPlane(int coord) const { return Plane3(low[coord], normal[coord]); }
	Plane3  GetMaxPlane(int coord) const { return Plane3(-high[coord], -normal[coord]); }

	bool    IsEmpty() const              { return low[0] > high[0] || low[1] > high[1] || low[2] > high[2]; }
	void    Clear()                      { low[0] = low[1] = low[2] = BIGDOUBLE; high[0] = high[1] = high[2] = -BIGDOUBLE; }
	void    Union(Pointf3 pt);

	Pointf3 normal[3];
	double  low[3];
	double  high[3];
};

inline bool IsNull(Box3 b) { return IsNull(b.low[0]); }

class Camera
{
public:
	Camera();

	void     Serialize(Stream& stream);

	Camera&  Location(Pointf3 new_location)             { location = new_location; return *this; }
	Camera&  Target(Pointf3 new_target)                 { target = new_target; return *this; }
	Camera&  Upwards(Pointf3 new_upwards)               { upwards = new_upwards; return *this; }
	Camera&  ViewingAngle(double new_va)                { viewing_angle = new_va; return *this; }
	Camera&  Viewport(double wmm, double hmm)           { width_mm = wmm; height_mm = hmm; return *this; }
	Camera&  Viewport(Sizef mm)                         { width_mm = mm.cx; height_mm = mm.cy; return *this; }
	Camera&  ViewportOffset(double xc, double yc)       { shift_x = xc; shift_y = yc; return *this; }
	Camera&  ViewportSize(Sizef px)                     { view_px = px.cx; view_py = px.cy; return *this; }
	Camera&  ViewportSize(double px, double py)         { view_px = px; view_py = py; return *this; }
	Camera&  Projection(const Matrixf3& pm)             { projection_matrix = pm; return *this; }
	Camera&  FarDistance(double new_fd)                 { far_distance = new_fd; return *this; }
	Camera&  NearDistance(double new_nd)                { near_distance = new_nd; return *this; }

	double   GetDistance(Pointf3 v) const               { return (v ^ direction) + distance_delta; }

	double   GetLengthByDistance(double l, double d)    { return l * near_distance / d; }
	double   GetDistanceByLength(double l, double t)    { return near_distance * l / t; }

	void     Update();

	Pointf3  Transform(Pointf3 point) const;
	bool     TransformClip(Pointf3 a, Pointf3 b, Pointf& outa, Pointf& outb) const;
	Pointf3  InverseXY(Pointf point, double z) const;

	void     SetPolar(Pointf3 dz, Pointf3 dx,
		double distance, double azimuth, double bearing, double rotation);
	void     GetPolar(Pointf3 dz, Pointf3 dx,
		double& distance, double& azimuth, double& bearing, double& rotation) const;

public:
	Pointf3  location;
	Pointf3  target;
	Pointf3  upwards;
	double   viewing_angle;
	double   width_mm, height_mm;
	double   view_px, view_py;
	double   shift_x, shift_y;
	double   near_distance;
	double   far_distance;
	Matrixf3 projection_matrix;


	Pointf3  straight_up;
	Pointf3  straight_right;
	Pointf3  direction;
	double   distance_delta;
	Matrixf3 camera_matrix;
	Matrixf3 invcam_matrix;
	Matrixf3 transform_matrix;
	double   z_delta;
	double   viewing_distance;
};
#line 10 "u:/uppsrc\\Geom/Geom.h"
#line 1 "u:\\uppsrc\\geom\\linsolv.h"
class LinearSolver
{
public:
	LinearSolver(int count, double tolerance = 1e-10);

	double        *Row(int r)                        { return &matrix[r * col1]; }
	const double  *Row(int r) const                  { return &matrix[r * col1]; }
	double&        Left(int r, int c)                { return matrix[r * col1 + c]; }
	double         Left(int r, int c) const          { return matrix[r * col1 + c]; }
	double&        Right(int r)                      { return matrix[(r + 1) * col1 - 1]; }
	double         Right(int r) const                { return matrix[(r + 1) * col1 - 1]; }
	double&        operator () (int r, int c)        { return Left(r, c); }
	double         operator () (int r, int c) const  { return Left(r, c); }
	double&        operator () (int r)               { return Right(r); }
	double         operator () (int r) const         { return Right(r); }

	void           AddLSI(const double *bases, double value);

	Vector<double> Solve();

	static void    SelfTest();

private:
	int            rows;
	int            col1;
	Vector<double> matrix;
	Vector<Point>  pivots;
	double         tolerance;
	Vector<int>    left_rows, left_cols;
};
#line 11 "u:/uppsrc\\Geom/Geom.h"
#line 1 "u:\\uppsrc\\geom\\delaunay.h"
class Delaunay
{
public:
	Delaunay() : tihull(-1) {}
	Delaunay(const Array<Pointf>& points, double epsilon = 1e-6) { Build(points, epsilon); }

	void                          Build(const Array<Pointf>& points, double epsilon = 1e-6);

public:
	struct Triangle
	{
		bool IsProper() const                       { return vertex[0] >= 0; }
		int  operator [] (int i) const              { return vertex[i]; }
		int& operator [] (int i)                    { return vertex[i]; }

		int  Next(int i) const                      { return nextindex[i] >> 2; }
		int  NextIndex(int i) const                 { return nextindex[i] & 3; }

		void Set(int a, int b, int c)               { vertex[0] = a; vertex[1] = b; vertex[2] = c; }
		void SetNext(int i, int next, int index)    { ; nextindex[i] = next * 4 + index; }

		int  vertex[3];
		int  nextindex[3];
	};

	int                           GetCount() const                             { return triangles.GetCount(); }
	const Triangle&               operator [] (int i) const                    { return triangles[i]; }
	Pointf                        At(int i) const                              { return points[i]; }
	Pointf                        At(const Triangle& t, int i) const           { return points[t[i]]; }
	int                           GetHullIndex() const                         { return tihull; }

private:
	bool                          IsNear(const Pointf& a, const Pointf& b) const { return fabs(a.x - b.x) <= epsilon && fabs(a.y - b.y) <= epsilon; }
	void                          CreatePair(int i, int j);
	void                          AddHull(int i);
	void                          Link(int ta, int ia, int tb, int ib)         { triangles[ta].SetNext(ia, tb, ib); triangles[tb].SetNext(ib, ta, ia); }

private:
	Array<Pointf>                 points;
	Vector<int>                   order;
	Array<Triangle>               triangles;
	double                        epsilon;
	double                        epsilon2;
	int                           tihull;
};
#line 12 "u:/uppsrc\\Geom/Geom.h"

};

#line 16 "u:/uppsrc\\Geom/Geom.h"
#line 6 "u:/uppsrc\\TDraw/TDraw.h"
#line 1 "u:/uppsrc\\Web/Web.h"















































#line 7 "u:/uppsrc\\TDraw/TDraw.h"

#line 1 "u:\\uppsrc\\tdraw\\util.h"
namespace Upp {

static const int    DOTS_PER_METER_INT = 23622;
static const double DOTS_PER_METER_DBL = 600e3 / 25.4;

Draw&  ScreenInfo();

Size   GetPixelsPerMeter(const Draw& draw);
int    GetHorzPixelsPerMeter(const Draw& draw);
int    GetVertPixelsPerMeter(const Draw& draw);
int    GetAvgPixelsPerMeter(const Draw& draw);

double GetHorzPixelsPerDot(const Draw& draw);
double GetVertPixelsPerDot(const Draw& draw);
double GetAvgPixelsPerDot(const Draw& draw);

Font   GetPixelFont(Font font, const Draw& draw);

int    DotsToPixels(const Draw& draw, int dots);
Size   DotsToPixels(const Draw& draw, Size size);
int    HorzDotsToPixels(const Draw& draw, int dots);
int    VertDotsToPixels(const Draw& draw, int dots);

int    PixelsToDots(const Draw& draw, int pixels);
Size   PixelsToDots(const Draw& draw, Size size);
int    HorzPixelsToDots(const Draw& draw, int dots);
int    VertPixelsToDots(const Draw& draw, int dots);

int    PixelsToPoints(const Draw& draw, int pixels);
Size   PixelsToPoints(const Draw& draw, Size pixels);
int    PointsToPixels(const Draw& draw, int points);
Size   PointsToPixels(const Draw& draw, Size points);

void   RGBtoHSV(Color c, double& h, double& s, double& v);
Color  HSVtoRGB(double h, double s, double v);

Color  GetColorGradient(Color c1, Color c2, int ratio1, int ratio2, double gamma = 2.5);

void   DrawDragDropRect(Draw& draw, const Rect& rc_old, const Rect& rc_new, int width, Color c1 = White, Color c2 = Black);
void   DrawDragDropRect(Draw& draw, const Rect& rc_old, const Rect& rc_new, Color c1 = White, Color c2 = Black);

void   PaintDragHorzLine(Draw& draw, const Rect& rc, Color c1, Color c2, Color bgnd, int mingap = 3);
void   PaintDragVertLine(Draw& draw, const Rect& rc, Color c1, Color c2, Color bgnd, int mingap = 3);
void   PaintDragRect(Draw& draw, const Rect& rc, Color c1, Color c2, Color bgnd, int width);

















void   DrawPolyPolyPolygon(Draw& draw,
	const Point *vertices, int vertex_count,
	const int *subpolygon_counts, int subpolygon_count_count,
	const int *disjunct_polygon_counts, int disjunct_polygon_count_count,
	Color color = Black, int width = 0, Color outline = Null, uint64 pattern = 0, Color doxor = Null);
void   DrawPolyPolyPolygon(Draw& draw,
	const Vector<Point>& vertices, const Vector<int>& subpolygon_counts, const Vector<int>& disjunct_polygon_counts,
	Color color = Black, int width = 0, Color outline = Null, uint64 pattern = 0, Color doxor = Null);
void   DrawPolyPolygon(Draw& draw,
	const Point *vertices, int vertex_count, const int *subpolygon_counts, int subpolygon_count_count,
	Color color = Black, int width = 0, Color outline = Null, uint64 pattern = 0, Color doxor = Null);
void   DrawPolyPolygon(Draw& draw, const Vector<Point>& vertices, const Vector<int>& subpolygon_counts,
	Color color = Black, int width = 0, Color outline = Null, uint64 pattern = 0, Color doxor = Null);
void   DrawPolygons(Draw& draw,
	const Point *vertices, int vertex_count, const int *polygon_counts, int polygon_count_count,
	Color color = Black, int width = 0, Color outline = Null, uint64 pattern = 0, Color doxor = Null);
void   DrawPolygons(Draw& draw, const Vector<Point>& vertices, const Vector<int>& polygon_counts,
	Color color = Black, int width = 0, Color outline = Null, uint64 pattern = 0, Color doxor = Null);
void   DrawPolygon(Draw& draw, const Point *vertices, int vertex_count,
	Color color = Black, int width = 0, Color outline = Null, uint64 pattern = 0, Color doxor = Null);
void   DrawPolygon(Draw& draw, const Vector<Point>& vertices,
	Color color = Black, int width = 0, Color outline = Null, uint64 pattern = 0, Color doxor = Null);



inline PaintRect WhiteDisplay()   { return PaintRect(ColorDisplay(), White()); }
inline PaintRect BlackDisplay()   { return PaintRect(ColorDisplay(), Black()); }
inline PaintRect SWhiteDisplay()  { return PaintRect(ColorDisplay(), SWhite()); }
inline PaintRect SLtGrayDisplay() { return PaintRect(ColorDisplay(), SLtGray()); }
inline PaintRect SBlackDisplay()  { return PaintRect(ColorDisplay(), SBlack()); }



















































class GradientDisplay : public Display
{
public:
	GradientDisplay() : a(0, 0), ca(White), b(-1, -1), cb(LtGray), gamma(2.5) {}
	GradientDisplay(Point a, Color ca, Point b, Color cb, double gamma = 2.5);

	void             Set(Point a_, Color ca_, Point b_, Color cb_) { a = a_; ca = ca_; b = b_; cb = cb_; }
	Point            GetPos1() const                               { return a; }
	Color            GetColor1() const                             { return ca; }
	Point            GetPos2() const                               { return b; }
	Color            GetColor2() const                             { return cb; }

	void             Gamma(double g)                               { gamma = g; }
	double           GetGamma() const                              { return gamma; }

	virtual void     Paint(Draw& w, const Rect& r, const Value& q, Color i, Color p, dword s) const;

protected:
	Point            a, b;
	Color            ca, cb;
	double           gamma;

	static Point     GetRectPoint(Point P, const Rect& rc);
};



class PrinterInfo
{
public:
	PrinterInfo();

	operator bool () const { return page_size.cx > 0 && page_size.cy > 0; }

public:

	const DEVMODE *devmode;
#line 181 "u:\\uppsrc\\tdraw\\util.h"
	String         driver;
	String         device;
	String         output;
	Size           page_size;

private:
	String         devmode_data;
};





int GdiGetFreeSpace();
#line 196 "u:\\uppsrc\\tdraw\\util.h"

};
#line 9 "u:/uppsrc\\TDraw/TDraw.h"

#line 11 "u:/uppsrc\\TDraw/TDraw.h"
#line 7 "u:/uppsrc\\TCtrlLib/TCtrlLib.h"
#line 1 "u:/uppsrc\\TCore/TCore.h"

















#line 8 "u:/uppsrc\\TCtrlLib/TCtrlLib.h"
#line 1 "u:\\uppsrc\\tctrllib\\util.h"
namespace Upp {











class Pump
{
public:
	struct Item
	{
		virtual ~Item() {}
		virtual void Run(bool write) = 0;
	};

	Pump()                                          {}

	void         Run(bool write)                    { for(int i = 0; i < items.GetCount(); i++) items[i].Run(write); }

	void         Read()                             { Run(false); }
	void         Write()                            { Run(true); }

	bool         IsEmpty() const                    { return items.IsEmpty(); }

	Pump&        Add(Item *item)                    { items.Add(item); return *this; }

	Pump&        operator << (One<Item> item)       { Add(-item); return *this; }
	Pump&        operator << (Item *item)           { Add(item); return *this; }
	void         operator << (bool write)           { Run(write); }

	void         Clear()                            { items.Clear(); }

public:
	Array<Item> items;
};

inline Pump WithPump() { return Pump(); }

template <class A, class B>
struct PumpItemSet : public Pump::Item
{
	PumpItemSet(A& a, B& b) : a(a), b(b) {}
	virtual void Run(bool write) { if(write) a = b; else b = a; }
	A& a; B& b;
};

template <class A, class B>
inline One<Pump::Item> PumpSet(A& a, B& b) { return new PumpItemSet<A, B>(a, b); }

template <class A, class B>
struct PumpItemData : public Pump::Item
{
	PumpItemData(A& a, B& b) : a(a), b(b) {}
	virtual void Run(bool write) { if(write) a = ~b; else b <<= a; }
	A& a; B& b;
};

template <class A, class B>
inline One<Pump::Item> PumpData(A& a, B& b) { return new PumpItemData<A, B>(a, b); }

template <class B>
struct PumpItemDataRef : public Pump::Item
{
	PumpItemDataRef(Ref ref, B& b) : ref(ref), b(b) {}
	virtual void Run(bool write) { if(write) ref.SetValue(~b); else b <<= Value(ref); }
	Ref ref; B& b;
};

template <class B>
inline One<Pump::Item> PumpDataRef(Ref ref, B& b) { return new PumpItemDataRef<B>(ref, b); }

template <class A, class B>
struct PumpItemEnumData : public Pump::Item
{
	PumpItemEnumData(A& a, B& b) : a(a), b(b) {}
	virtual void Run(bool write) { if(write) a = A(int(~b)); else b <<= (int)a; }
	A& a; B& b;
};

template <class A, class B>
inline One<Pump::Item> PumpEnumData(A& a, B& b) { return new PumpItemEnumData<A, B>(a, b); }

template <class A>
struct PumpItemArray : public Pump::Item
{
	PumpItemArray(A& a, ArrayCtrl& array, int row, int column) : a(a), array(array), row(row), column(column) {}
	virtual void Run(bool write)
	{
		if(write) { a = array.Get(row, column); }
		else      { array.Set(row, column, a); }
	}

	A&         a;
	ArrayCtrl& array;
	int        row;
	int        column;
};

template <class A, class B>
struct PumpItemScaledData : public Pump::Item
{
	PumpItemScaledData(A& a, B& b, double scale) : a(a), b(b), scale(scale) {}
	virtual void Run(bool write)
	{
		if(write) { double d = ~b; a   = (IsNull(d) ? d : d * scale); }
		else      { b <<= (IsNull(a) ? double(Null) : (double)a / scale); }
	}

	A& a;
	B& b;
	double scale;
};

template <class A, class B>
struct PumpItemIntScaledData : public Pump::Item
{
	PumpItemIntScaledData(A& a, B& b, double scale) : a(a), b(b), scale(scale) {}
	virtual void Run(bool write)
	{
		if(write) { double d = ~b; a   = (IsNull(d) ? (int)Null : fround(d * scale)); }
		else      { b <<= (IsNull(a) ? double(Null) : (double)a / scale); }
	}

	A& a;
	B& b;
	double scale;
};

template <class A, class B>
One<Pump::Item> PumpScaledData(A& a, B& b, double scale) { return new PumpItemScaledData<A, B>(a, b, scale); }

template <class A, class B>
One<Pump::Item> PumpAngleData(A& a, B& b) { return PumpScaledData<A, B>(a, b, 3.14159265358979323846 / 180.0); }

template <class A, class B>
One<Pump::Item> PumpIntScaledData(A& a, B& b, double scale) { return new PumpItemIntScaledData<A, B>(a, b, scale); }

template <class A, class B>
One<Pump::Item> PumpIntAngleData(A& a, B& b) { return PumpIntScaledData<A, B>(a, b, 3.14159265358979323846 / 180.0); }

template <class A>
inline One<Pump::Item> PumpArray(A& a, ArrayCtrl& array, int row, int column)
{ return new PumpItemArray<A>(a, array, row, column); }

template <class A>
inline One<Pump::Item> PumpArray(A& a, ArrayCtrl& array, int row, Id column)
{ return new PumpItemArray<A>(a, array, row, array.GetPos(column)); }

template <class A, class C>
struct PumpItemArrayCast : public Pump::Item
{
	PumpItemArrayCast(A& a, ArrayCtrl& array, int row, int column) : a(a), array(array), row(row), column(column) {}

	virtual void Run(bool write)
	{
		if(write) { a = A(C(array.Get(row, column))); }
		else      { array.Set(row, column, (C)a); }
	}

	A&         a;
	ArrayCtrl& array;
	int        row;
	int        column;
};

template <class C, class A>
inline One<Pump::Item> PumpArrayCast(A& a, ArrayCtrl& array, int row, int column)
{ return new PumpItemArrayCast<A, C>(a, array, row, column); }

template <class C, class A>
inline One<Pump::Item> PumpArrayCast(A& a, ArrayCtrl& array, int row, Id column)
{ return new PumpItemArrayCast<A, C>(a, array, row, array.GetPos(column)); }

struct PumpItemArrayRef : public Pump::Item
{
	PumpItemArrayRef(Ref ref, ArrayCtrl& array, int row, int column)
		: ref(ref), array(array), row(row), column(column) {}

	virtual void Run(bool write)
	{
		if(write) { ref.SetValue(array.Get(row, column)); }
		else      { array.Set(row, column, Value(ref)); }
	}

	Ref        ref;
	ArrayCtrl& array;
	int        row;
	int        column;
};

inline One<Pump::Item> PumpArrayRef(Ref ref, ArrayCtrl& array, int row, int column)
{ return new PumpItemArrayRef(ref, array, row, column); }

inline One<Pump::Item> PumpArrayRef(Ref ref, ArrayCtrl& array, int row, Id column)
{ return new PumpItemArrayRef(ref, array, row, array.GetPos(column)); }

bool   IsUnique(const ArrayCtrl& table, int column);
bool   IsUnique(const ArrayCtrl& table, Id column);
int    SwapRows(ArrayCtrl& table, int row1, int row2);
void   SetColumn(ArrayCtrl& table, int index, const Value& value);
void   SetColumn(ArrayCtrl& table, Id column, const Value& value);

BorderFrame& TopJoinFrame();
BorderFrame& BottomJoinFrame();

class TabPageCtrl : public StaticRect {
public:
	TabPageCtrl() { Transparent(); Color(Null);  }
};

class DropListAll : public DropList
{
public:
	DropListAll() { DisplayAll(); }
};

class DropButton : public FrameRight<Button>
{
public:
	DropButton();
	virtual bool HotKey(dword key);

public:
	Gate1<dword> WhenHotKey;
};

class ChoiceList : public PopUpTable
{
public:
	typedef ChoiceList CLASSNAME;

	ChoiceList();

	ChoiceList& Attach(Ctrl& owner);
	void        Detach();

	ChoiceList& operator >> (Ctrl& owner) { return Attach(owner); }

	void        OnDrop();
	void        OnToggle();
	void        OnSelect();
	void        OnCancel();

	ChoiceList& DropWidth(int _wd)    { dropbutton.Width(_wd); return *this; }
	ChoiceList& DropShow(bool ds)     { dropbutton.Show(ds); return *this; }
	ChoiceList& DataItem(int _item)   { item = _item; return *this; }
	ChoiceList& DataItem(Id _col_id)  { item = GetPos(_col_id); return *this; }
	int         GetDataItem() const   { return item; }

	bool        OnKey(dword key);

public:
	Callback    WhenDrop;

protected:
	void        Initialize();

protected:
	DropButton  dropbutton;
	Ctrl       *owner;
	int         item;
};

class ExtendedButton : public FrameRight<Button>
{
public:
	ExtendedButton();
	virtual bool HotKey(dword key);
};

class ExtendedFileButton : public FrameRight<Button>
{
public:
	ExtendedFileButton();
	virtual bool HotKey(dword key);
};

class MenuButton : public ExtendedButton
{
public:
	MenuButton();

	Callback1<Bar&> WhenBar;

private:
	void            OnMenu();
};




class DragDropCtrl : public Ctrl
{
public:
	DragDropCtrl();
	virtual ~DragDropCtrl();


	virtual bool Push(Point pt, dword keyflags);
	virtual void Drag(Point pt, Point last, Point next, dword keyflags);
	virtual void Drop(Point pt, Point end, dword keyflags);
	virtual void Click(Point pt, dword keyflags);
	virtual void Cancel();

	virtual void DragRect(const Rect& last, const Rect& next, dword keyflags);
	virtual void DropRect(const Rect& rc, dword keyflags);

	void         DragShow(bool _show = true);
	void         DragHide()                    { DragShow(false); }
	void         DragStop(bool accept, dword keyflags);
	void         DragStop(bool accept = false) { DragStop(accept, last_key); }

	bool         IsDragging() const            { return state == ON || state == HIDDEN; }
	bool         IsPushed() const              { return state != OFF; }


	virtual void LeftDown(Point pt, dword keyflags);
	virtual void LeftDouble(Point pt, dword keyflags);
	virtual void LeftUp(Point pt, dword keyflags);
	virtual void RightDown(Point pt, dword keyflags);
	virtual void RightDouble(Point pt, dword keyflags);
	virtual void RightUp(Point pt, dword keyflags);
	virtual void MouseMove(Point pt, dword keyflags);
	virtual bool Key(dword key, int repcnt);

private:
	Point        start, last;
	dword        last_key;
	char         state;
	enum { OFF, ON, POSSIBLE, HIDDEN };
};

class StdArrayOrder : public ArrayCtrl::Order
{
public:
	StdArrayOrder() {}
	StdArrayOrder(int i, bool d = false, dword l = 0)    { Add(i, d, l); }

	void         Clear()                                 { index.Clear(); desc.Clear(); lang.Clear(); }
	void         Add(int i, bool d = false, dword l = 0) { index.Add(i); desc.Add(d); lang.Add(l); }
	void         Set(int i, bool d = false, dword l = 0) { Clear(); Add(i, d, l); }

	virtual bool operator () (const Vector<Value>& row1, const Vector<Value>& row2) const;

private:
	Vector<int>   index;
	Vector<bool>  desc;
	Vector<dword> lang;
};

class ArrayPair : public Ctrl
{
public:
	typedef ArrayPair CLASSNAME;
	ArrayPair();

	ArrayPair&              RowName(const char *s)                  { left.RowName(s); right.RowName(s); return *this; }
	ArrayPair&              AppendLine(bool b = true)               { left.AppendLine(b); right.AppendLine(b); return *this; }
	ArrayPair&              NoAppendLine()                          { return AppendLine(false); }
	ArrayPair&              Inserting(bool b = true)                { left.Inserting(b); right.Inserting(b); return AppendLine(b); }
	ArrayPair&              NoInserting()                           { return Inserting(false); }
	ArrayPair&              Removing(bool b = true)                 { left.Removing(b); right.Removing(b); return *this; }
	ArrayPair&              NoRemoving()                            { return Removing(false); }
	ArrayPair&              Appending(bool b = true)                { left.Appending(b); right.Appending(b); return *this; }
	ArrayPair&              BeforeAfterInserting(int q = 1)         { left.BeforeAfterInserting(q); right.BeforeAfterInserting(q); return *this; }
	ArrayPair&              AfterBeforeInserting(int q = 2)         { left.AfterBeforeInserting(q); right.AfterBeforeInserting(q); return *this; }
	ArrayPair&              Duplicating(bool b = true)              { left.Duplicating(b); right.Duplicating(b); return *this; }
	ArrayPair&              NoInsertAppend(bool b = true)           { left.NoInsertAppend(b); right.NoInsertAppend(b); return *this; }
	ArrayPair&              Moving(bool b = true)                   { left.Moving(b); right.Moving(b); return *this; }
	ArrayPair&              NoDuplicating()                         { return Duplicating(false); }
	ArrayPair&              AskRemove(bool b = true)                { left.AskRemove(b); right.AskRemove(b); return *this; }
	ArrayPair&              NoAskRemove()                           { return AskRemove(false); }

	ArrayPair&              Header(bool b = true)                   { left.Header(b); right.Header(b); return *this; }
	ArrayPair&              NoHeader()                              { return Header(false); }
	ArrayPair&              Track(bool b = true)                    { left.Track(b); right.Track(b); return *this; }
	ArrayPair&              NoTrack()                               { return Track(false); }
	ArrayPair&              VertGrid(bool b = true)                 { left.VertGrid(b); right.VertGrid(b); return *this; }
	ArrayPair&              NoVertGrid()                            { return VertGrid(false); }
	ArrayPair&              HorzGrid(bool b = true)                 { left.HorzGrid(b); right.HorzGrid(b); return *this; }
	ArrayPair&              NoHorzGrid()                            { return HorzGrid(false); }
	ArrayPair&              Grid(bool b = true)                     { return VertGrid(b).HorzGrid(b); }
	ArrayPair&              NoGrid()                                { return Grid(false); }
	ArrayPair&              GridColor(Color c)                      { left.GridColor(c); right.GridColor(c); return *this; }
	ArrayPair&              NoCursor(bool b = true)                 { left.NoCursor(b); right.NoCursor(b); return *this; }
	ArrayPair&              MouseMoveCursor(bool b = true)          { left.MouseMoveCursor(b); right.MouseMoveCursor(b); return *this; }
	ArrayPair&              NoMouseMoveCursor()                     { return MouseMoveCursor(false); }
	ArrayPair&              AutoHideSb(bool b = true)               { left.AutoHideSb(b); right.AutoHideSb(); return *this; }
	ArrayPair&              NoAutoHideSb()                          { return AutoHideSb(false); }
	ArrayPair&              MultiSelect(bool b = true)              { left.MultiSelect(b); right.MultiSelect(b); return *this; }

	ArrayPair&              Vert(bool vert = true);
	ArrayPair&              Horz()                                  { return Vert(false); }
	bool                    IsVert() const                          { return is_vert; }

	void                    SetPos(int pos);
	void                    HalfPos()                               { SetPos(5000); }
	int                     GetPos() const                          { return pane_pos; }

	virtual void            Layout();

	virtual void            SetData(const Value& value);
	virtual Value           GetData() const;

	void                    SetKey(int i);
	void                    SetKey(Id id);
	int                     GetKey() const { return key_index; }

	void                    SetSort(int i, const ArrayCtrl::Order& order);
	void                    SetSort(Id id, const ArrayCtrl::Order& order) { SetSort(left.GetPos(id), order); }
	void                    SetSort(int i);
	void                    SetSort(Id id)                                { SetSort(left.GetPos(id)); }
	void                    NoSort()                                      { SetSort(-1, std_order); }

	void                    UpdateGUI();

	void ToolLeft(Bar& bar); void OnLeft(); static void HelpLeft();
		void ToolAdd(Bar& bar); void OnAdd(); static void HelpAdd();
		void ToolAddAll(Bar& bar); void OnAddAll(); static void HelpAddAll();

	void ToolRight(Bar& bar); void OnRight(); static void HelpRight();
		void ToolRemove(Bar& bar); void OnRemove(); static void HelpRemove();
		void ToolRemoveAll(Bar& bar); void OnRemoveAll(); static void HelpRemoveAll();

public:
	Callback                WhenAdd;
	ArrayCtrl               left, right;

private:
	void                    OnRightCursor();
	void                    SortLeft();
	void                    SortRight();

private:
	Button                  add, add_all, remove, remove_all;
	int                     key_index;
	int                     sort_index;
	int                     pane_pos;
	bool                    is_vert;
	const ArrayCtrl::Order *order;
	StdArrayOrder           std_order;
};

template <class T>
Vector<T> GetArrayColumn(const ArrayCtrl& array, int column)
{
	Vector<T> out;
	out.SetCount(array.GetCount());
	for(int i = 0; i < out.GetCount(); i++)
		out[i] = array.Get(i, column);
	return out;
}

template <class T>
Vector<T> GetKeyVector(const ArrayPair& pair)
{
	;
	return GetArrayColumn<T>(pair.right, pair.GetKey());
}

template <class C>
void SetKeyContainer(ArrayPair& pair, const C& container)
{
	typedef typename C::ConstIterator CI;
	int k = pair.GetKey();
	;
	for(CI b = container.Begin(), e = container.End(); b != e; ++b)
		if(pair.left.FindSetCursor(*b, k))
			pair.OnAdd();
	if(pair.left.GetCount() > 0)
		pair.left.SetCursor(0);
	if(pair.right.GetCount() > 0)
		pair.right.SetCursor(0);
}

class ValueArrayCtrl : public ArrayCtrl
{
public:
	typedef ValueArrayCtrl CLASSNAME;
	ValueArrayCtrl();

	virtual void    SetData(const Value& data);
	virtual Value   GetData() const;
	virtual bool    Accept();

public:
	Callback        WhenSetData;
	Gate            WhenAccept;

private:
	void            OnArrayAction();
};

































void           DropFilesRegister(HWND hwnd);
Point          DropFilesGetPos(WPARAM hdrop);
Vector<String> DropFilesGetList(WPARAM hdrop);
#line 536 "u:\\uppsrc\\tctrllib\\util.h"

bool ShowErrorFocus(bool cond, const char *text, Ctrl& focus);

};
#line 9 "u:/uppsrc\\TCtrlLib/TCtrlLib.h"
#line 1 "u:\\uppsrc\\tctrllib\\template.h"
namespace Upp {











































































template <class T>
class WithChoiceList : public T
{
public:
	WithChoiceList();

	virtual bool Key(dword key, int repcnt);

public:
	ChoiceList choices;
};

template <class T>
WithChoiceList<T>::WithChoiceList()
{
	choices.Attach(*this);
}

template <class T>
bool WithChoiceList<T>::Key(dword key, int repcnt)
{
	return choices.OnKey(key) || T::Key(key, repcnt);
}

template <class T>
class WithKeyMap : public T
{
public:
	WithKeyMap() {}

	void         AddKey(dword key, Callback callback) { map.Add(key, callback); }
	void         ClearKey(dword key);
	void         ClearKey()                           { map.Clear(); }

	virtual bool Key(dword key, int count);

public:
	VectorMap<dword, Callback> map;
};

template <class T>
void WithKeyMap<T>::ClearKey(dword key)
{
	Vector<int> found;
	for(int i = map.Find(key); i >= 0; i = map.FindNext(i))
		found.Add(i);
	while(!found.IsEmpty())
		map.Remove(found.Pop());
}

template <class T>
bool WithKeyMap<T>::Key(dword key, int count)
{
	int i = map.Find(key);
	if(i < 0)
		return T::Key(key, count);
	for(; i >= 0; i = map.FindNext(i))
		map[i]();
	return true;
}

template <class T>
class WithKeyCallback : public T
{
public:
	WithKeyCallback() : WhenKey(false) {}
	virtual bool Key(dword key, int count);

	Gate1<dword> WhenKey;
};

template <class T>
bool WithKeyCallback<T>::Key(dword key, int count)
{
	return WhenKey(key) || T::Key(key, count);
}

template <class T>
class CtrlDataHelper
{
public:
	CtrlDataHelper(Ctrl& ctrl, T dflt) : ctrl(ctrl), value(dflt) {}

	void Serialize(Stream& stream)
	{
		if(stream.IsStoring())
			value = ~ctrl;
		stream % value;
		if(stream.IsLoading())
			ctrl <<= value;
	}

	friend Stream& operator % (Stream& stream, CtrlDataHelper<T> hlp) { hlp.Serialize(stream); return stream; }

private:
	Ctrl& ctrl;
	T     value;
};

template <class T>
inline CtrlDataHelper<T>
CtrlData(Ctrl& ctrl, T dflt = Null)
{ return CtrlDataHelper<T>(ctrl, dflt); }

template <class T>
class WithDisplay : public T
{
public:
	WithDisplay();
	WithDisplay(const PaintRect& prc) : prc(prc) {}
	WithDisplay(const Display& picture, const Value& value) : prc(picture, value) {}

	virtual void     Paint(Draw& draw);

	WithDisplay&     Background(const PaintRect& _prc)  { prc = _prc; this->Refresh(); return *this; }
	WithDisplay&     Background(const Value& _value)    { prc.SetValue(_value); this->Refresh(); return *this; }

	const Display&   GetDisplay() const                 { return prc.GetDisplay(); }
	const Value&     GetValue() const                   { return prc.GetValue(); }
	const PaintRect& GetPaintRect() const               { return prc; }

protected:
	PaintRect        prc;
};

template <class T>
WithDisplay<T>::WithDisplay()
: prc(StdDisplay())
{
}

template <class T>
void WithDisplay<T>::Paint(Draw& draw)
{
	prc.Paint(draw, Rect(this->GetSize()), SBlack, SLtGray, 0);
}

template <class T>
class NotNullCtrl : public T
{
public:
	virtual Value  GetData() const;
};

template <class T>
Value NotNullCtrl<T>::GetData() const
{
	Value value = T::GetData();
	if(value.IsError() || !value.IsNull())
		return value;
	return ErrorValue("Hodnota nesm bt przdn.");
}

template <class T>
class WithDropFiles : public T
{
public:
	WithDropFiles() : registered(false) {}


	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
#line 239 "u:\\uppsrc\\tctrllib\\template.h"
	virtual void    DropFiles(Point pt, const Vector<String>& file_list) = 0;

private:
	bool            registered;
};


template <class T>
LRESULT WithDropFiles<T>::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	if(!registered && this->GetHWND())
	{
		registered = true;
		DropFilesRegister(this->GetHWND());
	}
	if(registered && message == 0x0233)
	{
		Point pt = DropFilesGetPos(wParam);
		DropFiles(pt, DropFilesGetList(wParam));
		return 0;
	}
	return T::WindowProc(message, wParam, lParam);
}
#line 263 "u:\\uppsrc\\tctrllib\\template.h"

template <class T>
class WithBar : public T
{
public:
	virtual void RightDown(Point pt, dword keyflags);
	virtual bool Key(dword key, int repcnt);

public:
	Callback1<Bar&> WhenBar;
};

template <class T>
void WithBar<T>::RightDown(Point pt, dword keyflags)
{
	MenuBar::Execute(WhenBar);
}

template <class T>
bool WithBar<T>::Key(dword key, int repcnt)
{
	return MenuBar::Scan(WhenBar, key) || T::Key(key, repcnt);
}

};
#line 10 "u:/uppsrc\\TCtrlLib/TCtrlLib.h"

#line 1 "u:\\uppsrc\\tctrllib\\Ruler.h"
namespace Upp {

class RulerCtrl : public FrameCtrl<Ctrl>
{
public:
	RulerCtrl();
	virtual ~RulerCtrl();

	void            Horz(bool bottom = false)         { is_vert = false; is_right = bottom; Refresh(); }
	void            Vert(bool right = false)          { is_vert = true; is_right = right; Refresh(); }
	bool            IsVert() const                    { return is_vert; }
	bool            IsBottomRight() const             { return is_right; }
	int             GetLength() const                 { return is_vert ? GetSize().cy : GetSize().cx; }

	void            SetWidth(int w)                   { width = w; RefreshParentLayout(); }
	int             GetWidth() const                  { return width; }

	void            SetZoom(double scale, double delta);

	void            SetScale(double scale)            { SetZoom(scale, GetDelta()); }
	double          GetScale() const                  { return scale; }

	void            SetDelta(double delta)            { SetZoom(GetScale(), delta); }
	double          GetDelta() const                  { return delta; }

	void            MinMax(double min, double max);
	double          GetMin() const                    { return min_range; }
	double          GetMax() const                    { return max_range; }

	void            SetCursor(double pos);
	void            KillCursor()                      { SetCursor(Null); }
	double          GetCursor() const                 { return cursor; }

	void            AutoSelect()                      { autoselect = true; }
	void            NoAutoSelect()                    { autoselect = false; }

	void            PickSmallStep( Vector<double>& pos, double repeat = Null);
	void            SetSmallStep(double delta);

	void            PickTextStep( Vector<double>& pos,  Vector<String>& texts, double repeat, const Convert& convert = NoConvert());
	void            SetTextStep(double repeat, const Convert& convert = NoConvert());

	void            SetFont(Font f)                   { font = f; Refresh(); }
	Font            GetFont() const                   { return font; }

	void            SetBackground(Color bg)           { background = bg; Refresh(); }
	Color           GetBackground() const             { return background; }

	void            SetOuterColor(Color bg)           { outer_color = bg; Refresh(); }
	Color           GetOuterColor() const             { return outer_color; }

	double          FromClient(double client) const   { return (client - GetRawDelta()) / scale; }
	double          ToClientf(double pos) const       { return pos * scale + GetRawDelta(); }
	int             ToClient(double pos) const        { return fround(ToClientf(pos)); }

	double          Snap(double v) const;

	virtual void    Layout();
	virtual void    FrameLayout(Rect& rc);
	virtual void    FrameAddSize(Size& sz);
	virtual void    Paint(Draw& draw);

	void            SetLabel(const char *s)           { label_text = s; Refresh(); }

	virtual void    LeftDown(Point pt, dword keyflags);
	virtual void    LeftUp(Point pt, dword keyflags);
	virtual void    RightDown(Point pt, dword keyflags);
	virtual void    MouseMove(Point pt, dword keyflags);

	static int      GetStdWidth();
	void            RefreshCursor(double cursor);

	virtual void    SetData(const Value& v);
	virtual Value   GetData() const;

public:
	Callback1<Bar&> WhenBar;
	Callback1<double> WhenSelect;
	Callback        WhenLeftClick;

private:
	double          GetRawDelta() const;

private:
	int             width;
	double          scale, delta;
	mutable double  raw_delta;
	double          min_range, max_range;
	Vector<double>  small_step;
	double          small_repeat;
	Vector<double>  text_step;
	Vector<String>  text_value;
	const Convert  *text_convert;
	double          text_repeat;
	double          cursor;
	Font            font;
	bool            is_vert;
	bool            is_right;
	bool            autoselect;
	String          label_text;
	Color           background;
	Color           outer_color;

	enum
	{
		ARROW_DIAM  = 7,
		ARROW_RAD   = (ARROW_DIAM + 1) >> 1,
		ARROW_WIDTH = 5,
	};
};

class HRulerCtrl : public RulerCtrl { public: HRulerCtrl() { Horz(); } };
class VRulerCtrl : public RulerCtrl { public: VRulerCtrl() { Vert(); } };

};
#line 12 "u:/uppsrc\\TCtrlLib/TCtrlLib.h"
#line 1 "u:\\uppsrc\\tctrllib\\DocMgr.h"
namespace Upp {


#line 1 "u:/uppsrc\\CtrlCore/lay.h"







#line 1 "u:/uppsrc\\TCtrlLib/DocMgr.lay"
struct DocListWindowsLayout__layid {};






struct DocListSaveLayout__layid {};







struct DocListNewLayout__layid {};




#line 9 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/uppsrc\\TCtrlLib/DocMgr.lay"
template<class T> struct WithDocListWindowsLayout : public T, public DocListWindowsLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(400, 200); }
	ArrayCtrl window_list;
	Button ok;
	Button close;
	Button cancel;
};

template<class T> struct WithDocListSaveLayout : public T, public DocListSaveLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(276, 296); }
	Label dv___0;
	ArrayCtrl list;
	Button ok;
	Button no;
	Button cancel;
};

template<class T> struct WithDocListNewLayout : public T, public DocListNewLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(234, 110); }
	ArrayCtrl types;
	Button ok;
	Button cancel;
};
#line 23 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/uppsrc\\TCtrlLib/DocMgr.lay"
template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, DocListWindowsLayout__layid&) { parent.LayoutId("DocListWindowsLayout");
	layout.window_list.AutoHideSb(true).HSizePosZ(4, 4).VSizePosZ(4, 32); layout.window_list.LayoutId("window_list"); parent.Add(layout.window_list);
	layout.ok.SetLabel(t_GetLngString("&Activate")).LeftPosZ(4, 80).BottomPosZ(4, 22); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.close.SetLabel(t_GetLngString("&Close window")).LeftPosZ(89, 80).BottomPosZ(4, 22); layout.close.LayoutId("close"); parent.Add(layout.close);
	layout.cancel.SetLabel(t_GetLngString("Close &list")).RightPosZ(4, 80).BottomPosZ(4, 22); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, DocListSaveLayout__layid&) { parent.LayoutId("DocListSaveLayout");
	layout.dv___0.SetLabel(t_GetLngString("Some files have been changed since last save.\nSelect files you want to save to the disk.")).HSizePosZ(4, 4).TopPosZ(2, 30); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.list.AutoHideSb(true).HSizePosZ(4, 4).VSizePosZ(36, 32); layout.list.LayoutId("list"); parent.Add(layout.list);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(4, 80).BottomPosZ(4, 22); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.no.SetLabel(t_GetLngString("&Don't save")).LeftPosZ(88, 80).BottomPosZ(4, 22); layout.no.LayoutId("no"); parent.Add(layout.no);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).RightPosZ(4, 80).BottomPosZ(4, 22); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, DocListNewLayout__layid&) { parent.LayoutId("DocListNewLayout");
	layout.types.AutoHideSb(true).HSizePosZ(4, 92).VSizePosZ(4, 4); layout.types.LayoutId("types"); parent.Add(layout.types);
	layout.ok.SetLabel(t_GetLngString("OK")).RightPosZ(4, 80).TopPosZ(4, 22); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).RightPosZ(4, 80).TopPosZ(30, 22); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};
#line 37 "u:/uppsrc\\CtrlCore/lay.h"







#line 5 "u:\\uppsrc\\tctrllib\\DocMgr.h"

class DlgFile;

class DocType;
class DocCtrl;
class DocList;

class DocType : Moveable<DocType>
{
public:
	DocType(DocCtrl *(*create_doc)() = 0);

	int              GetIndex() const;

	DocType&         Icon(Image l, Image s)         { large_icon = l; small_icon = s; return *this; }
	DocType&         SmallIcon(Image s)             { small_icon = s; return *this; }
	DocType&         LargeIcon(Image l)             { large_icon = l; return *this; }
	Image            GetSmallIcon() const           { return small_icon; }
	Image            GetLargeIcon() const           { return large_icon; }
	Image            GetIcon(bool s) const          { return s ? small_icon : large_icon; }

	DocType&         Paper(Color _paper)            { paper = _paper; return *this; }
	Color            GetPaper() const               { return paper; }

	DocType&         DocName(const char *_ndn);
	String           GetDocName() const             { return doc_name; }

	DocType&         EnableNewList(bool en = true)  { new_list = en; return *this; }
	DocType&         DisableNewList()               { return EnableNewList(false); }
	bool             IsNewListEnabled() const       { return new_list; }

	DocType&         Filter(const char *_filter, const char *_defext);
	String           GetFilter() const              { return filter; }
	String           GetExt() const                 { return extensions; }

	DocType&         DefaultName(String dn)         { default_name = dn; return *this; }
	String           GetDefaultName() const         { return default_name; }

	DocType&         StreamName(const char *sn);
	String           GetStreamName() const;
	static const DocType *FindStreamName(String sn);

	DocType&         HelpTopic(const char *_ht);
	String           GetHelpTopic() const           { return help_topic; }

	DocType&         CreateDoc(DocCtrl *(*c)())     { create_doc = c; return *this; }
	DocCtrl       *(*GetCreateDoc() const)()        { return create_doc; }

	DocType&         DetectDoc(bool (*d)(Stream&))  { detect_doc = d; return *this; }
	bool           (*GetDetectDoc() const)(Stream&) { return detect_doc; }

	DocCtrl         *CreateDocument(DocList& list) const;

	static const DocType *GetDocType(const char *filename);

	static DocCtrl  *CreateDefaultDocument(DocList& list);
	static DocCtrl  *CreateAnyDocument(DocList& list);

	static void      SetOpenFileDlg(FileSelector& fsel);
	void             SetSaveFileDlg(FileSelector& fsel) const;

public:
	DocCtrl       *(*create_doc)();
	bool           (*detect_doc)(Stream& stream);

	String           stream_name;
	String           doc_name;
	String           filter;
	String           extensions;
	String           default_name;
	String           help_topic;
	Image            small_icon;
	Image            large_icon;
	bool             new_list;

	Color            paper;

	static Vector<const DocType*> doc_types;

	static int      Add(const DocType& doctype);
};

class DocCtrl : public TopWindow
{
	friend class DocList;

public:
	typedef DocCtrl CLASSNAME;

	DocCtrl();
	DocCtrl(const DocCtrl& another)                       { ; }
	virtual ~DocCtrl();

	DocCtrl&         SetDocType(const DocType *type)      { doc_type = type; return *this; }
	const DocType   *GetDocType() const                   { return doc_type; }

	DocCtrl&         SetDocList(DocList *list);
	DocList         *GetDocList() const                   { return doc_list; }

	void             SetActive(bool kill_init = false);
	virtual void     Activate();

	virtual void     Serialize(Stream& stream);

	virtual bool     New();
	virtual bool     Open(const char *doc, bool rdonly = false);
	virtual bool     Save(const char *as);
	virtual bool     CloseDoc();

	bool             IsOpenDoc() const { return !IsNull(filename); }

	virtual bool     IsTopWindow() const;





	bool             SaveAs(const char *fn = 0);

	enum
	{
		NONE,

		OPENWINDOW,

		UNTOUCH,
		TOUCH,

		READ_ONLY,
		WRITEABLE,

		RENAME,
		APPNAME,

		NEW,
		OPEN,
		CLOSE,

		OTHER_REASON,
	};

	virtual void     Change(int reason);
	virtual void     State(int reason);

	DocCtrl&         SetReadOnly(bool _ro = true);
	DocCtrl&         SetWriteable()               { return SetReadOnly(false); }
	bool             IsReadOnly() const           { return is_read_only; }

	void             Touch(bool _touch = true);
	void             DoTouch()                    { Touch(true); }
	void             Untouch()                    { Touch(false); }
	bool             IsDirty() const              { return is_dirty; }

	bool             IsUnnamed() const            { return is_unnamed; }
	bool             IsClosing() const            { return is_closing; }

	virtual bool     FlushDirty();

	void             DoClose();

	virtual bool     HotKey(dword key);
	virtual void     Paint(Draw& draw);

	virtual void     ClipboardChanged()           { Rescan(); }

	void ToolFileSave(Bar& bar); void OnFileSave(); static void HelpFileSave();
	void ToolFileSaveAs(Bar& bar); void OnFileSaveAs(); static void HelpFileSaveAs();
	void ToolFileClose(Bar& bar); void OnFileClose(); static void HelpFileClose();

	void             ToolFile(Bar& bar);

	void ToolWindowToolBar(Bar& bar); void OnWindowToolBar(); static void HelpWindowToolBar();
	void ToolWindowInfoBar(Bar& bar); void OnWindowInfoBar(); static void HelpWindowInfoBar();

	void             ToolWindow(Bar& bar);
	void             AddToolWindow(Bar& bar);

	void ToolHelpContents(Bar& bar); void OnHelpContents(); static void HelpHelpContents();
	void ToolHelpSearch(Bar& bar); void OnHelpSearch(); static void HelpHelpSearch();
	void ToolHelpBook(Bar& bar); void OnHelpBook(); static void HelpHelpBook();

	void             ToolHelp(Bar& bar);

	virtual void     BarView(Bar& bar);
	virtual void     BarTool(Bar& bar);

	virtual void     Rescan();

	void             OnWindowActivate();
	void             OnWindowClose();

	void             SetName(String name, bool clear_unnamed = true);
	String           GetName() const { return filename; }

	virtual String   GetDirtyName() const;
	virtual String   GetShortName() const;
	virtual String   GetFullName() const;

	virtual String   QueryFileName();

public:
	MenuBar          menu_bar;
	ToolBar          tool_bar;
	StatusBar        info_bar;















protected:
	void             PostClose();

protected:
	const DocType   *doc_type;
	DocList         *doc_list;
	String           filename;
	bool             is_dirty;
	bool             is_unnamed;
	bool             is_read_only;
	bool             is_closing;
};

class DocList : public WithDocListWindowsLayout<TopWindow>
{
	friend class DocCtrl;

public:
	typedef DocList        CLASSNAME;
	typedef Array<DocCtrl> DocVector;

	DocList();

	virtual void       Serialize(Stream& stream);

	DocCtrl           *OpenDoc(const char *filename, int type_index = -1);
	bool               OpenExistingDoc(const char *filename);

	virtual DocList&   AppName(const char *app_name);
	String             GetAppName() const                 { return app_name; }

	DocList&           StoreDocs(bool _sd = true)         { store_docs = _sd; return *this; }
	DocList&           NoStoreDocs()                      { return StoreDocs(false); }
	bool               IsStoreDocs() const                { return store_docs; }

	int                GetIndex(const DocCtrl *doc) const { return doc_list.GetIndex(*doc); }
	int                GetDocCount() const                { return doc_list.GetCount(); }
	DocCtrl&           GetDoc(int i)                      { return doc_list[i]; }
	const DocCtrl&     GetDoc(int i) const                { return doc_list[i]; }
	const DocVector&   GetDocVector() const               { return doc_list; }

	Vector<DocCtrl *>  FindDoc(const DocType& type) const;
	bool               IsDocAvail(const DocType& type) const;

	int                GetNextDocIndex()                  { return ++doc_counter; }

	void               SetActive(int index, bool kill_init = false);
	DocCtrl           *GetActive();
	const DocCtrl     *GetActive() const;
	int                GetActiveIndex() const;

	int                FindDoc(const char *filename) const;

	bool               Close(int index);

	void               AddLRU(const DocCtrl *doc);
	void               AddLRU(const char *doc_name, const DocType *type);
	void               RemoveLRU(const char *doc_name);

	DocList&           SetRecentPath(String path)         { recent_path = path; return *this; }
	String             GetRecentPath() const              { return recent_path; }

	virtual void       Activate();
	virtual void       Change(DocCtrl& doc, int change);

	void               Maximize(bool _maximize)           { maximize = _maximize; }
	bool               IsMaximize() const                 { return maximize; }

	void ToolFileNew(Bar& bar); void OnFileNew(); static void HelpFileNew();
	void ToolFileNewDefault(Bar& bar); void OnFileNewDefault(); static void HelpFileNewDefault();
	void ToolFileOpen(Bar& bar); void OnFileOpen(); static void HelpFileOpen();
	void ToolFileSaveAll(Bar& bar); void OnFileSaveAll(); static void HelpFileSaveAll();
	bool               ToolFileLru(Bar& bar);
	void               OnFileLru(int index);
	void ToolFileQuit(Bar& bar); void OnFileQuit(); static void HelpFileQuit();

	void               ToolFileIo(Bar& bar, DocCtrl *doc);

	void ToolFileMisc(Bar& bar); void OnFileMisc(); static void HelpFileMisc();

	void ToolWindowActivate(Bar& bar); void OnWindowActivate(); static void HelpWindowActivate();
	void ToolWindowList(Bar& bar); void OnWindowList(); static void HelpWindowList();
	void ToolWindowPrev(Bar& bar); void OnWindowPrev(); static void HelpWindowPrev();
	void ToolWindowNext(Bar& bar); void OnWindowNext(); static void HelpWindowNext();

	void ToolHelpContents(Bar& bar); void OnHelpContents(); static void HelpHelpContents();
	void ToolHelpSearch(Bar& bar); void OnHelpSearch(); static void HelpHelpSearch();
	void ToolHelpBook(Bar& bar); void OnHelpBook(); static void HelpHelpBook();

	void               OnRemove();
	void               OnActivate();
	void               OnClose();

	void               StdBar(Bar& bar);

	virtual int        SaveAll();
	virtual bool       CloseAll(bool save = true);

	void               Run();

protected:
	virtual void       Insert(DocCtrl *document);
	virtual void       Remove(DocCtrl *document);
	virtual void       Detach(DocCtrl *document);
	virtual void       Raise(DocCtrl *document);

	void               RefreshTable();
	void               UpdateTable(int new_ix = Null);

	void               Destroy();
	void               SetActiveTop(DocCtrl *ignore = 0);

protected:
	struct DocInfo
	{
		DocInfo() {}

		DocInfo& Name(String _name) { name = _name; return *this; }
		DocInfo& Type(String _type) { type = _type; return *this; }

		String name;
		String type;

		void Serialize(Stream& stream);
	};

	bool            store_docs;
	bool            lock;
	bool            maximize;
	String          app_name;
	int             doc_counter;
	DocVector       doc_list;
	Array<DocInfo>  lru;
	Array<DocInfo>  old_docs;
	String          recent_path;
};

template <class T>
T *CreateDocument(DocList& doclist, T * = 0)
{
	DocCtrl *doc = T::GetType().CreateDocument(doclist);
	T *t = 0;
	if(doc && !(t = dynamic_cast<T *>(doc)))
		doc -> DoClose();
	return t;
}

template <class T>
Vector<T *> FindAllDocuments(DocList& doclist, T * = 0)
{
	Vector<T *> sum;
	for(int i = 0; i < doclist.GetDocCount(); i++)
	{
		T *doc = dynamic_cast<T *>(&doclist.GetDoc(i));
		if(doc && !doc -> IsClosing())
			sum.Add(doc);
	}
	return sum;
}












#line 396 "u:\\uppsrc\\tctrllib\\DocMgr.h"

};
#line 13 "u:/uppsrc\\TCtrlLib/TCtrlLib.h"

#line 15 "u:/uppsrc\\TCtrlLib/TCtrlLib.h"
#line 5 "u:/idisapp\\BWC/BWC.h"
#line 1 "u:/uppsrc\\SqlCtrl/SqlCtrl.h"








































































































































































































































#line 6 "u:/idisapp\\BWC/BWC.h"
#line 1 "u:/uppsrc\\DocTypes/DocTypes.h"












































































































































































































































































































































































































































































































































































































































































































































#line 7 "u:/idisapp\\BWC/BWC.h"

using namespace Upp;

#line 1 "u:\\idisapp\\bwc\\TableCtrl.h"


namespace Upp {
class Bar;
};

class BaseTable : public Ctrl {
public:
	virtual void Paint(Draw& w);
	virtual void Layout();
	virtual void LeftDown(Point p, dword keyflags);
	virtual void LeftDouble(Point p, dword keyflags);
	virtual void MouseMove(Point p, dword keyflags);
	virtual void MouseWheel(Point p, int zdelta, dword keyflags);
	virtual void GotFocus();
	virtual void LostFocus();
	virtual bool Key(dword key, int);
	virtual bool Accept();
	virtual void Reject();
	virtual void ChildGotFocus();
	virtual void ChildLostFocus();

protected:
	virtual void  PaintCell(Draw& w, const Rect& r, int row, int column,
		                    Color ink, Color paper, dword style) = 0;

	virtual void  EnterRow();
	virtual void  LeaveRow();
	virtual void  CancelRow();

	virtual void  Append();

	virtual Ctrl *Editor(int column);
	virtual void  ActivateEdit(int column);

			void  SetRows();

protected:
	HeaderCtrl header;
	ScrollBar  scrollbar;
	int        rowcy;
	int        cursor, editcolumn;
	int        append;
	int        rows;

	Color      fillcolor;

	bool       editmode:1;

	bool       vertgrid:1;
	bool       horzgrid:1;
	bool       nocursor:1;
	bool       mousemove:1;
	bool       persistentedit;

	void       Page(int q);
	int        FindColumn(int posx);
	void       SetEditPos();
	void       Scroll();
	void       SbSet();
	void       StopEdit();
	bool       StartEdit();
	void       OtherEdit();
	void       DoPoint(Point p);
	int        GetAppendCy()                           { return append < 0 ? rowcy : append; }

public:
	virtual int GetRows() const = 0;

	Callback    WhenLeftClick;
	Callback    WhenLeftDouble;
	Callback    WhenBeginEdit;
	Callback    WhenCursor;

	HeaderCtrl::Column& SetHeaderColumn(int i)         { return header.Tab(i); }
	const HeaderCtrl::Column& GetHeaderColumn(int i)   { return header.Tab(i); }

	void       SerializeHeader(Stream& s)              { header.Serialize(s); }

	void       SetColumnAction(int i, Callback b)      { header.Tab(i).WhenAction = b; }

	void       ShowColumn(int i, bool show)            { header.ShowTab(i, show); }
	void       HideColumn(int i)                       { ShowColumn(i, false); }
	bool       IsColumnVisible(int i)                  { return header.IsTabVisible(i); }
	void       SetColumnWidth(int i, int w)            { header.SetTabWidth(i, w); }
	int        GetColumnWidth(int i)                   { return header.GetTabWidth(i); }
	void       SetColumnRatio(int i, int w)            { header.SetTabRatio(i, w); }
	int        GetColumnRatio(int i) const             { return (int)header.GetTabRatio(i); }

	int        GetColumns() const                      { return header.GetCount(); }
	Rect       GetCellRect(int row, int column);

	void       RefreshCell(int i, int j)               { Ctrl::Refresh(GetCellRect(i, j)); }
	void       RefreshRow(int row);

	bool       SetCursor(int _cursor = 0);
	void       SetCursorNextRow();
	void       SetCursorPrevRow();
	void       GoBegin();
	void       GoEnd();
	void       GoCursor(int _cursor);
	int        GetCursor() const                       { return cursor; }
	bool       KillCursor()                            { return SetCursor(-1); }
	bool       ReCursor();
	void       CancelCursor();
	bool       IsCursor() const                        { return cursor >= 0; }
	void       RefreshCursor()                         { RefreshRow(cursor); }
	int        GetCursorSc() const;
	void       ScCursor(int a);
	void       TopCursor();
	void       CenterCursor();
	void       CenterCursorLn();
	void       BottomCursor();

	int        GetEditColumn() const                   { return editcolumn; }
	int        GetClickColumn() const                  { return editcolumn; }

	int        GetFirstEditor();
	bool       Edit(int column);
	bool       IsEdit() const                          { return editmode; }

	BaseTable& Header(bool b = true);
	BaseTable& NoHeader()                              { return Header(false); }
	BaseTable& Track(bool b = true)                    { header.Track(b); return *this; }
	BaseTable& NoTrack()                               { return Track(false); }
	BaseTable& VertGrid(bool b = true)                 { vertgrid = b; Refresh(); return *this; }
	BaseTable& NoVertGrid()                            { return VertGrid(false); }
	BaseTable& HorzGrid(bool b = true)                 { horzgrid = b; Refresh(); return *this; }
	BaseTable& NoHorzGrid()                            { return HorzGrid(false); }
	BaseTable& Grid(bool b = true)                     { return VertGrid().HorzGrid(); }
	BaseTable& NoGrid()                                { return NoVertGrid().NoHorzGrid(); }
	BaseTable& NoCursor(bool b = true)                 { nocursor = b; Refresh(); return *this; }
	BaseTable& MouseMoveCursor(bool b = true)          { mousemove = b; return *this; }
	BaseTable& NoMouseMoveCursor()                     { return MouseMoveCursor(false); }
	BaseTable& AutoHideSb(bool b = true)               { scrollbar.AutoHide(b); return *this; }
	BaseTable& NoAutoHideSb()                          { return AutoHideSb(false); }
	BaseTable& PersistentEdit(bool b = true)           { persistentedit = b; return *this; }
	BaseTable& NoPersistentEdit()                      { return PersistentEdit(false); }
	BaseTable& AppendLine(int height = -1)             { append = height; return *this; }
	BaseTable& NoAppendLine()                          { return AppendLine(0); }
	BaseTable& FillColor(Color color)                  { fillcolor = color; return *this; }

	BaseTable& SetRowCy(int _rowcy);
	int        GetRowCy() const                        { return rowcy; }

	bool       IsEmpty() const                         { return GetRows() == 0; }

	void       Reset();

	const HeaderCtrl& GetHeader() const                { return header; }

	BaseTable();
};

class TableArray : public BaseTable {
public:
	virtual void  RightDown(Point, dword keyflags);
	virtual bool  Key(dword key, int);
	virtual bool  Accept();
	virtual int   GetRows() const;

protected:
	virtual void  PaintCell(Draw& w, const Rect& r, int row, int column,
		                    Color ink, Color paper, dword style);
	virtual Ctrl *Editor(int column);
	virtual void  ActivateEdit(int column);
	virtual void  EnterRow();
	virtual void  LeaveRow();
	virtual void  CancelRow();

	virtual void  Append();

public:
	enum {
		ROWNUM    = -1,
		MULTI     = -2,

		CTRL      = -1,
	};

	class MultiConvert {
	public:
		virtual Value Format(const Vector<Value>&) const = 0;
	};

	class Order {
	public:
		virtual bool operator()(const Vector<Value>& row1, const Vector<Value>& row2) const = 0;
	};

	class Item {
		TableArray         *tab;
		int                 index;
		int                 column;

		const Display      *display;

		Ctrl               *ctrl;
		Callback            activate;

		ValueGen           *insertgen;
		Value               insertval;

		const Convert      *convert;
		const MultiConvert *mconvert;

		struct MultiItem {
			Id             id;
			int            index;
			Value          value;
			const Convert *convert;
		};

		Array<MultiItem>    mitem;
		Vector<Value>       cache;
		Vector<String>      sache;

		bool                nocache:1;
		bool                update:1;
		bool                insert:1;

		Value          GetMulti(int row);
		Value          GetValue(int row);
		void           ClearCache()           { cache.Clear(); sache.Clear(); }
		void           ShrinkCache()          { cache.Shrink(); sache.Shrink(); }
		bool           IsControl()            { return column < 0 && ctrl; }
		bool           IsColumn()             { return column >= 0; }
		bool           IsMulti()              { return column >= 0 && index == MULTI; }
		bool           IsValue()              { return column < 0 && ctrl == 0; }
		void           UpdateCache(int i);
		void           InsertCache(int i);
		void           RemoveCache(int i);


		friend class TableArray;

	public:
		Item& SetDisplay(const Display& d)       { ; display = &d; return *this; }
		Item& SetConvert(const Convert& c)       { ; convert = &c; return *this; }
		Item& NoCache()                          { nocache = true; return *this; }
		Item& Update(bool b = true)              { update = b; return *this; }
		Item& NoUpdate()                         { return Update(false); }
		Item& Insert(bool b = true)              { insert = b; return *this; }
		Item& NoInsert()                         { return Insert(false); }
		Item& ReadOnly()                         { return NoUpdate().NoInsert(); }
		Item& Editable()                         { return Update().Insert(); }
		Item& SetEdit(Ctrl& c);
		Item& Edit(Ctrl& c)                      { return SetEdit(c).Editable(); }
		Item& ActivateEdit(Callback x)           { activate = x; return *this; }
		Item& ActivateEdit(Ctrl& c, Callback x)  { return ActivateEdit(x).Edit(c); }
		Item& InsertValue(const Value& v)        { insertval = v; return *this; }
		Item& InsertValue(ValueGen& x)           { insertgen = &x; return *this; }

		Item& SetConvert(const MultiConvert& c)  { ; mconvert = &c; return *this; }
		Item& Add(Id id);
		Item& Add(Id id, const Convert& cv);
		Item& Add(const Value& v);
		Item& Add(const char *s);
		Item& Add(const String& s);

		Item& Key();
		Item& Join(TableArray& master, Id id);
		Item& Join(TableArray& master);

		Item& HeaderAction(Callback cb)          { SetHeaderColumn().WhenAction = cb; return *this; }

		Item& Accel()                            { ; tab->SetAccel(index);
		                                           return *this; }

		HeaderCtrl::Column& SetHeaderColumn()              { return tab->header.Tab(column); }
		const HeaderCtrl::Column& GetHeaderColumn() const  { return tab->header.Tab(column); }

		int   GetColumn() const                            { return column; }

		Ctrl *GetCtrl()                                    { return ctrl; }
		const Ctrl *GetCtrl() const                        { return ctrl; }

		Item();
	};

protected:
	virtual void   Load();

	virtual bool   RowUpdate();
	virtual bool   RowInsert();
	virtual bool   RowRemove();
	virtual bool   QueryRemove();

	bool           CancelUpdate();
	bool           CancelInsert();

public:
	virtual bool   DeleteQuery();

protected:
	struct Join {
		int            index;
		TableArray    *master;
		Id             masterid;
	};

	Index<Id>                         index;
	Array<Item>                       item;
	Vector<Item *>                    column;
	Vector< Vector<Value> >           cell;
	Vector< Vector<const Display *> > display;
	Vector<bool>                      modify;
	Vector<Value>                     actual;
	Vector<Ctrl *>                    ctrl;
	Array<Join>                       join;
	Vector<TableArray *>              detail;

	int                         key;
	int                         accel;
	Value                       insertkeyval;
	ValueGen                   *insertkeygen;

	bool                        insertmode:1;

	bool                        removing:1;
	bool                        inserting:1;
	bool                        askremove:1;
	bool                        iappend:1;
	bool                        goendpostquery:1;
	bool                        duplicating:1;

	void SetAssert();
	void PostAdd();
	void UpdateCache(int row);
	void InsertCache(int row);
	void RemoveCache(int row);
	void Init();
	void RemoveRow0(int row);
	void InsertRow0(int row);
	void DetailsQuery();
	void SaveRow();
	void ClearRowModify();
	Vector<Value>& SetRow(int i);
	Vector<Value>& Add()        { return SetRow(GetRows()); }
	bool TestKey(int row, int c);

	struct ItemOrder;
	friend class Item;

public:
	Callback1<Bar&> WhenBar;
	Callback        WhenPostQuery;
	Callback        WhenEnterRow;
	Callback        WhenUpdateInsertRemove;

	void            StdBar(Bar& m);

	void            EnableDetails(bool en);
	void            Enable(bool en = true);

	int             AddIndex(Id id = Id());

	int             AddKey(Id id);
	int             AddKey(Id id, const Value& ikv)      { insertkeyval = ikv; return AddKey(id); }
	int             AddKey(Id id, ValueGen& ikg)         { insertkeygen = &ikg; return AddKey(id); }

	int             AddJoin(Id id, TableArray& master, Id masterid);
	int             AddJoin(Id id, TableArray& master);

	Item&           AddItem(int index);
	Item&           AddItem(Id id);
	Item&           AddItem();

	Item&           AddColumn(int index, const char *label, int lw = 0);
	Item&           AddColumn(Id id, const char *label, int lw = 0);
	Item&           AddColumn(const char *label = 0, int lw = 0);
	Item&           AddRowNumColumn(const char *label, int lw = 0);
	Item&           AddMultiColumn(const char *label, int lw = 0);
	Item&           AddNextColumn(const char *label, int lw = 0);

	Item&           AddControl(int index, Ctrl& ctrl);
	Item&           AddControl(Id id, Ctrl& ctrl);
	Item&           AddControl(Ctrl& ctrl);
	Item&           AddRowNumControl(Ctrl& ctrl);
	Item&           AddMultiControl(Ctrl& ctrl);
	Item&           AddNextControl(Ctrl& ctrl);

	void            SetAccel(int i)                      { accel = i; }

	bool            IsUpdating() const;

	void            Reset();

	int             GetItems() const                 { return item.GetCount(); }
	Item&           GetItem(int i)                   { return item[i]; }
	const Item&     GetItem(int i) const             { return item[i]; }
	Item&           GetItem(Id id);
	const Item&     GetItem(Id id) const;

	Item&           GetColumn(int i)                 { return *column[i]; }
	const Item&     GetColumn(int i) const           { return *column[i]; }

	void            ShowColumn(int i, bool s = true) { BaseTable::ShowColumn(i, s); }
	void            HideColumn(int i)                { BaseTable::HideColumn(i); }
	void            ShowColumn(Id id, bool s = true) { ShowColumn(GetItem(id).column, s); }
	void            HideColumn(Id id)                { HideColumn(GetItem(id).column); }
	bool            IsColumnVisible(int i)           { return BaseTable::IsColumnVisible(i); }
	bool            IsColumnVisible(Id id)           { return IsColumnVisible(GetItem(id).column); }
	void            SetColumnWidth(int i, int w)     { BaseTable::SetColumnWidth(i, w); }
	void            SetColumnWidth(Id id, int w)     { SetColumnWidth(GetItem(id).column, w); }

	class CellProxy {
		TableArray& tab;
		int i, j;
	public:
		CellProxy& operator=(const Value& val)      { tab.SetCell(i, j, val); return *this; }
		operator Value() const                      { return tab.GetCell(i, j); }
		CellProxy(TableArray& tab, int i, int j) : tab(tab), i(i), j(j) {}
	};
	class RowProxy {
		TableArray& tab;
		int         i;
	public:
		CellProxy operator[](int j)                 { return CellProxy(tab, i, j); }
		CellProxy operator[](Id id)                 { return CellProxy(tab, i, tab.GetIndex(id)); }
		operator const Vector<Value>&()             { return tab.GetRow(i); }
		RowProxy(TableArray& tab, int i) : tab(tab), i(i) {}
	};

	void           RemoveRow(int row);
	void           InsertRow(int row, const Vector<Value>& x);

	void           SetRow(int row, const Vector<Value>& x);
	void           SetPickRow(int row, Vector<Value>& x);
	void           AddRow(const Vector<Value>& x)   { SetRow(GetRows(), x); }
	void           AddPickRow(Vector<Value>& x)     { SetPickRow(GetRows(), x); }
	const Vector<Value>& GetRow(int i) const;

	void           AddRow()                         { SetRow(GetRows()); }
	void           SetRows(int n);

	const Vector<Value>& operator[](int i) const    { return GetRow(i); }
	RowProxy operator[](int i)                      { return RowProxy(*this, i); }

	void           SetCellDisplay(int i, int j, const Display& display);
	const Display& GetDisplay(int i, int j) const;


	void Add(Value p1); void Add(Value p1, Value p2); void Add(Value p1, Value p2, Value p3); void Add(Value p1, Value p2, Value p3, Value p4); void Add(Value p1, Value p2, Value p3, Value p4, Value p5); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37, Value p38); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37, Value p38, Value p39); void Add(Value p1, Value p2, Value p3, Value p4, Value p5, Value p6, Value p7, Value p8, Value p9, Value p10, Value p11, Value p12, Value p13, Value p14, Value p15, Value p16, Value p17, Value p18, Value p19, Value p20, Value p21, Value p22, Value p23, Value p24, Value p25, Value p26, Value p27, Value p28, Value p29, Value p30, Value p31, Value p32, Value p33, Value p34, Value p35, Value p36, Value p37, Value p38, Value p39, Value p40);

	int            GetIndexCount() const           { return index.GetCount(); }
	int            GetIndex(Id id) const           { return index.Find(id); }
	int            GetKeyIndex() const             { return key; }
	Id             GetId(int i) const              { return index[i]; }
	Id             GetKeyId() const                { return index[key]; }

	Value          Get(int i = 0) const;
	Value          Get(Id id) const;
	Value          GetKey() const                  { return IsCursor() ? Get(key) : Null; }
	bool           IsIndexModified(int i) const;
	bool           IsIndexModified(Id id) const;

	void           Set(int i, const Value& v);
	void           Set(Id id, const Value& v);

	void           SetCell(int i, int j, const Value& x);
	Value          GetCell(int i, int j) const;
	void           SetCell(int i, Id id, const Value& x);
	Value          GetCell(int i, Id id) const;

	Value          GetConverted(int i, int j);

	int            Find(const Value& val, int index = 0, int from = 0) const;
	int            Find(const Value& val, Id id, int from = 0) const;

	bool           FindSetCursor(const Value& val, int index = 0, int from = 0);
	bool           FindSetCursor(const Value& val, Id id, int from = 0);

	bool           IsInsertMode() const            { return insertmode; }

	virtual bool   BeginUpdate();
	virtual bool   BeginInsert(bool append = false);
	virtual bool   BeginDuplicate(bool append = false);
	virtual bool   Remove();

	void           VBeginUpdate();
	void           VBeginInsert();
	void           VBeginDuplicate();
	void           VRemove();

	bool           Query();

	void           Sort(const Order& order);

	void           Clear();
	void           Shrink();

	TableArray&    Inserting(bool b = true)         { inserting = b; return *this; }
	TableArray&    NoInserting()                    { return Inserting(false); }
	TableArray&    Removing(bool b = true)          { removing = b; return *this; }
	TableArray&    NoRemoving()                     { return Removing(false); }
	TableArray&    AppendInserting(bool b = true)   { inserting = iappend = b; return *this; }
	TableArray&    Duplicating(bool b = true)       { duplicating = b; return *this; }
	TableArray&    NoDuplicating()                  { return Duplicating(false); }
	TableArray&	   AskRemove(bool b = true)         { askremove = b; return *this; }
	TableArray&    NoAskRemove()                    { return AskRemove(false); }
	TableArray&    GoEndPostQuery(bool b = true)    { goendpostquery = b; return *this; }
	TableArray&    NoGoEndPostQuery()               { return GoEndPostQuery(false); }

	TableArray();
};

class TableCheck : public Pusher
{
public:
	TableCheck(const Value& value0 = "0", const Value& value1 = "1");

	const Value&   operator [] (bool b) const { return b ? value1 : value0; }
	Value&         operator [] (bool b)       { return b ? value1 : value0; }

	void           Set(bool b);
	bool           Get() const         { return checked; }

	TableCheck&    operator = (bool b) { Set(b); return *this; }
	operator bool () const             { return checked; }

	virtual Value  GetData();
	virtual void   SetData(const Value& value);

	virtual void   Paint(Draw& draw);
	virtual bool   Key(dword key, int);

protected:
	virtual void   PerformAction();

protected:
	Value          value0, value1;
	bool           checked;
};

class CheckDisplay : public Display
{
public:
	CheckDisplay(const Value& value0 = "0", const Value& value1 = "1");

	const Value&   operator [] (bool b) const { return b ? value1 : value0; }
	Value&         operator [] (bool b)       { return b ? value1 : value0; }

	virtual void Paint(Draw& w, const Rect& r, const Value& q, Color i, Color p, dword s) const;
	virtual Size GetStdSize(const Value& q) const;

protected:
	Value value0, value1;
};



const CheckDisplay& StdCheckDisplay();
const CheckDisplay& BoolCheckDisplay();
#line 11 "u:/idisapp\\BWC/BWC.h"

#line 1 "u:\\idisapp\\bwc\\HelpBook.h"






#line 1 "u:\\idisapp\\bwc\\help.h"










class HelpStyle;
class HelpPage;
class HelpIndex;

namespace Upp {
class DocReport;
};

class ProgressMeter;



extern String HelpAutoAnchor;



String GetHelpSeePageRef();
String GetHelpTitle(const char *t);




class HelpStyle
{
public:
	HelpStyle();

	virtual void   Clear();

	int            GetMode() const                { return mode; }

	Document&      Output()                       { return *output; }
	Document&      operator ~ ()                  { return Output(); }

	Document&      Output(Document& doc)          { output = &doc; return doc; }
	Document&      Body()                         { return Output(body); }
	Document&      Footnote();
	Document&      Contents()                     { return Output(contents); }

	bool           IsBody() const                 { return output == &body; }
	bool           IsFootnote() const             { return output == &footnote; }
	bool           IsContents() const             { return output == &contents; }

	bool           IsHypertext() const            { return hypertext; }
	bool           IsBook() const                 { return book; }

	virtual String Link(const char *destination, const char *text = 0,
		const char *ref = GetHelpSeePageRef(), const char *tag = 0);

	virtual void   Toc(int level, const char *title, const String& anchor);
	void           TocPage(int level, const HelpPage& page);
	void           TocPage(int level, const char *page);

	virtual void   Step();
	virtual void   Flush(int columns = 1);
	virtual void   Page(int columns = 1);
	virtual void   PutPage(const HelpPage& page, bool title = false);
	void           Put(const char *page, bool title = false);
	void           Put(const Document& doc);

	virtual void   PutIndex(bool title = true);
	virtual void   PutContents(bool title = true);

	void           AdvanceSection(int level);
	virtual String FormatSection() const;
	int            GetLevel() const               { return section_number.GetCount(); }
	const Vector<int>& GetSection() const         { return section_number; }

	void           LocalPrefix(const String& pfx);
	const String&  GetLocalPrefix() const         { return local_prefix; }
	void           PushAnchorPrefix(const String& pfx);
	void           PopAnchorPrefix();
	const String&  GetAnchorPrefix() const        { return anchor_prefix; }

	void           GetSymbolMap(Vector<String>& names, Vector<String>& values) const;
	void           PutSymbolMap();
	Index<String>  GetUndefinedSymbols() const;

	virtual Paragraph OuterAnchor(const char *anchor, const char *tail = 0);
	Paragraph      Anchor(const char *anchor, const char *tail = 0);
	void           SetAnchor(const char *anchor, const char *tail, const String& value);
	void           SetAnchor(const char *anchor, const String& value) { SetAnchor(anchor, 0, value); }
	virtual String GetAnchor(const char *anchor, const char *tail = 0) const;

	HelpStyle&     ChapterName(const String& cn)  { chapter_name = cn; return *this; }
	HelpStyle&     AppendixName(const String& an) { appendix_name = an; return *this; }
	HelpStyle&     IndexName(const String& in)    { index_name = in; return *this; }
	HelpStyle&     TocName(const String& tn)      { toc_name = tn; return *this; }

	const String&  GetChapterName() const         { return chapter_name; }
	const String&  GetAppendixName() const        { return appendix_name; }
	const String&  GetIndexName() const           { return index_name; }
	const String&  GetTocName() const             { return toc_name; }

	enum NUMBERING
	{
		NONE,
		ARABIC,
		UPPER_ROMAN,
		LOWER_ROMAN,
		UPPER_ALPHA,
		LOWER_ALPHA,
	};

	virtual void   Numbering(NUMBERING num, int pageno = 1);
	void           NoNumbering()                  { Numbering(NONE); }
	void           Arabic()                       { Numbering(ARABIC); }
	void           UpperRoman()                   { Numbering(UPPER_ROMAN); }
	void           LowerRoman()                   { Numbering(LOWER_ROMAN); }
	void           UpperAlphabetic()              { Numbering(UPPER_ALPHA); }
	void           LowerAlphabetic()              { Numbering(LOWER_ALPHA); }

	void           Appendix();

protected:
	String         chapter_name;
	String         appendix_name;
	String         index_name;
	String         toc_name;

	Document      *output;
	Document       body, footnote, contents, old_toc;
	Array<Document> footnotes;

	String         local_prefix;
	String         anchor_prefix;
	Vector<int>    anchor_prefix_stack;
	Index<String>  changing_anchors;
	Vector<int>    section_number;
	Index<String>  include_topics;
	mutable VectorMap<String, String> anchors;




	int            auto_anchor;
	bool           hypertext      : 1;
	bool           book           : 1;
	bool           appendix       : 1;
	bool           toc_used       : 1;
	bool           restart        : 1;
	bool           log_anchors    : 1;



	char           mode;
};

enum
{
	HELP_MODE_ONLINE,
	HELP_MODE_BOOK,
	HELP_MODE_HTML,
	HELP_MODE_RTF,
};



extern One<HelpStyle> (*CreateHelpStyle)();
extern HelpStyle       *help_style;





class HelpPage
{
public:
	HelpPage(const char *id, Callback generator, const char *title,
		const char *index_entries = 0, bool no_page_title = false);

	void            Run(const char *anchor = 0) const;
	void            Put(bool title = true) const;

	const char     *GetTitle() const { return title; }
	const char     *GetIndex() const { return index_entries; }	const String&   GetID() const    { return id; }
	bool            UseTitle() const { return !no_page_title; }

protected:
	HelpPage();

protected:
	Callback        generator;
	String          id;
	StringC         title;
	StringC         index_entries;
	bool            no_page_title;
};













class HelpIndex : Moveable<HelpIndex>
{
public:
	typedef VectorMap<String, const HelpPage *> IdMap;
	enum TAB { RECENT_TAB, TOPICS_TAB, INDEX_TAB, FULLTEXT_TAB };

	static HelpIndex& Get();

	void              Add(const HelpPage& page);
	void              AddIndex(const String& entry, const String& page) { dyna_index_entries.Add(entry); dyna_index_pages.Add(page); }

	String            Run(TAB tab = RECENT_TAB) const;
	const HelpPage   *Find(const char *ref) const;

	void              Perform(TAB tab = RECENT_TAB) const;

	bool              IsVisited(const String& link) const { return visited_links.Find(link) >= 0; }
	void              AddVisited(const String& link)      { visited_links.FindAdd(link); }
	void              ClearVisited()                      { visited_links.Clear(); }

	const IdMap&      GetIdMap() const                    { return id_map; }
	int               GetCount() const                    { return id_map.GetCount(); }

	static bool       RunPage(const char *page);


	struct Entry : Moveable<Entry>
	{
		int            nesting;
		String         text;
		Vector<String> anchors;
	};

	Vector<Entry>     GetIndex(bool letters = true, const Index<String> *pages = 0) const;

private:
	HelpIndex();

private:
	IdMap             id_map;
	Index<String>     visited_links;
	Vector<String>    dyna_index_entries;
	Vector<String>    dyna_index_pages;
};



class WithHelpRaw
{
public:
	WithHelpRaw(const String& page_id = Null) : page_id(page_id) {}

	void          Page(const String& id) { page_id = id; }
	const String& GetPage() const        { return page_id; }

	String        PageGetTitle(const String& id);
	String        PageGetTitle(const type_info& info);
	bool          ShowPage();

private:
	String        page_id;
};



template <class T>
class WithHelp : public T

, public WithHelpRaw
#line 282 "u:\\idisapp\\bwc\\help.h"
{
public:
	WithHelp(const String& page_id = Null)

		: WithHelpRaw(page_id) {  }

	virtual void ShowHelp()                 { ShowPage(); }
	virtual bool Key(dword key, int repcnt) { return (key == K_F1 && ShowPage()) || T::Key(key, repcnt); }


#line 293 "u:\\idisapp\\bwc\\help.h"
};




String           GetCtrlLabel(Ctrl& ctrl, bool kill_colon = true);
String           GetLabelQtf(const char *label, bool kill_under = false);
String           GetCtrlLabelQtf(Ctrl& ctrl, bool kill_colon = true, bool kill_under = false);

inline Document& HelpOut()      { return help_style -> Output(); }
inline Document& HelpBody()     { return help_style -> Body(); }
inline Document& HelpFootnote() { return help_style -> Footnote(); }
inline Document& HelpContents() { return help_style -> Contents(); }

inline Document& operator << (Document& doc, const char * s)     { doc |= s; return doc; }
inline Document& operator << (Document& doc, const String& s)    { doc |= s; return doc; }
inline Document& operator << (Document& doc, int i)              { doc |= IntStr(i); return doc; }
inline Document& operator << (Document& doc, double d)           { doc |= DblStr(d); return doc; }
inline Document& operator << (Document& doc, Time t)             { doc |= Format(t); return doc; }
inline Document& operator << (Document& doc, Date d)             { doc |= Format(d); return doc; }
inline Document& operator << (Document& doc, const Value& v)     { doc |= StdFormat(v); return doc; }
inline Document& operator << (Document& doc, const Paragraph& p) { doc.Cat(p); return doc; }
inline Document& operator << (Document& doc, Table& t)           { doc.AddTable() = t; return doc; }






Ctrl            *HelpOpenImage(Ctrl& ctrl, Size size, bool popup = false);
Ctrl            *HelpOpenImage(Ctrl& ctrl, bool popup = false);

PaintRect        HelpImagePaintRect(Draw& draw, const Rect& rc);
PaintRect        HelpImagePaintRect(Ctrl& ctrl);

Paragraph        HelpImage(const PaintRect& prc, int size = 1024);
Paragraph        HelpImage(const PaintRect& prc, Size size);
Paragraph        HelpImage(const Image& image, int size = 1024);
Paragraph        HelpButton(const char *label, int size = 1024, int cx = 80, int cy = 23);
inline Paragraph HelpButton(const char *label, int size, Size dim) { return HelpButton(label, size, dim.cx, dim.cy); }

inline Document& operator << (Document& doc, const Image& image)     { return doc << HelpImage(image); }
inline Document& operator << (Document& doc, const Display& display) { return doc << HelpImage(display); }
inline Document& operator << (Document& doc, const PaintRect& prc)   { return doc << HelpImage(prc); }

Paragraph        HelpImage(Draw& draw, const Rect& rc, int size = 1024);
Paragraph        HelpImage(Ctrl& ctrl, int size = 1024);




Paragraph        HelpMenuImage(Callback1<Bar&> generator, int size = 1024);




Paragraph        HelpHeader(HeaderCtrl& header, int column, bool screenshot = false);
Paragraph        HelpHeader(BaseTable& table, int column, bool screenshot = false);
Paragraph        HelpHeader(TableArray& table, Id column, bool screenshot = false);




String           HelpCase(const Switch& sw, const Value& value);
Document&        HelpCaseBullet(const Switch& sw, const Value& value);




Document&        HelpCenter(const Paragraph& para, bool skip_after = true);
Document&        HelpCenterImage(Ctrl& ctrl, bool skip_after = true, int size = 1024);
Document&        HelpTitle(const char *title);
Document&        HelpSection(const char *section, bool skip_after = true);
Document&        HelpSection(Ctrl &ctrl, bool image = false);
Document&        HelpSubsection(const char *subsection, bool skip_after = true);
Document&        HelpBullet();
Document&        HelpBullet(const char *tag);
Document&        HelpBulletQtf(const char *qtf);
Document&        HelpBullet(const Image& image, int offset = 0);
Document&        HelpBulletImage(Ctrl& ctrl, bool label = false, int offset = 0, int size = 1024);
Document&        HelpBullet(Ctrl& ctrl, bool label = false);
Document&        HelpBulletLabel(Ctrl& ctrl);
Document&        HelpSepBullet();
Document&        HelpSepBullet(const char *tag);
Document&        HelpSepBullet(const Image& image, int offset = 0);
Document&        HelpSepBullet(Ctrl& ctrl, bool label = false);
Document&        HelpSepBulletLabel(Ctrl& ctrl);
Document&        HelpKeep();




inline String    HelpTagLink(const char *tag, const char *anchor, const char *text = 0, const char *ref = GetHelpSeePageRef()) { return help_style -> Link(anchor, text, ref, tag); }
inline String    HelpLink(const char *anchor, const char *text = 0, const char *ref = GetHelpSeePageRef())                     { return help_style -> Link(anchor, text, ref, 0); }
inline String    HelpBoldLink(const char *anchor, const char *text = 0, const char *ref = GetHelpSeePageRef())                 { return help_style -> Link(anchor, text, ref, "*"); }

inline Document& HelpAnchor(const char *anchor)                          { return HelpOut() << help_style -> Anchor(anchor); }
inline Document& HelpOuterAnchor(const char *anchor)                     { return HelpOut() << help_style -> OuterAnchor(anchor); }
inline String    HelpGetAnchor(const char *anchor, const char *tail = 0) { return help_style -> GetAnchor(anchor, tail); }

inline void      HelpPushAnchorPrefix(const String& pfx) { help_style -> PushAnchorPrefix(pfx); }
inline void      HelpPopAnchorPrefix()                   { help_style -> PopAnchorPrefix(); }

Paragraph        HelpCommand(Callback cb, const Paragraph& para);
Paragraph        HelpCommand(Callback cb, const char *qtf);




inline char      HelpMode()     { return help_style -> GetMode(); }
inline bool      IsHypertext()  { return help_style -> IsHypertext(); }
inline bool      IsBook()       { return help_style -> IsBook(); }
inline bool      IsOnlineMode() { return help_style -> GetMode() == HELP_MODE_ONLINE; }
inline bool      IsBookMode()   { return help_style -> GetMode() == HELP_MODE_BOOK; }
inline bool      IsHtmlMode()   { return help_style -> GetMode() == HELP_MODE_HTML; }
inline bool      IsRtfMode()    { return help_style -> GetMode() == HELP_MODE_RTF; }

bool             HelpSeeAlso();
void             HelpSeeLink(const char *anchor, const char *text = 0);



inline void      HelpToc(int level, const char *title, const String& anchor) { help_style -> Toc(level, title, anchor); }
inline void      HelpToc(int level, const char *title)                       { help_style -> Toc(level, title, HelpAutoAnchor); }
inline void      HelpTocPage(int level, const char *page)                    { help_style -> TocPage(level, page); }
inline void      HelpPutContents(bool title = true)                          { help_style -> PutContents(title); }
inline void      HelpPutIndex(bool title = true)                             { help_style -> PutIndex(title); }
inline void      HelpNextPage()                                              { help_style -> Page(); }
inline void      HelpAppendix()                                              { help_style -> Appendix(); }




template <class T, class S>  inline void HelpLayout        (T& ctrl, const S *self) { CtrlLayout        (ctrl, ctrl.PageGetTitle(typeid(S))); }
template <class T, class S>  inline void HelpLayoutOK      (T& ctrl, const S *self) { CtrlLayoutOK      (ctrl, ctrl.PageGetTitle(typeid(S))); }
template <class T, class S>  inline void HelpLayoutCancel  (T& ctrl, const S *self) { CtrlLayoutCancel  (ctrl, ctrl.PageGetTitle(typeid(S))); }
template <class T, class S>  inline void HelpLayoutOKCancel(T& ctrl, const S *self) { CtrlLayoutOKCancel(ctrl, ctrl.PageGetTitle(typeid(S))); }
template <class T, class S>  inline void HelpLayoutExit    (T& ctrl, const S *self) { CtrlLayoutExit    (ctrl, ctrl.PageGetTitle(typeid(S))); }



template<>
inline unsigned int Upp::GetHashValue(const class HelpPage *const & x) { return (unsigned)x; }

#line 438 "u:\\idisapp\\bwc\\help.h"
#line 8 "u:\\idisapp\\bwc\\HelpBook.h"



class BookHelpStyle : public HelpStyle
{
public:
	BookHelpStyle();


	bool           CreateBook();
	void           RunBook(const char *title = "Uivatelsk pruka");


	virtual void   Step();
	virtual void   Flush(int columns = 1);
	virtual void   Page(int columns = 1);
	virtual void   EjectPage();

	virtual void   Numbering(NUMBERING num, int pageno = 1);

protected:
	String         FormatNumbering() const;

protected:
	ProgressMeter *progress;
	DocReport      book;
	NUMBERING      numbering;
};



extern One<BookHelpStyle> (*CreateBookHelpStyle)();



#line 44 "u:\\idisapp\\bwc\\HelpBook.h"
#line 13 "u:/idisapp\\BWC/BWC.h"
#line 1 "u:\\idisapp\\bwc\\setop.h"








namespace SetOp
{



enum SETOP
{
	NULLOP,
	LEFT,
	RIGHT,
	LADD,
	RADD,
	AND,
	LSUB,
	RSUB,
	XOR,
};

inline void AssertMoveable0(SETOP *) {};

template<class V, class I>
Index<V> GetIndex(I begin, I end)
{
	Index<V> result;
	while(begin != end)
		result.FindAdd(*begin++);
	return result;
}



template <class C, class I>
C LAdd(I begin1, I end1, I begin2, I end2)
{
	typedef typename C::ValueType V;
	C result;
	if(begin1 == end1)
		Append(result, begin2, end2);
	else
	{
		Append(result, begin1, end1);
		if(begin2 != end2)
		{
			Index<V> hash = GetIndex<V>(begin1, end1);
			for(; begin2 != end2; begin2++)
				if(hash.Find(*begin2) < 0)
					result.Add(*begin2);
		}
	}
	return result;
}



template <class C, class I>
C RAdd(I begin1, I end1, I begin2, I end2)
{
	typedef typename C::ValueType V;
	C result;
	if(begin2 == end2)
		Append(result, begin1, end1);
	else
	{
		if(begin1 != end1)
		{
			Index<V> hash = GetIndex<V>(begin2, end2);
			while(begin1 != end1)
			{
				if(hash.Find(*begin1) < 0)
					result.Add(*begin1);
				begin1++;
			}
		}
		Append(result, begin2, end2);
	}
	return result;
}



template <class C, class I>
C And(I begin1, I end1, I begin2, I end2)
{
	typedef typename C::ValueType V;
	C result;
	int count1 = end1 - begin1;
	int count2 = end2 - begin2;
	if(count1 == 0 || count2 == 0)
		return result;
	if(count1 > count2)
	{
		Index<V> hash = GetIndex<V>(begin2, end2);
		while(begin1 != end1)
		{
			if(hash.Find(*begin1) >= 0)
				result.Add(*begin1);
			begin1++;
		}
	}
	else
	{
		Index<V> hash = GetIndex<V>(begin1, end1);
		while(begin2 != end2)
		{
			if(hash.Find(*begin2) >= 0)
				result.Add(*begin2);
			begin2++;
		}
	}
	return result;
}



template <class C, class I>
C Sub(I begin1, I end1, I begin2, I end2)
{
	typedef typename C::ValueType V;
	C result;
	if(begin1 == end1)
		;
	else if(begin2 == end2)
		Append(result, begin1, end1);
	else
	{
		Index<V> hash = GetIndex<V>(begin2, end2);
		while(begin1 != end1)
		{
			if(hash.Find(*begin1) < 0)
				result.Add(*begin1);
			begin1++;
		}
	}
	return result;
}



template <class C, class I>
C Xor(I begin1, I end1, I begin2, I end2)
{
	typedef typename C::ValueType V;
	C result;
	if(begin1 == end1)
		Append(result, begin2, end2);
	else if(begin2 == end2)
		Append(result, begin1, end1);
	else
	{
		Index<V> hash = GetIndex<V>(begin2, end2);
		for(I temp = begin1; temp != end1; temp++)
			if(hash.Find(*temp) < 0)
				result.Add(*temp);
		hash = GetIndex<V>(begin1, end1);
		while(begin2 != end2)
		{
			if(hash.Find(*begin2) < 0)
				result.Add(*begin2);
			begin2++;
		}
	}
	return result;
}



template <class C, class I>
C Setop(I begin1, I end1, I begin2, I end2, SETOP op)
{
	C result;
	switch(op)
	{
	default: ;
	case NULLOP: break;
	case LEFT:   Append(result, begin1, end1); break;
	case RIGHT:  Append(result, begin2, end2); break;
	case LADD:   return LAdd<C>(begin1, end1, begin2, end2);
	case RADD:   return RAdd<C>(begin1, end1, begin2, end2);
	case AND:    return And<C>(begin1, end1, begin2, end2);
	case LSUB:   return Sub<C>(begin1, end1, begin2, end2);
	case RSUB:   return Sub<C>(begin2, end2, begin1, end1);
	case XOR:    return Xor<C>(begin1, end1, begin2, end2);
	}
	return result;
}



template <class T>
T Setop(const T& set1, const T& set2, SETOP op)
{
	return Setop<T>(set1.Begin(), set1.End(), set2.Begin(), set2.End(), op);
}



template <class T> T LAdd(const T& set1, const T& set2) { return Setop<T>(set1, set2, LADD); }
template <class T> T RAdd(const T& set1, const T& set2) { return Setop<T>(set1, set2, RADD); }
template <class T> T And (const T& set1, const T& set2) { return Setop<T>(set1, set2, AND);  }
template <class T> T Sub (const T& set1, const T& set2) { return Setop<T>(set1, set2, LSUB); }
template <class T> T Xor (const T& set1, const T& set2) { return Setop<T>(set1, set2, XOR);  }



}

#line 216 "u:\\idisapp\\bwc\\setop.h"
#line 14 "u:/idisapp\\BWC/BWC.h"







#line 1 "u:/uppsrc\\TSql/TSql.h"


















#line 22 "u:/idisapp\\BWC/BWC.h"
#line 1 "u:/uppsrc\\TSql/id.h"



#pragma BLITZ_APPROVE

const Upp::SqlId DUAL("DUAL");
const Upp::SqlId ROWID("ROWID");
const Upp::SqlId ROWNUM("ROWNUM");
const Upp::SqlId USERNAME("USERNAME");
const Upp::SqlId ALL_USERS("ALL_USERS");
const Upp::SqlId TABLE_NAME("TABLE_NAME");
const Upp::SqlId USER_TABLES("USER_TABLES");
const Upp::SqlId VIEW_NAME("VIEW_NAME");
const Upp::SqlId USER_VIEWS("USER_VIEWS");
const Upp::SqlId SEQUENCE_NAME("SEQUENCE_NAME");
const Upp::SqlId USER_SEQUENCES("USER_SEQUENCES");
const Upp::SqlId SESSION_ROLES("SESSION_ROLES");
const Upp::SqlId TABLE_SCHEMA("TABLE_SCHEMA");
const Upp::SqlId GRANTEE("GRANTEE");
const Upp::SqlId GRANTOR("GRANTOR");
const Upp::SqlId GRANTED_ROLE("GRANTED_ROLE");
const Upp::SqlId PRIVILEGE("PRIVILEGE");
const Upp::SqlId ALL_TAB_PRIVS("ALL_TAB_PRIVS");
const Upp::SqlId SYNONYM_NAME("SYNONYM_NAME");
const Upp::SqlId ALL_SYNONYMS("ALL_SYNONYMS");
const Upp::SqlId USER("USER");
const Upp::SqlId USER_ROLE_PRIVS("USER_ROLE_PRIVS");
const Upp::SqlId DBA_ROLE_PRIVS("DBA_ROLE_PRIVS");
const Upp::SqlId ALL_TAB_COLUMNS("ALL_TAB_COLUMNS");
const Upp::SqlId DATA_TYPE("DATA_TYPE");
const Upp::SqlId COLUMN_ID("COLUMN_ID");
#line 23 "u:/idisapp\\BWC/BWC.h"

bool                  LockSql(Sql& cursor = AppCursor());
bool                  LockSql(const SqlVal& table, SqlBool where, Sql& cursor = AppCursor());
bool                  LockSql(const SqlVal& table, SqlId column, const Value& value, Sql& cursor = AppCursor());
bool                  LockSchemaSql(const SqlVal& table, SqlBool where, Sql& cursor = AppCursor());
bool                  LockSchemaSql(const SqlVal& table, SqlId column, const Value& value, Sql& cursor = AppCursor());

class SqlTable : public TableArray {
public:
	virtual bool   DeleteQuery();

protected:
	virtual void   Load();

	virtual bool   RowUpdate();
	virtual bool   RowInsert();
	virtual bool   RowRemove();

protected:
	SqlSession *ssn;
	SqlId       table;
	SqlBool     where;
	SqlSet      orderby;
	int         querytime;

	SqlBool     GetWhere();
	SqlSession& Session()                                  { return ssn ? *ssn : AppCursor().GetSession(); }

public:
	void  SetSession(SqlSession& _session)                 { ssn = &_session; }

	SqlTable& SetTable(SqlId _table)                       { table = _table; return *this; }
	SqlTable& SetWhere(SqlBool _where)                     { where = _where; return *this;  }
	SqlTable& SetOrderBy(SqlSet _orderby)                  { orderby = _orderby; return *this; }
	SqlTable& SetOrderBy(const SqlVal& a)                  { return SetOrderBy(SqlSet(a)); }
	SqlTable& SetOrderBy(const SqlVal& a, const SqlVal& b) { return SetOrderBy(SqlSet(a, b)); }
	SqlTable& SetOrderBy(const SqlVal& a, const SqlVal& b, const SqlVal& c) {
		return SetOrderBy(SqlSet(a, b)); }

	SqlTable();
	SqlTable(SqlId table);
	SqlTable(SqlSession& session);
	SqlTable(SqlId table, SqlSession& session);
};

enum
{
	CSET_1250,
	CSET_LATIN2,

	CSET_DEFAULT = CSET_1250,


#line 77 "u:/idisapp\\BWC/BWC.h"
};

extern const byte *CsUpper;
extern const byte *CsLower;
extern const byte *CsAscii;
extern const byte *CsUpperAscii;
extern const byte *CsLowerAscii;
extern const bool *CsIsLetter;

const byte *GetCsUpper(int charset = CSET_DEFAULT);
const byte *GetCsLower(int charset = CSET_DEFAULT);
const byte *GetCsAscii(int charset = CSET_DEFAULT);
const byte *GetCsUpperAscii(int charset = CSET_DEFAULT);
const byte *GetCsLowerAscii(int charset = CSET_DEFAULT);
const bool *GetCsIsLetter(int charset = CSET_DEFAULT);

int           CsCompare(const char *s1, const char *s2, int cs = CSET_DEFAULT);
int           CsNumCompare(const char *s1, const char *s2, int cs = CSET_DEFAULT);

struct CsStringComp
{
	bool operator () (const char *a, const char *b) const { return CsCompare(a, b) < 0; }
	int  Compare     (const char *a, const char *b) const { return CsCompare(a, b); }
};

struct CsNumStringComp
{
	bool operator () (const char *a, const char *b) const { return CsNumCompare(a, b) < 0; }
	int  Compare     (const char *a, const char *b) const { return CsNumCompare(a, b); }
};

extern CsStringComp    StdCsSort;
extern CsNumStringComp StdCsNumSort;

String& AppendStr(String& dest, const char *what, const char *brk);

class ProgressMeter
{
public:
	enum
	{
		FILTER   = 0x01,
		THROW    = 0x02,
		NOCANCEL = 0x04,
		HIDDEN   = 0x08,
	};

	ProgressMeter(int step = 1, const char *title = 0, int total = 0,
		int flags = FILTER, HWND parent = 0);
	ProgressMeter(const char *title, int step = 1, int total = 0,
		int flags = THROW, HWND parent = 0);
	~ProgressMeter();

	bool           Create();
	void           Destroy();
	bool           IsOpen() const                      { return window; }

	ProgressMeter& Step();
	bool           Cancelled();
	bool           StepCancelled();
	bool           SetPosCancelled(int pos);
	void           Refresh()                           { Cancelled(); }

	bool           IgnoreStep(int pos) const;

	ProgressMeter& Caption(const char *_caption);
	const String&  GetCaption() const                  { return caption; }

	ProgressMeter& Filter(bool _fm = true);
	ProgressMeter& NoFilter()                          { return Filter(false); }
	bool           IsFilter() const                    { return flags & FILTER; }

	ProgressMeter& Throw(bool _th = true);
	ProgressMeter& NoThrow()                           { return Throw(false); }
	bool           IsThrow() const                     { return flags & THROW; }

	ProgressMeter& AllowCancel(bool _ac = true);
	ProgressMeter& NoAllowCancel()                     { return AllowCancel(false); }
	bool           IsAllowCancel() const               { return !(flags & NOCANCEL); }

	ProgressMeter& Show(bool _show = true);
	ProgressMeter& Hide()                              { return Show(false); }
	bool           IsVisible() const                   { return !(flags & HIDDEN); }

	ProgressMeter& SetRange(int total);
	int            GetRange() const                    { return total; }

	ProgressMeter& SetChunk(int n)                     { chunk = n; return *this; }
	int            GetChunk() const                    { return chunk; }

	ProgressMeter& SetPos(int pos);
	ProgressMeter& Reset()                             { return SetPos(0); }
	int            GetPos() const                      { return pos; }

	ProgressMeter& SetText(const char *s, bool reset = true);
	const String&  GetText() const                     { return text; }

	ProgressMeter& Set(int pos, int total);

	operator Gate2<int, int> ()                        { return callback(this, &ProgressMeter::OnStep); }
	bool           OnStep(int done, int total);

protected:
	static LRESULT __stdcall StaticProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
	LRESULT  Proc(UINT message, WPARAM wParam, LPARAM lParam);

	void           Enable(bool en);

protected:
	HWND           parent;
	HWND           window;
	HWND           progress;

	Vector<HWND>   enable;

	bool           cancel;
	bool           visible;
	int            flags;
	int            total;
	int            pos;
	int            chunk;
	int            next_ticks;
	String         text;
	String         old_text;
	String         caption;
};

struct SyncTable
{
public:
	SyncTable();
	SyncTable(TableArray& table, int column = 0, bool clear_table = true, int prev = -1);
	SyncTable(TableArray& table, Id column_id, bool clear_table = true, int prev = -1);
	~SyncTable();

	void        Clear() { table = 0; }

	void        Cursor(int row);
	void        Cursor();

	void        SetValue(const Value& _value, bool force_null = false);

	void        operator () (bool cond) { if(cond) Cursor(); }

	void        Get(TableArray& table, int column = 0, bool clear_table = true, int prev = -1);
	void        Get(TableArray& table, Id column_id, bool clear_table = true, int prev = -1);
	void        Set(bool clear = true);

protected:
	TableArray *table;
	Value       value;
	int         row;
	int         sc;
	int         column;
};



























template <class T>
T SerializeIn(const String& data, T * = 0)
{
	T temp;
	if(SerializeIn(temp, data, false))
		return temp;
	return T();
}



template <class T>
bool SerializeLoad(T& object, const char *filename, bool backup = false)
{
	FileIn file(filename);
	if(!file.IsOpen())
		return true;
	String backup_string;
	if(backup)
		backup_string = SerializeOut(object);
	file % object;
	if(!file.IsError())
		return true;

	if(backup)
		StringStream(backup_string) % object;
	return false;
}



template <class T>
T SerializeLoad(const char *filename, T * = 0)
{
	T temp;
	if(SerializeLoad(temp, filename, false))
		return temp;
	return T();
}



template <class T>
bool SerializeSave(T& object, const char *filename)
{
	if(!filename || !*filename)
		return false;
	FileOut file(filename);
	if(!file.IsOpen())
		return false;
	file % object;
	file.Flush();
	file.Close();
	if(!file.IsError())
		return true;
	DeleteFileA(filename);
	return false;
}

class StaticCtrl : public Ctrl
{
public:
	StaticCtrl();

	virtual void   Paint(Draw& draw);

	StaticCtrl&    Image(const ::Image& _image);
	const ::Image *GetImage() const                   { return image; }

	StaticCtrl&    IconSep(int _icon_sep)             { icon_sep = _icon_sep; Refresh(); return *this; }
	int            GetIconSep() const                 { return icon_sep; }

	virtual void   SetLabelText(const char *text);
	virtual String GetLabelText() const;

	StaticCtrl&    Font(::Font _font)                 { font = _font; Refresh(); return *this; }
	::Font         GetFont() const                    { return font; }

	StaticCtrl&    Ink(Color _ink)                    { ink = _ink; Refresh(); return *this; }
	Color          GetInk() const                     { return ink; }

	StaticCtrl&    Paper(Color _paper);
	Color          GetPaper() const                   { return paper; }

	StaticCtrl&    HorzAlign(Alignment _a)            { halign = _a; Refresh(); return *this; }
	int            GetHorzAlign() const               { return halign; }

	StaticCtrl&    VertAlign(Alignment _a)            { valign = _a; Refresh(); return *this; }
	int            GetVertAlign() const               { return valign; }

	StaticCtrl&    Top()                              { return VertAlign(ALIGN_TOP); }
	StaticCtrl&    Centered()                         { return VertAlign(ALIGN_CENTER); }
	StaticCtrl&    Bottom()                           { return VertAlign(ALIGN_BOTTOM); }
	StaticCtrl&    FullCentered()                     { return HorzAlign(ALIGN_CENTER).VertAlign(ALIGN_CENTER); }

protected:
	::Font         font;
	Color          ink;
	Color          paper;
	const ::Image *image;
	::Image        m;
	int            icon_sep;
	Alignment      halign;
	Alignment      valign;
	String         text;
	const Convert *convert;
};

String SetHotKey(const char *s, __int64& map, bool ascii_only);

template <class B>
struct PumpItemRefData : public Pump::Item
{
	PumpItemRefData(Ref a, B& b) : a(a), b(b) {}
	virtual void Run(bool write) { if(write) a.SetValue(~b); else b <<= a; }
	Ref a; B& b;
};

template <class B>
One<Pump::Item> PumpRefData(Ref a, B& b) { return new PumpItemRefData<B>(a, b); }


class QtfDisplay : public Display
{
public:
	QtfDisplay(const String& head) : head(head) {}

	QtfDisplay&   Head(const String& _head) { head = _head; return *this; }
	const String& GetHead() const           { return head; }

	virtual void  Paint(Draw& w, const Rect& r, const Value& q, Color i, Color p, dword s) const;
	virtual Size  GetStdSize(const Value& q) const;

private:
	String        head;
};

const QtfDisplay& StdQtfDisplay();
const QtfDisplay& RawQtfDisplay();

class CallbackConvert : public Convert
{
public:
	CallbackConvert(Callback1<Value&> convert = Callback1<Value&>()) : WhenFormat(convert) {}
	virtual Value  Format(const Value& q) const;

	Callback1<Value&> operator = (Callback1<Value&> cb) { return WhenFormat = cb; }

public:
	Callback1<Value&> WhenFormat;
};

String CreateUniqueKey(const Index<String>& keys, const char *s, int wd = 3);


enum FDLG { FDLG_LOAD, FDLG_SAVE };

bool FileDlg(FDLG type, String& filename, const char* defext, const char* filter,
			 const char* title = 0);




struct NameMapEntry
{
	const char *text;
	int         key;
};

class NameMap : public VectorMap<int, String>
{
public:
	NameMap(const NameMapEntry *entries, int count = -1);
};










template <class C>
C& FetchMapContainer(C& container, Sql& cursor, Gate2<int, int> progress = false)
{
	int done = 0;
	typedef typename C::ValueType VT;
	VT T;
	while(cursor.Fetch(T))
	{
		container.FindAdd(T);
		if(progress(++done, 0))
			throw AbortExc();
	}
	return container;
}



template <class T>
inline Vector<T> FetchVector(Sql& cursor, Gate2<int, int> progress = false)
{
	return FetchContainer(Vector<T>(), cursor, progress);
}



template <class T>
inline Index<T> FetchIndex(Sql& cursor, Gate2<int, int> progress = false)
{
	return FetchMapContainer(Index<T>(), cursor, progress);
}



template <class C>
C& FetchContainerExc(C& container, const SqlSelect& set, Gate2<int, int> progress = false)
{
	Sql cursor;
	set.Force(cursor);
	return FetchContainer(container, cursor, progress);
}



template <class C>
C& FetchMapContainerExc(C& container, const SqlSelect& set, Gate2<int, int> progress = false)
{
	Sql cursor;
	set.Force(cursor);
	return FetchMapContainer(container, cursor, progress);
}



template <class C>
C& FetchMapContainer(C& container, const SqlStatement& set, Gate2<int, int> progress = false)
{
	try
	{
		FetchMapContainerExc(container, set, progress);
	}
	catch(Exc e)
	{

	}
	return container;
}



template <class T>
inline Vector<T> FetchVectorExc(const SqlSelect& set, Gate2<int, int> progress = false, T * = 0)
{
	Vector<T> vector;
	FetchContainerExc(vector, set, progress);
	return vector;
}



template <class T>
inline Vector<T> FetchVector(const SqlSelect& set, Gate2<int, int> progress = false, T * = 0)
{
	Vector<T> vector;
	FetchContainer(vector, set, progress);
	return vector;
}



template <class T>
inline Index<T> FetchIndexExc(const SqlSelect& set, Gate2<int, int> progress = false, T * = 0)
{
	Index<T> index;
	FetchMapContainerExc(index, set, progress);
	return index;
}



template <class T>
inline Index<T> FetchIndex(const SqlSelect& set, Gate2<int, int> progress = false, T * = 0)
{
	Index<T> index;
	FetchMapContainer(index, set, progress);
	return index;
}







































template <class T>
T& FetchSchemaSeq(T& data, SqlId key, const Value& value, SqlId table)
{
	Select(data).From(SchemaAlias((table))).Where(key == value && ROWNUM == 1).Force();
	if(!AppCursor().Fetch(data)) {
		String str;
		throw SqlExc(str << "dek '" << Value(value).Format() << "' nebyl nalezen (tabulka '" << ~table << "').");
	}
	return data;
}



template <class T>
inline T& FetchSchemaSeq(T& data, SqlId key, const Value& value)
{
	return FetchSchemaSeq<T>(data, key, value, SqlId(T::TableName));
}



template <class T>
inline T FetchSchemaSeq(SqlId key, const Value& value, SqlId table, T * = 0)
{
	T temp;
	return FetchSchemaSeq(temp, key, value, table);
}











template <class C>
C& FetchTableContainer(C& dest, const SqlBool& cond = SqlBool::True(), Gate2<int, int> progress = false)
{
	typedef typename C::ValueType VT;
	SqlId table = VT::TableName;
	int total = (int)(progress ? SelectCount(table, cond) : 0);
	Sql cursor;
	Select(VT::ColumnSet()).From(table).Where(cond).Force(cursor);
	for(VT temp; cursor.Fetch(temp); dest.Add(temp))
		;
	return dest;
}



template <class T>
Vector<T> FetchTableVector(const SqlBool& cond = SqlBool::True(), Gate2<int, int> progress = false, T * = 0)
{
	return FetchTableContainer(Vector<T>(), cond, progress);
}



template <class C>
C& FetchSchemaTableContainer(C& dest, const SqlBool& cond = SqlBool::True(), Gate2<int, int> progress = false)
{
	typedef typename C::ValueType VT;
	SqlId table = VT::TableName;
	int total = (progress ? SelectCount(table, cond) : 0);
	Sql cursor;
	Select(VT::ColumnSet()).From(SchemaAlias((table))).Where(cond).Force(cursor);
	for(VT temp; cursor.Fetch(temp); dest.Add(temp))
		;
	return dest;
}



template <class T>
Vector<T> FetchSchemaTableVector(const SqlBool& cond = SqlBool::True(), Gate2<int, int> progress = false, T * = 0)
{
	return FetchSchemaTableContainer(Vector<T>(), cond, progress);
}

template <class T, class C = Callback1<T> >
struct CallbackArg
{
public:
	typedef T Arg;
	typedef CallbackArg CLASSNAME;

	CallbackArg()                                        {}
	CallbackArg(const CallbackArg& ca)                   { *this = ca; }
	CallbackArg(C handler) : handler(handler)            {}

	CallbackArg&               operator = (const CallbackArg& a);
	CallbackArg&               operator = (C _handler)   { handler = _handler; return *this; }
	C                          operator <<= (C _handler) { return handler = _handler; }

	void                       Clear()                   { stubs.Clear(); }
	bool                       IsEmpty() const           { return stubs.IsEmpty(); }
	int                        GetCount() const          { return stubs.GetCount(); }

	Callback                   operator [] (const T& value) const;

protected:
	struct Stub;
	friend struct Stub;

	struct Stub
	{
		Stub(const CLASSNAME *owner, int index) : owner(owner), index(index) {}

		void             Call() { (owner -> handler)(owner -> stubs.GetKey(index)); }

		const CLASSNAME *owner;
		int              index;
	};

	mutable SegtorMap<T, Stub> stubs;
	C                          handler;
};

template <class T, class C>
CallbackArg<T, C>& CallbackArg<T, C>::operator = (const CallbackArg& a)
{
	for(int i = 0; i < a.stubs.GetCount(); i++)
		stubs.Add(a.stubs.GetKey(i), Stub(this, i));
	handler = a.handler;
	return *this;
}

template <class T, class C>
Callback CallbackArg<T, C>::operator [] (const T& value) const
{
	int i = stubs.Find(value);
	if(i < 0)
	{
		i = stubs.GetCount();
		stubs.Add(value, Stub(this, i));
	}
	return callback(&stubs[i], &Stub::Call);
}

class InfoBar : public FrameCtrl<StaticCtrl>
{
public:
	InfoBar();
	virtual ~InfoBar();

	virtual void             FrameLayout(Rect& rc);
	virtual void             FrameAddSize(Size& sz);

	void                     Height(int ht);
	int                      GetHeight() const  { return height; }

	void                     Clear();
	void                     Set(const String& text);
	void                     SetDefault(const String& text);

	void                     Attach(Ctrl& child, Size size = Size(200, 10), int delta = 0);

	enum
	{
		DEFAULT_TIME = 2000,
	};

	void                     Temporary(const String& text, dword time = DEFAULT_TIME);

	virtual void             State(int reason);

	Callback1<const String&> Get()                    { return callback(this, &InfoBar::Set); }
	InfoBar&                 operator = (const String& text)      { SetDefault(text); return *this; }
	                     operator Callback1<const String&> () { return Get(); }

	void                     HelpDefault();
	void                     NoHelpDefault();

public:
	static InfoBar          *StatusDefault;




protected:
	String                   dflt_text;
	int                      height;
};

#line 776 "u:/idisapp\\BWC/BWC.h"
#line 55 "u:/idisapp\\IdisMisc/IdisMisc.h"
#line 1 "u:/uppsrc\\Esc/Esc.h"



#line 1 "u:/idisapp\\Core/Core.h"






























































































































































































































































































































































































































































































































#line 5 "u:/uppsrc\\Esc/Esc.h"


namespace Upp {

enum { ESC_VOID, ESC_NUMBER, ESC_ARRAY, ESC_MAP, ESC_LAMBDA };

String EscTypeName(int sv_type);

struct EscEscape;
class  EscLambda;
struct EscHandle;
struct Esc;

class EscValue : Moveable<EscValue> {
	struct RefCount {
		Atomic   refcount;
		RefCount()              { AtomicWrite(refcount, 1); }
	};

	int              type;
	mutable unsigned hash;

	struct EscMap;
	struct EscArray;

	union {
		double         number;
		EscArray      *array;
		EscMap        *map;
		EscLambda     *lambda;
	};

	void                  Free();
	void                  Assign(const EscValue& s);

	void                  InitString(const WString& w);
	Vector<EscValue>&     CloneArray();

	VectorMap<EscValue, EscValue>& CloneMap();

	static int             total;
	static int             max_total;

public:
	static int             GetTotalCount();
	static void            SetMaxTotalCount(int n);
	static int             GetMaxTotalCount();

	bool IsVoid() const                          { return type == ESC_VOID; }
	EscValue();

	bool                   IsNumber() const      { return type == ESC_NUMBER; }
	double                 GetNumber() const     { return IsNumber() ? number : 0; }
	bool                   IsInt() const;
	int                    GetInt() const;
	EscValue(double n);

	bool                    IsArray() const      { return type == ESC_ARRAY; }
	const Vector<EscValue>& GetArray() const;
	EscValue                ArrayGet(int i) const;
	EscValue                ArrayGet(int i, int n) const;
	bool                    ArraySet(int i, EscValue val);
	bool                    Replace(int i, int n, EscValue a);
	void                    SetEmptyArray();
	void                    ArrayAdd(EscValue val);
	bool                    Append(EscValue a);

	operator WString() const;
	operator String() const                     { return operator WString().ToString(); }

	EscValue(const char *s)                     { InitString(WString(s)); }
	EscValue(const WString& s)                  { InitString(s); }
	EscValue(const String& s)                   { InitString(s.ToWString()); }

	bool                                 IsMap() const         { return type == ESC_MAP; }
	const VectorMap<EscValue, EscValue>& GetMap() const;
	EscValue                             MapGet(EscValue key) const;
	void                                 MapSet(EscValue key, EscValue value);
	void                                 SetEmptyMap();

	bool                                 IsLambda() const     { return type == ESC_LAMBDA; }
	const EscLambda&                     GetLambda() const;
	EscLambda&                           CreateLambda();


	void    Escape(const char *method, Callback1<EscEscape&> escape);
	void    Escape(const char *method, EscHandle *h, Callback1<EscEscape&> escape);
	bool    HasNumberField(const char *id) const;
	int     GetFieldInt(const char *id) const;

	int     GetType() const                                   { return type; }
	String  GetTypeName() const                               { return Upp::EscTypeName(type); }

	int     GetCount() const;

	unsigned GetHashValue() const;
	bool     operator==(const EscValue& a) const;
	bool     operator!=(const EscValue& a) const              { return !(*this == a); }

	String ToString(int maxlen = 2147483647, int indent_step = 4, bool hex = false, int indent = 0) const;

	EscValue& operator=(const EscValue& s);
	EscValue(const EscValue& src);

	~EscValue();
};

struct EscValue::EscArray : EscValue::RefCount {
	Vector<EscValue> array;

	void     Retain()        { AtomicInc(refcount); }
	void     Release()       { if(AtomicDec(refcount) == 0) delete this; }
};

struct EscValue::EscMap : EscValue::RefCount {
	VectorMap<EscValue, EscValue> map;
	int                           count;

	void     Retain()        { AtomicInc(refcount); }
	void     Release()       { if(AtomicDec(refcount) == 0) delete this; }

	EscMap()                 { count = 0; }
};

struct EscHandle {
	Atomic   refcount;

	void       Retain()        { AtomicInc(refcount); }
	void       Release()       { if(AtomicDec(refcount) == 0) delete this; }

	EscHandle()              { AtomicWrite(refcount, 0); }
	virtual ~EscHandle()     {}
};

class EscLambda {
	Atomic   refcount;

	void     Retain()        { AtomicInc(refcount); }
	void     Release()       { if(AtomicDec(refcount) == 0) delete this; }

	EscLambda()                 { AtomicWrite(refcount, 1); varargs = false; handle = 0; }
	~EscLambda()                { if(handle) handle->Release(); }

	friend class EscValue;

public:
	Vector<String>        arg;
	Vector<String>        def;
	Vector<bool>          inout;
	String                code;
	EscHandle            *handle;
	Callback1<EscEscape&> escape;
	bool                  varargs;
	String                filename;
	int                   line;

private:
	EscLambda(const EscLambda&);
	void operator=(const EscLambda&);
};

template <>
inline unsigned GetHashValue(const EscValue& v)
{
	return v.GetHashValue();
}

bool     IsTrue(const EscValue& a);

void     SkipBlock(CParser& p);
EscValue ReadLambda(CParser& p);
EscValue ReadLambda(const char *s);

struct Esc : public CParser {
	struct SRVal : Moveable<SRVal> {
		EscValue *lval;
		EscValue  rval;
		EscValue  sbs;

		SRVal()                    { lval = 0; }
		SRVal(const EscValue& v)   { lval = 0; rval = v; }
		SRVal(double n)            { lval = 0; rval = n; }
	};

	ArrayMap<String, EscValue>& global;
	EscValue                    self;
	ArrayMap<String, EscValue>  var;

	int      skipexp;
	int      loop;
	bool     no_break, no_return;
	int&     op_limit;
	int      r_stack_level;
	EscValue return_value;

	static int stack_level;

	void       OutOfMemory();

	void       TestLimit();
	double     DoCompare(const EscValue& a, const EscValue& b, const char *op);
	double     DoCompare(const SRVal& a, const char *op);
	String     ReadName();
	EscValue   ExecuteLambda(const String& id, EscValue lambda, SRVal self, Vector<SRVal>& arg);

	void       Assign(EscValue& val, const Vector<EscValue>& sbs, int si, const EscValue& src);

	EscValue   Get(const SRVal& val);
	void       Assign(const SRVal& val, const EscValue& src);

	EscValue   GetExp();

	double Number(const EscValue& a, const char *oper);
	int    Int(const EscValue& a, const char *oper);
	double Number(const SRVal& a, const char *oper);
	int    Int(const SRVal& a, const char *oper);

	EscValue   MulArray(EscValue array, EscValue times);

	void  Subscript(SRVal& r, SRVal _self, String id);
	void  Subscript(SRVal& r);
	void  Term(SRVal& r);
	void  Unary(SRVal& r);
	void  Mul(SRVal& r);
	void  Add(SRVal& r);
	void  Shift(SRVal& r);
	void  Compare(SRVal& r);
	void  Equal(SRVal& r);
	void  BinAnd(SRVal& r);
	void  BinXor(SRVal& r);
	void  BinOr(SRVal& r);
	void  And(SRVal& r);
	void  Or(SRVal& r);
	void  Cond(SRVal& r);
	void  Assign(SRVal& r);
	void  Exp(SRVal& r);

	void  SkipTerm();
	void  SkipStatement();
	void  SkipExp();
	bool  PCond();
	void  FinishSwitch();
	void  DoStatement();

	void  Run();

	Esc(ArrayMap<String, EscValue>& global, const char *s, int& oplimit,
	    const String& fn, int line = 1)
	: CParser(s, fn, line), global(global), op_limit(oplimit)
	{ r_stack_level = stack_level;  skipexp = false; }
	~Esc() { stack_level = r_stack_level; }
};

struct EscEscape {
	Esc&             esc;
	EscValue         self;
	Array<EscValue>& arg;
	EscValue         ret_val;
	String           id;

	EscValue&    operator[](int i)             { return arg[i]; }
	int          GetCount() const              { return arg.GetCount(); }
	void         operator=(const EscValue& v)  { ret_val = v; }
	operator     EscValue&()                   { return ret_val; }
	void         ThrowError(const char *s)     { esc.ThrowError(s); }

	String       DumpType(int i);
	String       InCall();

	void         CheckNumber(int i);
	void         CheckArray(int i);
	void         CheckMap(int i);

	double       Number(int i);
	int          Int(int i);

	EscEscape(Esc& esc, EscValue self, Array<EscValue>& arg)
	  : esc(esc), self(self), arg(arg) {}
};

void Escape(ArrayMap<String, EscValue>& globals, const char *function, void (*escape)(EscEscape& e));
void Escape(ArrayMap<String, EscValue>& globals, const char *function, Callback1<EscEscape&> escape);

void Scan(ArrayMap<String, EscValue>& global, const char *code, const char *filename = "");

void StdLib(ArrayMap<String, EscValue>& global);

EscValue Execute(ArrayMap<String, EscValue>& global, EscValue *self,
                 const EscValue& lambda, Vector<EscValue>& arg, int oplimit = 50000);
EscValue Execute(ArrayMap<String, EscValue>& global, EscValue *self,
                 const char *name, Vector<EscValue>& arg, int oplimit = 50000);
EscValue Execute(ArrayMap<String, EscValue>& global, const char *name, int oplimit = 50000);

EscValue Evaluatex(const char *expression, ArrayMap<String, EscValue>& global, int oplimit = 50000);
EscValue Evaluate(const char *expression, ArrayMap<String, EscValue>& global, int oplimit = 50000);

EscValue EscFromStdValue(const Value& v);
Value    StdValueFromEsc(const EscValue& v);
void     StdValueLib(ArrayMap<String, EscValue>& global);

bool     IsDate(const EscValue& v);
bool     IsTime(const EscValue& v);

String   Expand(const String& doc, ArrayMap<String, EscValue>& global,
                int oplimit = 50000, String (*format)(const Value& v) = StdFormat);

};

#line 314 "u:/uppsrc\\Esc/Esc.h"
#line 56 "u:/idisapp\\IdisMisc/IdisMisc.h"
#line 1 "u:/uppsrc\\CodeEditor/CodeEditor.h"




#line 1 "u:/uppsrc\\CtrlLib/CtrlLib.h"

























































#line 6 "u:/uppsrc\\CodeEditor/CodeEditor.h"


namespace Upp {


#line 1 "u:/uppsrc\\CtrlCore/lay.h"







#line 1 "u:/uppsrc\\CodeEditor/CodeEditor.lay"
struct IDEFindReplaceLayout__layid {};













#line 9 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/uppsrc\\CodeEditor/CodeEditor.lay"
template<class T> struct WithIDEFindReplaceLayout : public T, public IDEFindReplaceLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(266, 118); }
	Label dv___0;
	WithDropChoice<EditString> find;
	Label dv___2;
	WithDropChoice<EditString> replace;
	Option wholeword;
	Option ignorecase;
	Option wildcards;
	Button amend;
	Button findback;
	Button ok;
	Button cancel;
};

#line 23 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/uppsrc\\CodeEditor/CodeEditor.lay"
template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, IDEFindReplaceLayout__layid&) { parent.LayoutId("IDEFindReplaceLayout");
	layout.dv___0.SetLabel(t_GetLngString("&Find:")).LeftPosZ(4, 46).TopPosZ(4, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.find.HSizePosZ(50, 4).TopPosZ(4, 19); layout.find.LayoutId("find"); parent.Add(layout.find);
	layout.dv___2.SetLabel(t_GetLngString("&Replace:")).LeftPosZ(4, 46).TopPosZ(28, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.replace.HSizePosZ(50, 4).TopPosZ(28, 19); layout.replace.LayoutId("replace"); parent.Add(layout.replace);
	layout.wholeword.SetLabel(t_GetLngString("&Whole word")).LeftPosZ(8, 76).TopPosZ(58, 18); layout.wholeword.LayoutId("wholeword"); parent.Add(layout.wholeword);
	layout.ignorecase.SetLabel(t_GetLngString("&Ignore case")).LeftPosZ(100, 76).TopPosZ(58, 18); layout.ignorecase.LayoutId("ignorecase"); parent.Add(layout.ignorecase);
	layout.wildcards.SetLabel(t_GetLngString("Wild&cards")).LeftPosZ(192, 68).TopPosZ(58, 18); layout.wildcards.LayoutId("wildcards"); parent.Add(layout.wildcards);
	layout.amend.SetLabel(t_GetLngString("R&eplace")).LeftPosZ(4, 60).BottomPosZ(4, 24); layout.amend.LayoutId("amend"); parent.Add(layout.amend);
	layout.findback.SetLabel(t_GetLngString("Find &Prev.")).LeftPosZ(70, 60).BottomPosZ(4, 24); layout.findback.LayoutId("findback"); parent.Add(layout.findback);
	layout.ok.SetLabel(t_GetLngString("Find")).RightPosZ(70, 60).BottomPosZ(4, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Cancel")).RightPosZ(4, 60).BottomPosZ(4, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

#line 37 "u:/uppsrc\\CtrlCore/lay.h"







#line 12 "u:/uppsrc\\CodeEditor/CodeEditor.h"




#line 1 "u:/uppsrc\\Draw/iml_header.h"













class CodeEditorImg {
public:


	enum {
#line 1 "u:/uppsrc\\CodeEditor/CodeEditor.iml"
I_Breakpoint,
I_InvalidBreakpoint,
I_CondBreakpoint,
I_N0,
I_N1,
I_N2,
I_N3,
I_N4,
I_N5,
I_N6,
I_N7,
I_N8,
I_N9,
I_I,













#line 20 "u:/uppsrc\\Draw/iml_header.h"
		COUNT
	};



public:
	static Upp::Iml&   Iml();

	static void        Register__()                { Register("CodeEditorImg", Iml()); }

	static int         Find(const Upp::String& s);
	static int         Find(const char *s);
	static int         GetCount()                  { return Iml().GetCount(); }
	static Upp::String GetId(int i)                { return Iml().GetId(i); }

	static Upp::Image  Get(int i);
	static Upp::Image  Get(const char *s);
	static Upp::Image  Get(const Upp::String& s);

	static void   Set(int i, const Upp::Image& m);
	static void   Set(const char *s, const Upp::Image& m);

	static void   Reset()                     { Iml().Reset(); }



#line 1 "u:/uppsrc\\CodeEditor/CodeEditor.iml"
static Upp::Image Breakpoint() { return Get(I_Breakpoint); }
static Upp::Image InvalidBreakpoint() { return Get(I_InvalidBreakpoint); }
static Upp::Image CondBreakpoint() { return Get(I_CondBreakpoint); }
static Upp::Image N0() { return Get(I_N0); }
static Upp::Image N1() { return Get(I_N1); }
static Upp::Image N2() { return Get(I_N2); }
static Upp::Image N3() { return Get(I_N3); }
static Upp::Image N4() { return Get(I_N4); }
static Upp::Image N5() { return Get(I_N5); }
static Upp::Image N6() { return Get(I_N6); }
static Upp::Image N7() { return Get(I_N7); }
static Upp::Image N8() { return Get(I_N8); }
static Upp::Image N9() { return Get(I_N9); }
static Upp::Image I() { return Get(I_I); }













#line 47 "u:/uppsrc\\Draw/iml_header.h"



};












#line 64 "u:/uppsrc\\Draw/iml_header.h"
#line 17 "u:/uppsrc\\CodeEditor/CodeEditor.h"

void FindWildcardMenu(Callback1<int> cb, Point p, bool tablf, Ctrl *owner = 0);

struct LineInfoRecord {
	int    lineno;
	String breakpoint;
	int    count;
	int    error;
	int    firstedited;
	int    edited;

	LineInfoRecord() { error = 0; edited = 0; }
};

typedef Array<LineInfoRecord> LineInfo;

void ClearErrors(LineInfo& li);

struct LineInfoRemRecord : Moveable<LineInfoRemRecord> {
	int    firstedited;
	int    edited;
};
typedef Vector<LineInfoRemRecord> LineInfoRem;

void Renumber(LineInfo& lf);
void ClearBreakpoints(LineInfo& lf);
void ValidateBreakpoints(LineInfo& lf);

class CodeEditor;

class EditorBar : public FrameLeft<Ctrl> {
public:
	virtual void Paint(Draw& w);
	virtual void MouseMove(Point p, dword flags);
	virtual void LeftDown(Point p, dword flags);
	virtual void LeftDouble(Point p, dword flags);
	virtual void RightDown(Point p, dword flags);

private:
	struct LnInfo : Moveable<LnInfo> {
		int    lineno;
		String breakpoint;
		int    error;
		int    firstedited;
		int    edited;

		LnInfo() { lineno = -1; error = 0; firstedited = 0; edited = 0; }
	};
	Vector<LnInfo>   li;
	LineInfoRem      li_removed;

	int              sy;
	CodeEditor       *editor;
	int              ptrline[2];
	Image            ptrimg[2];
	bool             bingenabled;
	bool             hilite_if_endif;
	bool             line_numbers;
	bool             ignored_next_edit;
	int              next_age;

	String& PointBreak(int& y);
	void    sPaintImage(Draw& w, int y, int fy, const Image& img);

public:
	Callback1<int> WhenBreakpoint;

	void InsertLines(int i, int count);
	void RemoveLines(int i, int count);
	void ClearLines();

	void Scroll()                          { Refresh(); }

	void Renumber(int linecount);
	void ClearBreakpoints();
	void ValidateBreakpoints();

	String  GetBreakpoint(int ln);
	void    SetBreakpoint(int ln, const String& s);
	void    SetEdited(int ln, int count = 1);
	void    ClearEdited();
	void    SetError(int ln, int err);
	void    ClearErrors(int ln);

	void SetEditor(CodeEditor *e)           { editor = e; }

	LineInfo GetLineInfo() const;
	void     SetLineInfo(const LineInfo& li, int total);
	LineInfoRem & GetLineInfoRem()                   { return li_removed; }
	void     SetLineInfoRem( LineInfoRem& li)   { li_removed = li; }

	int      GetLineNo(int lineno) const;
	int      GetNoLine(int line) const;

	void     SetPtr(int line, const Image& img, int i);
	void     HidePtr();

	void     EnableBreakpointing(bool b)   { bingenabled = b; }
	void     HiliteIfEndif(bool b)         { hilite_if_endif = b; Refresh(); }
	void     LineNumbers(bool b);

	bool     IsHiliteIfEndif() const       { return hilite_if_endif; }

	EditorBar();
	virtual ~EditorBar();
};

struct IdentPos {
	int    begin;
	int    end;
	String ident;
};

Array<IdentPos> GetLineIdent(const char *line);
Vector<Point>   GetLineString(const wchar *wline, bool& is_begin, bool& is_end);

inline int  CharFilterCIdent(int i)  { return IsAlNum(i) || i == '_' ? i : 0; }
inline bool islbrkt(int c)           { return c == '{' || c == '[' || c == '('; }
inline bool isrbrkt(int c)           { return c == '}' || c == ']' || c == ')'; }
inline bool isbrkt(int c)            { return islbrkt(c) || isrbrkt(c); }

class CodeEditor : public LineEdit {
	friend class EditorBar;

public:
	virtual bool Key(dword code, int count);
	virtual void LeftDown(Point p, dword keyflags);
	virtual void LeftDouble(Point p, dword keyflags);
	virtual void MouseMove(Point p, dword keyflags);
	virtual void Serialize(Stream& s);
	void         CheckEdited(bool e = true) { check_edited = e; }
	bool         GetCheckEdited()           { return check_edited; }

	enum {
		HIGHLIGHT_NONE = -1, HIGHLIGHT_CPP = 0, HIGHLIGHT_USC, HIGHLIGHT_JAVA, HIGHLIGHT_T, HIGHLIGHT_CALC,
		HIGHLIGHT_COUNT
	};

protected:
	virtual void HighlightLine(int line, Vector<Highlight>& h, int pos);
	virtual void PreInsert(int pos, const WString& s);
	virtual void PostInsert(int pos, const WString& s);
	virtual void PreRemove(int pos, int size);
	virtual void PostRemove(int pos, int size);
	virtual void DirtyFrom(int line);
	virtual void SelectionChanged();

	virtual void ClearLines();
	virtual void InsertLines(int line, int count);
	virtual void RemoveLines(int line, int count);

	virtual void NewScrollPos();

	EditorBar   bar;
	Vector<int> line2;

	static Index<String> keyword[HIGHLIGHT_COUNT];
	static Index<String> name[HIGHLIGHT_COUNT];
	static Index<String> kw_upp_macros;
	static Index<String> kw_sql_base;
	static Index<String> kw_sql_bool;
	static Index<String> kw_sql_func;

	struct Isx : Moveable<Isx> {
		int    line;
		int    pos;

		friend bool operator==(Isx a, Isx b) { return a.line == b.line && a.pos == b.pos; }
		friend bool operator!=(Isx a, Isx b) { return !(a == b); }
	};

	struct IfState : Moveable<IfState> {
		enum        { IF = '0', ELIF, ELSE, ELSE_ERROR, ENDIF_ERROR };
		WString iftext;
		short   ifline;
		char    state;

		bool operator==(const IfState& b) const {
			return iftext == b.iftext && state == b.state && ifline == b.ifline;
		}

		IfState()                         { ifline = state = 0; }
	};

	struct SyntaxState {
		int         line;

		bool        comment;
		bool        linecomment;
		bool        string;
		bool        linecont;
		char        macro;
		enum        { MACRO_OFF, MACRO_CONT, MACRO_END };

		int         cl, bl, pl;

		WithDeepCopy< Vector<int> > brk;
		WithDeepCopy< Vector<int> > blk;
		WithDeepCopy< Vector<int> > bid;
		WithDeepCopy< Vector<Isx> > par;
		WithDeepCopy< Vector<IfState> > ifstack;

		int         stmtline;
		int         endstmtline;
		int         seline;
		int         spar;
		Color       uvscolor;

		void  DropItem(int type);
		bool  Drop(int type);
		void  Clear();
		bool  MatchHilite(const SyntaxState& st) const;
		void  ScanSyntax(const wchar *ln, const wchar *e);

		static Color IfColor(char ifstate);

		SyntaxState()                         { Clear(); }
	};

	friend struct SyntaxState;

	SyntaxState scache[4];
	SyntaxState rm_ins;
	char        rmb;
	byte        hilite_bracket;
	int         highlight_bracket_pos0;
	int         highlight_bracket_pos;
	bool        bracket_flash;
	int         bracket_start;

	byte    hilite_scope;
	byte    hilite_ifdef;
	bool    indent_spaces : 1;
	bool    no_parenthesis_indent : 1;
	int     indent_amount;
	double  stat_edit_time;
	Time    last_key_time;

	bool    auto_enclose;
	bool    mark_lines;
	bool    check_edited;

	struct FindReplace : WithIDEFindReplaceLayout<TopWindow> {
		WString itext;
		virtual bool Key(dword key, int count);
	} findreplace;

	enum {
		WILDANY = 16,
		WILDONE,
		WILDSPACE,
		WILDNUMBER,
		WILDID,
	};

	struct Found {
		int     type;
		WString text;
	};

	Array<Found> foundwild;
	bool   foundsel;
	bool   found, notfoundfw, notfoundbk;

	int    iwc;

	int    highlight;

	struct HlSt;

	static void InitKeywords();

	const wchar *HlString(HlSt& hls, const wchar *p);

	SyntaxState ScanSyntax(int line);

	void   CancelBracketHighlight(int& pos);
	void   CheckBracket(int li, int pos, int ppos, int pos0, WString ln, int d, int limit);
	void   CheckLeftBracket(int pos);
	void   CheckRightBracket(int pos);
	void   CheckBrackets();
	void   OpenNormalFindReplace();
	void   FindReplaceAddHistory();
	void   FindWildcard();
	void   ReplaceWildcard();
	void   InsertWildcard(int c);

	void   SetFound(int fi, int type, const WString& text);

	int     Match(const wchar *f, const wchar *s, int line, bool we, bool icase, int fi = 0);
	WString GetWild(int type, int& i);
	WString GetReplaceText();
	WString GetReplaceText(WString replace, bool wildcards);

	bool   InsertRS(int chr, int count = 1);
	void   IndentEnter(int count = 1);
	void   SyntaxIndent(const SyntaxState& st, bool ndnt);
	void   IndentInsert(int chr);

	void   ForwardWhenBreakpoint(int i);

	Color  BlockColor(int level);
	void   Bracket(int pos, HlSt& hls);

	bool   ToggleSimpleComment(int &start_line, int &end_line, bool usestars = true);
	void   ToggleLineComments(bool usestars = false);
	void   ToggleStarComments();
	void   Enclose(const char *c1, const char *c2, int l = -1, int h = -1);

	enum {
		TIMEID_PERIODIC = Ctrl::TIMEID_COUNT,
		TIMEID_COUNT,
	};

	void   Periodic();

public:

	enum {
#line 1 "u:\\uppsrc\\codeeditor\\hl_color.i"


INK_NORMAL,
PAPER_NORMAL,
INK_SELECTED,
PAPER_SELECTED,
INK_DISABLED,
PAPER_READONLY,

INK_COMMENT,
INK_CONST_STRING,
INK_OPERATOR,
INK_KEYWORD,
INK_UPP,
PAPER_LNG,
INK_ERROR,
INK_PAR0,
INK_PAR1,
INK_PAR2,
INK_PAR3,
INK_CONST_INT,
INK_CONST_FLOAT,
INK_CONST_HEX,
INK_CONST_OCT,
INK_CONST_STRINGOP,
PAPER_BRACKET0,
PAPER_BRACKET,

PAPER_BLOCK1,
PAPER_BLOCK2,
PAPER_BLOCK3,
PAPER_BLOCK4,

INK_MACRO,
PAPER_MACRO,
PAPER_IFDEF,
INK_IFDEF,

INK_UPPER,
INK_SQLBASE,
INK_SQLFUNC,
INK_SQLBOOL,
INK_UPPMACROS,
#line 337 "u:/uppsrc\\CodeEditor/CodeEditor.h"
		HL_COUNT
	};


	struct HlStyle {
		Color color;
		bool  bold;
		bool  italic;
		bool  underline;
	};

private:
	HlStyle  hl_style[HL_COUNT];

public:
	Callback WhenSelection;
	Callback1<const String&> WhenDbgView;
	Callback WhenLeftDown;

	FrameTop<Button>    topsbbutton;
	FrameTop<Button>    topsbbutton1;

	void   Clear()                    { LineEdit::Clear(); found = notfoundfw = notfoundbk = false; }

	void   Highlight(int h)           { highlight = h; Refresh(); }
	int    GetHighlight() const       { return highlight; }

	const HlStyle& GetHlStyle(int i);
	void           SetHlStyle(int i, Color c, bool bold = false, bool italic = false, bool underline = false);

	void   CloseFindReplace();
	void   FindReplace(bool pick_text);
	bool   Find(bool back, const wchar *text, bool wholeword, bool ignorecase, bool wildcards,
	            bool block);
	bool   Find(bool back = false, bool blockreplace = false);
	bool   GetStringRange(int cursor, int& b, int &e) const;
	bool   GetStringRange(int& b, int &e) const { return GetStringRange(GetCursor(), b, e); }
	bool   FindString(bool back);
	bool   FindLangString(bool back);
	void   Replace();
	void   BlockReplace();
	int    BlockReplace(WString find, WString replace, bool wholeword, bool ignorecase, bool wildcards);
	void   MakeTabs();
	void   MakeTabsOrSpaces(bool tabs);

	void   CopyWord();
	void   SwapChars();

	void   SerializeFind(Stream& s);
	bool   IsFindOpen() const                       { return findreplace.IsOpen(); }
	void   FindClose()                              { findreplace.Close(); }

	void   Goto();

	void   DoFind();
	void   DoFindBack();

	void    FindWord(bool back);
	WString GetI();
	void    SetI(Ctrl *edit);
	void    PutI(WithDropChoice<EditString>& edit);

	void   MoveNextWord(bool sel);
	void   MovePrevWord(bool sel);
	void   MoveNextBrk(bool sel);
	void   MovePrevBrk(bool sel);

	String GetWord();

	bool   GetWordPos(int pos, int& l, int& h);

	void   DeleteWord();
	void   DeleteWordBack();
	void   SetLineSelection(int l, int h);
	bool   GetLineSelection(int& l, int& h);
	void   TabRight();
	void   TabLeft();

	Callback1<int> WhenBreakpoint;

	LineInfo GetLineInfo() const                      { return bar.GetLineInfo(); }
	void     SetLineInfo(const LineInfo& lf);
	LineInfoRem GetLineInfoRem()                      { return LineInfoRem(bar.GetLineInfoRem(), 0); }
	void     SetLineInfoRem( LineInfoRem& lf)    { bar.SetLineInfoRem(LineInfoRem(lf, 0)); }
	double   GetStatEditTime() const                  { return stat_edit_time; }
	void     Renumber()                               { bar.Renumber(GetLineCount()); }
	void     ClearBreakpoints()                       { bar.ClearBreakpoints(); }
	void     ValidateBreakpoints()                    { bar.ValidateBreakpoints(); }
	int      GetLineNo(int line) const                { return bar.GetLineNo(line); }
	int      GetNoLine(int line) const                { return bar.GetNoLine(line); }
	void     SetPtr(int line, const Image& img, int i){ bar.SetPtr(line, img, i); }
	void     HidePtr()                                { bar.HidePtr(); }
	String   GetBreakpoint(int line)                  { return bar.GetBreakpoint(line); }
	void     SetBreakpoint(int line, const String& b) { bar.SetBreakpoint(line, b); }
	void     SetError(int line, int err)              { bar.SetError(line, err); }
	void     ClearErrors(int line = -1)               { bar.ClearErrors(line); }
	void     ClearEdited()                            { bar.ClearEdited(); }
	int		 GetUndoCount()                           { return undo.GetCount(); }
	void     GotoLine(int line);
	void     EnableBreakpointing()                    { bar.EnableBreakpointing(true); }
	void     DisableBreakpointing()                   { bar.EnableBreakpointing(false); }
	void     Renumber2();
	int      GetLine2(int i) const;

	void     HiliteScope(byte b)                      { hilite_scope = b; Refresh(); }
	void     HiliteBracket(byte b)                    { hilite_bracket = b; Refresh(); }
	void     HiliteIfDef(byte b)                      { hilite_ifdef = b; Refresh(); }
	void     HiliteIfEndif(bool b)                    { bar.HiliteIfEndif(b); }
	void     IndentSpaces(bool is)                    { indent_spaces = is; }
	void     IndentAmount(int ia)                     { indent_amount = ia; }
	void     NoParenthesisIndent(bool b)              { no_parenthesis_indent = b; }
	void     LineNumbers(bool b)                      { bar.LineNumbers(b); }
	void     MarkLines(bool b)                        { mark_lines = b; }
	bool     GetMarkLines()                           { return mark_lines; }
	void     AutoEnclose(bool b)                      { auto_enclose = b; }

	void     HideBar()                                { bar.Hide(); }

	void     DefaultHlStyles();
	void     LoadHlStyles(const char *s);
	String   StoreHlStyles();

	const char *GetHlName(int i);
	bool        HasHlFont(int i);

	typedef CodeEditor CLASSNAME;

	CodeEditor();
	virtual ~CodeEditor();

	static const Index<String>& CppKeywords();
};

};

#line 473 "u:/uppsrc\\CodeEditor/CodeEditor.h"
#line 57 "u:/idisapp\\IdisMisc/IdisMisc.h"

struct BarImg : public CtrlImg {};
struct DocImg : public CtrlImg {};





void LRUAdd(Vector<int>* lru, int value, int limit);

#line 1 "u:/idisapp\\isu/adresa.h"






namespace Adresy
{



void AdresyModel(bool run = false);

Index<int> GetObecAdresy();





#line 1 "u:/uppsrc\\Sql/sch_header.h"

































#line 1 "u:/uppsrc\\Oracle/OracleSchema.h"


























































#line 60 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 65 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 70 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 75 "u:/uppsrc\\Oracle/OracleSchema.h"















#line 1 "u:/uppsrc\\Sql/sch_model.h"




#line 6 "u:/uppsrc\\Sql/sch_model.h"



#line 10 "u:/uppsrc\\Sql/sch_model.h"



#line 14 "u:/uppsrc\\Sql/sch_model.h"



#line 18 "u:/uppsrc\\Sql/sch_model.h"




#line 23 "u:/uppsrc\\Sql/sch_model.h"



#line 27 "u:/uppsrc\\Sql/sch_model.h"



#line 31 "u:/uppsrc\\Sql/sch_model.h"








#line 40 "u:/uppsrc\\Sql/sch_model.h"



#line 44 "u:/uppsrc\\Sql/sch_model.h"







#line 52 "u:/uppsrc\\Sql/sch_model.h"











#line 64 "u:/uppsrc\\Sql/sch_model.h"







#line 72 "u:/uppsrc\\Sql/sch_model.h"







#line 80 "u:/uppsrc\\Sql/sch_model.h"



#line 84 "u:/uppsrc\\Sql/sch_model.h"



#line 88 "u:/uppsrc\\Sql/sch_model.h"



#line 92 "u:/uppsrc\\Sql/sch_model.h"



#line 96 "u:/uppsrc\\Sql/sch_model.h"



#line 100 "u:/uppsrc\\Sql/sch_model.h"



#line 104 "u:/uppsrc\\Sql/sch_model.h"



#line 108 "u:/uppsrc\\Sql/sch_model.h"



#line 112 "u:/uppsrc\\Sql/sch_model.h"



#line 116 "u:/uppsrc\\Sql/sch_model.h"







#line 124 "u:/uppsrc\\Sql/sch_model.h"







#line 132 "u:/uppsrc\\Sql/sch_model.h"








#line 141 "u:/uppsrc\\Sql/sch_model.h"



#line 145 "u:/uppsrc\\Sql/sch_model.h"



#line 149 "u:/uppsrc\\Sql/sch_model.h"



#line 153 "u:/uppsrc\\Sql/sch_model.h"



#line 157 "u:/uppsrc\\Sql/sch_model.h"



#line 161 "u:/uppsrc\\Sql/sch_model.h"

#line 1 "u:/idisapp\\isu/adr_model.sch"









 struct S_KATASTR  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_KATASTR::FieldLayout); } S_KATASTR();
	 enum { KATASTR_SEQ_WIDTH = 0, KATASTR_SEQ_PRECISION = 0 }; int KATASTR_SEQ;
	 enum { POPIS_WIDTH = 100, POPIS_PRECISION = 0 }; String POPIS;
};





struct S_ADRESA_BASE  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_ADRESA_BASE::FieldLayout); } S_ADRESA_BASE();
	 enum { PAR_ADRESA_SEQ_WIDTH = 0, PAR_ADRESA_SEQ_PRECISION = 0 }; int PAR_ADRESA_SEQ;
	 enum { UROVEN_WIDTH = 0, UROVEN_PRECISION = 0 }; int UROVEN;

	 enum { HODNOTA1_WIDTH = 200, HODNOTA1_PRECISION = 0 }; String HODNOTA1;
	 enum { HODNOTA2_WIDTH = 200, HODNOTA2_PRECISION = 0 }; String HODNOTA2;
	 enum { PSC_WIDTH = 20, PSC_PRECISION = 0 }; String PSC;
	 enum { IDX_WIDTH = 20, IDX_PRECISION = 0 }; String IDX;
	 enum { ZUZI_WIDTH = 20, ZUZI_PRECISION = 0 }; String ZUZI;
	 enum { KOD_WIDTH = 30, KOD_PRECISION = 0 }; String KOD;
	 enum { ZDROJ_WIDTH = 20, ZDROJ_PRECISION = 0 }; String ZDROJ;
	enum { KATASTR_SEQ_WIDTH = 0, KATASTR_SEQ_PRECISION = 0 }; int KATASTR_SEQ;
	 enum { TEXT_WIDTH = 200, TEXT_PRECISION = 0 }; String TEXT;
};



 struct S_ADRESA : public S_ADRESA_BASE { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_ADRESA::FieldLayout); } S_ADRESA();
	 enum { ADRESA_SEQ_WIDTH = 0, ADRESA_SEQ_PRECISION = 0 }; int ADRESA_SEQ;
};



 struct S_A_ADRESA : public S_ADRESA_BASE { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_A_ADRESA::FieldLayout); } S_A_ADRESA();
	enum { ADRESA_SEQ_WIDTH = 0, ADRESA_SEQ_PRECISION = 0 }; int ADRESA_SEQ;
	 enum { A_ADRESA_SEQ_WIDTH = 0, A_ADRESA_SEQ_PRECISION = 0 }; int A_ADRESA_SEQ;
	 enum { A_DO_WIDTH = 0, A_DO_PRECISION = 0 }; Date A_DO;
	 enum { A_TEXT_WIDTH = 2000, A_TEXT_PRECISION = 0 }; String A_TEXT;
};


#line 163 "u:/uppsrc\\Sql/sch_model.h"




































#line 91 "u:/uppsrc\\Oracle/OracleSchema.h"





















































#line 35 "u:/uppsrc\\Sql/sch_header.h"










#line 1 "u:/uppsrc\\Oracle/OracleSchema.h"


























































#line 60 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 65 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 70 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 75 "u:/uppsrc\\Oracle/OracleSchema.h"















#line 1 "u:/uppsrc\\Sql/sch_model.h"








#line 10 "u:/uppsrc\\Sql/sch_model.h"
















#line 27 "u:/uppsrc\\Sql/sch_model.h"




















#line 48 "u:/uppsrc\\Sql/sch_model.h"



#line 52 "u:/uppsrc\\Sql/sch_model.h"



#line 56 "u:/uppsrc\\Sql/sch_model.h"



#line 60 "u:/uppsrc\\Sql/sch_model.h"



#line 64 "u:/uppsrc\\Sql/sch_model.h"



#line 68 "u:/uppsrc\\Sql/sch_model.h"



#line 72 "u:/uppsrc\\Sql/sch_model.h"



#line 76 "u:/uppsrc\\Sql/sch_model.h"



#line 80 "u:/uppsrc\\Sql/sch_model.h"



#line 84 "u:/uppsrc\\Sql/sch_model.h"



#line 88 "u:/uppsrc\\Sql/sch_model.h"



#line 92 "u:/uppsrc\\Sql/sch_model.h"



#line 96 "u:/uppsrc\\Sql/sch_model.h"



#line 100 "u:/uppsrc\\Sql/sch_model.h"



#line 104 "u:/uppsrc\\Sql/sch_model.h"



#line 108 "u:/uppsrc\\Sql/sch_model.h"



#line 112 "u:/uppsrc\\Sql/sch_model.h"



#line 116 "u:/uppsrc\\Sql/sch_model.h"



#line 120 "u:/uppsrc\\Sql/sch_model.h"



#line 124 "u:/uppsrc\\Sql/sch_model.h"



#line 128 "u:/uppsrc\\Sql/sch_model.h"







#line 136 "u:/uppsrc\\Sql/sch_model.h"








#line 145 "u:/uppsrc\\Sql/sch_model.h"



#line 149 "u:/uppsrc\\Sql/sch_model.h"



#line 153 "u:/uppsrc\\Sql/sch_model.h"



#line 157 "u:/uppsrc\\Sql/sch_model.h"



#line 161 "u:/uppsrc\\Sql/sch_model.h"

#line 1 "u:/idisapp\\isu/adr_model.sch"





extern SqlId OBEC_ADRESY;



extern SqlId KATASTR;
	extern SqlId KATASTR_SEQ;
	extern SqlId POPIS;







	extern SqlId PAR_ADRESA_SEQ;
	extern SqlId UROVEN;

	extern SqlId HODNOTA1;
	extern SqlId HODNOTA2;
	extern SqlId PSC;
	extern SqlId IDX;
	extern SqlId ZUZI;
	extern SqlId KOD;
	extern SqlId ZDROJ;

	extern SqlId TEXT;




extern SqlId ADRESA;
	extern SqlId ADRESA_SEQ;




extern SqlId A_ADRESA;

	extern SqlId A_ADRESA_SEQ;
	extern SqlId A_DO;
	extern SqlId A_TEXT;



#line 163 "u:/uppsrc\\Sql/sch_model.h"




































#line 91 "u:/uppsrc\\Oracle/OracleSchema.h"





















































#line 46 "u:/uppsrc\\Sql/sch_header.h"
#line 21 "u:/idisapp\\isu/adresa.h"


extern SqlSequence SeqAdresa;



inline void AssertMoveable0(S_ADRESA *) {};

class AdresaArchiv
{
public:
	Vector<String> stat, obec, okres, ulice, ctvrt, misto, cor, cpop, byt, vchod;

	void                 Apply(const S_ADRESA_BASE& archiv);
};



class Adresa
{
public:
	Adresa(int adresa_seq = Null, Date date = Null, bool archiv = false);

	void                 Apply(const S_ADRESA_BASE& adresa, int adresa_seq, bool first, bool noquery = false);

	void                 SelfLines(String& l1, String& l2, String& l3, bool psc = true, bool nookres = false) const;
	String               SelfDesc(dword style = 0) const;
	String               SelfLevelDesc(int level) const;

	int                  GetLevelSeq(int level) const;
	int                  GetDiffLevel(const Adresa&) const;
	void                 SelfDiffLines(const Adresa& a, String& l1, String& l2, String& l3, bool p = true,
	                                   bool nookres = false, bool upperobec = false, bool popis = false) const;
	String               SelfDiffDesc(const Adresa& a, dword style = 0) const;

	static  void         GetLines(int node, String& l1, String& l2, String& l3, bool psc = true,
	                              Date date = Null, bool archiv = false, bool nookres = false);
	static  String       GetDesc(int adr_seq, dword style = 0, Date date = Null);
	static  int          GetParent(int node, Date date = Null);
	static  int          GetLevel(int node);
	static  bool         HasChildren(int node, int maxlvl = MAX_LEVEL);
	static  void         GetDiffLines(int adr_seq, const Adresa& a, String& l1, String& l2, String& l3,
	                                  bool psc = true, Date = Null, bool archiv = false,
	                                  bool nookres = false, bool upperobec = false);
	static  String       GetDiffDesc(int adr_seq, const Adresa& a, dword style = 0, Date date = Null);

	static const Adresa& GetEmpty();
	static const Adresa& GetObecAdresa();
	static const Adresa& GetStatAdresa();
	static const Adresa& GetUradAdresa() { return GetObecAdresa(); }

public:
	int                  adresa_seq;

	String               zdroj;
	String               psc;
	bool                 haspsc;
	bool                 zrusena;
	String               idx;
	String               zuzi;
	String               kod;

	int                  okrsek_seq;
	int                  okrsek;
	String               cast_okrsku;

	int                  level;
	int                  parent_seq;

	int                  stat_seq;
	String               stat;

	int                  obec_seq;
	String               obec;
	String               okres;

	int                  katastr_seq;
	String               katastr;
	bool                 haskatastr;

	int                  ulice_seq;
	String               ulice;
	String               ctvrt;

	int                  misto_seq;
	String               cor, a_cor;
	String               cpop, a_cpop;
	String               popis;

	int                  byt_seq;
	String               vchod, a_vchod;
	String               byt, a_byt;

	enum {
		SVET_LEVEL,
		STAT_LEVEL,
		OBEC_LEVEL,
		ULICE_LEVEL,
		MISTO_LEVEL,
		BYT_LEVEL,

		MIN_LEVEL = STAT_LEVEL,
		MAX_LEVEL = BYT_LEVEL,
	};

	enum {
		MULTILINE = 0x00000001,
		PSC       = 0x80000000,
		STAT      = 0x40000000,
		BYT       = 0x20000000,
		NOZRUSENA = 0x10000000,
		ARCHIV    = 0x08000000,
		NOOKRES   = 0x04000000,
		UPPEROBEC = 0x02000000,
		POPIS     = 0x01000000,
	};

private:
	void                 SetNulls();
	static const Adresa& GetEmd();
};




class AdresaSort
{
public:
	AdresaSort(int index = Null);

	bool                           Load(int index);
	bool                           Save();

	String                         GetSortItems() const;
	String                         SelfDesc() const;

	operator bool () const         { return !IsNull(index); }

	int                            Compare(const Adresa& a, const Adresa& b) const;
	bool                           operator () (const Adresa& a, const Adresa& b) const { return Compare(a, b) < 0; }

	static VectorMap<Value, Value> GetSortMap(int offset = 0);
	static Index<int>              GetIndex(int method);

public:
	enum
	{
		STAT,
		OBEC, OKRES,
		ULICE, CTVRT,
		CPOP, COR,
		BYT, VCHOD,
		IDX, PSC, ZUZI, KOD,
		OKRSEK, CAST_OKRSKU,
		COUNT,

		DESC = 0x80,
	};

public:
	int                            index;
	String                         name;
	int                            aspect[COUNT];

	static const String            Key;
	static const char             *AspectName[COUNT];
};

template Moveable<AdresaSort>;




Adresa& CachedAdresa(int adresa_seq, Date date = Null);

class ConvertAdresa : public Convert
{
public:
	ConvertAdresa(dword style = 0, Date date = Null) : style(style), date(date) {}

	virtual Value  Format(const Value& value) const;

	ConvertAdresa& SetStyle(dword _style) { style = _style; return *this; }
	dword          GetStyle() const       { return style; }

	ConvertAdresa& SetDate(Date _date)    { date = _date; return *this; }
	Date           GetDate() const        { return date; }

protected:
	Date           date;
	dword          style;
};

extern const ConvertAdresa StdConvertAdresa;
extern const ConvertAdresa StdConvertArchivAdresa;
extern const ConvertAdresa StdConvertLineAdresa;
extern const ConvertAdresa StdConvertLineArchivAdresa;
extern const ConvertAdresa StdConvertStateAdresa;
extern const ConvertAdresa StdConvertLineStateAdresa;
extern const ConvertAdresa StdConvertCityAdresa;
extern const ConvertAdresa StdConvertLineCityAdresa;



extern Vector<int> AdresaLRU;



class DlgAdresa
{
public:
	DlgAdresa();

	DlgAdresa&         Node(int _node)              { node = _node; return *this; }
	int                GetNode() const              { return node; }

	DlgAdresa&         ExcludeNode(int _excl)       { exclude = _excl; return *this; }
	int                GetExcludeNode() const       { return exclude; }

	DlgAdresa&         Title(const String& _title)  { title = _title; return *this; }
	const String&      GetTitle() const             { return title; }

	DlgAdresa&         MinLevel(int _minlvl)        { minlvl = _minlvl; return *this; }
	int                GetMinLevel() const          { return minlvl; }

	DlgAdresa&         MaxLevel(int _maxlvl)        { maxlvl = _maxlvl; return *this; }
	int                GetMaxLevel() const          { return maxlvl; }

	DlgAdresa&         MinMax(int _min, int _max)   { minlvl = _min; maxlvl = _max; return *this; }
	DlgAdresa&         Level(int _lvl)              { minlvl = maxlvl = _lvl; return *this; }

	DlgAdresa&         NotNull(bool _nn = true)     { notnull = _nn; return *this; }
	DlgAdresa&         NoNotNull()                  { return NotNull(false); }
	bool               IsNotNull() const            { return notnull; }

	DlgAdresa&         Edit(bool e = true)          { editable = e; return *this; }
	DlgAdresa&         NoEdit()                     { return Edit(false); }
	bool               IsEdit() const               { return editable; }

	DlgAdresa&         Editor(bool ed = true)       { editor = ed; return *this; }
	DlgAdresa&         NoEditor()                   { return Editor(false); }
	bool               IsEditor() const             { return editor; }

	DlgAdresa&         ShowVolby(bool _v = true)    { volby = _v; return *this; }
	DlgAdresa&         NoShowVolby()                { return ShowVolby(false); }
	bool               IsShowVolby() const          { return volby; }

	DlgAdresa&         LRU(Vector<int> *_lru)       { lru = _lru; return *this; }
	Vector<int>       *GetLRU() const               { return lru; }

	DlgAdresa&         Hint(const Vector<int> *_h)  { hint = _h; return *this; }
	const Vector<int> *GetHint() const              { return hint; }

	int                Run();




	void               LRUAdd(int seq)              { ::LRUAdd(lru, seq, 10); }

protected:
	int                node;
	int                exclude;
	String             title;
	int                minlvl, maxlvl;
	bool               editable;
	bool               editor;
	bool               notnull;
	bool               volby;
	Vector<int>       *lru;
	const Vector<int> *hint;
};



class AdresaCtrl : public DataPusher, public DlgAdresa
{
public:
	bool mesto;
	bool local;
	AdresaCtrl(const Convert& cv = StdConvertArchivAdresa);

	        operator int () const { return (int)data; }
	AdresaCtrl& operator = (int seq)  { SetData(seq); return *this; }

	virtual void   SetData(const Value& value);



protected:
	virtual void DoAction();
};

class LineAdresaCtrl : public AdresaCtrl
{
public:
	LineAdresaCtrl() : AdresaCtrl(StdConvertLineArchivAdresa) {}

	LineAdresaCtrl& operator = (int seq)  { SetData(seq); return *this; }
};

class StateAdresaCtrl : public AdresaCtrl
{
public:
	StateAdresaCtrl() : AdresaCtrl(StdConvertStateAdresa) {}

	StateAdresaCtrl& operator = (int seq)  { SetData(seq); return *this; }
};

class LineStateAdresaCtrl : public AdresaCtrl
{
public:
	LineStateAdresaCtrl() : AdresaCtrl(StdConvertLineStateAdresa) {}

	LineStateAdresaCtrl& operator = (int seq)  { SetData(seq); return *this; }
};

class CityAdresaCtrl : public AdresaCtrl
{
public:
	CityAdresaCtrl() : AdresaCtrl(StdConvertCityAdresa) {}

	CityAdresaCtrl& operator = (int seq)  { SetData(seq); return *this; }
};

class LineCityAdresaCtrl : public AdresaCtrl {
public:
	LineCityAdresaCtrl() : AdresaCtrl(StdConvertLineCityAdresa) {}

	LineCityAdresaCtrl& operator = (int seq)  { SetData(seq); return *this; }
};

class StatCtrl : public AdresaCtrl {
public:
	StatCtrl();

	StatCtrl& operator = (int seq)  { SetData(seq); return *this; }
};




String RunDlgOkres(int parent_seq, const String& init = Null,
				   bool write = true, bool not_null = false,
				   const String& exclude = Null);



class OkresCtrl : public DataPusher
{
public:
	OkresCtrl();

	OkresCtrl&   Parent(int _parent_seq)       { parent_seq = _parent_seq; return *this; }
	int          GetParent() const             { return parent_seq; }

	OkresCtrl&   Edit(bool _write = true)      { write = _write; return *this; }
	OkresCtrl&   NoEdit()                      { return Edit(false); }
	bool         IsEdit() const                { return write; }

	OkresCtrl&   NotNull(bool _nn = true)      { not_null = _nn; return *this; }
	OkresCtrl&   NoNotNull()                   { return NotNull(false); }
	bool         IsNotNull() const             { return not_null; }

protected:
	virtual void DoAction();

protected:
	int          parent_seq;
	bool         write;
	bool         not_null;
};



class ConvertKatastr : public Convert
{
public:
	ConvertKatastr(bool code = true, bool name = true) : code(code), name(name) {}

	ConvertKatastr& Code(bool _code) { code = _code; return *this; }
	ConvertKatastr& NoCode()         { return Code(false); }
	bool            IsCode() const   { return code; }

	ConvertKatastr& Name(bool _name) { name = _name; return *this; }
	ConvertKatastr& NoName()         { return Name(false); }
	bool            IsName() const   { return name; }

	virtual Value   Format(const Value& value) const;

protected:
	bool            code;
	bool            name;
};

extern ConvertKatastr StdConvertKatastr;
extern ConvertKatastr StdConvertKatastrName;
extern ConvertKatastr StdConvertKatastrCode;




int RunDlgKatastr(int init = Null, bool write = true, bool not_null = false);



class KatastrCtrl : public DataPusher
{
public:
	KatastrCtrl(const Convert& convert = StdConvertKatastr,
		bool edit = true, bool not_null = false)
		: DataPusher(convert), edit(edit), not_null(not_null) {}

	KatastrCtrl& Edit(bool _edit = true)        { edit = _edit; return *this; }
	KatastrCtrl& NoEdit()                       { return Edit(false); }
	bool         IsEdit() const                 { return edit; }

	KatastrCtrl& NotNull(bool _not_null = true) { not_null = _not_null; return *this; }
	KatastrCtrl& NoNotNull()                    { return NotNull(false); }
	bool         IsNotNull() const              { return not_null; }

protected:
	virtual void DoAction();

protected:
	bool         edit;
	bool         not_null;
};








































































}

using namespace Adresy;

SqlSelect AdresaIn(int adresa_seq);
SqlSelect ObecAdresa();

#line 529 "u:/idisapp\\isu/adresa.h"
#line 68 "u:/idisapp\\IdisMisc/IdisMisc.h"
#line 1 "u:/idisapp\\isu/osoba.h"






#line 1 "u:\\idisapp\\isu\\os_model.h"








namespace Osoby
{



void OsobyModel(bool run = false);






#line 1 "u:/uppsrc\\Sql/sch_header.h"

































#line 1 "u:/uppsrc\\Oracle/OracleSchema.h"


























































#line 60 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 65 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 70 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 75 "u:/uppsrc\\Oracle/OracleSchema.h"















#line 1 "u:/uppsrc\\Sql/sch_model.h"








#line 10 "u:/uppsrc\\Sql/sch_model.h"
















#line 27 "u:/uppsrc\\Sql/sch_model.h"
















#line 44 "u:/uppsrc\\Sql/sch_model.h"







#line 52 "u:/uppsrc\\Sql/sch_model.h"











#line 64 "u:/uppsrc\\Sql/sch_model.h"







#line 72 "u:/uppsrc\\Sql/sch_model.h"







#line 80 "u:/uppsrc\\Sql/sch_model.h"



#line 84 "u:/uppsrc\\Sql/sch_model.h"



#line 88 "u:/uppsrc\\Sql/sch_model.h"



#line 92 "u:/uppsrc\\Sql/sch_model.h"



#line 96 "u:/uppsrc\\Sql/sch_model.h"



#line 100 "u:/uppsrc\\Sql/sch_model.h"



#line 104 "u:/uppsrc\\Sql/sch_model.h"



#line 108 "u:/uppsrc\\Sql/sch_model.h"



#line 112 "u:/uppsrc\\Sql/sch_model.h"



#line 116 "u:/uppsrc\\Sql/sch_model.h"







#line 124 "u:/uppsrc\\Sql/sch_model.h"




















#line 145 "u:/uppsrc\\Sql/sch_model.h"



#line 149 "u:/uppsrc\\Sql/sch_model.h"



#line 153 "u:/uppsrc\\Sql/sch_model.h"



#line 157 "u:/uppsrc\\Sql/sch_model.h"



#line 161 "u:/uppsrc\\Sql/sch_model.h"

#line 1 "u:/idisapp\\isu/os_model.sch"










 struct S_OSOBA_LOV  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OSOBA_LOV::FieldLayout); } S_OSOBA_LOV();
	 enum { OSOBA_LOV_SEQ_WIDTH = 0, OSOBA_LOV_SEQ_PRECISION = 0 }; int OSOBA_LOV_SEQ;
	enum { POPIS_WIDTH = 50, POPIS_PRECISION = 0 }; String POPIS;
	 enum { HIDDEN_WIDTH = 0, HIDDEN_PRECISION = 0 }; int HIDDEN;
	 enum { WRITEABLE_WIDTH = 0, WRITEABLE_PRECISION = 0 }; int WRITEABLE;
};



 struct S_OSOBA_LOVD  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OSOBA_LOVD::FieldLayout); } S_OSOBA_LOVD();
	 enum { OSOBA_LOVD_SEQ_WIDTH = 0, OSOBA_LOVD_SEQ_PRECISION = 0 }; int OSOBA_LOVD_SEQ;
	enum { OSOBA_LOV_SEQ_WIDTH = 0, OSOBA_LOV_SEQ_PRECISION = 0 }; int OSOBA_LOV_SEQ;
	 enum { LOVKEY_WIDTH = 20, LOVKEY_PRECISION = 0 }; String LOVKEY;
	 enum { VAL_WIDTH = 2000, VAL_PRECISION = 0 }; String VAL;
};



 struct S_OSOBA_CON  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OSOBA_CON::FieldLayout); } S_OSOBA_CON();
	 enum { OSOBA_CON_SEQ_WIDTH = 0, OSOBA_CON_SEQ_PRECISION = 0 }; int OSOBA_CON_SEQ;
	 enum { TYP_WIDTH = 1, TYP_PRECISION = 0 }; String TYP;
	 enum { MULTI_WIDTH = 0, MULTI_PRECISION = 0 }; int MULTI;
	 enum { COLNAME_WIDTH = 20, COLNAME_PRECISION = 0 }; String COLNAME;
	 enum { COLTYPE_WIDTH = 1, COLTYPE_PRECISION = 0 }; String COLTYPE;
	 enum { SKUPINA_WIDTH = 50, SKUPINA_PRECISION = 0 }; String SKUPINA;
	 enum { NAZEV_WIDTH = 50, NAZEV_PRECISION = 0 }; String NAZEV;
	enum { POPIS_WIDTH = 100, POPIS_PRECISION = 0 }; String POPIS;
	 enum { FORMAT_WIDTH = 100, FORMAT_PRECISION = 0 }; String FORMAT;

	 enum { LOV1_LOV_WIDTH = 0, LOV1_LOV_PRECISION = 0 }; int LOV1_LOV;
	 enum { LOV2_LOV_WIDTH = 0, LOV2_LOV_PRECISION = 0 }; int LOV2_LOV;

	 enum { NUM1_WIDTH = 50, NUM1_PRECISION = 0 }; String NUM1;
	 enum { NUM2_WIDTH = 50, NUM2_PRECISION = 0 }; String NUM2;
	 enum { CHR1_WIDTH = 50, CHR1_PRECISION = 0 }; String CHR1;
	 enum { CHR2_WIDTH = 50, CHR2_PRECISION = 0 }; String CHR2;
	 enum { LOV1_WIDTH = 50, LOV1_PRECISION = 0 }; String LOV1;
	 enum { LOV2_WIDTH = 50, LOV2_PRECISION = 0 }; String LOV2;
	 enum { DATE1_WIDTH = 50, DATE1_PRECISION = 0 }; String DATE1;
	 enum { DATE2_WIDTH = 50, DATE2_PRECISION = 0 }; String DATE2;
	 enum { OSOBA1_WIDTH = 50, OSOBA1_PRECISION = 0 }; String OSOBA1;
	 enum { OSOBA2_WIDTH = 50, OSOBA2_PRECISION = 0 }; String OSOBA2;
	 enum { ADRESA1_WIDTH = 50, ADRESA1_PRECISION = 0 }; String ADRESA1;
	 enum { ADRESA2_WIDTH = 50, ADRESA2_PRECISION = 0 }; String ADRESA2;
};



 struct S_OSOBA  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OSOBA::FieldLayout); } S_OSOBA();
	 enum { OSOBA_SEQ_WIDTH = 0, OSOBA_SEQ_PRECISION = 0 }; int OSOBA_SEQ;
	 enum { USERID_WIDTH = 20, USERID_PRECISION = 0 }; String USERID;
	 enum { CHLOG_WIDTH = 2000, CHLOG_PRECISION = 0 }; String CHLOG;


	enum { TYP_WIDTH = 1, TYP_PRECISION = 0 }; String TYP;

	 enum { RC_ICO_WIDTH = 20, RC_ICO_PRECISION = 0 }; String RC_ICO;

	 enum { DAT_NAR_WIDTH = 0, DAT_NAR_PRECISION = 0 }; Date DAT_NAR;
	 enum { DAT_UMRTI_WIDTH = 0, DAT_UMRTI_PRECISION = 0 }; Date DAT_UMRTI;

	 enum { PRIJM_WIDTH = 500, PRIJM_PRECISION = 0 }; String PRIJM;
	 enum { ROD_PRIJM_WIDTH = 100, ROD_PRIJM_PRECISION = 0 }; String ROD_PRIJM;
	 enum { JMENO_WIDTH = 100, JMENO_PRECISION = 0 }; String JMENO;
	 enum { TIT_PRED_WIDTH = 50, TIT_PRED_PRECISION = 0 }; String TIT_PRED;
	 enum { TIT_ZA_WIDTH = 50, TIT_ZA_PRECISION = 0 }; String TIT_ZA;

	 enum { TRV_BYDL_WIDTH = 0, TRV_BYDL_PRECISION = 0 }; int TRV_BYDL;
	 enum { PRECH_BYDL_WIDTH = 0, PRECH_BYDL_PRECISION = 0 }; int PRECH_BYDL;
	 enum { MISTO_NAR_WIDTH = 0, MISTO_NAR_PRECISION = 0 }; int MISTO_NAR;

	 enum { NARODNOST_WIDTH = 20, NARODNOST_PRECISION = 0 }; String NARODNOST;
	 enum { STAT_OBC_WIDTH = 0, STAT_OBC_PRECISION = 0 }; int STAT_OBC;

	 enum { ZVOLENA_WIDTH = 1, ZVOLENA_PRECISION = 0 }; String ZVOLENA;
	 enum { PODNIKA_WIDTH = 1, PODNIKA_PRECISION = 0 }; String PODNIKA;
	 enum { VOJAK_WIDTH = 1, VOJAK_PRECISION = 0 }; String VOJAK;
	 enum { NEVOLIC_WIDTH = 1, NEVOLIC_PRECISION = 0 }; String NEVOLIC;

	 enum { ROD_STAV_WIDTH = 1, ROD_STAV_PRECISION = 0 }; String ROD_STAV;


	 enum { OTEC_SEQ_WIDTH = 0, OTEC_SEQ_PRECISION = 0 }; int OTEC_SEQ;
	 enum { OTEC_TYP_WIDTH = 1, OTEC_TYP_PRECISION = 0 }; String OTEC_TYP;


	 enum { MATKA_SEQ_WIDTH = 0, MATKA_SEQ_PRECISION = 0 }; int MATKA_SEQ;
	 enum { MATKA_TYP_WIDTH = 1, MATKA_TYP_PRECISION = 0 }; String MATKA_TYP;



	 enum { MANZEL_SEQ_WIDTH = 0, MANZEL_SEQ_PRECISION = 0 }; int MANZEL_SEQ;
 	 enum { MANZEL_TYP_WIDTH = 1, MANZEL_TYP_PRECISION = 0 }; String MANZEL_TYP;

 	 enum { T_PRIJM_WIDTH = 500, T_PRIJM_PRECISION = 0 }; String T_PRIJM;
 	 enum { T_JMENO_WIDTH = 500, T_JMENO_PRECISION = 0 }; String T_JMENO;
 	 enum { T_DATNAR_WIDTH = 0, T_DATNAR_PRECISION = 0 }; Date T_DATNAR;
 	 enum { T_RC_WIDTH = 200, T_RC_PRECISION = 0 }; String T_RC;
 	 enum { T_ULICE_WIDTH = 500, T_ULICE_PRECISION = 0 }; String T_ULICE;
 	 enum { T_PSC_WIDTH = 30, T_PSC_PRECISION = 0 }; String T_PSC;
 	 enum { T_OBEC_WIDTH = 500, T_OBEC_PRECISION = 0 }; String T_OBEC;
};



struct S_OSOBA_DS_BASE  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OSOBA_DS_BASE::FieldLayout); } S_OSOBA_DS_BASE();
	 enum { OD_WIDTH = 0, OD_PRECISION = 0 }; Date OD;
	enum { OSOBA_SEQ_WIDTH = 0, OSOBA_SEQ_PRECISION = 0 }; int OSOBA_SEQ;
	enum { OSOBA_CON_SEQ_WIDTH = 0, OSOBA_CON_SEQ_PRECISION = 0 }; int OSOBA_CON_SEQ;

	enum { NUM1_WIDTH = 0, NUM1_PRECISION = 0 }; int NUM1;
	enum { NUM2_WIDTH = 0, NUM2_PRECISION = 0 }; int NUM2;

	enum { CHR1_WIDTH = 2000, CHR1_PRECISION = 0 }; String CHR1;
	enum { CHR2_WIDTH = 2000, CHR2_PRECISION = 0 }; String CHR2;

	enum { LOV1_WIDTH = 20, LOV1_PRECISION = 0 }; String LOV1;
	enum { LOV2_WIDTH = 20, LOV2_PRECISION = 0 }; String LOV2;

	enum { DATE1_WIDTH = 0, DATE1_PRECISION = 0 }; Date DATE1;
	enum { DATE2_WIDTH = 0, DATE2_PRECISION = 0 }; Date DATE2;

	enum { OSOBA1_WIDTH = 0, OSOBA1_PRECISION = 0 }; int OSOBA1;
	enum { OSOBA2_WIDTH = 0, OSOBA2_PRECISION = 0 }; int OSOBA2;

	enum { ADRESA1_WIDTH = 0, ADRESA1_PRECISION = 0 }; int ADRESA1;
	enum { ADRESA2_WIDTH = 0, ADRESA2_PRECISION = 0 }; int ADRESA2;

	 enum { POZN_WIDTH = 2000, POZN_PRECISION = 0 }; String POZN;
};



 struct S_OSOBA_DS : public S_OSOBA_DS_BASE { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OSOBA_DS::FieldLayout); } S_OSOBA_DS();
	 enum { OSOBA_DS_SEQ_WIDTH = 0, OSOBA_DS_SEQ_PRECISION = 0 }; int OSOBA_DS_SEQ;
};



 struct S_OSOBA_ARCHIV : public S_OSOBA_DS_BASE { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OSOBA_ARCHIV::FieldLayout); } S_OSOBA_ARCHIV();
	 enum { OSOBA_ARCHIV_SEQ_WIDTH = 0, OSOBA_ARCHIV_SEQ_PRECISION = 0 }; int OSOBA_ARCHIV_SEQ;
	enum { USERID_WIDTH = 20, USERID_PRECISION = 0 }; String USERID;
	 enum { DUVOD_WIDTH = 20, DUVOD_PRECISION = 0 }; String DUVOD;
	 enum { DO_WIDTH = 0, DO_PRECISION = 0 }; Date DO;
};



 struct S_CLIP  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_CLIP::FieldLayout); } S_CLIP();
	 enum { CLIP_SEQ_WIDTH = 0, CLIP_SEQ_PRECISION = 0 }; int CLIP_SEQ;
	enum { USERID_WIDTH = 20, USERID_PRECISION = 0 }; String USERID;
	enum { POPIS_WIDTH = 50, POPIS_PRECISION = 0 }; String POPIS;
	enum { TYP_WIDTH = 1, TYP_PRECISION = 0 }; String TYP;
	 enum { VZNIK_WIDTH = 0, VZNIK_PRECISION = 0 }; Date VZNIK;
};



 struct S_CLIP_DS  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_CLIP_DS::FieldLayout); } S_CLIP_DS();
	 enum { CLIP_DS_SEQ_WIDTH = 0, CLIP_DS_SEQ_PRECISION = 0 }; int CLIP_DS_SEQ;
	enum { CLIP_SEQ_WIDTH = 0, CLIP_SEQ_PRECISION = 0 }; int CLIP_SEQ;
	 enum { DATA_WIDTH = 0, DATA_PRECISION = 0 }; int DATA;
};



 struct S_VOLBY  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_VOLBY::FieldLayout); } S_VOLBY();
	 enum { VOLBY_SEQ_WIDTH = 0, VOLBY_SEQ_PRECISION = 0 }; int VOLBY_SEQ;
	enum { NAZEV_WIDTH = 50, NAZEV_PRECISION = 0 }; String NAZEV;
};



 struct S_VOLBY_OKRSEK  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_VOLBY_OKRSEK::FieldLayout); } S_VOLBY_OKRSEK();
	 enum { VOLBY_OKRSEK_SEQ_WIDTH = 0, VOLBY_OKRSEK_SEQ_PRECISION = 0 }; int VOLBY_OKRSEK_SEQ;
	 enum { OKRSEK_WIDTH = 0, OKRSEK_PRECISION = 0 }; int OKRSEK;
	 enum { CAST_WIDTH = 10, CAST_PRECISION = 0 }; String CAST;
};



 struct S_VOLBY_DS  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_VOLBY_DS::FieldLayout); } S_VOLBY_DS();
	 enum { VOLBY_DS_SEQ_WIDTH = 0, VOLBY_DS_SEQ_PRECISION = 0 }; int VOLBY_DS_SEQ;
	enum { ADRESA_SEQ_WIDTH = 0, ADRESA_SEQ_PRECISION = 0 }; int ADRESA_SEQ;
	 enum { OKRSEK_SEQ_WIDTH = 0, OKRSEK_SEQ_PRECISION = 0 }; int OKRSEK_SEQ;
};



 struct S_VOLBY_MISTNOST  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_VOLBY_MISTNOST::FieldLayout); } S_VOLBY_MISTNOST();
	enum { VOLBY_SEQ_WIDTH = 0, VOLBY_SEQ_PRECISION = 0 }; int VOLBY_SEQ;
	enum { OKRSEK_WIDTH = 0, OKRSEK_PRECISION = 0 }; int OKRSEK;
	enum { MISTNOST_WIDTH = 0, MISTNOST_PRECISION = 0 }; int MISTNOST;
	enum { POZN_WIDTH = 100, POZN_PRECISION = 0 }; String POZN;
	enum { KOD_WIDTH = 10, KOD_PRECISION = 0 }; String KOD;
	 enum { DLOUHY_KOD_WIDTH = 20, DLOUHY_KOD_PRECISION = 0 }; String DLOUHY_KOD;
};


#line 163 "u:/uppsrc\\Sql/sch_model.h"




































#line 91 "u:/uppsrc\\Oracle/OracleSchema.h"





















































#line 35 "u:/uppsrc\\Sql/sch_header.h"










#line 1 "u:/uppsrc\\Oracle/OracleSchema.h"


























































#line 60 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 65 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 70 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 75 "u:/uppsrc\\Oracle/OracleSchema.h"















#line 1 "u:/uppsrc\\Sql/sch_model.h"








#line 10 "u:/uppsrc\\Sql/sch_model.h"
















#line 27 "u:/uppsrc\\Sql/sch_model.h"




















#line 48 "u:/uppsrc\\Sql/sch_model.h"



#line 52 "u:/uppsrc\\Sql/sch_model.h"



#line 56 "u:/uppsrc\\Sql/sch_model.h"



#line 60 "u:/uppsrc\\Sql/sch_model.h"



#line 64 "u:/uppsrc\\Sql/sch_model.h"



#line 68 "u:/uppsrc\\Sql/sch_model.h"



#line 72 "u:/uppsrc\\Sql/sch_model.h"



#line 76 "u:/uppsrc\\Sql/sch_model.h"



#line 80 "u:/uppsrc\\Sql/sch_model.h"



#line 84 "u:/uppsrc\\Sql/sch_model.h"



#line 88 "u:/uppsrc\\Sql/sch_model.h"



#line 92 "u:/uppsrc\\Sql/sch_model.h"



#line 96 "u:/uppsrc\\Sql/sch_model.h"



#line 100 "u:/uppsrc\\Sql/sch_model.h"



#line 104 "u:/uppsrc\\Sql/sch_model.h"



#line 108 "u:/uppsrc\\Sql/sch_model.h"



#line 112 "u:/uppsrc\\Sql/sch_model.h"



#line 116 "u:/uppsrc\\Sql/sch_model.h"



#line 120 "u:/uppsrc\\Sql/sch_model.h"



#line 124 "u:/uppsrc\\Sql/sch_model.h"



#line 128 "u:/uppsrc\\Sql/sch_model.h"







#line 136 "u:/uppsrc\\Sql/sch_model.h"








#line 145 "u:/uppsrc\\Sql/sch_model.h"



#line 149 "u:/uppsrc\\Sql/sch_model.h"



#line 153 "u:/uppsrc\\Sql/sch_model.h"



#line 157 "u:/uppsrc\\Sql/sch_model.h"



#line 161 "u:/uppsrc\\Sql/sch_model.h"

#line 1 "u:/idisapp\\isu/os_model.sch"


extern SqlId SEQ_OSOBA;
extern SqlId SEQ_OSOBA_DS;
extern SqlId SEQ_OSOBA_ARCHIV;
extern SqlId SEQ_CLIP;
extern SqlId SEQ_VOLBY;



extern SqlId OSOBA_LOV;
	extern SqlId OSOBA_LOV_SEQ;

	extern SqlId HIDDEN;
	extern SqlId WRITEABLE;




extern SqlId OSOBA_LOVD;
	extern SqlId OSOBA_LOVD_SEQ;

	extern SqlId LOVKEY;
	extern SqlId VAL;




extern SqlId OSOBA_CON;
	extern SqlId OSOBA_CON_SEQ;
	extern SqlId TYP;
	extern SqlId MULTI;
	extern SqlId COLNAME;
	extern SqlId COLTYPE;
	extern SqlId SKUPINA;
	extern SqlId NAZEV;

	extern SqlId FORMAT;

	extern SqlId LOV1_LOV;
	extern SqlId LOV2_LOV;

	extern SqlId NUM1;
	extern SqlId NUM2;
	extern SqlId CHR1;
	extern SqlId CHR2;
	extern SqlId LOV1;
	extern SqlId LOV2;
	extern SqlId DATE1;
	extern SqlId DATE2;
	extern SqlId OSOBA1;
	extern SqlId OSOBA2;
	extern SqlId ADRESA1;
	extern SqlId ADRESA2;




extern SqlId OSOBA;
	extern SqlId OSOBA_SEQ;
	extern SqlId USERID;
	extern SqlId CHLOG;




	extern SqlId RC_ICO;

	extern SqlId DAT_NAR;
	extern SqlId DAT_UMRTI;

	extern SqlId PRIJM;
	extern SqlId ROD_PRIJM;
	extern SqlId JMENO;
	extern SqlId TIT_PRED;
	extern SqlId TIT_ZA;

	extern SqlId TRV_BYDL;
	extern SqlId PRECH_BYDL;
	extern SqlId MISTO_NAR;

	extern SqlId NARODNOST;
	extern SqlId STAT_OBC;

	extern SqlId ZVOLENA;
	extern SqlId PODNIKA;
	extern SqlId VOJAK;
	extern SqlId NEVOLIC;

	extern SqlId ROD_STAV;


	extern SqlId OTEC_SEQ;
	extern SqlId OTEC_TYP;


	extern SqlId MATKA_SEQ;
	extern SqlId MATKA_TYP;



	extern SqlId MANZEL_SEQ;
 	extern SqlId MANZEL_TYP;

 	extern SqlId T_PRIJM;
 	extern SqlId T_JMENO;
 	extern SqlId T_DATNAR;
 	extern SqlId T_RC;
 	extern SqlId T_ULICE;
 	extern SqlId T_PSC;
 	extern SqlId T_OBEC;





	extern SqlId OD;





















	extern SqlId POZN;




extern SqlId OSOBA_DS;
	extern SqlId OSOBA_DS_SEQ;




extern SqlId OSOBA_ARCHIV;
	extern SqlId OSOBA_ARCHIV_SEQ;

	extern SqlId DUVOD;
	extern SqlId DO;




extern SqlId CLIP;
	extern SqlId CLIP_SEQ;



	extern SqlId VZNIK;




extern SqlId CLIP_DS;
	extern SqlId CLIP_DS_SEQ;

	extern SqlId DATA;




extern SqlId VOLBY;
	extern SqlId VOLBY_SEQ;





extern SqlId VOLBY_OKRSEK;
	extern SqlId VOLBY_OKRSEK_SEQ;
	extern SqlId OKRSEK;
	extern SqlId CAST;




extern SqlId VOLBY_DS;
	extern SqlId VOLBY_DS_SEQ;

	extern SqlId OKRSEK_SEQ;




extern SqlId VOLBY_MISTNOST;





	extern SqlId DLOUHY_KOD;



#line 163 "u:/uppsrc\\Sql/sch_model.h"




































#line 91 "u:/uppsrc\\Oracle/OracleSchema.h"





















































#line 46 "u:/uppsrc\\Sql/sch_header.h"
#line 22 "u:\\idisapp\\isu\\os_model.h"


extern SqlSequence SeqOsoba, SeqOsobaDs, SeqOsobaArchiv;
extern SqlSequence SeqVolby, SeqClip;

extern const String NullGroupText;



enum TYPEID
{
	TYPE_NULL,
	TYPE_NUM,
	TYPE_CHR,
	TYPE_DATE,
	TYPE_LOV,
	TYPE_OSOBA,
	TYPE_ADRESA,

	TYPE_FIRST = TYPE_NUM,
	TYPE_LAST  = TYPE_ADRESA,
	TYPE_COUNT = TYPE_LAST + 1,
	PER_TYPE = 2,
};



enum STDLOV
{
	LOV_FIRST = -1000,
	LOV_TYP,
	LOV_NARODNOST,
	LOV_OTEC_TYP,
	LOV_MATKA_TYP,
	LOV_ROD_STAV,
	LOV_ROD_STAV_M,
	LOV_ROD_STAV_Z,
	LOV_VOJAK,
	LOV_BOOL,
	__LOV_UNUSED,
	LOV_ACT,
	LOV_NEVOLIC,

	LOV_NULL = 0,
};



enum STDCON
{
	CON_TYP = -1000,
	CON_NOVY,
	CON_POZN,
	CON_ZMENA,

	CON_RC = -990,
	CON_ICO,
	CON_DIC,
	CON_OP,
	CON_PAS,

	CON_DAT_NAR = -980,
	CON_DAT_UMRTI,
	CON_DAT_VZNIK,
	CON_DAT_ZANIK,
	CON_PRIC_UMRTI,
	CON_PRIC_ZANIK,

	CON_PRIJM = -970,
	CON_ROD_PRIJM,
	CON_JMENO,
	CON_TIT_PRED = -960,
	CON_TIT_ZA,
	CON_NAZEV,

	CON_TRV_BYDL = -950,
	CON_PRECH_BYDL,
	CON_SIDLO,
	CON_MISTO_NAR,

	CON_NARODNOST = -940,
	CON_STAT_OBC,

	CON_NEVOLIC = -930,
	CON_ZVOLENA,
	CON_PODNIKA,
	CON_VOJAK,
	__CON_UNUSED,

	CON_ROD_STAV = -920,

	CON_OTEC = -910,
	CON_MATKA,
	CON_MANZEL,

	CON_T_OTEC = -900,
	CON_T_MATKA,
	CON_T_MANZEL,

	CON_NULL = 0,
};



enum VIRTCON
{
	VCON_FIRST = -0x8000,

	VCON_OKRSEK,
	VCON_DRIV_BYDL,
	VCON_SEQ,
	VCON_ROWNUM,

	VCON_LAST,
};



struct Osoba : public S_OSOBA, ::Moveable<Osoba>
{
	Osoba() {}
	Osoba(int seq, Date date = Null);



	enum
	{
		MULTILINE     = 0x0001,
		SURNAME_FIRST = 0x0010,
		FIXES         = 0x0020,
		NUMBER        = 0x0040,
		DATE          = 0x0080,
		ADRESA        = 0x0100,
		JUST_ADRESA   = 0x0200,
		JUST_SURNAME  = 0x0400,
		DEAD          = 0x0800,
		BORN          = 0x1000,
		BYEAR         = 0x2000,
		REJSTRIK      = 0x4000,
		DATNAR        = 0x8000,
	};

	int           SelfAdresa() const;
	String        SelfDesc(int flags = 0, int pad = 1) const;
	String        VirtConDesc(int con) const;

	bool          IsLocal() const { return IsNull(TYP); }
	String        GetRC() const   { return IsLocal() ? T_RC : RC_ICO; }

	static String ExcDesc(int seq, int flags = 0, int pad = 1, Date date = Null);
	static String GetDesc(int seq, int flags = 0, int pad = 1, Date date = Null);
	static String ExcDesc(int seq, int flags, Date date) { return ExcDesc(seq, flags, 1, date); }
	static String GetDesc(int seq, int flags, Date date) { return GetDesc(seq, flags, 1, date); }

	static int    ExcAdresa(int seq, Date date = Null);
	static int    GetAdresa(int seq, Date date = Null);
};



struct OsobaRefSimple
{
	int    OSOBA_SEQ;
	int    TRV_BYDL;

	enum { PRIJM = 0 };
	short  JMENO;
	short  TIT_PRED;
	short  TIT_ZA;
	short  RC_ICO;
	short  ROD_PRIJM;
	char   TYP;

	Date   DAT_NAR;
	Date   DAT_UMRTI;

	OsobaRefSimple();
};



struct OsobaRef : public OsobaRefSimple, Moveable<OsobaRef>
{
	String data;

	OsobaRef();
	OsobaRef(Sql& cursor);
	OsobaRef(const Osoba& osoba);
	OsobaRef(int osoba_seq, int trv_bydl, const String& jmeno, const String& prijm,
		const String& tit_pred, const String& tit_za, const String& rc_ico, const String& typ,
		Date dat_nar, Date dat_umrti, const String& rod_prijm);

	void          Set(Osoba& osoba) const;

	bool operator == (const OsobaRef& another) const { return OSOBA_SEQ == another.OSOBA_SEQ; }
	bool operator != (const OsobaRef& another) const { return !(*this == another); }

	const char   *GetPrijm()       const { return ~data + PRIJM;                }
	int           GetPrijmLen()    const { return JMENO - PRIJM - 1;            }

	const char   *GetJmeno()       const { return ~data + JMENO;                }
	int           GetJmenoLen()    const { return TIT_PRED - JMENO - 1;         }

	const char   *GetTitPred()     const { return ~data + TIT_PRED;             }
	int           GetTitPredLen()  const { return TIT_ZA - TIT_PRED - 1;        }

	const char   *GetTitZa()       const { return ~data + TIT_ZA;               }
	int           GetTitZaLen()    const { return RC_ICO - TIT_ZA - 1;          }

	const char   *GetRcIco()       const { return ~data + RC_ICO;               }
	int           GetRcIcoLen()    const { return ROD_PRIJM - RC_ICO - 1;       }

	const char   *GetRodPrijm()    const { return ~data + ROD_PRIJM;            }
	int           GetRodPrijmLen() const { return data.GetLength() - ROD_PRIJM; }

	friend int    Compare(const OsobaRef& l1, const OsobaRef& l2)
	{ return cmp(l1.OSOBA_SEQ, l2.OSOBA_SEQ); }

	static SqlSet    ColumnSet();
	static SqlSelect Select();

	void          Fetch(Sql& cursor);

	String        Format(bool dat_umrti) const;
	String        FormatRcIco() const;



	struct Compare
	{
		enum ORDER
		{
			NONE, NAME, AGE, RC_ICO, SEQ,
			ADDRESS = 0x1000,
		};

		Compare(int order = NAME);
		bool operator () (const OsobaRef& o1, const OsobaRef& o2) const;

		int        order;
		Index<int> adresa_index;
	};



	static Array<OsobaRef> Load(Sql& cursor, int order = Compare::NAME, Gate2<int, int> progress = false);
	static Array<OsobaRef> Load(const SqlSelect& set, int order = Compare::NAME, Gate2<int, int> progress = false);
	static Array<OsobaRef> Load(const Vector<int>& seq_list, Gate2<int, int> progress = false);



	static void Sort(Array<OsobaRef>& list, int order = Compare::NAME);
	static void AddSortMethods(DropList& list);
};



typedef S_OSOBA_DS_BASE OsobaDsBase;

struct OsobaDs : public S_OSOBA_DS, ::Moveable<OsobaDs> {};
struct OsobaArchiv : public S_OSOBA_ARCHIV, ::Moveable<OsobaArchiv> {};

enum
{
	NO_CON = 0x0001,
	ARCHIV = 0x0002,
};

Ref           GetDsRef(S_OSOBA_DS_BASE& ds, int type, int index = 0);
Value         GetDsValue(const S_OSOBA_DS_BASE& ds, int type, int index = 0);

bool          IsDataEqual(const S_OSOBA_DS_BASE& ds1, const S_OSOBA_DS_BASE& ds2);
bool          IsDataEmpty(const S_OSOBA_DS_BASE& ds);

int           Fetch(S_OSOBA_DS_BASE& ds, const Osoba& osoba, int con);

bool          Inject(const S_OSOBA_DS_BASE& ds, Osoba& osoba);

bool          SetSimple(S_OSOBA_DS_BASE& ds, const Value& value);
Value         GetSimple(const S_OSOBA_DS_BASE& ds);



struct OsobaDsCompare
{
	bool operator () (const OsobaDs& d, const OsobaDs& e) const;
};



String GetDescItem(const S_OSOBA_DS_BASE& ds, int type, int index = 0);
String GetDesc(const S_OSOBA_DS_BASE& ds, int options = 0);
String GetOsobaDsDesc(int seq, int options = 0);



struct OsobaLovData : public S_OSOBA_LOVD, ::Moveable<OsobaLovData> {};

struct OsobaLov : public S_OSOBA_LOV, ::Moveable<OsobaLov>
{
public:
	static bool   Add(DropList& list, int lov_seq, int index);
	static bool   Add(DropList& list, int lov_seq, const String& key);
	static bool   Add(DropList& list, int lov_seq);
	static void   Add(DropList& list);



	static String GetDesc(int lov_seq, const String& key);

	static void   Load();
	static void   Sync();









public:
	static ArrayMap<int, OsobaLov>                 lov;
	static Vector<ArrayMap<String, OsobaLovData> > data;
};



struct OsobaCon : public S_OSOBA_CON, ::Moveable<OsobaCon>
{
public:
	static void   Add(DropList& combo, bool entries = false, bool virtual_cons = false);



	enum
	{
		GROUP = 0x01,
		DESC  = 0x02,
	};

	String        SelfName(int type, int index = 0) const;
	String        SelfDesc(int options = GROUP | DESC) const;
	static String GetDesc(int con, int options = GROUP | DESC);

	static SqlId  GetDetailId(int type, int index = 0);
	static SqlId  GetLovLovId(int index = 0);

	int           GetLovLov(int index = 0) const;

	static void   Load();
	static void   Sync();



	static bool   IsVirtCon(int con)         { return con > VCON_FIRST && con < VCON_LAST; }

	static String VirtConName(int con);

	static void   VirtSetRowNum(int _rownum) { rownum = _rownum; }
	static int    VirtGetRowNum()            { return rownum; }



	struct Detail : Moveable<Detail>
	{
		Detail(int con = Null, int type = TYPE_NULL, int index = -1)
			: con(con), type(type), index(index) {}

		bool   IsVirtual() const { return IsVirtCon(con); }
		void   Serialize(Stream& stream);
		String Dump() const;

		int con;
		int type;
		int index;
	};



	struct Entry : public Detail, Moveable<Entry>
	{
		Entry(int con, int type, int ix = 0);
		Entry(const Detail& detail);

		operator bool () const            { return data != 0; }
		bool            IsVirtual() const { return OsobaCon::IsVirtCon(con); }

		void            Serialize(Stream& stream);

		const OsobaCon* data;
		bool            ext;
		SqlId           base;
		SqlId           ds;
	};



	static Vector<Detail> GetDetail(int con_seq = Null, int vcon_seq = Null);



public:
	static int                      rownum;
	static ArrayMap<int, OsobaCon>  con;
	static Index<int>               root;
	static SqlSet                   root_set;
};



struct Clip : public S_CLIP, ::Moveable<Clip>
{
	static const char     StdClipName[];

	enum FLAGS { GLOBAL = 0x01, OVERWRITEPROMPT = 0x02};

	static VectorMap<int, String> GetClipList(const char* typ, BOOL global = Null);
	static void           Add(DropList& list, const char* typ);

	static int            Find(const char* popis = StdClipName, bool global = false);
	static bool           Delete(const char* popis = StdClipName, bool global = false);
	static bool           Delete(int clip_seq);
	static int            Save(const char* typ, const char* popis, int options = 0);
	static bool           Save(const int* begin, const int* end, const char* typ, const char* popis = StdClipName, int flags = 0);
	static bool           Save(const Vector<int>& data, const char* typ, const char* popis = StdClipName, int flags = 0) { return Save(data.Begin(), data.End(), typ, popis, flags); }
	static Vector<int>    Load(int clip_seq);
	static Vector<int>    Load(const char* typ, const char* popis = "Bn schrnka", bool global = false);
	static bool           IsAvail(const char* typ, const char* popis = "Bn schrnka", bool global = false);



};

struct ClipDs : public S_CLIP_DS, ::Moveable<ClipDs> {};



struct Volby : public S_VOLBY, ::Moveable<Volby> {};



struct VolbyOkrsek : public S_VOLBY_OKRSEK, ::Moveable<VolbyOkrsek>
{
public:
	enum
	{
		SLASH  = 0x0001,
		LPAD   = 0x0002,
		NOCAST = 0x0004,
	};

	String SelfDesc(int options = 0) const;

	static String GetDesc(int seq, int options = 0);

	struct Compare
	{
		bool operator () (const VolbyOkrsek& a, const VolbyOkrsek& b) const
		{ return a.OKRSEK < b.OKRSEK || a.OKRSEK == b.OKRSEK && a.CAST < b.CAST; }
	};
};



struct VolbyDs : public S_VOLBY_DS, ::Moveable<VolbyDs> {};
struct VolbyMistnost : public S_VOLBY_MISTNOST, ::Moveable<VolbyMistnost> {};



}

template <>
inline unsigned Upp::GetHashValue(const Osoby::OsobaRef& osoba) { return osoba.OSOBA_SEQ; }

#line 498 "u:\\idisapp\\isu\\os_model.h"
#line 8 "u:/idisapp\\isu/osoba.h"

namespace Osoby
{



void AnalyzeRC(const String& rc, String& pohlavi, Date& dat_nar);

bool CheckDupRC(const String& rc, int ignore_seq = Null, bool cancel = true);
bool CheckSexRC(const String& rc, char typ);



int    RunDlgOsobaAccel(const Array<OsobaRef>& list, char first_letter);
bool   RunDlgPoznamka(String& pozn, Font& font, bool edit = true);



class PumpOsobaDs : public Pump::Item
{
public:
	PumpOsobaDs(Ref data, int osoba_seq, int con_seq, int type = TYPE_NULL, int index = 0);

	virtual void Run(bool write);

private:
	int osoba_seq;
	int con_seq;
	int type;
	int index;
	Ref data;
};



class PumpOsobaDsData : public PumpOsobaDs
{
public:
	PumpOsobaDsData(Ctrl& ctrl, int osoba_seq, int con_seq, int type = TYPE_NULL, int index = 0)
		: PumpOsobaDs(value, osoba_seq, con_seq, type, index), ctrl(ctrl) {}

	virtual void Run(bool write);

private:
	Ctrl& ctrl;
	Value value;
};



extern Vector<int> OsobaLRU;
extern Vector<int> NarozeniLRU;



void MoveDsToArchive(SqlBool where, const String& reason = Null, Date date = GetSysDate());
void CopyDsToArchive(SqlBool where, const String& reason = Null, Date date = GetSysDate());



struct RichOsobaDs : public OsobaDs, Moveable<RichOsobaDs>
{
	enum STATE { ROD_NORMAL, ROD_ACT, ROD_DELETE, ROD_ARCHIVE };
	OsobaDs     old;
	STATE       state;

	RichOsobaDs();
};



struct OsobaUpdate : DeepCopyOption<OsobaUpdate>
{
	int     flags;
	bool    fixups;
	Date    date;
	String  reason;
	String  userid;
	Osoba   os_old;
	Osoba   os_new;
	VectorMap<int , Vector<RichOsobaDs> > ds;



	OsobaUpdate();
	OsobaUpdate(const OsobaUpdate& another, int);

	void         Clear();

	void         Set(const Osoba& osoba);
	void         FetchDs();
	void         Update();
	void         UpdateDs();

	RichOsobaDs& Add(int con_seq);
	RichOsobaDs& Add(const OsobaDs& ds);

	RichOsobaDs& Modify(const OsobaDs& ds, bool card_archive = false);

	static bool  Lock(int seq);
};



class OsobaLovConvert : public Convert
{
public:
	OsobaLovConvert(int lov_seq = Null) : lov_seq(lov_seq) {}

	OsobaLovConvert& Lov(int _lov_seq) { lov_seq = _lov_seq; return *this; }
	int              GetLov() const    { return lov_seq; }

	virtual Value    Format(const Value& v) const;

private:
	int              lov_seq;
};



class OsobaLovCtrl : public DropList
{
public:
	typedef OsobaLovCtrl CLASSNAME;
	OsobaLovCtrl(int lov_seq = Null, bool edit = true);

	OsobaLovCtrl& Lov(int _lov_seq);
	int           GetLov() const            { return lov_seq; }

	OsobaLovCtrl& NotNull(bool _nn = true)  { not_null = _nn; return Lov(lov_seq); }
	OsobaLovCtrl& NoNotNull()               { return NotNull(false); }
	bool          IsNotNull() const         { return not_null; }

	OsobaLovCtrl& Edit(bool _edit);
	OsobaLovCtrl& NoEdit()                  { return Edit(false); }
	bool          IsEdit() const            { return edit; }

	static String RunAdd(int lov_seq);

private:
	void          OnAdd();
	virtual void  Layout();

private:
	FrameLeft<Button> add;
	int           lov_seq;
	bool          edit;
	bool          not_null;
};








#line 1 "u:/uppsrc\\CtrlCore/lay.h"







#line 1 "u:/idisapp\\isu/osoby/osoba.lay"
struct OsobaAccelLayout__layid {};







struct PoznamkaLayout__layid {};









struct OsobaListLayout__layid {};











struct OsobaDetailLayout__layid {};






struct OsobaNewFyzLayout__layid {};









































struct OsobaNewPravLayout__layid {};

















struct OsobaLovAddLayout__layid {};









struct OsobaFunctionLayout__layid {};















#line 9 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/idisapp\\isu/osoby/osoba.lay"
template<class T> struct WithOsobaAccelLayout : public T, public OsobaAccelLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(620, 400); }
	WithKeyCallback<TableArray> list;
	Label dv___1;
	EditField find;
	Button ok;
	Button cancel;
};

template<class T> struct WithPoznamkaLayout : public T, public PoznamkaLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(628, 474); }
	DocEdit text;
	Label dv___1;
	DropList dlgfont;
	Label dv___3;
	EditIntSpin size;
	Button ok;
	Button cancel;
};

template<class T> struct WithOsobaListLayout : public T, public OsobaListLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(600, 280); }
	TableArray table;
	Button find;
	Button detail;
	Button insert;
	Button edit;
	Button empty;
	Button ok;
	Button cancel;
	Button show_help;
};

template<class T> struct WithOsobaDetailLayout : public T, public OsobaDetailLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(450, 350); }
	TableArray table;
	Button detail;
	Button cancel;
	Button show_help;
};

template<class T> struct WithOsobaNewFyzLayout : public T, public OsobaNewFyzLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(400, 280); }
	Label dv___0;
	EditString tit_pred;
	Label dv___2;
	EditString prijm;
	Label dv___4;
	EditString jmeno;
	Label dv___6;
	EditString tit_za;
	Label dv___8;
	EditString rc;
	Label dv___10;
	DropList pohlavi;
	Label dv___12;
	EditString rod_prijm;
	Label dv___14;
	EditDate dat_nar;
	Label dv___16;
	EditDate dat_umrti;
	Label dv___18;
	LineAdresaCtrl misto_nar;
	Label dv___20;
	StatCtrl stat_obc;
	Label dv___22;
	OsobaLovCtrl narodnost;
	Label dv___24;
	AdresaCtrl trv_bydl;
	Label dv___26;
	AdresaCtrl prech_bydl;
	Label dv___28;
	EditString op;
	Label dv___30;
	OsobaLovCtrl podnika;
	Label dv___32;
	EditString ico;
	Label dv___34;
	EditString dic;
	Button ok;
	Button cancel;
	Button show_help;
};

template<class T> struct WithOsobaNewPravLayout : public T, public OsobaNewPravLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(382, 160); }
	Label dv___0;
	EditStringNotNull nazev;
	Label dv___2;
	EditString ico;
	Label dv___4;
	EditString dic;
	Label dv___6;
	AdresaCtrl sidlo;
	Label dv___8;
	EditDate dat_vznik;
	Label dv___10;
	EditDate dat_zanik;
	Button ok;
	Button cancel;
	Button show_help;
};

template<class T> struct WithOsobaLovAddLayout : public T, public OsobaLovAddLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(270, 84); }
	Label dv___0;
	EditStringNotNull val;
	Label dv___2;
	EditString lovkey;
	Button ok;
	Button cancel;
	Button show_help;
};

template<class T> struct WithOsobaFunctionLayout : public T, public OsobaFunctionLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(540, 80); }
	StaticCtrl tag;
	Button f1;
	Button f2;
	Button f3;
	Button f4;
	Button f5;
	Button f6;
	Button f7;
	Button f8;
	Button f9;
	Button f10;
	Button f11;
	Button f12;
	Button cancel;
};
#line 23 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/idisapp\\isu/osoby/osoba.lay"
template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, OsobaAccelLayout__layid&) { parent.LayoutId("OsobaAccelLayout");
	layout.list.HSizePosZ(4, 4).VSizePosZ(4, 32); layout.list.LayoutId("list"); parent.Add(layout.list);
	layout.dv___1.SetLabel(t_GetLngString("&Hledat:")).LeftPosZ(4, 40).BottomPosZ(8, 15); layout.dv___1.LayoutId("dv___1"); parent.Add(layout.dv___1);
	layout.find.LeftPosZ(46, 154).BottomPosZ(6, 19); layout.find.LayoutId("find"); parent.Add(layout.find);
	layout.ok.SetLabel(t_GetLngString("OK")).RightPosZ(88, 80).BottomPosZ(4, 22); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).RightPosZ(4, 80).BottomPosZ(4, 22); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, PoznamkaLayout__layid&) { parent.LayoutId("PoznamkaLayout");
	layout.text.HSizePosZ(4, 4).VSizePosZ(4, 30); layout.text.LayoutId("text"); parent.Add(layout.text);
	layout.dv___1.SetLabel(t_GetLngString("&Psmo:")).LeftPosZ(4, 38).BottomPosZ(8, 15); layout.dv___1.LayoutId("dv___1"); parent.Add(layout.dv___1);
	layout.dlgfont.LeftPosZ(40, 166).BottomPosZ(5, 19); layout.dlgfont.LayoutId("dlgfont"); parent.Add(layout.dlgfont);
	layout.dv___3.SetLabel(t_GetLngString("Velikost:")).LeftPosZ(220, 46).BottomPosZ(7, 15); layout.dv___3.LayoutId("dv___3"); parent.Add(layout.dv___3);
	layout.size.LeftPosZ(264, 62).BottomPosZ(5, 19); layout.size.LayoutId("size"); parent.Add(layout.size);
	layout.ok.SetLabel(t_GetLngString("OK")).RightPosZ(88, 80).BottomPosZ(4, 22); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).RightPosZ(4, 80).BottomPosZ(4, 22); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, OsobaListLayout__layid&) { parent.LayoutId("OsobaListLayout");
	layout.table.HSizePosZ(4, 4).VSizePosZ(4, 32); layout.table.LayoutId("table"); parent.Add(layout.table);
	layout.find.SetLabel(t_GetLngString("&Hledat")).LeftPosZ(4, 60).BottomPosZ(4, 22); layout.find.LayoutId("find"); parent.Add(layout.find);
	layout.detail.SetLabel(t_GetLngString("&Detaily")).LeftPosZ(78, 60).BottomPosZ(4, 22); layout.detail.LayoutId("detail"); parent.Add(layout.detail);
	layout.insert.SetLabel(t_GetLngString("&Vloit")).LeftPosZ(152, 60).BottomPosZ(4, 22); layout.insert.LayoutId("insert"); parent.Add(layout.insert);
	layout.edit.SetLabel(t_GetLngString("&Oprava")).LeftPosZ(216, 60).BottomPosZ(4, 22); layout.edit.LayoutId("edit"); parent.Add(layout.edit);
	layout.empty.SetLabel(t_GetLngString("&Nic")).RightPosZ(220, 60).BottomPosZ(4, 22); layout.empty.LayoutId("empty"); parent.Add(layout.empty);
	layout.ok.SetLabel(t_GetLngString("OK")).RightPosZ(144, 60).BottomPosZ(4, 22); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).RightPosZ(80, 60).BottomPosZ(4, 22); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
	layout.show_help.SetLabel(t_GetLngString("Npovda")).RightPosZ(4, 60).BottomPosZ(4, 22); layout.show_help.LayoutId("show_help"); parent.Add(layout.show_help);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, OsobaDetailLayout__layid&) { parent.LayoutId("OsobaDetailLayout");
	layout.table.HSizePosZ(4, 4).VSizePosZ(4, 32); layout.table.LayoutId("table"); parent.Add(layout.table);
	layout.detail.SetLabel(t_GetLngString("&Detaily")).LeftPosZ(4, 80).BottomPosZ(4, 22); layout.detail.LayoutId("detail"); parent.Add(layout.detail);
	layout.cancel.SetLabel(t_GetLngString("Zavt")).RightPosZ(88, 80).BottomPosZ(4, 22); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
	layout.show_help.SetLabel(t_GetLngString("Npovda")).RightPosZ(4, 80).BottomPosZ(4, 22); layout.show_help.LayoutId("show_help"); parent.Add(layout.show_help);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, OsobaNewFyzLayout__layid&) { parent.LayoutId("OsobaNewFyzLayout");
	layout.dv___0.SetLabel(t_GetLngString("&Titul(y):")).LeftPosZ(4, 36).TopPosZ(4, 13); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.tit_pred.LeftPosZ(4, 64).TopPosZ(18, 19); layout.tit_pred.LayoutId("tit_pred"); parent.Add(layout.tit_pred);
	layout.dv___2.SetLabel(t_GetLngString("&Pjmen:")).LeftPosZ(72, 44).TopPosZ(4, 13); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.prijm.LeftPosZ(72, 126).TopPosZ(18, 19); layout.prijm.LayoutId("prijm"); parent.Add(layout.prijm);
	layout.dv___4.SetLabel(t_GetLngString("&Jmno:")).LeftPosZ(204, 36).TopPosZ(4, 13); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.jmeno.LeftPosZ(202, 126).TopPosZ(18, 19); layout.jmeno.LayoutId("jmeno"); parent.Add(layout.jmeno);
	layout.dv___6.SetLabel(t_GetLngString("Za jmnem:")).LeftPosZ(334, 57).TopPosZ(4, 13); layout.dv___6.LayoutId("dv___6"); parent.Add(layout.dv___6);
	layout.tit_za.LeftPosZ(332, 64).TopPosZ(18, 19); layout.tit_za.LayoutId("tit_za"); parent.Add(layout.tit_za);
	layout.dv___8.SetLabel(t_GetLngString("&Rodn slo:")).LeftPosZ(4, 62).TopPosZ(42, 13); layout.dv___8.LayoutId("dv___8"); parent.Add(layout.dv___8);
	layout.rc.LeftPosZ(4, 84).TopPosZ(56, 19); layout.rc.LayoutId("rc"); parent.Add(layout.rc);
	layout.dv___10.SetLabel(t_GetLngString("Pohlav:")).LeftPosZ(92, 41).TopPosZ(42, 13); layout.dv___10.LayoutId("dv___10"); parent.Add(layout.dv___10);
	layout.pohlavi.LeftPosZ(92, 66).TopPosZ(56, 19); layout.pohlavi.LayoutId("pohlavi"); parent.Add(layout.pohlavi);
	layout.dv___12.SetLabel(t_GetLngString("Rodn pjmen:")).LeftPosZ(162, 76).TopPosZ(42, 13); layout.dv___12.LayoutId("dv___12"); parent.Add(layout.dv___12);
	layout.rod_prijm.LeftPosZ(162, 94).TopPosZ(56, 19); layout.rod_prijm.LayoutId("rod_prijm"); parent.Add(layout.rod_prijm);
	layout.dv___14.SetLabel(t_GetLngString("Narozen(a):")).LeftPosZ(260, 57).TopPosZ(42, 13); layout.dv___14.LayoutId("dv___14"); parent.Add(layout.dv___14);
	layout.dat_nar.LeftPosZ(260, 66).TopPosZ(56, 19); layout.dat_nar.LayoutId("dat_nar"); parent.Add(layout.dat_nar);
	layout.dv___16.SetLabel(t_GetLngString("Zemel(a):")).LeftPosZ(330, 50).TopPosZ(42, 13); layout.dv___16.LayoutId("dv___16"); parent.Add(layout.dv___16);
	layout.dat_umrti.LeftPosZ(330, 66).TopPosZ(56, 19); layout.dat_umrti.LayoutId("dat_umrti"); parent.Add(layout.dat_umrti);
	layout.dv___18.SetLabel(t_GetLngString("&Msto narozen:")).LeftPosZ(4, 75).TopPosZ(80, 13); layout.dv___18.LayoutId("dv___18"); parent.Add(layout.dv___18);
	layout.misto_nar.LeftPosZ(4, 160).TopPosZ(94, 19); layout.misto_nar.LayoutId("misto_nar"); parent.Add(layout.misto_nar);
	layout.dv___20.SetLabel(t_GetLngString("Sttn obanstv:")).LeftPosZ(168, 81).TopPosZ(80, 13); layout.dv___20.LayoutId("dv___20"); parent.Add(layout.dv___20);
	layout.stat_obc.LeftPosZ(168, 112).TopPosZ(94, 19); layout.stat_obc.LayoutId("stat_obc"); parent.Add(layout.stat_obc);
	layout.dv___22.SetLabel(t_GetLngString("Nrodnost:")).LeftPosZ(284, 54).TopPosZ(80, 13); layout.dv___22.LayoutId("dv___22"); parent.Add(layout.dv___22);
	layout.narodnost.LeftPosZ(284, 112).TopPosZ(94, 19); layout.narodnost.LayoutId("narodnost"); parent.Add(layout.narodnost);
	layout.dv___24.SetLabel(t_GetLngString("&Trval bydlit:")).LeftPosZ(4, 72).TopPosZ(118, 13); layout.dv___24.LayoutId("dv___24"); parent.Add(layout.dv___24);
	layout.trv_bydl.LeftPosZ(4, 194).TopPosZ(132, 72); layout.trv_bydl.LayoutId("trv_bydl"); parent.Add(layout.trv_bydl);
	layout.dv___26.SetLabel(t_GetLngString("Kontaktn adresa:")).LeftPosZ(204, 96).TopPosZ(118, 13); layout.dv___26.LayoutId("dv___26"); parent.Add(layout.dv___26);
	layout.prech_bydl.LeftPosZ(202, 194).TopPosZ(132, 72); layout.prech_bydl.LayoutId("prech_bydl"); parent.Add(layout.prech_bydl);
	layout.dv___28.SetLabel(t_GetLngString("slo OP:")).LeftPosZ(4, 45).TopPosZ(210, 13); layout.dv___28.LayoutId("dv___28"); parent.Add(layout.dv___28);
	layout.op.LeftPosZ(4, 120).BottomPosZ(37, 19); layout.op.LayoutId("op"); parent.Add(layout.op);
	layout.dv___30.SetLabel(t_GetLngString("Podnikatel:")).LeftPosZ(134, 54).TopPosZ(210, 13); layout.dv___30.LayoutId("dv___30"); parent.Add(layout.dv___30);
	layout.podnika.LeftPosZ(128, 76).TopPosZ(224, 19); layout.podnika.LayoutId("podnika"); parent.Add(layout.podnika);
	layout.dv___32.SetLabel(t_GetLngString("&IO:")).LeftPosZ(210, 23).TopPosZ(210, 13); layout.dv___32.LayoutId("dv___32"); parent.Add(layout.dv___32);
	layout.ico.LeftPosZ(208, 92).TopPosZ(224, 19); layout.ico.LayoutId("ico"); parent.Add(layout.ico);
	layout.dv___34.SetLabel(t_GetLngString("DI:")).LeftPosZ(306, 23).TopPosZ(210, 13); layout.dv___34.LayoutId("dv___34"); parent.Add(layout.dv___34);
	layout.dic.LeftPosZ(304, 92).TopPosZ(224, 19); layout.dic.LayoutId("dic"); parent.Add(layout.dic);
	layout.ok.SetLabel(t_GetLngString("OK")).HSizePosZ(136, 184).BottomPosZ(4, 22); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).RightPosZ(100, 80).BottomPosZ(4, 22); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
	layout.show_help.SetLabel(t_GetLngString("Npovda")).RightPosZ(4, 80).BottomPosZ(4, 22); layout.show_help.LayoutId("show_help"); parent.Add(layout.show_help);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, OsobaNewPravLayout__layid&) { parent.LayoutId("OsobaNewPravLayout");
	layout.dv___0.SetLabel(t_GetLngString("Prvnick osoba:")).LeftPosZ(4, 84).TopPosZ(4, 15); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.nazev.LeftPosZ(4, 150).TopPosZ(18, 19); layout.nazev.LayoutId("nazev"); parent.Add(layout.nazev);
	layout.dv___2.SetLabel(t_GetLngString("IO:")).LeftPosZ(158, 72).TopPosZ(4, 15); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.ico.LeftPosZ(158, 108).TopPosZ(18, 19); layout.ico.LayoutId("ico"); parent.Add(layout.ico);
	layout.dv___4.SetLabel(t_GetLngString("DI:")).LeftPosZ(270, 23).TopPosZ(4, 15); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.dic.HSizePosZ(270, 4).TopPosZ(18, 19); layout.dic.LayoutId("dic"); parent.Add(layout.dic);
	layout.dv___6.SetLabel(t_GetLngString("Sdlo:")).LeftPosZ(4, 29).TopPosZ(42, 15); layout.dv___6.LayoutId("dv___6"); parent.Add(layout.dv___6);
	layout.sidlo.LeftPosZ(4, 150).TopPosZ(56, 68); layout.sidlo.LayoutId("sidlo"); parent.Add(layout.sidlo);
	layout.dv___8.SetLabel(t_GetLngString("Zaloena:")).LeftPosZ(158, 54).TopPosZ(42, 15); layout.dv___8.LayoutId("dv___8"); parent.Add(layout.dv___8);
	layout.dat_vznik.LeftPosZ(158, 70).TopPosZ(56, 19); layout.dat_vznik.LayoutId("dat_vznik"); parent.Add(layout.dat_vznik);
	layout.dv___10.SetLabel(t_GetLngString("Zruena:")).LeftPosZ(234, 44).TopPosZ(42, 15); layout.dv___10.LayoutId("dv___10"); parent.Add(layout.dv___10);
	layout.dat_zanik.LeftPosZ(232, 70).TopPosZ(56, 19); layout.dat_zanik.LayoutId("dat_zanik"); parent.Add(layout.dat_zanik);
	layout.ok.SetLabel(t_GetLngString("OK")).RightPosZ(184, 80).BottomPosZ(4, 22); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).RightPosZ(100, 80).BottomPosZ(4, 22); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
	layout.show_help.SetLabel(t_GetLngString("Npovda")).RightPosZ(4, 80).BottomPosZ(4, 22); layout.show_help.LayoutId("show_help"); parent.Add(layout.show_help);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, OsobaLovAddLayout__layid&) { parent.LayoutId("OsobaLovAddLayout");
	layout.dv___0.SetLabel(t_GetLngString("&Hodnota:")).LeftPosZ(4, 50).TopPosZ(6, 15); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.val.HSizePosZ(58, 4).TopPosZ(4, 19); layout.val.LayoutId("val"); parent.Add(layout.val);
	layout.dv___2.SetLabel(t_GetLngString("&Kl:")).LeftPosZ(4, 25).TopPosZ(28, 15); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.lovkey.HSizePosZ(58, 4).TopPosZ(26, 19); layout.lovkey.LayoutId("lovkey"); parent.Add(layout.lovkey);
	layout.ok.SetLabel(t_GetLngString("OK")).RightPosZ(186, 80).BottomPosZ(4, 22); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).RightPosZ(102, 80).BottomPosZ(4, 22); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
	layout.show_help.SetLabel(t_GetLngString("Npovda")).RightPosZ(4, 80).BottomPosZ(4, 22); layout.show_help.LayoutId("show_help"); parent.Add(layout.show_help);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, OsobaFunctionLayout__layid&) { parent.LayoutId("OsobaFunctionLayout");
	layout.tag.HSizePosZ(4, 4).VSizePosZ(4, 32); layout.tag.LayoutId("tag"); parent.Add(layout.tag);
	layout.f1.SetLabel(t_GetLngString("F1")).LeftPosZ(4, 30).BottomPosZ(4, 22); layout.f1.LayoutId("f1"); parent.Add(layout.f1);
	layout.f2.SetLabel(t_GetLngString("F2")).LeftPosZ(38, 30).BottomPosZ(4, 22); layout.f2.LayoutId("f2"); parent.Add(layout.f2);
	layout.f3.SetLabel(t_GetLngString("F3")).LeftPosZ(72, 30).BottomPosZ(4, 22); layout.f3.LayoutId("f3"); parent.Add(layout.f3);
	layout.f4.SetLabel(t_GetLngString("F4")).LeftPosZ(106, 30).BottomPosZ(4, 22); layout.f4.LayoutId("f4"); parent.Add(layout.f4);
	layout.f5.SetLabel(t_GetLngString("F5")).LeftPosZ(150, 30).BottomPosZ(4, 22); layout.f5.LayoutId("f5"); parent.Add(layout.f5);
	layout.f6.SetLabel(t_GetLngString("F6")).LeftPosZ(184, 30).BottomPosZ(4, 22); layout.f6.LayoutId("f6"); parent.Add(layout.f6);
	layout.f7.SetLabel(t_GetLngString("F7")).LeftPosZ(218, 30).BottomPosZ(4, 22); layout.f7.LayoutId("f7"); parent.Add(layout.f7);
	layout.f8.SetLabel(t_GetLngString("F8")).LeftPosZ(252, 30).BottomPosZ(4, 22); layout.f8.LayoutId("f8"); parent.Add(layout.f8);
	layout.f9.SetLabel(t_GetLngString("F9")).LeftPosZ(296, 30).BottomPosZ(4, 22); layout.f9.LayoutId("f9"); parent.Add(layout.f9);
	layout.f10.SetLabel(t_GetLngString("F10")).LeftPosZ(330, 30).BottomPosZ(4, 22); layout.f10.LayoutId("f10"); parent.Add(layout.f10);
	layout.f11.SetLabel(t_GetLngString("F11")).LeftPosZ(364, 30).BottomPosZ(4, 22); layout.f11.LayoutId("f11"); parent.Add(layout.f11);
	layout.f12.SetLabel(t_GetLngString("F12")).LeftPosZ(398, 30).BottomPosZ(4, 22); layout.f12.LayoutId("f12"); parent.Add(layout.f12);
	layout.cancel.SetLabel(t_GetLngString("Zruit")).RightPosZ(4, 80).BottomPosZ(4, 22); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};
#line 37 "u:/uppsrc\\CtrlCore/lay.h"







#line 166 "u:/idisapp\\isu/osoba.h"
#line 167 "u:/idisapp\\isu/osoba.h"




class ConvertOsoba : public Convert
{
public:
	ConvertOsoba(dword style = 0, Date date = Null) : style(style), date(date) {}

	virtual Value  Format(const Value& value) const;

	ConvertOsoba&  SetStyle(dword _style) { style = _style; return *this; }
	dword          GetStyle() const       { return style; }

	ConvertOsoba&  SetDate(Date _date)    { date = _date; return *this; }
	Date           GetDate() const        { return date; }

public:
	static const ConvertOsoba Normal;
	static const ConvertOsoba SurnameFirst;
	static const ConvertOsoba Short;
	static const ConvertOsoba MultiLine;
	static const ConvertOsoba Adresa;
	static const ConvertOsoba AdresaMultiLine;

protected:
	Date           date;
	dword          style;
};



class ConvertRodneCisloCls : public Convert
{
public:
	ConvertRodneCisloCls(bool ask = false) : ask(ask) {}

	virtual Value Format(const Value& q) const;
	virtual Value Scan(const Value& text) const;

private:
	bool ask;
};

const ConvertRodneCisloCls ConvertRodneCislo(false);

bool IsRCError(const String& text);



class DlgOsobaDetail
{
public:
	typedef DlgOsobaDetail CLASSNAME;
	DlgOsobaDetail(bool edit);

	void Run(int osoba_seq);

private:
	void OnNew();
	void OnEdit();
	void OnView();
	void OnDelete();

	void OnMenu(Bar& bar);

	void Load(int _osoba_seq, int _osoba_ds_seq = Null, int _osoba_con_seq = Null);

private:
	WithOsobaDetailLayout<TopWindow> dialog;
	Osoba osoba;
	Vector<OsobaDs> ds;

	int osoba_seq;
	bool edit;
};

class DlgOsoba
{
public:
	DlgOsoba();

	DlgOsoba&          Node(int _node)              { node = _node; return *this; }
	int                GetNode() const              { return node; }

	DlgOsoba&          ExcludeNode(int _excl)       { exclude = _excl; return *this; }
	int                GetExcludeNode() const       { return exclude; }

	DlgOsoba&          Title(const String& _title)  { title = _title; return *this; }
	const String&      GetTitle() const             { return title; }

	DlgOsoba&          Filter(byte _filter)         { filter = _filter; return *this; }
	byte               GetFilter() const            { return filter; }

	enum
	{
		MUZI      = 0x01,
		ZENY      = 0x02,
		FYZICKE   = MUZI | ZENY,
		PRAVNICKE = 0x04,
		VSECHNY   = FYZICKE | PRAVNICKE,
	};

	DlgOsoba&          NoMuzi()                     { filter &= ~MUZI; return *this; }
	DlgOsoba&          NoZeny()                     { filter &= ~ZENY; return *this; }
	DlgOsoba&          NoFyzicke()                  { filter &= ~FYZICKE; return *this; }
	DlgOsoba&          NoPravnicke()                { filter &= ~PRAVNICKE; return *this; }

	bool               IsMuzi() const               { return filter & MUZI; }
	bool               IsZeny() const               { return filter & ZENY; }
	bool               IsFyzicke() const            { return filter & FYZICKE; }
	bool               IsPravnicke() const          { return filter & PRAVNICKE; }

	DlgOsoba&          NotNull(bool _nn = true)     { notnull = _nn; return *this; }
	DlgOsoba&          NoNotNull()                  { return NotNull(false); }
	bool               IsNotNull() const            { return notnull; }

	DlgOsoba&          Edit(bool e = true)          { editable = e; return *this; }
	DlgOsoba&          NoEdit()                     { return Edit(false); }
	bool               IsEdit() const               { return editable; }

	DlgOsoba&          StartWithFind(bool e = true) { startwithfind = e; return *this; }
	DlgOsoba&          NoStartWithFind()            { return StartWithFind(false); }
	bool               IsStartWithFind() const      { return startwithfind; }

	DlgOsoba&          Editor(bool ed = true)       { editor = ed; return *this; }
	DlgOsoba&          NoEditor()                   { return Editor(false); }
	bool               IsEditor() const             { return editor; }

	DlgOsoba&          Find(bool f = true)          { find = f; return *this; }
	DlgOsoba&          NoFind()                     { return Find(false); }
	bool               IsFind() const               { return find; }

	DlgOsoba&          LRU(Vector<int> *_lru)       { lru = _lru; return *this; }
	Vector<int>       *GetLRU() const               { return lru; }

	DlgOsoba&          Hint(const Vector<int> *_h)  { hint = _h; return *this; }
	const Vector<int> *GetHint() const              { return hint; }

	int                Run();
	int                Run(const Array<OsobaRef>& list);




	void               LRUAdd(int seq)              { ::LRUAdd(lru, seq, 10); }

protected:
	int                node;
	int                exclude;
	String             title;
	bool               editable;
	bool               notnull;
	bool               editor;
	bool               find;
	bool               startwithfind;
	byte               filter;
	Vector<int>       *lru;
	const Vector<int> *hint;
};



int  RunDlgOsoba(int osoba_seq);
int  RunDlgOsobaFyzicka(int osoba_seq);
int  RunDlgOsobaPravnicka(int osoba_seq);
void RunDlgOsobaDetail(int osoba_seq, bool edit = false);

class OsobaCtrl : public DataPusher, public DlgOsoba, public ConvertOsoba
{
public:
	OsobaCtrl(const Convert& cv);
	OsobaCtrl(int style = Osoba::SURNAME_FIRST | Osoba::ADRESA, Date date = Null);

	       operator int () const { return (int)data; }
	OsobaCtrl& operator = (int seq)  { SetData(seq); return *this; }

	virtual void SetData(const Value& v);

	OsobaCtrl&  SetStyle(dword _style) { style = _style; Refresh(); return *this; }
	OsobaCtrl&  SetDate(Date _date)    { date = _date; Refresh(); return *this; }

protected:
	Button  edit;

	void    Setup();
	void    Edit();

	virtual void DoAction();
};



class DlgOsobaDs
{
public:
	enum
	{
		CON       = 0x0001,
		ROOT_CON  = 0x0002,
		OD_DATA   = 0x0004,
		DO_DATA   = 0x0008,
		DUVOD     = 0x0010,
		POZN      = 0x0020,
		EDIT      = 0x0040,
		PRAVNICKA = 0x0080,
		ROOT_DATE = 0x0100,
		OD_NNULL  = 0x0200,

		NEW_DS    = CON | OD_DATA | DUVOD | POZN | EDIT,
		NEW_ROOT  = NEW_DS | ROOT_CON,
		NEW_ARCH  = NEW_ROOT | DO_DATA | ROOT_DATE,
		EDIT_DS   = OD_DATA | POZN | EDIT,
		EDIT_ARCH = EDIT_DS | DO_DATA | DUVOD | ROOT_DATE,
		VIEW_DS   = OD_DATA | POZN,
		VIEW_ARCH = VIEW_DS | DO_DATA | DUVOD | ROOT_DATE,
	};

	typedef DlgOsobaDs CLASSNAME;
	DlgOsobaDs(int options);

	void        Serialize(Stream& stream);

	DlgOsobaDs& New(int osoba_seq) { base.OSOBA_SEQ = osoba_seq; return *this; }
	DlgOsobaDs& Set(const OsobaDs& ds);
	DlgOsobaDs& Set(const OsobaArchiv& archiv);
	DlgOsobaDs& Set(int osoba_ds_archiv_seq, bool archiv = false);
	DlgOsobaDs& Set(const Osoba& osoba, int root_con);

	DlgOsobaDs& Title(const char *title);
	DlgOsobaDs& ConTitle(const char *tail);

	bool        Run();

	bool        IsRoot() const;

	void        Get(OsobaDs& dest);
	void        Get(OsobaArchiv& dest);
	bool        Get(Osoba& osoba);

	int         UpdateDs(int osoba_ds_seq, bool actualize);
	int         UpdateArchiv(int osoba_archiv_seq);

public:
	String title;
	int ds_archiv_seq;
	S_OSOBA_DS_BASE base;
	EditDateNotNull do_data;
	EditDate od_data;
	EditString pozn;
	OsobaLovCtrl duvod;
	EditString userid;

private:
	void        Layout();
	void        AddLabel(int x, int y, int w, const char *label);
	Ctrl       *GetFieldCtrl(int type, int lov_seq);
	void        LoadCon();

	void        OnConKey();
	void        OnConAction();

	bool        OnKey(dword key);

private:
	static ConfigItem config;
	int         options;
	String      caption;
	__int64     hotkeys;

	WithKeyCallback<TopWindow> dialog;
	DropList    con;
	FrameLeft<Button> con_key;
	Pump        pump;
	Array<Ctrl> dynamic;
	Array<Convert> dynamic_convert;
	Button ok, cancel, close, help;
	Ctrl       *data;

	VectorMap<int, int> con_keys;
};



















































































}

using namespace Osoby;

#line 536 "u:/idisapp\\isu/osoba.h"
#line 69 "u:/idisapp\\IdisMisc/IdisMisc.h"
#line 1 "u:/idisapp\\isu/HlpAdresa.h"






namespace Adresy
{

extern char *h_obce[];

}

#line 15 "u:/idisapp\\isu/HlpAdresa.h"
#line 70 "u:/idisapp\\IdisMisc/IdisMisc.h"
#line 1 "u:/idisapp\\isu/isu.h"








void   IdisBegin(DocReport& report, bool header, const String& odbor = Null);



enum SKTYPE { SK_DEFAULT, SK_OSOBA, SK_ADRESA };

Value  StreamKeyValue(bool write, const char *key_name, const Value& value, SKTYPE type = SK_DEFAULT);
void   StreamKey(bool write, const char* key_name, Ref ref, SKTYPE type = SK_DEFAULT);




extern const char *const MesicNames[];








Date   RunDlgCalendar(bool editor = false, bool not_null = false, Date init_date = GetSysDate());



bool   RunDlgClip(Vector<int>& data, const String& type, bool allow_write = true);
int    RunDlgClipView(const Vector<int>& data, const String& type, bool allow_select = false);



bool   MU_HP();
bool   EOApp();

bool RunDlgWarning(const char *msg, bool *ignore);





#line 1 "u:/uppsrc\\CtrlCore/lay.h"







#line 1 "u:/idisapp\\isu/clip/clip.lay"


struct ClipLayout__layid {};






struct ClipViewLayout__layid {};





struct ClipCopyMoveLayout__layid {};







struct ClipOpLayout__layid {};








#line 34 "u:/idisapp\\isu/clip/clip.lay"
#line 9 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/idisapp\\isu/clip/clip.lay"


template<class T> struct WithClipLayout : public T, public ClipLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(400, 300); }
	SqlTable list;
	MenuButton menu;
	Button ok;
	Button cancel;
};

template<class T> struct WithClipViewLayout : public T, public ClipViewLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(500, 400); }
	TableArray list;
	Button ok;
	Button cancel;
};

template<class T> struct WithClipCopyMoveLayout : public T, public ClipCopyMoveLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(322, 62); }
	Label dv___0;
	WithChoiceList<EditStringNotNull> name;
	Option global;
	Button cancel;
	Button ok;
};

template<class T> struct WithClipOpLayout : public T, public ClipOpLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(322, 80); }
	Label dv___0;
	DropList clip;
	Label dv___2;
	DropList setop;
	Button cancel;
	Button ok;
};

#line 34 "u:/idisapp\\isu/clip/clip.lay"
#line 23 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/idisapp\\isu/clip/clip.lay"


template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, ClipLayout__layid&) { parent.LayoutId("ClipLayout");
	layout.list.HSizePosZ(4, 4).VSizePosZ(4, 34); layout.list.LayoutId("list"); parent.Add(layout.list);
	layout.menu.SetLabel("Funkce").LeftPosZ(4, 80).BottomPosZ(4, 22); layout.menu.LayoutId("menu"); parent.Add(layout.menu);
	layout.ok.SetLabel("Vybrat").RightPosZ(88, 80).BottomPosZ(4, 22); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel("Zavt").RightPosZ(4, 80).BottomPosZ(4, 22); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, ClipViewLayout__layid&) { parent.LayoutId("ClipViewLayout");
	layout.list.HSizePosZ(4, 4).VSizePosZ(4, 32); layout.list.LayoutId("list"); parent.Add(layout.list);
	layout.ok.SetLabel("OK").RightPosZ(88, 80).BottomPosZ(4, 22); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel("Storno").RightPosZ(4, 80).BottomPosZ(4, 22); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, ClipCopyMoveLayout__layid&) { parent.LayoutId("ClipCopyMoveLayout");
	layout.dv___0.SetLabel("&Nzev schrnky:").LeftPosZ(4, 90).TopPosZ(4, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.name.HSizePosZ(92, 4).TopPosZ(4, 19); layout.name.LayoutId("name"); parent.Add(layout.name);
	layout.global.SetLabel("&Veejn").LeftPosZ(91, 80).TopPosZ(24, 18); layout.global.LayoutId("global"); parent.Add(layout.global);
	layout.cancel.SetLabel("Storno").RightPosZ(4, 80).BottomPosZ(4, 22); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
	layout.ok.SetLabel("OK").RightPosZ(88, 80).BottomPosZ(4, 22); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, ClipOpLayout__layid&) { parent.LayoutId("ClipOpLayout");
	layout.dv___0.SetLabel("&Nzev schrnky:").LeftPosZ(4, 90).TopPosZ(4, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.clip.HSizePosZ(92, 4).TopPosZ(4, 19); layout.clip.LayoutId("clip"); parent.Add(layout.clip);
	layout.dv___2.SetLabel("&Pout filtr:").LeftPosZ(4, 58).TopPosZ(26, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.setop.HSizePosZ(92, 4).TopPosZ(26, 19); layout.setop.LayoutId("setop"); parent.Add(layout.setop);
	layout.cancel.SetLabel("Storno").RightPosZ(4, 80).BottomPosZ(4, 22); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
	layout.ok.SetLabel("OK").RightPosZ(88, 80).BottomPosZ(4, 22); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
};

#line 34 "u:/idisapp\\isu/clip/clip.lay"
#line 37 "u:/uppsrc\\CtrlCore/lay.h"







#line 49 "u:/idisapp\\isu/isu.h"
#line 50 "u:/idisapp\\isu/isu.h"

#line 52 "u:/idisapp\\isu/isu.h"
#line 71 "u:/idisapp\\IdisMisc/IdisMisc.h"
#line 1 "u:/idisapp\\isu/gis.h"













































































#line 79 "u:/idisapp\\isu/gis.h"
#line 72 "u:/idisapp\\IdisMisc/IdisMisc.h"
#line 1 "u:/idisapp\\isu/Osobaexp.h"








SqlSelect   SelectOsoba();
SqlVal      GetAnyAdresa();
SqlSelect   SelectMistni();



SqlSet   GetAdresaSubtreeOf(const SqlBool& exp);
SqlSet   GetAdresaSubtree(const SqlVal& node);
SqlBool  GetAdresaLikeTest(const String& s);
SqlSet   GetAdresaLikeSubtree(const String& s);



SqlSet   GetClipboardData(int clip_seq);



SqlSet   GetOsobaOrderName();
SqlSet   GetOsobaOrderAge();
SqlSet   GetOsobaOrderRcIco();



#line 33 "u:/idisapp\\isu/Osobaexp.h"
#line 73 "u:/idisapp\\IdisMisc/IdisMisc.h"
#line 1 "u:/idisapp\\isu/DlgFind.h"










namespace Osoby
{







#line 1 "u:/uppsrc\\CtrlCore/lay.h"







#line 1 "u:/idisapp\\isu/find.lay"
struct FindMasterLayout__layid {};

















struct FindPageZakladniLayout__layid {};

































struct FindPageAdresaLayout__layid {};




































struct FindPageVztahyLayout__layid {};



















struct FindPageCustomLayout__layid {};









#line 9 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/idisapp\\isu/find.lay"
template<class T> struct WithFindMasterLayout : public T, public FindMasterLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(500, 320); }
	Label dv___0;
	DropList set;
	Label dv___2;
	DropList setop;
	TabCtrl tab;
	Label dv___5;
	DropList sort;
	Button preview;
	Button clear_all;
	Button ok;
	Button cancel;
	Label dv___11;
	DropList userid;
	Option noarchive;
	Option errors;
};

template<class T> struct WithFindPageZakladniLayout : public T, public FindPageZakladniLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(480, 194); }
	Label dv___0;
	EditField prijm_od;
	EditField prijm_do;
	Option predchozi_prijmeni;
	Label dv___4;
	EditField jmeno_od;
	EditField jmeno_do;
	Label dv___7;
	EditField rod_prijm_od;
	EditField rod_prijm_do;
	Label dv___10;
	EditField rc_ico_od;
	EditField rc_ico_do;
	Label dv___13;
	EditDate dat_nar_od;
	EditDate dat_nar_do;
	Label dv___16;
	EditDate dat_umrti_od;
	EditDate dat_umrti_do;
	Label dv___19;
	EditInt vek_od;
	EditInt vek_do;
	Label dv___22;
	EditDate vek_obdobi_od;
	EditDate vek_obdobi_do;
	LabelBox dv___25;
	Option muzi;
	Option zeny;
	Option pravnicke;
	Switch zive_mrtve;

};

template<class T> struct WithFindPageAdresaLayout : public T, public FindPageAdresaLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(480, 194); }
	Label dv___0;
	Switch mistni;
	Label dv___2;
	EditField stat;
	Label dv___4;
	EditField obec;
	Label dv___6;
	EditField okres;
	Label dv___8;
	EditField ulice;
	Label dv___10;
	EditField ctvrt;
	Label dv___12;
	EditField cpop;
	Label dv___14;
	EditField cor;
	Label dv___16;
	EditField byt;
	Label dv___18;
	EditField vchod;
	Label dv___20;
	EditField idx;
	Label dv___22;
	EditField psc;
	Label dv___24;
	EditField zuzi;
	Label dv___26;
	LineAdresaCtrl adresa;
	Label dv___28;
	DropList clip;
	Option predchozi;
	Option prechodne;
	Option archiv;

};

template<class T> struct WithFindPageVztahyLayout : public T, public FindPageVztahyLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(480, 194); }
	Label dv___0;
	OsobaCtrl deti;
	Label dv___2;
	DropList deti_clip;
	Label dv___4;
	OsobaCtrl rodice;
	Label dv___6;
	DropList rodice_clip;
	Label dv___8;
	OsobaCtrl manzel;
	Label dv___10;
	DropList manzel_clip;
	Label dv___12;
	EditInt seq_od;
	Label dv___14;
	EditInt seq_do;

};

template<class T> struct WithFindPageCustomLayout : public T, public FindPageCustomLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(480, 194); }
	Label dv___0;
	Label dv___1;
	Label dv___2;
	Ctrl typ;
	Ctrl cond;
	Ctrl data;
	Option archiv;

};
#line 23 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/idisapp\\isu/find.lay"
template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, FindMasterLayout__layid&) { parent.LayoutId("FindMasterLayout");
	layout.dv___0.SetLabel(t_GetLngString("Zkladn mnoina:")).LeftPosZ(6, 89).TopPosZ(4, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.set.LeftPosZ(97, 116).TopPosZ(5, 19); layout.set.LayoutId("set"); parent.Add(layout.set);
	layout.dv___2.SetLabel(t_GetLngString("Mnoinov operace:")).LeftPosZ(4, 101).TopPosZ(264, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.setop.LeftPosZ(107, 138).TopPosZ(264, 19); layout.setop.LayoutId("setop"); parent.Add(layout.setop);
	layout.tab.LeftPosZ(4, 492).TopPosZ(32, 224); layout.tab.LayoutId("tab"); parent.Add(layout.tab);
	layout.dv___5.SetLabel(t_GetLngString("Seadit:")).LeftPosZ(4, 39).TopPosZ(292, 19); layout.dv___5.LayoutId("dv___5"); parent.Add(layout.dv___5);
	layout.sort.LeftPosZ(108, 96).TopPosZ(292, 19); layout.sort.LayoutId("sort"); parent.Add(layout.sort);
	layout.preview.SetLabel(t_GetLngString("Nhled")).LeftPosZ(224, 80).TopPosZ(288, 26); layout.preview.LayoutId("preview"); parent.Add(layout.preview);
	layout.clear_all.SetLabel(t_GetLngString("Smazat ve")).LeftPosZ(308, 68).TopPosZ(288, 26); layout.clear_all.LayoutId("clear_all"); parent.Add(layout.clear_all);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(380, 56).TopPosZ(288, 26); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(440, 56).TopPosZ(288, 26); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
	layout.dv___11.SetLabel(t_GetLngString("Zdroj:")).LeftPosZ(236, 32).TopPosZ(4, 19); layout.dv___11.LayoutId("dv___11"); parent.Add(layout.dv___11);
	layout.userid.LeftPosZ(272, 100).TopPosZ(4, 19); layout.userid.LayoutId("userid"); parent.Add(layout.userid);
	layout.noarchive.SetLabel(t_GetLngString("Nem archiv")).LeftPosZ(412, 84).TopPosZ(0, 15); layout.noarchive.LayoutId("noarchive"); parent.Add(layout.noarchive);
	layout.errors.SetLabel(t_GetLngString("Chyby z MV")).LeftPosZ(412, 84).TopPosZ(16, 15); layout.errors.LayoutId("errors"); parent.Add(layout.errors);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, FindPageZakladniLayout__layid&) { parent.LayoutId("FindPageZakladniLayout");
	layout.dv___0.SetLabel(t_GetLngString("&Pjmen:")).LeftPosZ(4, 56).TopPosZ(4, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.prijm_od.LeftPosZ(92, 124).TopPosZ(4, 19); layout.prijm_od.LayoutId("prijm_od"); parent.Add(layout.prijm_od);
	layout.prijm_do.LeftPosZ(220, 124).TopPosZ(4, 19); layout.prijm_do.LayoutId("prijm_do"); parent.Add(layout.prijm_do);
	layout.predchozi_prijmeni.SetLabel(t_GetLngString("&I pedchoz pjmen")).LeftPosZ(358, 116).TopPosZ(4, 19); layout.predchozi_prijmeni.LayoutId("predchozi_prijmeni"); parent.Add(layout.predchozi_prijmeni);
	layout.dv___4.SetLabel(t_GetLngString("Jmno:")).LeftPosZ(4, 44).TopPosZ(26, 19); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.jmeno_od.LeftPosZ(92, 124).TopPosZ(26, 19); layout.jmeno_od.LayoutId("jmeno_od"); parent.Add(layout.jmeno_od);
	layout.jmeno_do.LeftPosZ(220, 124).TopPosZ(26, 19); layout.jmeno_do.LayoutId("jmeno_do"); parent.Add(layout.jmeno_do);
	layout.dv___7.SetLabel(t_GetLngString("&Rodn pjmen:")).LeftPosZ(4, 86).TopPosZ(48, 19); layout.dv___7.LayoutId("dv___7"); parent.Add(layout.dv___7);
	layout.rod_prijm_od.LeftPosZ(92, 124).TopPosZ(48, 19); layout.rod_prijm_od.LayoutId("rod_prijm_od"); parent.Add(layout.rod_prijm_od);
	layout.rod_prijm_do.LeftPosZ(220, 124).TopPosZ(48, 19); layout.rod_prijm_do.LayoutId("rod_prijm_do"); parent.Add(layout.rod_prijm_do);
	layout.dv___10.SetLabel(t_GetLngString("R/I&O:")).LeftPosZ(4, 50).TopPosZ(70, 19); layout.dv___10.LayoutId("dv___10"); parent.Add(layout.dv___10);
	layout.rc_ico_od.LeftPosZ(92, 124).TopPosZ(70, 19); layout.rc_ico_od.LayoutId("rc_ico_od"); parent.Add(layout.rc_ico_od);
	layout.rc_ico_do.LeftPosZ(220, 124).TopPosZ(70, 19); layout.rc_ico_do.LayoutId("rc_ico_do"); parent.Add(layout.rc_ico_do);
	layout.dv___13.SetLabel(t_GetLngString("&Narozen(a)/Vznik:")).LeftPosZ(4, 98).TopPosZ(92, 19); layout.dv___13.LayoutId("dv___13"); parent.Add(layout.dv___13);
	layout.dat_nar_od.LeftPosZ(136, 80).TopPosZ(92, 19); layout.dat_nar_od.LayoutId("dat_nar_od"); parent.Add(layout.dat_nar_od);
	layout.dat_nar_do.LeftPosZ(220, 80).TopPosZ(92, 19); layout.dat_nar_do.LayoutId("dat_nar_do"); parent.Add(layout.dat_nar_do);
	layout.dv___16.SetLabel(t_GetLngString("&Zemel(a)/Znik:")).LeftPosZ(4, 86).TopPosZ(114, 19); layout.dv___16.LayoutId("dv___16"); parent.Add(layout.dv___16);
	layout.dat_umrti_od.LeftPosZ(136, 80).TopPosZ(114, 19); layout.dat_umrti_od.LayoutId("dat_umrti_od"); parent.Add(layout.dat_umrti_od);
	layout.dat_umrti_do.LeftPosZ(220, 80).TopPosZ(114, 19); layout.dat_umrti_do.LayoutId("dat_umrti_do"); parent.Add(layout.dat_umrti_do);
	layout.dv___19.SetLabel(t_GetLngString("&Doshl(a) vku:")).LeftPosZ(4, 86).TopPosZ(136, 19); layout.dv___19.LayoutId("dv___19"); parent.Add(layout.dv___19);
	layout.vek_od.LeftPosZ(136, 80).TopPosZ(136, 19); layout.vek_od.LayoutId("vek_od"); parent.Add(layout.vek_od);
	layout.vek_do.LeftPosZ(220, 80).TopPosZ(136, 19); layout.vek_do.LayoutId("vek_do"); parent.Add(layout.vek_do);
	layout.dv___22.SetLabel(t_GetLngString("V obdob:")).LeftPosZ(4, 56).TopPosZ(158, 19); layout.dv___22.LayoutId("dv___22"); parent.Add(layout.dv___22);
	layout.vek_obdobi_od.LeftPosZ(136, 80).TopPosZ(158, 19); layout.vek_obdobi_od.LayoutId("vek_obdobi_od"); parent.Add(layout.vek_obdobi_od);
	layout.vek_obdobi_do.LeftPosZ(220, 80).TopPosZ(158, 19); layout.vek_obdobi_do.LayoutId("vek_obdobi_do"); parent.Add(layout.vek_obdobi_do);
	layout.dv___25.SetLabel(t_GetLngString("Filtr")).LeftPosZ(352, 124).TopPosZ(24, 120); layout.dv___25.LayoutId("dv___25"); parent.Add(layout.dv___25);
	layout.muzi.SetLabel(t_GetLngString("&Mui")).LeftPosZ(358, 52).TopPosZ(38, 18); layout.muzi.LayoutId("muzi"); parent.Add(layout.muzi);
	layout.zeny.SetLabel(t_GetLngString("&eny")).LeftPosZ(358, 50).TopPosZ(54, 18); layout.zeny.LayoutId("zeny"); parent.Add(layout.zeny);
	layout.pravnicke.SetLabel(t_GetLngString("Prvni&ck osoby")).LeftPosZ(358, 104).TopPosZ(70, 18); layout.pravnicke.LayoutId("pravnicke"); parent.Add(layout.pravnicke);
	layout.zive_mrtve.SetLabel(t_GetLngString("iv\nZemel / zruen\niv i mrtv")).LeftPosZ(358, 116).TopPosZ(92, 50); layout.zive_mrtve.LayoutId("zive_mrtve"); parent.Add(layout.zive_mrtve);
	uts.clear.SetLabel(t_GetLngString("&Smazat")).LeftPosZ(396, 80).TopPosZ(168, 22); uts.clear.LayoutId("clear"); parent.Add(uts.clear);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, FindPageAdresaLayout__layid&) { parent.LayoutId("FindPageAdresaLayout");
	layout.dv___0.SetLabel(t_GetLngString("Omezit vbr adres na:")).LeftPosZ(4, 120).TopPosZ(4, 18); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.mistni.SetLabel(t_GetLngString("&Vechny\n&Mstn\n&Ciz")).LeftPosZ(134, 176).TopPosZ(4, 18); layout.mistni.LayoutId("mistni"); parent.Add(layout.mistni);
	layout.dv___2.SetLabel(t_GetLngString("Stt:")).LeftPosZ(4, 34).TopPosZ(32, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.stat.LeftPosZ(40, 64).TopPosZ(32, 19); layout.stat.LayoutId("stat"); parent.Add(layout.stat);
	layout.dv___4.SetLabel(t_GetLngString("&Obec:")).LeftPosZ(248, 40).TopPosZ(32, 19); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.obec.LeftPosZ(288, 64).TopPosZ(32, 19); layout.obec.LayoutId("obec"); parent.Add(layout.obec);
	layout.dv___6.SetLabel(t_GetLngString("O&kres:")).LeftPosZ(372, 40).TopPosZ(32, 19); layout.dv___6.LayoutId("dv___6"); parent.Add(layout.dv___6);
	layout.okres.LeftPosZ(412, 64).TopPosZ(32, 19); layout.okres.LayoutId("okres"); parent.Add(layout.okres);
	layout.dv___8.SetLabel(t_GetLngString("&Ulice:")).LeftPosZ(4, 34).TopPosZ(54, 19); layout.dv___8.LayoutId("dv___8"); parent.Add(layout.dv___8);
	layout.ulice.LeftPosZ(40, 64).TopPosZ(54, 19); layout.ulice.LayoutId("ulice"); parent.Add(layout.ulice);
	layout.dv___10.SetLabel(t_GetLngString("tv&r:")).LeftPosZ(124, 34).TopPosZ(54, 19); layout.dv___10.LayoutId("dv___10"); parent.Add(layout.dv___10);
	layout.ctvrt.LeftPosZ(164, 64).TopPosZ(54, 19); layout.ctvrt.LayoutId("ctvrt"); parent.Add(layout.ctvrt);
	layout.dv___12.SetLabel(t_GetLngString(".pop.:")).LeftPosZ(248, 40).TopPosZ(54, 19); layout.dv___12.LayoutId("dv___12"); parent.Add(layout.dv___12);
	layout.cpop.LeftPosZ(288, 64).TopPosZ(54, 19); layout.cpop.LayoutId("cpop"); parent.Add(layout.cpop);
	layout.dv___14.SetLabel(t_GetLngString(".or.:")).LeftPosZ(372, 34).TopPosZ(54, 19); layout.dv___14.LayoutId("dv___14"); parent.Add(layout.dv___14);
	layout.cor.LeftPosZ(412, 64).TopPosZ(54, 19); layout.cor.LayoutId("cor"); parent.Add(layout.cor);
	layout.dv___16.SetLabel(t_GetLngString("&Byt:")).LeftPosZ(4, 34).TopPosZ(76, 19); layout.dv___16.LayoutId("dv___16"); parent.Add(layout.dv___16);
	layout.byt.LeftPosZ(40, 64).TopPosZ(76, 19); layout.byt.LayoutId("byt"); parent.Add(layout.byt);
	layout.dv___18.SetLabel(t_GetLngString("&Vchod:")).LeftPosZ(124, 40).TopPosZ(76, 19); layout.dv___18.LayoutId("dv___18"); parent.Add(layout.dv___18);
	layout.vchod.LeftPosZ(164, 64).TopPosZ(76, 19); layout.vchod.LayoutId("vchod"); parent.Add(layout.vchod);
	layout.dv___20.SetLabel(t_GetLngString("Inde&x domu:")).LeftPosZ(344, 62).TopPosZ(76, 19); layout.dv___20.LayoutId("dv___20"); parent.Add(layout.dv___20);
	layout.idx.LeftPosZ(412, 64).TopPosZ(76, 19); layout.idx.LayoutId("idx"); parent.Add(layout.idx);
	layout.dv___22.SetLabel(t_GetLngString("&PS:")).LeftPosZ(4, 34).TopPosZ(98, 19); layout.dv___22.LayoutId("dv___22"); parent.Add(layout.dv___22);
	layout.psc.LeftPosZ(40, 64).TopPosZ(98, 19); layout.psc.LayoutId("psc"); parent.Add(layout.psc);
	layout.dv___24.SetLabel(t_GetLngString("&ZUZI:")).LeftPosZ(124, 36).TopPosZ(98, 19); layout.dv___24.LayoutId("dv___24"); parent.Add(layout.dv___24);
	layout.zuzi.LeftPosZ(164, 64).TopPosZ(98, 19); layout.zuzi.LayoutId("zuzi"); parent.Add(layout.zuzi);
	layout.dv___26.SetLabel(t_GetLngString("Ko&nkrtn adresa:")).LeftPosZ(4, 96).TopPosZ(120, 19); layout.dv___26.LayoutId("dv___26"); parent.Add(layout.dv___26);
	layout.adresa.LeftPosZ(102, 374).TopPosZ(120, 19); layout.adresa.LayoutId("adresa"); parent.Add(layout.adresa);
	layout.dv___28.SetLabel(t_GetLngString("Z&e schrnky:")).LeftPosZ(4, 80).TopPosZ(142, 19); layout.dv___28.LayoutId("dv___28"); parent.Add(layout.dv___28);
	layout.clip.LeftPosZ(102, 156).TopPosZ(142, 19); layout.clip.LayoutId("clip"); parent.Add(layout.clip);
	layout.predchozi.SetLabel(t_GetLngString("Pe&dchoz bydlit")).LeftPosZ(4, 112).TopPosZ(170, 19); layout.predchozi.LayoutId("predchozi"); parent.Add(layout.predchozi);
	layout.prechodne.SetLabel(t_GetLngString("Pechodn b&ydlit")).LeftPosZ(118, 118).TopPosZ(170, 19); layout.prechodne.LayoutId("prechodne"); parent.Add(layout.prechodne);
	layout.archiv.SetLabel(t_GetLngString("&Historick nzvy")).LeftPosZ(238, 102).TopPosZ(170, 19); layout.archiv.LayoutId("archiv"); parent.Add(layout.archiv);
	uts.clear.SetLabel(t_GetLngString("&Smazat")).LeftPosZ(396, 80).TopPosZ(168, 22); uts.clear.LayoutId("clear"); parent.Add(uts.clear);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, FindPageVztahyLayout__layid&) { parent.LayoutId("FindPageVztahyLayout");
	layout.dv___0.SetLabel(t_GetLngString("&Dti osoby:")).LeftPosZ(4, 64).TopPosZ(4, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.deti.LeftPosZ(90, 386).TopPosZ(4, 19); layout.deti.LayoutId("deti"); parent.Add(layout.deti);
	layout.dv___2.SetLabel(t_GetLngString("Ze schrnky:")).LeftPosZ(90, 74).TopPosZ(26, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.deti_clip.LeftPosZ(176, 150).TopPosZ(26, 19); layout.deti_clip.LayoutId("deti_clip"); parent.Add(layout.deti_clip);
	layout.dv___4.SetLabel(t_GetLngString("Rodie osoby:")).LeftPosZ(4, 80).TopPosZ(48, 19); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.rodice.LeftPosZ(90, 386).TopPosZ(48, 19); layout.rodice.LayoutId("rodice"); parent.Add(layout.rodice);
	layout.dv___6.SetLabel(t_GetLngString("Ze schrnky:")).LeftPosZ(90, 74).TopPosZ(70, 19); layout.dv___6.LayoutId("dv___6"); parent.Add(layout.dv___6);
	layout.rodice_clip.LeftPosZ(176, 150).TopPosZ(70, 19); layout.rodice_clip.LayoutId("rodice_clip"); parent.Add(layout.rodice_clip);
	layout.dv___8.SetLabel(t_GetLngString("&Manel osoby:")).LeftPosZ(4, 80).TopPosZ(92, 19); layout.dv___8.LayoutId("dv___8"); parent.Add(layout.dv___8);
	layout.manzel.LeftPosZ(90, 386).TopPosZ(92, 19); layout.manzel.LayoutId("manzel"); parent.Add(layout.manzel);
	layout.dv___10.SetLabel(t_GetLngString("Ze schrnky:")).LeftPosZ(90, 74).TopPosZ(114, 19); layout.dv___10.LayoutId("dv___10"); parent.Add(layout.dv___10);
	layout.manzel_clip.LeftPosZ(176, 150).TopPosZ(114, 19); layout.manzel_clip.LayoutId("manzel_clip"); parent.Add(layout.manzel_clip);
	layout.dv___12.SetLabel(t_GetLngString("&Volisk slo:")).LeftPosZ(4, 80).TopPosZ(136, 19); layout.dv___12.LayoutId("dv___12"); parent.Add(layout.dv___12);
	layout.seq_od.LeftPosZ(90, 70).TopPosZ(136, 19); layout.seq_od.LayoutId("seq_od"); parent.Add(layout.seq_od);
	layout.dv___14.SetLabel(t_GetLngString("a")).LeftPosZ(168, 20).TopPosZ(136, 19); layout.dv___14.LayoutId("dv___14"); parent.Add(layout.dv___14);
	layout.seq_do.LeftPosZ(192, 70).TopPosZ(136, 19); layout.seq_do.LayoutId("seq_do"); parent.Add(layout.seq_do);
	uts.clear.SetLabel(t_GetLngString("&Smazat")).LeftPosZ(396, 80).TopPosZ(168, 22); uts.clear.LayoutId("clear"); parent.Add(uts.clear);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, FindPageCustomLayout__layid&) { parent.LayoutId("FindPageCustomLayout");
	layout.dv___0.SetLabel(t_GetLngString("Typ daje:")).LeftPosZ(4, 80).TopPosZ(4, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.dv___1.SetLabel(t_GetLngString("Podmnka:")).LeftPosZ(114, 80).TopPosZ(4, 19); layout.dv___1.LayoutId("dv___1"); parent.Add(layout.dv___1);
	layout.dv___2.SetLabel(t_GetLngString("Parametry:")).LeftPosZ(224, 80).TopPosZ(4, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.typ.LeftPosZ(4, 106).TopPosZ(26, 19); layout.typ.LayoutId("typ"); parent.Add(layout.typ);
	layout.cond.LeftPosZ(114, 106).TopPosZ(26, 19); layout.cond.LayoutId("cond"); parent.Add(layout.cond);
	layout.data.LeftPosZ(224, 252).TopPosZ(26, 19); layout.data.LayoutId("data"); parent.Add(layout.data);
	layout.archiv.SetLabel(t_GetLngString("&Hledat i v archivu")).LeftPosZ(4, 114).TopPosZ(174, 18); layout.archiv.LayoutId("archiv"); parent.Add(layout.archiv);
	uts.clear.SetLabel(t_GetLngString("&Smazat")).LeftPosZ(396, 80).TopPosZ(168, 22); uts.clear.LayoutId("clear"); parent.Add(uts.clear);
};
#line 37 "u:/uppsrc\\CtrlCore/lay.h"







#line 21 "u:/idisapp\\isu/DlgFind.h"
#line 22 "u:/idisapp\\isu/DlgFind.h"



class FindInfo
{
public:
	FindInfo();

	void             Pick(Vector<int>& set);
	void             Pick(Array<OsobaRef>& set);

	void             RefAndSeq();
	void             SeqToRef();

	Vector<int>      GetSeq() const;

public:
	SqlBool          osoba_cond;
	SqlSet           osoba_set;
	enum { VSECHNY, MISTNI, MIMO_OBEC };
	int              mistni;

	enum { NONE, SEQ, REF } type;
	Vector<int>      seq_list;
	Array<OsobaRef>  ref_list;
};



template <class T>
class WithOpen : public T
{
public:
	virtual void State(int reason);

public:
	Callback WhenOpen;
};



template <class T>
void WithOpen<T>::State(int reason)
{
	if(reason == OPEN && IsOpen())
		WhenOpen();
	T::State(reason);
}



class DlgFindPage
{
public:
	typedef DlgFindPage CLASSNAME;
	DlgFindPage(const char *title = 0);
	virtual ~DlgFindPage() {}

	virtual void   Clear();
	virtual bool   Add(FindInfo& info) { return true; }
	virtual void   Serialize(Stream& stream);
	virtual void   UpdateUI() {}

	void           Register(int version);

	Callback       CallUI() { return callback(this, &CLASSNAME::UpdateUI); }

public:
	Button         clear;
	String         title;
	WithOpen<Ctrl> dialog;

protected:
	Vector<Ctrl *> stream_list;
	Vector<Value>  value_list;
	int            stream_version;
};




class DlgFind
{
public:
	typedef DlgFind CLASSNAME;
	DlgFind();

	DlgFind& Add(DlgFindPage *page) { pages.Add(page); return *this; }
	bool     Run(Array<OsobaRef>& list, ConfigItem *config = 0);

	void     Serialize(Stream& stream);

private:
	void     OnView();
	void     OnClearAll();
	bool     IsModified() const;
	void     ClearModify();
	bool     Execute();

private:
	WithFindMasterLayout<TopWindow> dialog;
	Array<DlgFindPage> pages;
	Array<OsobaRef> *master_list;
	Array<OsobaRef> result;
	Index<int> adresa_obec;
	ConfigItem *config;
};



}

#line 135 "u:/idisapp\\isu/DlgFind.h"
#line 74 "u:/idisapp\\IdisMisc/IdisMisc.h"
#line 1 "u:/idisapp\\isu/audit.h"






#line 1 "u:\\idisapp\\isu\\om_model.h"








void OmModel(bool run);



enum
{
	CNUM = 10,
	NNUM = 10,
	DNUM = 5,
	RNUM = 1,
};



#line 1 "u:/uppsrc\\Sql/sch_header.h"

































#line 1 "u:/uppsrc\\Oracle/OracleSchema.h"


























































#line 60 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 65 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 70 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 75 "u:/uppsrc\\Oracle/OracleSchema.h"















#line 1 "u:/uppsrc\\Sql/sch_model.h"








#line 10 "u:/uppsrc\\Sql/sch_model.h"
















#line 27 "u:/uppsrc\\Sql/sch_model.h"
















#line 44 "u:/uppsrc\\Sql/sch_model.h"







#line 52 "u:/uppsrc\\Sql/sch_model.h"











#line 64 "u:/uppsrc\\Sql/sch_model.h"







#line 72 "u:/uppsrc\\Sql/sch_model.h"







#line 80 "u:/uppsrc\\Sql/sch_model.h"



#line 84 "u:/uppsrc\\Sql/sch_model.h"



#line 88 "u:/uppsrc\\Sql/sch_model.h"



#line 92 "u:/uppsrc\\Sql/sch_model.h"



#line 96 "u:/uppsrc\\Sql/sch_model.h"



#line 100 "u:/uppsrc\\Sql/sch_model.h"



#line 104 "u:/uppsrc\\Sql/sch_model.h"



#line 108 "u:/uppsrc\\Sql/sch_model.h"



#line 112 "u:/uppsrc\\Sql/sch_model.h"



#line 116 "u:/uppsrc\\Sql/sch_model.h"







#line 124 "u:/uppsrc\\Sql/sch_model.h"




















#line 145 "u:/uppsrc\\Sql/sch_model.h"



#line 149 "u:/uppsrc\\Sql/sch_model.h"



#line 153 "u:/uppsrc\\Sql/sch_model.h"



#line 157 "u:/uppsrc\\Sql/sch_model.h"



#line 161 "u:/uppsrc\\Sql/sch_model.h"

#line 1 "u:/idisapp\\isu/om_model.sch"













 struct S_IDIS_USER  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_IDIS_USER::FieldLayout); } S_IDIS_USER();
	 enum { NAME_WIDTH = 30, NAME_PRECISION = 0 }; String NAME;
	enum { TYPE_WIDTH = 1, TYPE_PRECISION = 0 }; String TYPE;
};



 struct S_IDIS_RIGHTS  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_IDIS_RIGHTS::FieldLayout); } S_IDIS_RIGHTS();
	 enum { IDIS_RIGHTS_SEQ_WIDTH = 0, IDIS_RIGHTS_SEQ_PRECISION = 0 }; int IDIS_RIGHTS_SEQ;
	 enum { OWNER_WIDTH = 30, OWNER_PRECISION = 0 }; String OWNER;
	 enum { OBJECT_WIDTH = 30, OBJECT_PRECISION = 0 }; String OBJECT;
	 enum { OBJECT_TYPE_WIDTH = 1, OBJECT_TYPE_PRECISION = 0 }; String OBJECT_TYPE;
	 enum { R_RIGHTS_WIDTH = 1, R_RIGHTS_PRECISION = 0 }; String R_RIGHTS;
	 enum { W_RIGHTS_WIDTH = 1, W_RIGHTS_PRECISION = 0 }; String W_RIGHTS;
	 enum { A_RIGHTS_WIDTH = 1, A_RIGHTS_PRECISION = 0 }; String A_RIGHTS;
};



 struct S_IDIS_DETAILS  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_IDIS_DETAILS::FieldLayout); } S_IDIS_DETAILS();
	 enum { IDIS_DETAILS_SEQ_WIDTH = 0, IDIS_DETAILS_SEQ_PRECISION = 0 }; int IDIS_DETAILS_SEQ;
	enum { OWNER_WIDTH = 30, OWNER_PRECISION = 0 }; String OWNER;
	enum { OBJECT_WIDTH = 30, OBJECT_PRECISION = 0 }; String OBJECT;
	enum { TEXT_WIDTH = 500, TEXT_PRECISION = 0 }; String TEXT;
	 enum { NUM_WIDTH = 0, NUM_PRECISION = 0 }; double NUM;
};



 struct S_IDIS_TABLE  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_IDIS_TABLE::FieldLayout); } S_IDIS_TABLE();
	enum { TABLE_NAME_WIDTH = 30, TABLE_NAME_PRECISION = 0 }; String TABLE_NAME;
	 enum { GROUP_NAME_WIDTH = 50, GROUP_NAME_PRECISION = 0 }; String GROUP_NAME;
	 enum { DESCRIPTION_WIDTH = 100, DESCRIPTION_PRECISION = 0 }; String DESCRIPTION;
	enum { KEY_WIDTH = 30, KEY_PRECISION = 0 }; String KEY;
	 enum { BATCH_COUNT_WIDTH = 0, BATCH_COUNT_PRECISION = 0 }; int BATCH_COUNT;
	 enum { UNDO_ENABLED_WIDTH = 0, UNDO_ENABLED_PRECISION = 0 }; bool UNDO_ENABLED;
	 enum { LAST_TRAN_SEQ_WIDTH = 0, LAST_TRAN_SEQ_PRECISION = 0 }; int LAST_TRAN_SEQ;
};



 struct S_IDIS_TABLE_DS  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_IDIS_TABLE_DS::FieldLayout); } S_IDIS_TABLE_DS();
	 enum { IDIS_TABLE_DS_SEQ_WIDTH = 0, IDIS_TABLE_DS_SEQ_PRECISION = 0 }; int IDIS_TABLE_DS_SEQ;
	enum { TABLE_NAME_WIDTH = 30, TABLE_NAME_PRECISION = 0 }; String TABLE_NAME;
	 enum { COLUMN_NAME_WIDTH = 30, COLUMN_NAME_PRECISION = 0 }; String COLUMN_NAME;
	 enum { BATCH_INDEX_WIDTH = 0, BATCH_INDEX_PRECISION = 0 }; int BATCH_INDEX;
	 enum { VALUE_TYPE_WIDTH = 1, VALUE_TYPE_PRECISION = 0 }; String VALUE_TYPE;
	 enum { VALUE_INDEX_WIDTH = 0, VALUE_INDEX_PRECISION = 0 }; int VALUE_INDEX;
};






 struct S_IDIS_UNDO  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_IDIS_UNDO::FieldLayout); } S_IDIS_UNDO();
	 enum { IDIS_UNDO_SEQ_WIDTH = 0, IDIS_UNDO_SEQ_PRECISION = 0 }; int IDIS_UNDO_SEQ;
	 enum { IDIS_UNDO_TRAN_SEQ_WIDTH = 0, IDIS_UNDO_TRAN_SEQ_PRECISION = 0 }; int IDIS_UNDO_TRAN_SEQ;
	 enum { USER_NAME_WIDTH = 30, USER_NAME_PRECISION = 0 }; String USER_NAME;
	enum { TABLE_NAME_WIDTH = 30, TABLE_NAME_PRECISION = 0 }; String TABLE_NAME;

	 enum { COMMAND_WIDTH = 4, COMMAND_PRECISION = 0 }; String COMMAND;
	 enum { CVAL_WIDTH = 2000, CVAL_PRECISION = 0 }; String CVAL[CNUM];
	 enum { NVAL_WIDTH = 0, NVAL_PRECISION = 0 }; double NVAL[NNUM];
	 enum { DVAL_WIDTH = 0, DVAL_PRECISION = 0 }; Date DVAL[DNUM];
	enum { RVAL_WIDTH = 0, RVAL_PRECISION = 0 }; int RVAL[RNUM];
};


#line 163 "u:/uppsrc\\Sql/sch_model.h"




































#line 91 "u:/uppsrc\\Oracle/OracleSchema.h"





















































#line 35 "u:/uppsrc\\Sql/sch_header.h"










#line 1 "u:/uppsrc\\Oracle/OracleSchema.h"


























































#line 60 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 65 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 70 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 75 "u:/uppsrc\\Oracle/OracleSchema.h"















#line 1 "u:/uppsrc\\Sql/sch_model.h"








#line 10 "u:/uppsrc\\Sql/sch_model.h"
















#line 27 "u:/uppsrc\\Sql/sch_model.h"




















#line 48 "u:/uppsrc\\Sql/sch_model.h"



#line 52 "u:/uppsrc\\Sql/sch_model.h"



#line 56 "u:/uppsrc\\Sql/sch_model.h"



#line 60 "u:/uppsrc\\Sql/sch_model.h"



#line 64 "u:/uppsrc\\Sql/sch_model.h"



#line 68 "u:/uppsrc\\Sql/sch_model.h"



#line 72 "u:/uppsrc\\Sql/sch_model.h"



#line 76 "u:/uppsrc\\Sql/sch_model.h"



#line 80 "u:/uppsrc\\Sql/sch_model.h"



#line 84 "u:/uppsrc\\Sql/sch_model.h"



#line 88 "u:/uppsrc\\Sql/sch_model.h"



#line 92 "u:/uppsrc\\Sql/sch_model.h"



#line 96 "u:/uppsrc\\Sql/sch_model.h"



#line 100 "u:/uppsrc\\Sql/sch_model.h"



#line 104 "u:/uppsrc\\Sql/sch_model.h"



#line 108 "u:/uppsrc\\Sql/sch_model.h"



#line 112 "u:/uppsrc\\Sql/sch_model.h"



#line 116 "u:/uppsrc\\Sql/sch_model.h"



#line 120 "u:/uppsrc\\Sql/sch_model.h"



#line 124 "u:/uppsrc\\Sql/sch_model.h"



#line 128 "u:/uppsrc\\Sql/sch_model.h"







#line 136 "u:/uppsrc\\Sql/sch_model.h"








#line 145 "u:/uppsrc\\Sql/sch_model.h"



#line 149 "u:/uppsrc\\Sql/sch_model.h"



#line 153 "u:/uppsrc\\Sql/sch_model.h"



#line 157 "u:/uppsrc\\Sql/sch_model.h"



#line 161 "u:/uppsrc\\Sql/sch_model.h"

#line 1 "u:/idisapp\\isu/om_model.sch"





extern SqlId RIGHTS;







extern SqlId IDIS_USER;
	extern SqlId NAME;





extern SqlId IDIS_RIGHTS;
	extern SqlId IDIS_RIGHTS_SEQ;
	extern SqlId OWNER;
	extern SqlId OBJECT;
	extern SqlId OBJECT_TYPE;
	extern SqlId R_RIGHTS;
	extern SqlId W_RIGHTS;
	extern SqlId A_RIGHTS;




extern SqlId IDIS_DETAILS;
	extern SqlId IDIS_DETAILS_SEQ;



	extern SqlId NUM;




extern SqlId IDIS_TABLE;

	extern SqlId GROUP_NAME;
	extern SqlId DESCRIPTION;

	extern SqlId BATCH_COUNT;
	extern SqlId UNDO_ENABLED;
	extern SqlId LAST_TRAN_SEQ;




extern SqlId IDIS_TABLE_DS;
	extern SqlId IDIS_TABLE_DS_SEQ;

	extern SqlId COLUMN_NAME;
	extern SqlId BATCH_INDEX;
	extern SqlId VALUE_TYPE;
	extern SqlId VALUE_INDEX;







extern SqlId IDIS_UNDO;
	extern SqlId IDIS_UNDO_SEQ;
	extern SqlId IDIS_UNDO_TRAN_SEQ;
	extern SqlId USER_NAME;


	extern SqlId COMMAND;
	extern SqlId CVAL;
	extern SqlId NVAL;
	extern SqlId DVAL;




#line 163 "u:/uppsrc\\Sql/sch_model.h"




































#line 91 "u:/uppsrc\\Oracle/OracleSchema.h"





















































#line 46 "u:/uppsrc\\Sql/sch_header.h"
#line 24 "u:\\idisapp\\isu\\om_model.h"




const SqlId _TYPE("TYPE");



extern SqlSequence SeqIdisMan;



struct IdisUser : public S_IDIS_USER, ::Moveable<IdisUser>
{
public:
	struct Compare { bool operator () (const IdisUser& a, const IdisUser& b) const; };

	bool IsUser() const { return *TYPE == 'U'; }
	bool IsRole() const { return *TYPE == 'R'; }

	static SqlSet SelectUsers();

	static VectorMap<String, IdisUser> Load();
};



struct IdisRights : public S_IDIS_RIGHTS, ::Moveable<IdisRights>
{
public:
	struct Compare { bool operator () (const IdisRights& a, const IdisRights& b) const; };

	bool IsRole() const     { return *OBJECT_TYPE == 'R'; }
	bool IsSqlRole() const  { return *OBJECT_TYPE == 'O'; }
	bool IsTable() const    { return *OBJECT_TYPE == 'T'; }
	bool IsView() const     { return *OBJECT_TYPE == 'V'; }
	bool IsSequence() const { return *OBJECT_TYPE == 'S'; }

	static VectorMap<String, IdisRights> Load();
};



struct IdisDetails : public S_IDIS_DETAILS, ::Moveable<IdisDetails>
{
};



extern SqlSequence SeqIdisUndo, SeqIdisUndoTran;

struct IdisTable_ : public S_IDIS_TABLE, ::Moveable<IdisTable_> {};
struct IdisTableDs : public S_IDIS_TABLE_DS, ::Moveable<IdisTableDs> {};
struct IdisUndo : public S_IDIS_UNDO, ::Moveable<IdisUndo> {};



#line 82 "u:\\idisapp\\isu\\om_model.h"
#line 8 "u:/idisapp\\isu/audit.h"



class IdisAudit
{
public:
	IdisAudit() {}
	IdisAudit(const String& table) { Table(table); }
	IdisAudit(SqlId table)         { Table(table); }

	void          Table(const String& _table) { table = _table; columns.Clear(); }
	void          Table(SqlId _table)         { Table(_table.ToString()); }

	int           GetLastTranSeq() const;
	Vector<Value> GetValues(const String& column, int first_index = 0, int last_index = Null);
	Vector<Value> GetValues(SqlId column, int first_index = 0, int last_index = Null) { return GetValues(column.ToString(), first_index, last_index); }

private:
	void          FetchColumns();

private:
	String                         table;
	VectorMap<String, IdisTableDs> columns;
};



#line 36 "u:/idisapp\\isu/audit.h"
#line 75 "u:/idisapp\\IdisMisc/IdisMisc.h"
#line 1 "u:/idisapp\\isu/Find.h"






namespace Osoby
{

bool RunDlgFind(Array<OsobaRef>& list);

}

#line 15 "u:/idisapp\\isu/Find.h"
#line 76 "u:/idisapp\\IdisMisc/IdisMisc.h"

void IdisAbout(Image icon, const char *txt, const char *author);
void IdisAbout(Image icon, const char *txt);

inline Font GuiFont() { return StdFont(); }

inline
void AppIcon(TopWindow& app, int icon)
{
	app.Icon(Win32Icon(5555, 16), Win32Icon(5555, 32));
}












#line 1 "u:/uppsrc\\CtrlCore/lay.h"







#line 1 "u:/idisapp\\IdisMisc/imis.lay"
struct OracleLoginLayout__layid {};











struct RegistryLayout__layid {};














struct UserOsobaLayout__layid {};
























struct SimpleLayout__layid {};




struct ExportLayout__layid {};














struct SqlLayout__layid {};




struct ListOpLayout__layid {};







struct RCLayout__layid {};





struct NFindAdresaLayout__layid {};







struct NAdresaLayout__layid {};








struct NFindOsobaLayout__layid {};
















struct NOsobaLayout__layid {};









struct SearchLayout__layid {};





struct NewPwdLayout__layid {};








struct RightsLayout__layid {};


























struct FyzickaOsobaLayout__layid {};

































struct PravnickaOsobaLayout__layid {};


















struct IPreviewLayout__layid {};







struct PhPrehledLayout__layid {};



















#line 9 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/idisapp\\IdisMisc/imis.lay"
template<class T> struct WithOracleLoginLayout : public T, public OracleLoginLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(224, 116); }
	Label dv___0;
	EditString user;
	Label dv___2;
	EditString password;
	Label dv___4;
	EditString connection;
	Button ok;
	Button pwd;
	Button cancel;
};

template<class T> struct WithRegistryLayout : public T, public RegistryLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(764, 500); }
	SqlArray id;
	Label dv___1;
	DocEdit value;
	Label dv___3;
	AdresaCtrl adresa;
	Label dv___5;
	EditDouble cislo;
	Label dv___7;
	EditDate datum;
	Label dv___9;
	OsobaCtrl osoba;
	Button exit;
};

template<class T> struct WithUserOsobaLayout : public T, public UserOsobaLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(360, 364); }
	SqlArray id;
	Label dv___1;
	OsobaCtrl osoba;
	Label dv___3;
	EditString telefon;
	Label dv___5;
	EditString email;
	Label dv___7;
	EditString fax;
	Label dv___9;
	EditString idc;
	Label dv___11;
	EditString zn;
	Label dv___13;
	EditString pristup;
	Label dv___15;
	DropList s_odbor_seq;
	Label dv___17;
	EditString funkce;
	Label dv___19;
	EditString podpis;
	Button exit;
};

template<class T> struct WithSimpleLayout : public T, public SimpleLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(400, 244); }
	SqlTable tab;
	Button exit;
};

template<class T> struct WithExportLayout : public T, public ExportLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(352, 116); }
	Label dv___0;
	DropList owner;
	Label dv___2;
	DropList table;
	Label dv___4;
	EditString where;
	Label dv___6;
	EditString dir;
	Option cpp;
	Option nulls;
	Button doexport;
	Button cancel;
};

template<class T> struct WithSqlLayout : public T, public SqlLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(400, 244); }
	SqlArray tab;
	Button exit;
};

template<class T> struct WithListOpLayout : public T, public ListOpLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(352, 232); }
	ArrayCtrl list;
	Button create;
	Button ok;
	Button cancel;
	Button remove;
};

template<class T> struct WithRCLayout : public T, public RCLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(124, 60); }
	Label lbl;
	EditString rc;
	Button ok;
};

template<class T> struct WithNFindAdresaLayout : public T, public NFindAdresaLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(278, 62); }
	Label dv___0;
	EditString adr;
	Button empty;
	Button cancel;
	Button ok;
};

template<class T> struct WithNAdresaLayout : public T, public NAdresaLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(574, 280); }
	ArrayCtrl list;
	Button find;
	Button empty;
	Button tree;
	Button ok;
	Button cancel;
};

template<class T> struct WithNFindOsobaLayout : public T, public NFindOsobaLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(328, 392); }
	Label dv___0;
	EditString osoba;
	Label adresa_txt;
	AdresaCtrl adresa;
	Label dtm_txt;
	EditDate dtm_od;
	Label dtm_txt2;
	EditDate dtm_do;
	Label reason_txt;
	EditString reason;
	ArrayCtrl lru;
	Button empty;
	Button cancel;
	Button ok;
};

template<class T> struct WithNOsobaLayout : public T, public NOsobaLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(646, 282); }
	ArrayCtrl list;
	Button find;
	Button empty;
	Button ok;
	Button cancel;
	Button insert_fyzicka;
	Button insert_pravnicka;
};

template<class T> struct WithSearchLayout : public T, public SearchLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(148, 64); }
	EditString jmeno;
	Button ok;
	Button cancel;
};

template<class T> struct WithNewPwdLayout : public T, public NewPwdLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(232, 92); }
	Label dv___0;
	EditString password;
	Label dv___2;
	EditString password1;
	Button ok;
	Button cancel;
};

template<class T> struct WithRightsLayout : public T, public RightsLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(480, 528); }
	LabelBox dv___0;
	SqlArray role;
	LabelBox dv___2;
	SqlOption datum;
	SqlOption mistonar;
	SqlOption rc;
	SqlOption pobyt;
	SqlOption stav;
	SqlOption partner;
	SqlOption deti;
	SqlOption oo;
	SqlOption apobyt;
	SqlOption aprijm;
	SqlOption ph;
	SqlOption ph_detail;
	SqlOption ucto;
	SqlOption ucto_detail;
	LabelBox dv___17;
	Label dv___18;
	EditInt pocet;
	SqlOption sdatum;
	SqlOption spobyt;
	LabelBox dv___22;
	SqlArray user;
};

template<class T> struct WithFyzickaOsobaLayout : public T, public FyzickaOsobaLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(404, 248); }
	Label dv___0;
	EditString prijm;
	Label dv___2;
	EditString jmeno;
	Label dv___4;
	EditString rc_ico;
	Label typ_lbl;
	DropList typ;
	Label rod_prijm_lbl;
	EditString rod_prijm;
	Label dv___10;
	EditDate dat_nar;
	Label dat_umrti_lbl;
	EditDate dat_umrti;
	Label misto_nar_lbl;
	LineAdresaCtrl misto_nar;
	Label stat_obc_lbl;
	StatCtrl stat_obc;
	Label trv_bydl_lbl;
	AdresaCtrl trv_bydl;
	Label prech_bydl_lbl;
	AdresaCtrl prech_bydl;
	Label t_ulice_lbl;
	EditString t_ulice;
	Label t_mesto_lbl;
	EditString t_mesto;
	Label t_psc_lbl;
	EditString t_psc;
	Option local;
	Button ok;
	Button cancel;
};

template<class T> struct WithPravnickaOsobaLayout : public T, public PravnickaOsobaLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(316, 248); }
	Label dv___0;
	EditStringNotNull prijm;
	Label dv___2;
	EditString rc_ico;
	Label dv___4;
	EditDate dat_nar;
	Label dv___6;
	EditDate dat_umrti;
	Label dv___8;
	EditString rejstrik;
	Label dv___10;
	AdresaCtrl trv_bydl;
	Label dv___12;
	AdresaCtrl prech_bydl;
	Button ok;
	Button cancel;
};

template<class T> struct WithIPreviewLayout : public T, public IPreviewLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(756, 528); }
	Button ok;
	Button cancel;
	Picture preview;
	DropList page;
	Label dv___4;
};

template<class T> struct WithPhPrehledLayout : public T, public PhPrehledLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(300, 132); }
	Label dv___0;
	DropList ph_zdroj_seq;
	Label dv___2;
	EditDate vznik_od;
	Label dv___4;
	EditDate vznik_do;
	Label dv___6;
	EditDate splaceno_od;
	Label dv___8;
	EditDate splaceno_do;
	Option adresa;
	Option cj;
	Option nezaplacene;
	Option csv;
	Option prominute;
	Button ok;
	Button cancel;
};

#line 23 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/idisapp\\IdisMisc/imis.lay"
template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, OracleLoginLayout__layid&) { parent.LayoutId("OracleLoginLayout");
	layout.dv___0.SetLabel(t_GetLngString("&Uivatel:")).LeftPosZ(8, 56).TopPosZ(8, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.user.LeftPosZ(68, 148).TopPosZ(8, 19); layout.user.LayoutId("user"); parent.Add(layout.user);
	layout.dv___2.SetLabel(t_GetLngString("&Heslo:")).LeftPosZ(8, 56).TopPosZ(32, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.password.LeftPosZ(68, 148).TopPosZ(32, 19); layout.password.LayoutId("password"); parent.Add(layout.password);
	layout.dv___4.SetLabel(t_GetLngString("&Databze:")).LeftPosZ(8, 56).TopPosZ(56, 19); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.connection.LeftPosZ(68, 148).TopPosZ(56, 19); layout.connection.LayoutId("connection"); parent.Add(layout.connection);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(8, 64).TopPosZ(84, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.pwd.SetLabel(t_GetLngString("Heslo...")).LeftPosZ(80, 64).TopPosZ(84, 24); layout.pwd.LayoutId("pwd"); parent.Add(layout.pwd);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(152, 64).TopPosZ(84, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, RegistryLayout__layid&) { parent.LayoutId("RegistryLayout");
	layout.id.LeftPosZ(4, 216).TopPosZ(8, 488); layout.id.LayoutId("id"); parent.Add(layout.id);
	layout.dv___1.SetLabel(t_GetLngString("&Text")).LeftPosZ(230, 23).TopPosZ(7, 13); layout.dv___1.LayoutId("dv___1"); parent.Add(layout.dv___1);
	layout.value.LeftPosZ(230, 526).TopPosZ(23, 357); layout.value.LayoutId("value"); parent.Add(layout.value);
	layout.dv___3.SetLabel(t_GetLngString("&Adresa")).LeftPosZ(232, 35).TopPosZ(384, 13); layout.dv___3.LayoutId("dv___3"); parent.Add(layout.dv___3);
	layout.adresa.LeftPosZ(232, 196).TopPosZ(401, 65); layout.adresa.LayoutId("adresa"); parent.Add(layout.adresa);
	layout.dv___5.SetLabel(t_GetLngString("&slo")).LeftPosZ(234, 24).TopPosZ(475, 13); layout.dv___5.LayoutId("dv___5"); parent.Add(layout.dv___5);
	layout.cislo.LeftPosZ(264, 42).TopPosZ(472, 19); layout.cislo.LayoutId("cislo"); parent.Add(layout.cislo);
	layout.dv___7.SetLabel(t_GetLngString("&Datum")).LeftPosZ(314, 33).TopPosZ(475, 13); layout.dv___7.LayoutId("dv___7"); parent.Add(layout.dv___7);
	layout.datum.LeftPosZ(350, 76).TopPosZ(472, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.dv___9.SetLabel(t_GetLngString("&Osoba")).LeftPosZ(434, 33).TopPosZ(384, 13); layout.dv___9.LayoutId("dv___9"); parent.Add(layout.dv___9);
	layout.osoba.LeftPosZ(434, 184).TopPosZ(400, 92); layout.osoba.LayoutId("osoba"); parent.Add(layout.osoba);
	layout.exit.SetLabel(t_GetLngString("Zavt")).LeftPosZ(680, 76).TopPosZ(468, 24); layout.exit.LayoutId("exit"); parent.Add(layout.exit);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, UserOsobaLayout__layid&) { parent.LayoutId("UserOsobaLayout");
	layout.id.LeftPosZ(8, 148).TopPosZ(8, 348); layout.id.LayoutId("id"); parent.Add(layout.id);
	layout.dv___1.SetLabel(t_GetLngString("&Subjekt")).LeftPosZ(164, 38).TopPosZ(8, 13); layout.dv___1.LayoutId("dv___1"); parent.Add(layout.dv___1);
	layout.osoba.LeftPosZ(164, 188).TopPosZ(24, 80); layout.osoba.LayoutId("osoba"); parent.Add(layout.osoba);
	layout.dv___3.SetLabel(t_GetLngString("Telefon")).LeftPosZ(164, 48).TopPosZ(114, 15); layout.dv___3.LayoutId("dv___3"); parent.Add(layout.dv___3);
	layout.telefon.LeftPosZ(224, 128).TopPosZ(112, 19); layout.telefon.LayoutId("telefon"); parent.Add(layout.telefon);
	layout.dv___5.SetLabel(t_GetLngString("Email")).LeftPosZ(164, 48).TopPosZ(138, 15); layout.dv___5.LayoutId("dv___5"); parent.Add(layout.dv___5);
	layout.email.LeftPosZ(224, 128).TopPosZ(136, 19); layout.email.LayoutId("email"); parent.Add(layout.email);
	layout.dv___7.SetLabel(t_GetLngString("Fax")).LeftPosZ(164, 48).TopPosZ(162, 15); layout.dv___7.LayoutId("dv___7"); parent.Add(layout.dv___7);
	layout.fax.LeftPosZ(224, 128).TopPosZ(160, 19); layout.fax.LayoutId("fax"); parent.Add(layout.fax);
	layout.dv___9.SetLabel(t_GetLngString("Ident. .")).LeftPosZ(164, 48).TopPosZ(186, 15); layout.dv___9.LayoutId("dv___9"); parent.Add(layout.dv___9);
	layout.idc.LeftPosZ(224, 128).TopPosZ(184, 19); layout.idc.LayoutId("idc"); parent.Add(layout.idc);
	layout.dv___11.SetLabel(t_GetLngString("Znaka")).LeftPosZ(164, 48).TopPosZ(210, 15); layout.dv___11.LayoutId("dv___11"); parent.Add(layout.dv___11);
	layout.zn.LeftPosZ(224, 128).TopPosZ(208, 19); layout.zn.LayoutId("zn"); parent.Add(layout.zn);
	layout.dv___13.SetLabel(t_GetLngString("Pstup")).HSizePosZ(164, 140).TopPosZ(232, 19); layout.dv___13.LayoutId("dv___13"); parent.Add(layout.dv___13);
	layout.pristup.LeftPosZ(224, 128).TopPosZ(232, 19); layout.pristup.LayoutId("pristup"); parent.Add(layout.pristup);
	layout.dv___15.SetLabel(t_GetLngString("Odbor")).LeftPosZ(164, 40).TopPosZ(256, 19); layout.dv___15.LayoutId("dv___15"); parent.Add(layout.dv___15);
	layout.s_odbor_seq.LeftPosZ(224, 128).TopPosZ(256, 19); layout.s_odbor_seq.LayoutId("s_odbor_seq"); parent.Add(layout.s_odbor_seq);
	layout.dv___17.SetLabel(t_GetLngString("Funkce")).LeftPosZ(164, 56).TopPosZ(280, 19); layout.dv___17.LayoutId("dv___17"); parent.Add(layout.dv___17);
	layout.funkce.LeftPosZ(224, 128).TopPosZ(280, 19); layout.funkce.LayoutId("funkce"); parent.Add(layout.funkce);
	layout.dv___19.SetLabel(t_GetLngString("Podpis")).LeftPosZ(164, 56).TopPosZ(304, 19); layout.dv___19.LayoutId("dv___19"); parent.Add(layout.dv___19);
	layout.podpis.LeftPosZ(224, 128).TopPosZ(304, 19); layout.podpis.LayoutId("podpis"); parent.Add(layout.podpis);
	layout.exit.SetLabel(t_GetLngString("&Zavt")).LeftPosZ(284, 68).TopPosZ(332, 24); layout.exit.LayoutId("exit"); parent.Add(layout.exit);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, SimpleLayout__layid&) { parent.LayoutId("SimpleLayout");
	layout.tab.LeftPosZ(8, 384).TopPosZ(8, 196); layout.tab.LayoutId("tab"); parent.Add(layout.tab);
	layout.exit.SetLabel(t_GetLngString("Zavt")).LeftPosZ(316, 76).TopPosZ(212, 24); layout.exit.LayoutId("exit"); parent.Add(layout.exit);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, ExportLayout__layid&) { parent.LayoutId("ExportLayout");
	layout.dv___0.SetLabel(t_GetLngString("Vlastnk")).LeftPosZ(8, 44).TopPosZ(10, 15); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.owner.LeftPosZ(56, 96).TopPosZ(8, 19); layout.owner.LayoutId("owner"); parent.Add(layout.owner);
	layout.dv___2.SetLabel(t_GetLngString("Tabulka")).LeftPosZ(164, 36).TopPosZ(10, 15); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.table.LeftPosZ(208, 136).TopPosZ(8, 19); layout.table.LayoutId("table"); parent.Add(layout.table);
	layout.dv___4.SetLabel(t_GetLngString("Where")).LeftPosZ(8, 44).TopPosZ(34, 15); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.where.LeftPosZ(56, 288).TopPosZ(32, 19); layout.where.LayoutId("where"); parent.Add(layout.where);
	layout.dv___6.SetLabel(t_GetLngString("Adres")).LeftPosZ(8, 44).TopPosZ(58, 15); layout.dv___6.LayoutId("dv___6"); parent.Add(layout.dv___6);
	layout.dir.LeftPosZ(56, 288).TopPosZ(56, 19); layout.dir.LayoutId("dir"); parent.Add(layout.dir);
	layout.cpp.SetLabel(t_GetLngString("C++ - QSchema")).LeftPosZ(8, 96).TopPosZ(88, 15); layout.cpp.LayoutId("cpp"); parent.Add(layout.cpp);
	layout.nulls.SetLabel(t_GetLngString("Nulls")).LeftPosZ(112, 84).TopPosZ(87, 18); layout.nulls.LayoutId("nulls"); parent.Add(layout.nulls);
	layout.doexport.SetLabel(t_GetLngString("Export")).LeftPosZ(208, 64).TopPosZ(84, 24); layout.doexport.LayoutId("doexport"); parent.Add(layout.doexport);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(280, 64).TopPosZ(84, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, SqlLayout__layid&) { parent.LayoutId("SqlLayout");
	layout.tab.LeftPosZ(8, 384).TopPosZ(8, 196); layout.tab.LayoutId("tab"); parent.Add(layout.tab);
	layout.exit.SetLabel(t_GetLngString("Zavt")).LeftPosZ(316, 76).TopPosZ(212, 24); layout.exit.LayoutId("exit"); parent.Add(layout.exit);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, ListOpLayout__layid&) { parent.LayoutId("ListOpLayout");
	layout.list.LeftPosZ(8, 336).TopPosZ(8, 180); layout.list.LayoutId("list"); parent.Add(layout.list);
	layout.create.SetLabel(t_GetLngString("Nov")).LeftPosZ(8, 64).TopPosZ(200, 24); layout.create.LayoutId("create"); parent.Add(layout.create);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(212, 64).TopPosZ(200, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(280, 64).TopPosZ(200, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
	layout.remove.SetLabel(t_GetLngString("Vymazat")).LeftPosZ(76, 64).TopPosZ(200, 24); layout.remove.LayoutId("remove"); parent.Add(layout.remove);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, RCLayout__layid&) { parent.LayoutId("RCLayout");
	layout.lbl.SetLabel(t_GetLngString("R")).LeftPosZ(6, 24).TopPosZ(8, 15); layout.lbl.LayoutId("lbl"); parent.Add(layout.lbl);
	layout.rc.LeftPosZ(34, 84).TopPosZ(6, 19); layout.rc.LayoutId("rc"); parent.Add(layout.rc);
	layout.ok.SetLabel(t_GetLngString("Vyhledat")).LeftPosZ(42, 76).TopPosZ(30, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, NFindAdresaLayout__layid&) { parent.LayoutId("NFindAdresaLayout");
	layout.dv___0.SetLabel(t_GetLngString("Adresa")).LeftPosZ(6, 52).TopPosZ(7, 13); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.adr.LeftPosZ(62, 210).TopPosZ(4, 19); layout.adr.LayoutId("adr"); parent.Add(layout.adr);
	layout.empty.SetLabel(t_GetLngString("Przdn")).LeftPosZ(6, 64).TopPosZ(32, 24); layout.empty.LayoutId("empty"); parent.Add(layout.empty);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(138, 64).TopPosZ(32, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
	layout.ok.SetLabel(t_GetLngString("Vyhledat")).LeftPosZ(208, 64).TopPosZ(32, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, NAdresaLayout__layid&) { parent.LayoutId("NAdresaLayout");
	layout.list.LeftPosZ(6, 562).TopPosZ(6, 238); layout.list.LayoutId("list"); parent.Add(layout.list);
	layout.find.SetLabel(t_GetLngString("Vyhledat")).LeftPosZ(74, 64).TopPosZ(250, 24); layout.find.LayoutId("find"); parent.Add(layout.find);
	layout.empty.SetLabel(t_GetLngString("Przdn")).LeftPosZ(6, 64).TopPosZ(250, 24); layout.empty.LayoutId("empty"); parent.Add(layout.empty);
	layout.tree.SetLabel(t_GetLngString("Strom")).LeftPosZ(142, 64).TopPosZ(250, 24); layout.tree.LayoutId("tree"); parent.Add(layout.tree);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(504, 64).TopPosZ(250, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(434, 64).TopPosZ(250, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, NFindOsobaLayout__layid&) { parent.LayoutId("NFindOsobaLayout");
	layout.dv___0.SetLabel(t_GetLngString("Osoba")).LeftPosZ(8, 52).TopPosZ(4, 20); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.osoba.LeftPosZ(92, 228).TopPosZ(4, 19); layout.osoba.LayoutId("osoba"); parent.Add(layout.osoba);
	layout.adresa_txt.SetLabel(t_GetLngString("Bydlit")).LeftPosZ(8, 52).TopPosZ(32, 19); layout.adresa_txt.LayoutId("adresa_txt"); parent.Add(layout.adresa_txt);
	layout.adresa.LeftPosZ(92, 228).TopPosZ(32, 20); layout.adresa.LayoutId("adresa"); parent.Add(layout.adresa);
	layout.dtm_txt.SetLabel(t_GetLngString("Datum narozen")).LeftPosZ(8, 80).TopPosZ(60, 19); layout.dtm_txt.LayoutId("dtm_txt"); parent.Add(layout.dtm_txt);
	layout.dtm_od.LeftPosZ(92, 80).TopPosZ(60, 19); layout.dtm_od.LayoutId("dtm_od"); parent.Add(layout.dtm_od);
	layout.dtm_txt2.SetLabel(t_GetLngString("a")).LeftPosZ(196, 16).TopPosZ(60, 19); layout.dtm_txt2.LayoutId("dtm_txt2"); parent.Add(layout.dtm_txt2);
	layout.dtm_do.LeftPosZ(240, 80).TopPosZ(60, 19); layout.dtm_do.LayoutId("dtm_do"); parent.Add(layout.dtm_do);
	layout.reason_txt.SetLabel(t_GetLngString("Dvod hledn")).LeftPosZ(8, 80).TopPosZ(88, 19); layout.reason_txt.LayoutId("reason_txt"); parent.Add(layout.reason_txt);
	layout.reason.LeftPosZ(92, 228).TopPosZ(88, 19); layout.reason.LayoutId("reason"); parent.Add(layout.reason);
	layout.lru.LeftPosZ(8, 312).TopPosZ(116, 236); layout.lru.LayoutId("lru"); parent.Add(layout.lru);
	layout.empty.SetLabel(t_GetLngString("Przdn")).LeftPosZ(8, 64).BottomPosZ(8, 24); layout.empty.LayoutId("empty"); parent.Add(layout.empty);
	layout.cancel.SetLabel(t_GetLngString("Storno")).RightPosZ(80, 64).BottomPosZ(8, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
	layout.ok.SetLabel(t_GetLngString("Vyhledat")).RightPosZ(8, 64).BottomPosZ(8, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, NOsobaLayout__layid&) { parent.LayoutId("NOsobaLayout");
	layout.list.LeftPosZ(6, 634).TopPosZ(6, 238); layout.list.LayoutId("list"); parent.Add(layout.list);
	layout.find.SetLabel(t_GetLngString("Vyhledat")).LeftPosZ(76, 64).TopPosZ(252, 24); layout.find.LayoutId("find"); parent.Add(layout.find);
	layout.empty.SetLabel(t_GetLngString("Przdn")).LeftPosZ(8, 64).TopPosZ(252, 24); layout.empty.LayoutId("empty"); parent.Add(layout.empty);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(574, 64).TopPosZ(252, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(504, 64).TopPosZ(252, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
	layout.insert_fyzicka.SetLabel(t_GetLngString("Vloit fyzickou")).LeftPosZ(220, 92).TopPosZ(252, 24); layout.insert_fyzicka.LayoutId("insert_fyzicka"); parent.Add(layout.insert_fyzicka);
	layout.insert_pravnicka.SetLabel(t_GetLngString("Vloit prvnickou")).LeftPosZ(318, 92).TopPosZ(252, 24); layout.insert_pravnicka.LayoutId("insert_pravnicka"); parent.Add(layout.insert_pravnicka);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, SearchLayout__layid&) { parent.LayoutId("SearchLayout");
	layout.jmeno.LeftPosZ(4, 136).TopPosZ(4, 19); layout.jmeno.LayoutId("jmeno"); parent.Add(layout.jmeno);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(76, 64).TopPosZ(32, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(6, 64).TopPosZ(32, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, NewPwdLayout__layid&) { parent.LayoutId("NewPwdLayout");
	layout.dv___0.SetLabel(t_GetLngString("Nov heslo:")).LeftPosZ(8, 64).TopPosZ(8, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.password.NotNull(true).LeftPosZ(76, 148).TopPosZ(8, 19); layout.password.LayoutId("password"); parent.Add(layout.password);
	layout.dv___2.SetLabel(t_GetLngString("Pro kontrolu:")).LeftPosZ(8, 64).TopPosZ(32, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.password1.NotNull(true).LeftPosZ(76, 148).TopPosZ(32, 19); layout.password1.LayoutId("password1"); parent.Add(layout.password1);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(92, 64).TopPosZ(60, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(160, 64).TopPosZ(60, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, RightsLayout__layid&) { parent.LayoutId("RightsLayout");
	layout.dv___0.SetLabel(t_GetLngString("Role")).LeftPosZ(8, 464).TopPosZ(4, 272); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.role.LeftPosZ(16, 160).TopPosZ(20, 248); layout.role.LayoutId("role"); parent.Add(layout.role);
	layout.dv___2.SetLabel(t_GetLngString("Zobrazit")).LeftPosZ(184, 280).TopPosZ(16, 184); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.datum.SetLabel(t_GetLngString("Datum narozen (mrt)")).LeftPosZ(192, 132).TopPosZ(32, 15); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.mistonar.SetLabel(t_GetLngString("Msto narozen")).LeftPosZ(192, 132).TopPosZ(48, 15); layout.mistonar.LayoutId("mistonar"); parent.Add(layout.mistonar);
	layout.rc.SetLabel(t_GetLngString("Rodn slo")).LeftPosZ(192, 132).TopPosZ(64, 15); layout.rc.LayoutId("rc"); parent.Add(layout.rc);
	layout.pobyt.SetLabel(t_GetLngString("Trval pobyt")).LeftPosZ(192, 132).TopPosZ(80, 15); layout.pobyt.LayoutId("pobyt"); parent.Add(layout.pobyt);
	layout.stav.SetLabel(t_GetLngString("Rodinn stav")).LeftPosZ(192, 132).TopPosZ(96, 15); layout.stav.LayoutId("stav"); parent.Add(layout.stav);
	layout.partner.SetLabel(t_GetLngString("Partner")).LeftPosZ(192, 132).TopPosZ(112, 15); layout.partner.LayoutId("partner"); parent.Add(layout.partner);
	layout.deti.SetLabel(t_GetLngString("Rodie/dti")).LeftPosZ(192, 132).TopPosZ(128, 15); layout.deti.LayoutId("deti"); parent.Add(layout.deti);
	layout.oo.SetLabel(t_GetLngString("Data okresn evidence")).LeftPosZ(192, 132).TopPosZ(144, 15); layout.oo.LayoutId("oo"); parent.Add(layout.oo);
	layout.apobyt.SetLabel(t_GetLngString("Pedchoz pobyt")).LeftPosZ(192, 132).TopPosZ(160, 15); layout.apobyt.LayoutId("apobyt"); parent.Add(layout.apobyt);
	layout.aprijm.SetLabel(t_GetLngString("Pedchoz pjmen")).LeftPosZ(192, 132).TopPosZ(176, 15); layout.aprijm.LayoutId("aprijm"); parent.Add(layout.aprijm);
	layout.ph.SetLabel(t_GetLngString("Pohledvky")).LeftPosZ(340, 116).TopPosZ(32, 15); layout.ph.LayoutId("ph"); parent.Add(layout.ph);
	layout.ph_detail.SetLabel(t_GetLngString("Pohledvky druh")).LeftPosZ(340, 116).TopPosZ(48, 15); layout.ph_detail.LayoutId("ph_detail"); parent.Add(layout.ph_detail);
	layout.ucto.SetLabel(t_GetLngString("Nedoplatky")).LeftPosZ(340, 116).TopPosZ(72, 15); layout.ucto.LayoutId("ucto"); parent.Add(layout.ucto);
	layout.ucto_detail.SetLabel(t_GetLngString("Nedoplatky druh")).LeftPosZ(340, 116).TopPosZ(88, 15); layout.ucto_detail.LayoutId("ucto_detail"); parent.Add(layout.ucto_detail);
	layout.dv___17.SetLabel(t_GetLngString("Vyhledvat")).LeftPosZ(184, 280).TopPosZ(208, 60); layout.dv___17.LayoutId("dv___17"); parent.Add(layout.dv___17);
	layout.dv___18.SetLabel(t_GetLngString("Maximln poet")).LeftPosZ(192, 92).TopPosZ(228, 19); layout.dv___18.LayoutId("dv___18"); parent.Add(layout.dv___18);
	layout.pocet.LeftPosZ(284, 40).TopPosZ(228, 19); layout.pocet.LayoutId("pocet"); parent.Add(layout.pocet);
	layout.sdatum.SetLabel(t_GetLngString("Podle data narozen")).LeftPosZ(340, 132).TopPosZ(228, 15); layout.sdatum.LayoutId("sdatum"); parent.Add(layout.sdatum);
	layout.spobyt.SetLabel(t_GetLngString("Podle bydlit")).LeftPosZ(340, 132).TopPosZ(244, 15); layout.spobyt.LayoutId("spobyt"); parent.Add(layout.spobyt);
	layout.dv___22.SetLabel(t_GetLngString("Uivatel")).LeftPosZ(8, 464).TopPosZ(284, 236); layout.dv___22.LayoutId("dv___22"); parent.Add(layout.dv___22);
	layout.user.LeftPosZ(16, 448).TopPosZ(300, 212); layout.user.LayoutId("user"); parent.Add(layout.user);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, FyzickaOsobaLayout__layid&) { parent.LayoutId("FyzickaOsobaLayout");
	layout.dv___0.SetLabel(t_GetLngString("&Pjmen:")).LeftPosZ(4, 44).TopPosZ(4, 13); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.prijm.LeftPosZ(4, 194).TopPosZ(18, 19); layout.prijm.LayoutId("prijm"); parent.Add(layout.prijm);
	layout.dv___2.SetLabel(t_GetLngString("&Jmno:")).LeftPosZ(204, 36).TopPosZ(4, 13); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.jmeno.LeftPosZ(202, 194).TopPosZ(18, 19); layout.jmeno.LayoutId("jmeno"); parent.Add(layout.jmeno);
	layout.dv___4.SetLabel(t_GetLngString("&Rodn slo:")).LeftPosZ(4, 62).TopPosZ(42, 13); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.rc_ico.LeftPosZ(4, 84).TopPosZ(56, 19); layout.rc_ico.LayoutId("rc_ico"); parent.Add(layout.rc_ico);
	layout.typ_lbl.SetLabel(t_GetLngString("Pohlav:")).LeftPosZ(92, 41).TopPosZ(42, 13); layout.typ_lbl.LayoutId("typ_lbl"); parent.Add(layout.typ_lbl);
	layout.typ.LeftPosZ(92, 66).TopPosZ(56, 19); layout.typ.LayoutId("typ"); parent.Add(layout.typ);
	layout.rod_prijm_lbl.SetLabel(t_GetLngString("Rodn pjmen:")).LeftPosZ(162, 76).TopPosZ(42, 13); layout.rod_prijm_lbl.LayoutId("rod_prijm_lbl"); parent.Add(layout.rod_prijm_lbl);
	layout.rod_prijm.LeftPosZ(162, 94).TopPosZ(56, 19); layout.rod_prijm.LayoutId("rod_prijm"); parent.Add(layout.rod_prijm);
	layout.dv___10.SetLabel(t_GetLngString("Narozen(a):")).LeftPosZ(260, 57).TopPosZ(42, 13); layout.dv___10.LayoutId("dv___10"); parent.Add(layout.dv___10);
	layout.dat_nar.LeftPosZ(260, 66).TopPosZ(56, 19); layout.dat_nar.LayoutId("dat_nar"); parent.Add(layout.dat_nar);
	layout.dat_umrti_lbl.SetLabel(t_GetLngString("Zemel(a):")).LeftPosZ(330, 50).TopPosZ(42, 13); layout.dat_umrti_lbl.LayoutId("dat_umrti_lbl"); parent.Add(layout.dat_umrti_lbl);
	layout.dat_umrti.LeftPosZ(330, 66).TopPosZ(56, 19); layout.dat_umrti.LayoutId("dat_umrti"); parent.Add(layout.dat_umrti);
	layout.misto_nar_lbl.SetLabel(t_GetLngString("&Msto narozen:")).LeftPosZ(4, 75).TopPosZ(80, 13); layout.misto_nar_lbl.LayoutId("misto_nar_lbl"); parent.Add(layout.misto_nar_lbl);
	layout.misto_nar.LeftPosZ(4, 192).TopPosZ(94, 19); layout.misto_nar.LayoutId("misto_nar"); parent.Add(layout.misto_nar);
	layout.stat_obc_lbl.SetLabel(t_GetLngString("Sttn obanstv:")).LeftPosZ(200, 81).TopPosZ(80, 13); layout.stat_obc_lbl.LayoutId("stat_obc_lbl"); parent.Add(layout.stat_obc_lbl);
	layout.stat_obc.LeftPosZ(200, 196).TopPosZ(94, 19); layout.stat_obc.LayoutId("stat_obc"); parent.Add(layout.stat_obc);
	layout.trv_bydl_lbl.SetLabel(t_GetLngString("&Trval bydlit:")).LeftPosZ(4, 72).TopPosZ(118, 13); layout.trv_bydl_lbl.LayoutId("trv_bydl_lbl"); parent.Add(layout.trv_bydl_lbl);
	layout.trv_bydl.LeftPosZ(4, 194).TopPosZ(132, 72); layout.trv_bydl.LayoutId("trv_bydl"); parent.Add(layout.trv_bydl);
	layout.prech_bydl_lbl.SetLabel(t_GetLngString("Kontaktn adresa:")).LeftPosZ(201, 96).TopPosZ(118, 13); layout.prech_bydl_lbl.LayoutId("prech_bydl_lbl"); parent.Add(layout.prech_bydl_lbl);
	layout.prech_bydl.LeftPosZ(202, 194).TopPosZ(132, 72); layout.prech_bydl.LayoutId("prech_bydl"); parent.Add(layout.prech_bydl);
	layout.t_ulice_lbl.SetLabel(t_GetLngString("Ulice")).LeftPosZ(8, 76).TopPosZ(92, 19); layout.t_ulice_lbl.LayoutId("t_ulice_lbl"); parent.Add(layout.t_ulice_lbl);
	layout.t_ulice.LeftPosZ(92, 304).TopPosZ(92, 19); layout.t_ulice.LayoutId("t_ulice"); parent.Add(layout.t_ulice);
	layout.t_mesto_lbl.SetLabel(t_GetLngString("Msto")).LeftPosZ(8, 76).TopPosZ(116, 19); layout.t_mesto_lbl.LayoutId("t_mesto_lbl"); parent.Add(layout.t_mesto_lbl);
	layout.t_mesto.LeftPosZ(92, 304).TopPosZ(116, 19); layout.t_mesto.LayoutId("t_mesto"); parent.Add(layout.t_mesto);
	layout.t_psc_lbl.SetLabel(t_GetLngString("PS")).LeftPosZ(8, 76).TopPosZ(140, 19); layout.t_psc_lbl.LayoutId("t_psc_lbl"); parent.Add(layout.t_psc_lbl);
	layout.t_psc.LeftPosZ(92, 84).TopPosZ(140, 19); layout.t_psc.LayoutId("t_psc"); parent.Add(layout.t_psc);
	layout.local.SetLabel(t_GetLngString("Lokln zznam")).LeftPosZ(8, 124).TopPosZ(220, 20); layout.local.LayoutId("local"); parent.Add(layout.local);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(260, 64).TopPosZ(216, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(332, 64).TopPosZ(216, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, PravnickaOsobaLayout__layid&) { parent.LayoutId("PravnickaOsobaLayout");
	layout.dv___0.SetLabel(t_GetLngString("Prvnick osoba:")).LeftPosZ(4, 84).TopPosZ(4, 15); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.prijm.LeftPosZ(4, 150).TopPosZ(18, 19); layout.prijm.LayoutId("prijm"); parent.Add(layout.prijm);
	layout.dv___2.SetLabel(t_GetLngString("IO:")).LeftPosZ(158, 72).TopPosZ(4, 15); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.rc_ico.LeftPosZ(158, 142).TopPosZ(18, 19); layout.rc_ico.LayoutId("rc_ico"); parent.Add(layout.rc_ico);
	layout.dv___4.SetLabel(t_GetLngString("Zaloena:")).LeftPosZ(158, 54).TopPosZ(42, 15); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.dat_nar.LeftPosZ(158, 70).TopPosZ(56, 19); layout.dat_nar.LayoutId("dat_nar"); parent.Add(layout.dat_nar);
	layout.dv___6.SetLabel(t_GetLngString("Zruena:")).LeftPosZ(234, 44).TopPosZ(42, 15); layout.dv___6.LayoutId("dv___6"); parent.Add(layout.dv___6);
	layout.dat_umrti.LeftPosZ(232, 70).TopPosZ(56, 19); layout.dat_umrti.LayoutId("dat_umrti"); parent.Add(layout.dat_umrti);
	layout.dv___8.SetLabel(t_GetLngString("Rejstk")).LeftPosZ(4, 60).TopPosZ(76, 19); layout.dv___8.LayoutId("dv___8"); parent.Add(layout.dv___8);
	layout.rejstrik.LeftPosZ(4, 308).TopPosZ(96, 19); layout.rejstrik.LayoutId("rejstrik"); parent.Add(layout.rejstrik);
	layout.dv___10.SetLabel(t_GetLngString("Sdlo:")).LeftPosZ(4, 29).TopPosZ(124, 15); layout.dv___10.LayoutId("dv___10"); parent.Add(layout.dv___10);
	layout.trv_bydl.LeftPosZ(4, 150).TopPosZ(138, 68); layout.trv_bydl.LayoutId("trv_bydl"); parent.Add(layout.trv_bydl);
	layout.dv___12.SetLabel(t_GetLngString("Kontaktn adresa:")).LeftPosZ(160, 112).TopPosZ(124, 15); layout.dv___12.LayoutId("dv___12"); parent.Add(layout.dv___12);
	layout.prech_bydl.LeftPosZ(160, 150).TopPosZ(138, 68); layout.prech_bydl.LayoutId("prech_bydl"); parent.Add(layout.prech_bydl);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(176, 64).TopPosZ(216, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(244, 64).TopPosZ(216, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, IPreviewLayout__layid&) { parent.LayoutId("IPreviewLayout");
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(596, 72).TopPosZ(496, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(674, 72).TopPosZ(496, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
	layout.preview.LeftPosZ(8, 740).TopPosZ(8, 480); layout.preview.LayoutId("preview"); parent.Add(layout.preview);
	layout.page.LeftPosZ(50, 60).TopPosZ(500, 19); layout.page.LayoutId("page"); parent.Add(layout.page);
	layout.dv___4.SetLabel(t_GetLngString("Strana")).LeftPosZ(10, 40).TopPosZ(500, 19); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, PhPrehledLayout__layid&) { parent.LayoutId("PhPrehledLayout");
	layout.dv___0.SetLabel(t_GetLngString("Druh")).LeftPosZ(8, 56).TopPosZ(4, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.ph_zdroj_seq.LeftPosZ(96, 196).TopPosZ(4, 19); layout.ph_zdroj_seq.LayoutId("ph_zdroj_seq"); parent.Add(layout.ph_zdroj_seq);
	layout.dv___2.SetLabel(t_GetLngString("Datum vzniku od")).LeftPosZ(8, 88).TopPosZ(28, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.vznik_od.LeftPosZ(96, 84).TopPosZ(28, 19); layout.vznik_od.LayoutId("vznik_od"); parent.Add(layout.vznik_od);
	layout.dv___4.SetLabel(t_GetLngString("do")).SetAlign(ALIGN_CENTER).LeftPosZ(180, 24).TopPosZ(28, 19); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.vznik_do.LeftPosZ(208, 84).TopPosZ(28, 19); layout.vznik_do.LayoutId("vznik_do"); parent.Add(layout.vznik_do);
	layout.dv___6.SetLabel(t_GetLngString("Splaceno od")).LeftPosZ(8, 88).TopPosZ(52, 19); layout.dv___6.LayoutId("dv___6"); parent.Add(layout.dv___6);
	layout.splaceno_od.LeftPosZ(96, 84).TopPosZ(52, 19); layout.splaceno_od.LayoutId("splaceno_od"); parent.Add(layout.splaceno_od);
	layout.dv___8.SetLabel(t_GetLngString("do")).SetAlign(ALIGN_CENTER).LeftPosZ(180, 24).TopPosZ(52, 19); layout.dv___8.LayoutId("dv___8"); parent.Add(layout.dv___8);
	layout.splaceno_do.LeftPosZ(208, 84).TopPosZ(52, 19); layout.splaceno_do.LayoutId("splaceno_do"); parent.Add(layout.splaceno_do);
	layout.adresa.SetLabel(t_GetLngString("Adresa")).LeftPosZ(8, 56).TopPosZ(76, 16); layout.adresa.LayoutId("adresa"); parent.Add(layout.adresa);
	layout.cj.SetLabel(t_GetLngString("J")).LeftPosZ(72, 40).TopPosZ(76, 16); layout.cj.LayoutId("cj"); parent.Add(layout.cj);
	layout.nezaplacene.SetLabel(t_GetLngString("Jen nezaplacen")).LeftPosZ(120, 104).TopPosZ(76, 16); layout.nezaplacene.LayoutId("nezaplacene"); parent.Add(layout.nezaplacene);
	layout.csv.SetLabel(t_GetLngString("do .csv")).LeftPosZ(236, 60).TopPosZ(76, 16); layout.csv.LayoutId("csv"); parent.Add(layout.csv);
	layout.prominute.SetLabel(t_GetLngString("Jen prominut")).LeftPosZ(8, 116).TopPosZ(100, 16); layout.prominute.LayoutId("prominute"); parent.Add(layout.prominute);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(160, 64).TopPosZ(100, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(230, 64).TopPosZ(100, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

#line 37 "u:/uppsrc\\CtrlCore/lay.h"







#line 100 "u:/idisapp\\IdisMisc/IdisMisc.h"

inline String CsToUpper(const String& s)      { return ToUpper(s); }
inline String CsToLower(const String& s)      { return ToLower(s); }
inline String CsToUpperAscii(const String& s) { return ToUpper(ToAscii(s)); }

inline bool UserCanWrite(SqlId id)      { return SqlUserCanWrite(id); }

#line 108 "u:/idisapp\\IdisMisc/IdisMisc.h"



#line 1 "u:/uppsrc\\Sql/sch_header.h"

































#line 1 "u:/uppsrc\\Oracle/OracleSchema.h"


























































#line 60 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 65 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 70 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 75 "u:/uppsrc\\Oracle/OracleSchema.h"















#line 1 "u:/uppsrc\\Sql/sch_model.h"








#line 10 "u:/uppsrc\\Sql/sch_model.h"
















#line 27 "u:/uppsrc\\Sql/sch_model.h"
















#line 44 "u:/uppsrc\\Sql/sch_model.h"







#line 52 "u:/uppsrc\\Sql/sch_model.h"











#line 64 "u:/uppsrc\\Sql/sch_model.h"







#line 72 "u:/uppsrc\\Sql/sch_model.h"







#line 80 "u:/uppsrc\\Sql/sch_model.h"



#line 84 "u:/uppsrc\\Sql/sch_model.h"



#line 88 "u:/uppsrc\\Sql/sch_model.h"



#line 92 "u:/uppsrc\\Sql/sch_model.h"



#line 96 "u:/uppsrc\\Sql/sch_model.h"



#line 100 "u:/uppsrc\\Sql/sch_model.h"



#line 104 "u:/uppsrc\\Sql/sch_model.h"



#line 108 "u:/uppsrc\\Sql/sch_model.h"



#line 112 "u:/uppsrc\\Sql/sch_model.h"



#line 116 "u:/uppsrc\\Sql/sch_model.h"







#line 124 "u:/uppsrc\\Sql/sch_model.h"




















#line 145 "u:/uppsrc\\Sql/sch_model.h"



#line 149 "u:/uppsrc\\Sql/sch_model.h"



#line 153 "u:/uppsrc\\Sql/sch_model.h"



#line 157 "u:/uppsrc\\Sql/sch_model.h"



#line 161 "u:/uppsrc\\Sql/sch_model.h"

#line 1 "u:\\idisapp\\idismisc\\ImisModel.i"
 struct S_REGISTRY  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_REGISTRY::FieldLayout); } S_REGISTRY();
	 enum { KEY_WIDTH = 200, KEY_PRECISION = 0 }; String KEY;
	 enum { VALUE_WIDTH = 4000, VALUE_PRECISION = 0 }; String VALUE;
	enum { OSOBA_SEQ_WIDTH = 0, OSOBA_SEQ_PRECISION = 0 }; int OSOBA_SEQ;
	enum { ADRESA_SEQ_WIDTH = 0, ADRESA_SEQ_PRECISION = 0 }; int ADRESA_SEQ;
	 enum { CISLO_WIDTH = 0, CISLO_PRECISION = 0 }; double CISLO;
	 enum { DATUM_WIDTH = 0, DATUM_PRECISION = 0 }; Date DATUM;
};



 struct S_S_ODBOR  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_S_ODBOR::FieldLayout); } S_S_ODBOR();
	enum { S_ODBOR_SEQ_WIDTH = 0, S_ODBOR_SEQ_PRECISION = 0 }; int S_ODBOR_SEQ;
	enum { KOD_WIDTH = 200, KOD_PRECISION = 0 }; String KOD;
	enum { TEXT_WIDTH = 200, TEXT_PRECISION = 0 }; String TEXT;
};

 struct S_USEROSOBA  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_USEROSOBA::FieldLayout); } S_USEROSOBA();
	enum { USERID_WIDTH = 20, USERID_PRECISION = 0 }; String USERID;
	enum { OSOBA_SEQ_WIDTH = 0, OSOBA_SEQ_PRECISION = 0 }; int OSOBA_SEQ;
	 enum { TELEFON_WIDTH = 200, TELEFON_PRECISION = 0 }; String TELEFON;
	 enum { EMAIL_WIDTH = 200, EMAIL_PRECISION = 0 }; String EMAIL;
	 enum { FAX_WIDTH = 200, FAX_PRECISION = 0 }; String FAX;
	 enum { IDC_WIDTH = 200, IDC_PRECISION = 0 }; String IDC;
	 enum { ZN_WIDTH = 200, ZN_PRECISION = 0 }; String ZN;
	 enum { PRISTUP_WIDTH = 200, PRISTUP_PRECISION = 0 }; String PRISTUP;
	 enum { FUNKCE_WIDTH = 200, FUNKCE_PRECISION = 0 }; String FUNKCE;
	 enum { PODPIS_WIDTH = 200, PODPIS_PRECISION = 0 }; String PODPIS;
	 enum { S_ODBOR_SEQ_WIDTH = 0, S_ODBOR_SEQ_PRECISION = 0 }; int S_ODBOR_SEQ;
};

 struct S_ESC_LIB  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_ESC_LIB::FieldLayout); } S_ESC_LIB();
	 enum { ESC_LIB_ID_WIDTH = 200, ESC_LIB_ID_PRECISION = 0 }; String ESC_LIB_ID;
	enum { TEXT_WIDTH = 0, TEXT_PRECISION = 0 }; String TEXT;
};



 struct S_OI_ROLE  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OI_ROLE::FieldLayout); } S_OI_ROLE();
	 enum { OI_ROLE_SEQ_WIDTH = 0, OI_ROLE_SEQ_PRECISION = 0 }; int OI_ROLE_SEQ;
	enum { TEXT_WIDTH = 200, TEXT_PRECISION = 0 }; String TEXT;
	enum { DATUM_WIDTH = 0, DATUM_PRECISION = 0 }; bool DATUM;
	 enum { MISTONAR_WIDTH = 0, MISTONAR_PRECISION = 0 }; bool MISTONAR;
	 enum { RC_WIDTH = 0, RC_PRECISION = 0 }; bool RC;
	 enum { POBYT_WIDTH = 0, POBYT_PRECISION = 0 }; bool POBYT;
	 enum { STAV_WIDTH = 0, STAV_PRECISION = 0 }; bool STAV;
	 enum { PARTNER_WIDTH = 0, PARTNER_PRECISION = 0 }; bool PARTNER;
	 enum { DETI_WIDTH = 0, DETI_PRECISION = 0 }; bool DETI;
	 enum { OO_WIDTH = 0, OO_PRECISION = 0 }; bool OO;
	 enum { POCET_WIDTH = 0, POCET_PRECISION = 0 }; int POCET;
	 enum { SDATUM_WIDTH = 0, SDATUM_PRECISION = 0 }; bool SDATUM;
	 enum { SPOBYT_WIDTH = 0, SPOBYT_PRECISION = 0 }; bool SPOBYT;
	 enum { APOBYT_WIDTH = 0, APOBYT_PRECISION = 0 }; bool APOBYT;
	 enum { APRIJM_WIDTH = 0, APRIJM_PRECISION = 0 }; bool APRIJM;
	 enum { PH_WIDTH = 0, PH_PRECISION = 0 }; bool PH;
	 enum { PH_DETAIL_WIDTH = 0, PH_DETAIL_PRECISION = 0 }; bool PH_DETAIL;
	 enum { UCTO_WIDTH = 0, UCTO_PRECISION = 0 }; bool UCTO;
	 enum { UCTO_DETAIL_WIDTH = 0, UCTO_DETAIL_PRECISION = 0 }; bool UCTO_DETAIL;
};

 struct S_OI_RIGHTS  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OI_RIGHTS::FieldLayout); } S_OI_RIGHTS();
	 enum { OI_RIGHTS_SEQ_WIDTH = 0, OI_RIGHTS_SEQ_PRECISION = 0 }; int OI_RIGHTS_SEQ;
	enum { USERID_WIDTH = 200, USERID_PRECISION = 0 }; String USERID;
	enum { OI_ROLE_SEQ_WIDTH = 0, OI_ROLE_SEQ_PRECISION = 0 }; int OI_ROLE_SEQ;
	 enum { REASON_WIDTH = 200, REASON_PRECISION = 0 }; String REASON;
	 enum { POBOCKA_WIDTH = 200, POBOCKA_PRECISION = 0 }; String POBOCKA;
};

 struct S_OSOBA_ACCESS  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OSOBA_ACCESS::FieldLayout); } S_OSOBA_ACCESS();
	enum { DATUM_WIDTH = 0, DATUM_PRECISION = 0 }; Date DATUM;
	enum { USERID_WIDTH = 20, USERID_PRECISION = 0 }; String USERID;
	enum { OSOBA_SEQ_WIDTH = 0, OSOBA_SEQ_PRECISION = 0 }; int OSOBA_SEQ;
	enum { PCO_WIDTH = 0, PCO_PRECISION = 0 }; int PCO;
	enum { REASON_WIDTH = 200, REASON_PRECISION = 0 }; String REASON;
};

 struct S_VOLANI  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_VOLANI::FieldLayout); } S_VOLANI();
	 enum { VOLANI_SEQ_WIDTH = 0, VOLANI_SEQ_PRECISION = 0 }; int VOLANI_SEQ;
	 enum { CAS_WIDTH = 0, CAS_PRECISION = 0 }; Time CAS;
	enum { POBOCKA_WIDTH = 0, POBOCKA_PRECISION = 0 }; int POBOCKA;
	enum { CISLO_WIDTH = 200, CISLO_PRECISION = 0 }; String CISLO;
	 enum { DESTINACE_WIDTH = 200, DESTINACE_PRECISION = 0 }; String DESTINACE;
	 enum { DELKA_WIDTH = 200, DELKA_PRECISION = 0 }; String DELKA;
	 enum { CENA_WIDTH = 0, CENA_PRECISION = 0 }; double CENA;
	 enum { SOUKROMY_WIDTH = 0, SOUKROMY_PRECISION = 0 }; bool SOUKROMY;
};
#line 163 "u:/uppsrc\\Sql/sch_model.h"




































#line 91 "u:/uppsrc\\Oracle/OracleSchema.h"





















































#line 35 "u:/uppsrc\\Sql/sch_header.h"










#line 1 "u:/uppsrc\\Oracle/OracleSchema.h"


























































#line 60 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 65 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 70 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 75 "u:/uppsrc\\Oracle/OracleSchema.h"















#line 1 "u:/uppsrc\\Sql/sch_model.h"








#line 10 "u:/uppsrc\\Sql/sch_model.h"
















#line 27 "u:/uppsrc\\Sql/sch_model.h"




















#line 48 "u:/uppsrc\\Sql/sch_model.h"



#line 52 "u:/uppsrc\\Sql/sch_model.h"



#line 56 "u:/uppsrc\\Sql/sch_model.h"



#line 60 "u:/uppsrc\\Sql/sch_model.h"



#line 64 "u:/uppsrc\\Sql/sch_model.h"



#line 68 "u:/uppsrc\\Sql/sch_model.h"



#line 72 "u:/uppsrc\\Sql/sch_model.h"



#line 76 "u:/uppsrc\\Sql/sch_model.h"



#line 80 "u:/uppsrc\\Sql/sch_model.h"



#line 84 "u:/uppsrc\\Sql/sch_model.h"



#line 88 "u:/uppsrc\\Sql/sch_model.h"



#line 92 "u:/uppsrc\\Sql/sch_model.h"



#line 96 "u:/uppsrc\\Sql/sch_model.h"



#line 100 "u:/uppsrc\\Sql/sch_model.h"



#line 104 "u:/uppsrc\\Sql/sch_model.h"



#line 108 "u:/uppsrc\\Sql/sch_model.h"



#line 112 "u:/uppsrc\\Sql/sch_model.h"



#line 116 "u:/uppsrc\\Sql/sch_model.h"



#line 120 "u:/uppsrc\\Sql/sch_model.h"



#line 124 "u:/uppsrc\\Sql/sch_model.h"



#line 128 "u:/uppsrc\\Sql/sch_model.h"







#line 136 "u:/uppsrc\\Sql/sch_model.h"








#line 145 "u:/uppsrc\\Sql/sch_model.h"



#line 149 "u:/uppsrc\\Sql/sch_model.h"



#line 153 "u:/uppsrc\\Sql/sch_model.h"



#line 157 "u:/uppsrc\\Sql/sch_model.h"



#line 161 "u:/uppsrc\\Sql/sch_model.h"

#line 1 "u:\\idisapp\\idismisc\\ImisModel.i"
extern SqlId REGISTRY;
	extern SqlId KEY;
	extern SqlId VALUE;


	extern SqlId CISLO;
	extern SqlId DATUM;


extern SqlId SEQ_S;

extern SqlId S_ODBOR;





extern SqlId USEROSOBA;


	extern SqlId TELEFON;
	extern SqlId EMAIL;
	extern SqlId FAX;
	extern SqlId IDC;
	extern SqlId ZN;
	extern SqlId PRISTUP;
	extern SqlId FUNKCE;
	extern SqlId PODPIS;
	extern SqlId S_ODBOR_SEQ;


extern SqlId ESC_LIB;
	extern SqlId ESC_LIB_ID;



extern SqlId SEQ_OI;

extern SqlId OI_ROLE;
	extern SqlId OI_ROLE_SEQ;


	extern SqlId MISTONAR;
	extern SqlId RC;
	extern SqlId POBYT;
	extern SqlId STAV;
	extern SqlId PARTNER;
	extern SqlId DETI;
	extern SqlId OO;
	extern SqlId POCET;
	extern SqlId SDATUM;
	extern SqlId SPOBYT;
	extern SqlId APOBYT;
	extern SqlId APRIJM;
	extern SqlId PH;
	extern SqlId PH_DETAIL;
	extern SqlId UCTO;
	extern SqlId UCTO_DETAIL;


extern SqlId OI_RIGHTS;
	extern SqlId OI_RIGHTS_SEQ;


	extern SqlId REASON;
	extern SqlId POBOCKA;


extern SqlId OSOBA_ACCESS;







extern SqlId VOLANI;
	extern SqlId VOLANI_SEQ;
	extern SqlId CAS;


	extern SqlId DESTINACE;
	extern SqlId DELKA;
	extern SqlId CENA;
	extern SqlId SOUKROMY;

#line 163 "u:/uppsrc\\Sql/sch_model.h"




































#line 91 "u:/uppsrc\\Oracle/OracleSchema.h"





















































#line 46 "u:/uppsrc\\Sql/sch_header.h"
#line 112 "u:/idisapp\\IdisMisc/IdisMisc.h"





#line 1 "u:/uppsrc\\Sql/sch_header.h"

































#line 1 "u:/uppsrc\\Oracle/OracleSchema.h"


























































#line 60 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 65 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 70 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 75 "u:/uppsrc\\Oracle/OracleSchema.h"















#line 1 "u:/uppsrc\\Sql/sch_model.h"








#line 10 "u:/uppsrc\\Sql/sch_model.h"
















#line 27 "u:/uppsrc\\Sql/sch_model.h"
















#line 44 "u:/uppsrc\\Sql/sch_model.h"







#line 52 "u:/uppsrc\\Sql/sch_model.h"











#line 64 "u:/uppsrc\\Sql/sch_model.h"







#line 72 "u:/uppsrc\\Sql/sch_model.h"







#line 80 "u:/uppsrc\\Sql/sch_model.h"



#line 84 "u:/uppsrc\\Sql/sch_model.h"



#line 88 "u:/uppsrc\\Sql/sch_model.h"



#line 92 "u:/uppsrc\\Sql/sch_model.h"



#line 96 "u:/uppsrc\\Sql/sch_model.h"



#line 100 "u:/uppsrc\\Sql/sch_model.h"



#line 104 "u:/uppsrc\\Sql/sch_model.h"



#line 108 "u:/uppsrc\\Sql/sch_model.h"



#line 112 "u:/uppsrc\\Sql/sch_model.h"



#line 116 "u:/uppsrc\\Sql/sch_model.h"







#line 124 "u:/uppsrc\\Sql/sch_model.h"




















#line 145 "u:/uppsrc\\Sql/sch_model.h"



#line 149 "u:/uppsrc\\Sql/sch_model.h"



#line 153 "u:/uppsrc\\Sql/sch_model.h"



#line 157 "u:/uppsrc\\Sql/sch_model.h"



#line 161 "u:/uppsrc\\Sql/sch_model.h"

#line 1 "u:\\idisapp\\idismisc\\OOModel.i"
 struct S_OO_OSOBA  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OO_OSOBA::FieldLayout); } S_OO_OSOBA();
	 enum { PCO_WIDTH = 0, PCO_PRECISION = 0 }; int PCO;
	 enum { ROD_CIS_WIDTH = 200, ROD_CIS_PRECISION = 0 }; String ROD_CIS;
	 enum { JM_WIDTH = 200, JM_PRECISION = 0 }; String JM;
	 enum { RPR_WIDTH = 200, RPR_PRECISION = 0 }; String RPR;
	 enum { PR_WIDTH = 200, PR_PRECISION = 0 }; String PR;
	 enum { ROD_STAV_WIDTH = 200, ROD_STAV_PRECISION = 0 }; String ROD_STAV;
	 enum { STATP_WIDTH = 200, STATP_PRECISION = 0 }; String STATP;
	 enum { PCD_WIDTH = 0, PCD_PRECISION = 0 }; int PCD;
	 enum { T_POB_WIDTH = 1, T_POB_PRECISION = 0 }; String T_POB;
	 enum { MATR_SN_WIDTH = 200, MATR_SN_PRECISION = 0 }; String MATR_SN;
	 enum { M_NAR_UMR_WIDTH = 200, M_NAR_UMR_PRECISION = 0 }; String M_NAR_UMR;
	 enum { ROD_CIS_P_WIDTH = 200, ROD_CIS_P_PRECISION = 0 }; String ROD_CIS_P;
	 enum { JM_P_WIDTH = 200, JM_P_PRECISION = 0 }; String JM_P;
	 enum { RPR_P_WIDTH = 200, RPR_P_PRECISION = 0 }; String RPR_P;
	 enum { PR_P_WIDTH = 200, PR_P_PRECISION = 0 }; String PR_P;
	 enum { ROD_CIS_M_WIDTH = 200, ROD_CIS_M_PRECISION = 0 }; String ROD_CIS_M;
	 enum { JM_M_WIDTH = 200, JM_M_PRECISION = 0 }; String JM_M;
	 enum { RPR_M_WIDTH = 200, RPR_M_PRECISION = 0 }; String RPR_M;
	 enum { PR_M_WIDTH = 200, PR_M_PRECISION = 0 }; String PR_M;
	 enum { ROD_CIS_O_WIDTH = 200, ROD_CIS_O_PRECISION = 0 }; String ROD_CIS_O;
	 enum { JM_O_WIDTH = 200, JM_O_PRECISION = 0 }; String JM_O;
	 enum { RPR_O_WIDTH = 200, RPR_O_PRECISION = 0 }; String RPR_O;
	 enum { PR_O_WIDTH = 200, PR_O_PRECISION = 0 }; String PR_O;
	 enum { RC_DETI_WIDTH = 200, RC_DETI_PRECISION = 0 }; String RC_DETI;
	 enum { TP_OD_WIDTH = 200, TP_OD_PRECISION = 0 }; String TP_OD;
	 enum { OMEZ_ZPUS_WIDTH = 200, OMEZ_ZPUS_PRECISION = 0 }; String OMEZ_ZPUS;
	 enum { ZAK_POB_WIDTH = 200, ZAK_POB_PRECISION = 0 }; String ZAK_POB;
	 enum { TITUL_WIDTH = 200, TITUL_PRECISION = 0 }; String TITUL;
};

 struct S_OO_ADRESA  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OO_ADRESA::FieldLayout); } S_OO_ADRESA();
	enum { PCD_WIDTH = 0, PCD_PRECISION = 0 }; int PCD;
	 enum { KOD_BL_WIDTH = 0, KOD_BL_PRECISION = 0 }; int KOD_BL;
	 enum { DRUH_C_DOMU_WIDTH = 1, DRUH_C_DOMU_PRECISION = 0 }; String DRUH_C_DOMU;
	 enum { C_DOM_WIDTH = 0, C_DOM_PRECISION = 0 }; int C_DOM;
	 enum { KOD_UL_WIDTH = 0, KOD_UL_PRECISION = 0 }; int KOD_UL;
	 enum { C_OR_WIDTH = 0, C_OR_PRECISION = 0 }; int C_OR;
	 enum { ZNAK_C_OR_WIDTH = 1, ZNAK_C_OR_PRECISION = 0 }; String ZNAK_C_OR;
	enum { PSC_WIDTH = 0, PSC_PRECISION = 0 }; int PSC;
};

 struct S_OO_OKRES  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OO_OKRES::FieldLayout); } S_OO_OKRES();
	enum { KOD_WIDTH = 0, KOD_PRECISION = 0 }; int KOD;
	enum { TXT_WIDTH = 200, TXT_PRECISION = 0 }; String TXT;
};

 struct S_OO_LOKALITA  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OO_LOKALITA::FieldLayout); } S_OO_LOKALITA();
	enum { KOD_BL_WIDTH = 0, KOD_BL_PRECISION = 0 }; int KOD_BL;
	 enum { KOD_OB_WIDTH = 0, KOD_OB_PRECISION = 0 }; int KOD_OB;
	 enum { TXT_BL_WIDTH = 200, TXT_BL_PRECISION = 0 }; String TXT_BL;
	 enum { KOD_OKR_WIDTH = 0, KOD_OKR_PRECISION = 0 }; int KOD_OKR;
};

 struct S_OO_ULICE  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OO_ULICE::FieldLayout); } S_OO_ULICE();
	enum { KOD_WIDTH = 0, KOD_PRECISION = 0 }; int KOD;
	enum { KOD_BL_WIDTH = 0, KOD_BL_PRECISION = 0 }; int KOD_BL;
	 enum { KOD_TEXTU_WIDTH = 0, KOD_TEXTU_PRECISION = 0 }; int KOD_TEXTU;
};

 struct S_OO_ULICE_TXT  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OO_ULICE_TXT::FieldLayout); } S_OO_ULICE_TXT();
	enum { KOD_WIDTH = 0, KOD_PRECISION = 0 }; int KOD;
	 enum { TXT_WIDTH = 200, TXT_PRECISION = 0 }; String TXT;
};

 struct S_OA_ADRESA  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OA_ADRESA::FieldLayout); } S_OA_ADRESA();
	 enum { ADRESA_KOD_WIDTH = 0, ADRESA_KOD_PRECISION = 0 }; int ADRESA_KOD;
	enum { OBJEKT_KOD_WIDTH = 0, OBJEKT_KOD_PRECISION = 0 }; int OBJEKT_KOD;
	enum { ULICE_KOD_WIDTH = 0, ULICE_KOD_PRECISION = 0 }; int ULICE_KOD;
	 enum { CISOR_HOD_WIDTH = 0, CISOR_HOD_PRECISION = 0 }; int CISOR_HOD;
	 enum { CISOR_PIS_WIDTH = 10, CISOR_PIS_PRECISION = 0 }; String CISOR_PIS;
	enum { PSC_WIDTH = 0, PSC_PRECISION = 0 }; int PSC;
	enum { STAV_WIDTH = 0, STAV_PRECISION = 0 }; int STAV;
	enum { PCD_WIDTH = 0, PCD_PRECISION = 0 }; int PCD;
};

 struct S_OA_ADRESA_H  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OA_ADRESA_H::FieldLayout); } S_OA_ADRESA_H();
	enum { ADRESA_KOD_WIDTH = 0, ADRESA_KOD_PRECISION = 0 }; int ADRESA_KOD;
	 enum { PLATI_DO_WIDTH = 0, PLATI_DO_PRECISION = 0 }; Date PLATI_DO;
	enum { OBJEKT_KOD_WIDTH = 0, OBJEKT_KOD_PRECISION = 0 }; int OBJEKT_KOD;
	enum { ULICE_KOD_WIDTH = 0, ULICE_KOD_PRECISION = 0 }; int ULICE_KOD;
	enum { CISOR_HOD_WIDTH = 0, CISOR_HOD_PRECISION = 0 }; int CISOR_HOD;
	enum { CISOR_PIS_WIDTH = 10, CISOR_PIS_PRECISION = 0 }; String CISOR_PIS;
	enum { PSC_WIDTH = 0, PSC_PRECISION = 0 }; int PSC;
};

 struct S_OA_OBJEKT  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OA_OBJEKT::FieldLayout); } S_OA_OBJEKT();
	 enum { OBJEKT_KOD_WIDTH = 0, OBJEKT_KOD_PRECISION = 0 }; int OBJEKT_KOD;
	enum { COBCE_KOD_WIDTH = 0, COBCE_KOD_PRECISION = 0 }; int COBCE_KOD;
	enum { MCAST_KOD_WIDTH = 0, MCAST_KOD_PRECISION = 0 }; int MCAST_KOD;
	 enum { CISDOM_TYP_WIDTH = 0, CISDOM_TYP_PRECISION = 0 }; int CISDOM_TYP;
	 enum { CISDOM_HOD_WIDTH = 0, CISDOM_HOD_PRECISION = 0 }; int CISDOM_HOD;
	enum { STAV_WIDTH = 0, STAV_PRECISION = 0 }; int STAV;
};

 struct S_OA_OBJEKT_H  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OA_OBJEKT_H::FieldLayout); } S_OA_OBJEKT_H();
	enum { OBJEKT_KOD_WIDTH = 0, OBJEKT_KOD_PRECISION = 0 }; int OBJEKT_KOD;
	enum { PLATI_DO_WIDTH = 0, PLATI_DO_PRECISION = 0 }; Date PLATI_DO;
	enum { COBCE_KOD_WIDTH = 0, COBCE_KOD_PRECISION = 0 }; int COBCE_KOD;
	enum { MCAST_KOD_WIDTH = 0, MCAST_KOD_PRECISION = 0 }; int MCAST_KOD;
	enum { CISDOM_TYP_WIDTH = 0, CISDOM_TYP_PRECISION = 0 }; int CISDOM_TYP;
	enum { CISDOM_HOD_WIDTH = 0, CISDOM_HOD_PRECISION = 0 }; int CISDOM_HOD;
};

 struct S_OA_ULICE  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OA_ULICE::FieldLayout); } S_OA_ULICE();
	 enum { ULICE_KOD_WIDTH = 0, ULICE_KOD_PRECISION = 0 }; int ULICE_KOD;
	enum { OBEC_KOD_WIDTH = 0, OBEC_KOD_PRECISION = 0 }; int OBEC_KOD;
	enum { NAZEV_WIDTH = 200, NAZEV_PRECISION = 0 }; String NAZEV;
	enum { STAV_WIDTH = 0, STAV_PRECISION = 0 }; int STAV;
};

 struct S_OA_ULICE_H  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OA_ULICE_H::FieldLayout); } S_OA_ULICE_H();
	enum { ULICE_KOD_WIDTH = 0, ULICE_KOD_PRECISION = 0 }; int ULICE_KOD;
	enum { PLATI_DO_WIDTH = 0, PLATI_DO_PRECISION = 0 }; Date PLATI_DO;
	enum { OBEC_KOD_WIDTH = 0, OBEC_KOD_PRECISION = 0 }; int OBEC_KOD;
	enum { NAZEV_WIDTH = 200, NAZEV_PRECISION = 0 }; String NAZEV;
};

 struct S_OA_COBCE  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OA_COBCE::FieldLayout); } S_OA_COBCE();
	 enum { COBCE_KOD_WIDTH = 0, COBCE_KOD_PRECISION = 0 }; int COBCE_KOD;
	enum { OBEC_KOD_WIDTH = 0, OBEC_KOD_PRECISION = 0 }; int OBEC_KOD;
	enum { NAZEV_WIDTH = 200, NAZEV_PRECISION = 0 }; String NAZEV;
	enum { STAV_WIDTH = 0, STAV_PRECISION = 0 }; int STAV;
};

 struct S_OA_COBCE_H  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OA_COBCE_H::FieldLayout); } S_OA_COBCE_H();
	enum { COBCE_KOD_WIDTH = 0, COBCE_KOD_PRECISION = 0 }; int COBCE_KOD;
	enum { PLATI_DO_WIDTH = 0, PLATI_DO_PRECISION = 0 }; Date PLATI_DO;
	enum { OBEC_KOD_WIDTH = 0, OBEC_KOD_PRECISION = 0 }; int OBEC_KOD;
	enum { NAZEV_WIDTH = 200, NAZEV_PRECISION = 0 }; String NAZEV;
};

 struct S_OA_MCAST  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OA_MCAST::FieldLayout); } S_OA_MCAST();
	 enum { MCAST_KOD_WIDTH = 0, MCAST_KOD_PRECISION = 0 }; int MCAST_KOD;
	enum { OBEC_KOD_WIDTH = 0, OBEC_KOD_PRECISION = 0 }; int OBEC_KOD;
	enum { TYP_WIDTH = 0, TYP_PRECISION = 0 }; int TYP;
	enum { NAZEV_WIDTH = 200, NAZEV_PRECISION = 0 }; String NAZEV;
	enum { STAV_WIDTH = 0, STAV_PRECISION = 0 }; int STAV;
};

 struct S_OA_MCAST_H  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OA_MCAST_H::FieldLayout); } S_OA_MCAST_H();
	enum { MCAST_KOD_WIDTH = 0, MCAST_KOD_PRECISION = 0 }; int MCAST_KOD;
	enum { PLATI_DO_WIDTH = 0, PLATI_DO_PRECISION = 0 }; Date PLATI_DO;
	enum { OBEC_KOD_WIDTH = 0, OBEC_KOD_PRECISION = 0 }; int OBEC_KOD;
	enum { TYP_WIDTH = 0, TYP_PRECISION = 0 }; int TYP;
	enum { NAZEV_WIDTH = 200, NAZEV_PRECISION = 0 }; String NAZEV;
};

 struct S_OA_OBEC  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OA_OBEC::FieldLayout); } S_OA_OBEC();
	 enum { OBEC_KOD_WIDTH = 0, OBEC_KOD_PRECISION = 0 }; int OBEC_KOD;
	enum { OKRES_KOD_WIDTH = 0, OKRES_KOD_PRECISION = 0 }; int OKRES_KOD;
	enum { NAZEV_WIDTH = 200, NAZEV_PRECISION = 0 }; String NAZEV;
	enum { STAV_WIDTH = 0, STAV_PRECISION = 0 }; int STAV;
};

 struct S_OA_OBEC_H  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OA_OBEC_H::FieldLayout); } S_OA_OBEC_H();
	enum { OBEC_KOD_WIDTH = 0, OBEC_KOD_PRECISION = 0 }; int OBEC_KOD;
	enum { PLATI_DO_WIDTH = 0, PLATI_DO_PRECISION = 0 }; Date PLATI_DO;
	enum { OKRES_KOD_WIDTH = 0, OKRES_KOD_PRECISION = 0 }; int OKRES_KOD;
	enum { NAZEV_WIDTH = 200, NAZEV_PRECISION = 0 }; String NAZEV;
};

 struct S_OA_OKRES  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OA_OKRES::FieldLayout); } S_OA_OKRES();
	 enum { OKRES_KOD_WIDTH = 0, OKRES_KOD_PRECISION = 0 }; int OKRES_KOD;
	enum { NAZEV_WIDTH = 200, NAZEV_PRECISION = 0 }; String NAZEV;
	enum { STAV_WIDTH = 0, STAV_PRECISION = 0 }; int STAV;
};

 struct S_OA_OKRES_H  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_OA_OKRES_H::FieldLayout); } S_OA_OKRES_H();
	enum { OKRES_KOD_WIDTH = 0, OKRES_KOD_PRECISION = 0 }; int OKRES_KOD;
	enum { PLATI_DO_WIDTH = 0, PLATI_DO_PRECISION = 0 }; Date PLATI_DO;
	enum { NAZEV_WIDTH = 200, NAZEV_PRECISION = 0 }; String NAZEV;
};






#line 163 "u:/uppsrc\\Sql/sch_model.h"




































#line 91 "u:/uppsrc\\Oracle/OracleSchema.h"





















































#line 35 "u:/uppsrc\\Sql/sch_header.h"










#line 1 "u:/uppsrc\\Oracle/OracleSchema.h"


























































#line 60 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 65 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 70 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 75 "u:/uppsrc\\Oracle/OracleSchema.h"















#line 1 "u:/uppsrc\\Sql/sch_model.h"








#line 10 "u:/uppsrc\\Sql/sch_model.h"
















#line 27 "u:/uppsrc\\Sql/sch_model.h"




















#line 48 "u:/uppsrc\\Sql/sch_model.h"



#line 52 "u:/uppsrc\\Sql/sch_model.h"



#line 56 "u:/uppsrc\\Sql/sch_model.h"



#line 60 "u:/uppsrc\\Sql/sch_model.h"



#line 64 "u:/uppsrc\\Sql/sch_model.h"



#line 68 "u:/uppsrc\\Sql/sch_model.h"



#line 72 "u:/uppsrc\\Sql/sch_model.h"



#line 76 "u:/uppsrc\\Sql/sch_model.h"



#line 80 "u:/uppsrc\\Sql/sch_model.h"



#line 84 "u:/uppsrc\\Sql/sch_model.h"



#line 88 "u:/uppsrc\\Sql/sch_model.h"



#line 92 "u:/uppsrc\\Sql/sch_model.h"



#line 96 "u:/uppsrc\\Sql/sch_model.h"



#line 100 "u:/uppsrc\\Sql/sch_model.h"



#line 104 "u:/uppsrc\\Sql/sch_model.h"



#line 108 "u:/uppsrc\\Sql/sch_model.h"



#line 112 "u:/uppsrc\\Sql/sch_model.h"



#line 116 "u:/uppsrc\\Sql/sch_model.h"



#line 120 "u:/uppsrc\\Sql/sch_model.h"



#line 124 "u:/uppsrc\\Sql/sch_model.h"



#line 128 "u:/uppsrc\\Sql/sch_model.h"







#line 136 "u:/uppsrc\\Sql/sch_model.h"








#line 145 "u:/uppsrc\\Sql/sch_model.h"



#line 149 "u:/uppsrc\\Sql/sch_model.h"



#line 153 "u:/uppsrc\\Sql/sch_model.h"



#line 157 "u:/uppsrc\\Sql/sch_model.h"



#line 161 "u:/uppsrc\\Sql/sch_model.h"

#line 1 "u:\\idisapp\\idismisc\\OOModel.i"
extern SqlId OO_OSOBA;
	extern SqlId PCO;
	extern SqlId ROD_CIS;
	extern SqlId JM;
	extern SqlId RPR;
	extern SqlId PR;
	extern SqlId ROD_STAV;
	extern SqlId STATP;
	extern SqlId PCD;
	extern SqlId T_POB;
	extern SqlId MATR_SN;
	extern SqlId M_NAR_UMR;
	extern SqlId ROD_CIS_P;
	extern SqlId JM_P;
	extern SqlId RPR_P;
	extern SqlId PR_P;
	extern SqlId ROD_CIS_M;
	extern SqlId JM_M;
	extern SqlId RPR_M;
	extern SqlId PR_M;
	extern SqlId ROD_CIS_O;
	extern SqlId JM_O;
	extern SqlId RPR_O;
	extern SqlId PR_O;
	extern SqlId RC_DETI;
	extern SqlId TP_OD;
	extern SqlId OMEZ_ZPUS;
	extern SqlId ZAK_POB;
	extern SqlId TITUL;


extern SqlId OO_ADRESA;

	extern SqlId KOD_BL;
	extern SqlId DRUH_C_DOMU;
	extern SqlId C_DOM;
	extern SqlId KOD_UL;
	extern SqlId C_OR;
	extern SqlId ZNAK_C_OR;



extern SqlId OO_OKRES;




extern SqlId OO_LOKALITA;

	extern SqlId KOD_OB;
	extern SqlId TXT_BL;
	extern SqlId KOD_OKR;


extern SqlId OO_ULICE;


	extern SqlId KOD_TEXTU;


extern SqlId OO_ULICE_TXT;

	extern SqlId TXT;


extern SqlId OA_ADRESA;
	extern SqlId ADRESA_KOD;


	extern SqlId CISOR_HOD;
	extern SqlId CISOR_PIS;





extern SqlId OA_ADRESA_H;

	extern SqlId PLATI_DO;







extern SqlId OA_OBJEKT;
	extern SqlId OBJEKT_KOD;


	extern SqlId CISDOM_TYP;
	extern SqlId CISDOM_HOD;



extern SqlId OA_OBJEKT_H;








extern SqlId OA_ULICE;
	extern SqlId ULICE_KOD;





extern SqlId OA_ULICE_H;






extern SqlId OA_COBCE;
	extern SqlId COBCE_KOD;





extern SqlId OA_COBCE_H;






extern SqlId OA_MCAST;
	extern SqlId MCAST_KOD;






extern SqlId OA_MCAST_H;







extern SqlId OA_OBEC;
	extern SqlId OBEC_KOD;





extern SqlId OA_OBEC_H;






extern SqlId OA_OKRES;
	extern SqlId OKRES_KOD;




extern SqlId OA_OKRES_H;





extern SqlId UIRADR1;
extern SqlId UIRADR2;
extern SqlId ADRESA_SEQ2;
extern SqlId O_PRIPAD;
extern SqlId DTM_DO;
#line 163 "u:/uppsrc\\Sql/sch_model.h"




































#line 91 "u:/uppsrc\\Oracle/OracleSchema.h"





















































#line 46 "u:/uppsrc\\Sql/sch_header.h"
#line 118 "u:/idisapp\\IdisMisc/IdisMisc.h"



#line 1 "u:\\idisapp\\idismisc\\nisu.h"
extern String reason;



struct UserRights : S_OI_ROLE {
	void GrantAll();

	UserRights();
};

extern SqlSequence SeqOi;

void       SetupUserRights();
UserRights GetUserRights();

void   SetCanSelect();
bool   IsCanSelect();

void   SetOsobaAccessReason(const char *s);
void   AddOsobaAccessLog(int osoba_seq, const char *s);
void   AddOsobaAccessLog(int osoba_seq);

void   AddOOAccessLog(int pco, const char *s);
void   AddOOAccessLog(int pco);

void   CanShowDetails();
bool   IsCanShowDetails();

struct FindOsobaDlg : WithNFindOsobaLayout<TopWindow> {
	UserRights rights;
	String     jmeno1;
	String     jmeno2;
	String     rc;
	int        adresa_seq;
	Date       datnar, datnar_do;

	int     Perform();
	SqlBool GetWhere();
	SqlBool GetOOWhere();

	FindOsobaDlg::FindOsobaDlg(Vector<int> *lru = 0);
};

int     CsComp(const Value& a, const Value& b);
int     FindFilter(int c);

bool    NIsu();
void    DisableNIsu();

SqlBool NIsuAdresaText(const String& txt);

void    ClearNewFyzickaHint();
void    SetNewFyzickaHint(const String& prijm, const String& jmeno = Null, const String& rc = Null,
                          Date dat_nar = Null, int adresa_seq = Null);

int     NewFyzickaOsoba();
bool    EditFyzickaOsoba(int osoba_seq);
int     NewPravnickaOsoba();
bool    EditPravnickaOsoba(int osoba_seq);
bool    EditOsoba(int osoba_seq);

int     GetSelectOsoba(Vector<int> *lru = 0, bool vyber = false, SqlBool where = SqlBool());
int     GetSelectAdresa(int padresa_seq = Null, bool mesto = false, bool local = false);

inline  int     GetSelectAdresaLocal(int padresa_seq = Null) { return GetSelectAdresa(padresa_seq, false, true); }
#line 122 "u:/idisapp\\IdisMisc/IdisMisc.h"

void UpdateLongRaw(SqlId table, SqlId pk, int pkq, SqlId column, String text);

bool IsInvalidRC(const String& text);

extern bool NoLayoutZoom;

bool OracleLogin(OracleSession& session, const char *title);
void StreamOracleLogin(Stream& s);
bool OracleCfgLogin(const char *reason, OracleSession& session, const char *title = 0, const char *cfile = 0);

void   EditEnumTable(const char *title, SqlId table, SqlId key, SqlId text, SqlSequence& seq);

void   RunDlgUserOsoba();
void   RunDlgRegistry();

void   EditUserOsoba();
void   EditRegistry();

int    GetUserOsoba(const char *user);
int    GetUserOsobaSeq();

String GetUserOsobaTelefon(const char *user);
String GetUserOsobaTelefon(int osoba_seq);
String GetUserOsobaTelefon();

const Index<String>& UserPristup();

String GetRegistryKey(const char *key);

String GetRegistryString(const char *key);
String GetRegistryString(const char *key, const char *def);
int    GetRegistryAdresa(const char *key);
int    GetRegistryOsoba(const char *key);
double GetRegistryCislo(const char *key);
Date   GetRegistryDatum(const char *key);

void   SetRegistryString(const char *key, const String& s);
void   SetRegistryAdresa(const char *key, int adresa_seq);
void   SetRegistryOsoba(const char *key, int osoba_seq);
void   SetRegistryCislo(const char *key, double cislo);
void   SetRegistryDatum(const char *key, Date date);

void   TouchRegistry();

struct ListOp : public WithListOpLayout<TopWindow>
{
	void Load(bool all);
	void Delete();
	void ER();

	typedef ListOp CLASSNAME;

	ListOp();
};

class OsobaList : public TableArray {
public:
	virtual void  Serialize(Stream& s);
	virtual Value GetData() const;

private:
	typedef OsobaList CLASSNAME;

	Index<int>  map;
	String      title;
	bool        details;

	int         GetClipSeq(const String& user, const String& name) const;
	void        EnterOsoba();

public:
	void        Menu(Bar& bar);
	Callback    WhenSearch;
	Callback    WhenEnterRow;

	Vector<int> GetOsobaHint(int n = 50, bool addcurrent = true);

	void        Osoba();
	void        Edit();
	void        RemoveOsoba();
	void        Clear();
	void        Empty();
	void        Sort();
	void        Select(SqlSelect select);
	void        EditOsoba();
	void        Detail();
	void        Search();
	void        Print();

	int         Add(int osoba_seq);
	bool        Remove(int osoba_seq);
	void        Finish();
	void        FindAdd(int seq);

	void        ListLoad();
	void        ListAppend();
	void        ListSubtract();
	void        ListSave();
	void        ListDelete();

	void        SetTitle(const String& s)           { title = s; }

	int         GetOsobaSeq() const;
	operator    int() const                         { return GetOsobaSeq(); }

	void        AppendList(const String& user, const String& name);
	void        SubtractList(const String& user, const String& name);
	void        LoadList(const char *name = 0);
	void        SaveList(const char *name) const;

	void        WithDetails() { details = true; }

	OsobaList();
};


class OsobaArray : public ArrayCtrl {
public:
	virtual void  Serialize(Stream& s);
	virtual Value GetData() const;

private:
	typedef OsobaArray CLASSNAME;

	Index<int>  map;
	String      title;

	int         GetClipSeq(const String& user, const String& name) const;
	void        EnterOsoba();

public:
	void        Menu(Bar& bar);
	Callback    WhenSearch;
	Callback    WhenRC;
	Callback    WhenEnterRow;
	bool        hotkeys;

	Vector<int> GetOsobaHint(int n = 50, bool addcurrent = true);

	void        Osoba();
	void        RC();
	void        Edit();
	void        RemoveOsoba();
	void        Clear();
	void        Empty();
	void        Sort();
	void        Select(SqlSelect select);
	void        EditOsoba();
	void        Detail();
	void        Search();

	int         Add(int osoba_seq);
	bool        Remove(int osoba_seq);
	void        Finish();
	void        FindAdd(int seq);

	void        ListLoad();
	void        ListAppend();
	void        ListSubtract();
	void        ListSave();
	void        ListDelete();

	void        Print();

	void        SetTitle(const String& s)           { title = s; }

	int         GetOsobaSeq() const;
	operator    int() const                         { return GetOsobaSeq(); }

	void        AppendList(const String& user, const String& name);
	void        SubtractList(const String& user, const String& name);
	void        LoadList(const char *name = 0);
	void        SaveList(const char *name) const;

	OsobaArray();
};

struct AdresaInfo {
	int    adresa_seq;
	String psc;
	String cpop, cor;
	String ulice, ctvrt;
	String obec, okres;
	int    obec_seq;

	String Line1() const;
	String Line2(bool nosameobec = false) const;
};

class AdresaCache {
	struct Node {
		int    par_adresa_seq;
		int    uroven;
		String h1, h2;
		String psc;
	};

	ArrayMap<int, Node>    node;
	VectorMap<int, String> okrsek;

	static void  DoAdresa(AdresaInfo& f, Node *node);
	Node        *FetchNode(int adresa_seq);

public:
	void Invalidate()             { node.Clear(); }

	AdresaInfo Get(int adresa_seq);
	AdresaInfo Get(int adresa_seq, int par_adresa_seq,
	               String hodnota1, String hodnota2,
	               int uroven, String psc);
	String         GetOkrsek(int adresa_seq);
};

class OsobaSelect : public AdresaInfo {
	AdresaCache ac;
	Sql    sql;

public:
	int    osoba_seq;
	int    typ;
	String prijm;
	String jmeno;
	String rc_ico;
	String rprijm;
	String rod_stav;
	int    adresa_seq;
	String userid;

	String RcIco();
	void   Select(SqlBool where);
	bool   Fetch();
};

#line 357 "u:/idisapp\\IdisMisc/IdisMisc.h"



String Qtlf(const char *s);
void   Qtlf(VectorMap<String, Value>& var);
void   Qtlf_(VectorMap<String, Value>& var);
void   Qtlfan(VectorMap<String, Value>& var);

WString UniStr(const String& q);
String StrUni(const WString& t);

EscValue AsEsc(const Value& v);

int StringToUnderline(int c);

void IdisLib(ArrayMap<String, EscValue>& global);
void MakeVars(VectorMap<String, Value>& map, const SqlCtrls& ctrls);
void MakeVars(VectorMap<String, Value> &map, Fields fields);
VectorMap<String, Value> MakeVars(const SqlCtrls& ctrls);
VectorMap<String, Value> MakeVars(Fields fields);
void MakeVars(Sql& sql, ArrayMap<String, EscValue>& vars);

void   SetUsrLibId(const char *id);
String GetUsrLibId();
void   EditUsrLib(const ArrayMap<String, EscValue>& vars);
void   EditUsrLib(const VectorMap<String, Value>& vars);
void   IdisUsrLib(ArrayMap<String, EscValue>& global);

String MakeSberSymbol(int osoba_seq);

class IndexOperator {
protected:
	String table;
	String IxN(SqlId column);

public:
	virtual  void  Column(SqlId column) = 0;

	IndexOperator& Table(SqlId _table)      { table = _table.ToString(); return *this; }
	IndexOperator& operator()(SqlId column) { Column(column); return *this; }
};

class CreateIndex : public IndexOperator {
public:
	virtual  void  Column(SqlId column);
};

class DropIndex : public IndexOperator  {
public:
	virtual  void Column(SqlId column);
};

class ConvertOsobaAdresaObecCls : public Convert {
public:
	Value Format(const Value& value) const;
};

extern ConvertOsobaAdresaObecCls ConvertOsobaAdresaObec;

String FormatMoney(double money);
String FormatMoney00(double money);

String    Slovy(int i);

String Osloveni(int osoba_seq);

void LockForm(Button& ok, TopWindow& form, Callback unlock);
void UnlockForm(Button& ok, TopWindow& form, bool noask = false);

String    TempDocFile(const String& filename);
void      RemoveTempDocFiles();
bool      IsReadOnly(const char *filename);
void      SetReadOnly(const char *filename, bool rdonly);
void      OpenDoc(const String& p, const char *verb = 0);

class DisplayRight: public Display {
public:
	virtual void Paint(Draw& w, const Rect& r, const Value& q,
		               Color ink, Color paper, dword style) const;

protected:
	Font font;

public:
	static DisplayRight Normal;
	static DisplayRight Bold;


	DisplayRight(Font font = GuiFont()) : font(font) {}
};

class DisplayMoney : public Display {
public:
	void Paint(Draw& w, const Rect& r, const Value& q,
		       Color ink, Color paper, dword style) const;

protected:
	Font   font;
	bool   red;

public:
	static DisplayMoney Normal;
	static DisplayMoney Bold;
	static DisplayMoney NormalRed;


	DisplayMoney& SetFont(Font _font)  { font = _font; return *this; }
	DisplayMoney& Red(bool b)          { red = b; return *this; }
	DisplayMoney& NoRed()              { return Red(false); }

	DisplayMoney(Font font = GuiFont(), bool red = true) : font(font), red(red) {}
};

class FontDisplay : public Display {
public:
	void Paint(Draw& w, const Rect& r, const Value& q,
		       Color ink, Color paper, dword style) const;

protected:
	Font font;

public:
	static FontDisplay  Bold;
	static FontDisplay  Italic;
	static FontDisplay  Underline;
	static FontDisplay  BoldItalic;

	FontDisplay(Font font) : font(font) {}
};

class ColoredDisplay : public Display {
public:
	void Paint(Draw& w, const Rect& r, const Value& q,
		       Color ink, Color paper, dword style) const;

protected:
	Color color;

public:
	ColoredDisplay(Color color) : color(color) {}
};

class FontColorDisplay : public Display {
public:
	void Paint(Draw& w, const Rect& r, const Value& q, Color ink, Color paper, dword style) const;

protected:
	Color color;
	Font  font;

public:
	FontColorDisplay(Color color, Font font) : color(color), font(font) {}
};

int    GetOsobaAge(Date birthdate, Date date);
int    GetOsobaAge(int osoba_seq, Date date);
int    GetOsobaAge(int q);
String FormatAge(int age);
String NoLastLf(const String& s);
String MoneyFormat(double m);
String MoneyFormat00(double m);

String Sklon(const String& src, int pad);
String SklonZ(const String& src, int pad);
String SklonJmeno(const String& jmeno, const String& prijm, bool zena, int pad, bool surname_first);

bool PracovniKlid(Date d);
Date Npm(Date doruceni);
Date OdNpm(Date npm);
Date AddPracovni(Date d, int n);

void VarAdresa(VectorMap<String, Value>& map, const char *key, int adresa_seq);
void VarOsoba(VectorMap<String, Value>& map, const char *key, int osoba_seq,
              int adresa_seq = Null);
void VarAdresaQtf(VectorMap<String, Value>& map, const char *key, int adresa_seq = Null);
void VarOsobaQtf(VectorMap<String, Value>& map, const char *key, int osoba_seq, int adresa_seq = Null);

struct OAdresa {
	String obec;
	String lokalita;
	String okres;
	String psc;
	String ulice;
	String cpop;
	String cor;

	virtual void   Clear();
	virtual String Line1NoCislo();
	virtual String Line1();
	virtual String Line2();
	virtual String Line2Short();

	struct Lokalita : Moveable<Lokalita> {
		String nazev;
		int    kod_ob;
		int    kod_okr;
	};
	struct Dum : Moveable<Dum> {
		char   cpop_ch;
		char   cor_ch;
		int16  cpop;
		int16  cor;
		int16  psc;
		int    ulice;
		int    kod_bl;
	};

	static VectorMap<int, Dum>      dum;
	static VectorMap<int, String>   ulices;
	static VectorMap<int, Lokalita> lokality;
	static VectorMap<int, String>   okresy;

	static void ClearCache();

	static int  GetDum(int pcd);
	static int  GetUlice(int ulice);
	static int  GetLokalita(int kod_bl);
	static int  GetOkres(int kod_okr);

	int    kod_ob;

	bool   LoadOO(int pcd);

	static ArrayMap<int, S_OA_ADRESA> aadresa;
	static Index<int> pcd;
	static ArrayMap<int, S_OA_ULICE>  aulice;
	static ArrayMap<int, S_OA_OBJEKT> aobjekt;
	static ArrayMap<int, S_OA_COBCE>  acobce;
	static ArrayMap<int, S_OA_OBEC>   aobec;
	static ArrayMap<int, S_OA_OKRES>  aokres;

	const S_OA_ADRESA& AGetAdresa(int adresa_kod);
	const S_OA_ADRESA& AGetAdresaPCD(int pcd);
	const S_OA_OBJEKT& AGetObjekt(int objekt_kod);
	const S_OA_ULICE&  AGetUlice(int ulice_kod);
	const S_OA_COBCE&  AGetCobce(int cobce_kod);
	const S_OA_OBEC&   AGetObec(int obec_kod);
	const S_OA_OKRES&  AGetOkres(int okres_kod);

	bool   Load0(const S_OA_ADRESA& sadresa);;

	bool   LoadAdresa(int adresa_kod);
	bool   LoadOA(int pcd);

	bool   Load(int pcd);
};

bool OL_Compare(const String& o, const String& l);
String ACap(const String& s);
String FormatCisla(const String& cpop, const String& cor);







BorderFrame& InsetFrameRed();

#line 617 "u:/idisapp\\IdisMisc/IdisMisc.h"



bool  SeriousStep();

void  SQLConsole();

void IdisParamMenu(Bar& menu);

void IdisHeader(DocReport& report, const String& ln1, const String& ln2);
void IdisFooter(DocReport& report, const String& text = String());
void IdisReport(DocReport& report, const String& footer, const String& ln2, const String& ln1);
void IdisReport(DocReport& report, const String& footer, const String& ln2);
void IdisReport(DocReport& report, const String& footer);
void IdisReport(DocReport& report);

void ITisk(const String& nazev, const String& text, Callback2<String, Value&> var,
           const String& cj = Null, int osoba_seq = Null, bool single = false);
void ITisk(const String& nazev, const String& text, const VectorMap<String, Value>& vars,
           const String& cj = Null, int osoba_seq = Null, bool single = false);

void IdisTitle(DocReport& report, bool date = false, const char *rh2 = 0, const char *rh1 = 0);
void Idis(DocReport& report, const String& footer = String(), bool date = false,
		  const char *rh2 = 0, const char *rh1 = 0);
void Idis2(DocReport& report, const String& footer = String(), bool date = false);

bool IdisRecipient(const String& rp);
bool IdisRecipient(int osoba_seq, int adresa_seq);
bool IdisRecipient(int osoba_seq);




class IdisTable : public Table {
public:
	IdisTable& HeaderCell(int ratio, const char *text, Font font = Roman(-100).Bold());


	IdisTable& Header(Font font, const char *text1, int ratio1); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30, const char *text31, int ratio31); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30, const char *text31, int ratio31, const char *text32, int ratio32); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30, const char *text31, int ratio31, const char *text32, int ratio32, const char *text33, int ratio33); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30, const char *text31, int ratio31, const char *text32, int ratio32, const char *text33, int ratio33, const char *text34, int ratio34); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30, const char *text31, int ratio31, const char *text32, int ratio32, const char *text33, int ratio33, const char *text34, int ratio34, const char *text35, int ratio35); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30, const char *text31, int ratio31, const char *text32, int ratio32, const char *text33, int ratio33, const char *text34, int ratio34, const char *text35, int ratio35, const char *text36, int ratio36); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30, const char *text31, int ratio31, const char *text32, int ratio32, const char *text33, int ratio33, const char *text34, int ratio34, const char *text35, int ratio35, const char *text36, int ratio36, const char *text37, int ratio37); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30, const char *text31, int ratio31, const char *text32, int ratio32, const char *text33, int ratio33, const char *text34, int ratio34, const char *text35, int ratio35, const char *text36, int ratio36, const char *text37, int ratio37, const char *text38, int ratio38); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30, const char *text31, int ratio31, const char *text32, int ratio32, const char *text33, int ratio33, const char *text34, int ratio34, const char *text35, int ratio35, const char *text36, int ratio36, const char *text37, int ratio37, const char *text38, int ratio38, const char *text39, int ratio39); IdisTable& Header(Font font, const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30, const char *text31, int ratio31, const char *text32, int ratio32, const char *text33, int ratio33, const char *text34, int ratio34, const char *text35, int ratio35, const char *text36, int ratio36, const char *text37, int ratio37, const char *text38, int ratio38, const char *text39, int ratio39, const char *text40, int ratio40);;


	IdisTable& Header(const char *text1, int ratio1); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30, const char *text31, int ratio31); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30, const char *text31, int ratio31, const char *text32, int ratio32); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30, const char *text31, int ratio31, const char *text32, int ratio32, const char *text33, int ratio33); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30, const char *text31, int ratio31, const char *text32, int ratio32, const char *text33, int ratio33, const char *text34, int ratio34); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30, const char *text31, int ratio31, const char *text32, int ratio32, const char *text33, int ratio33, const char *text34, int ratio34, const char *text35, int ratio35); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30, const char *text31, int ratio31, const char *text32, int ratio32, const char *text33, int ratio33, const char *text34, int ratio34, const char *text35, int ratio35, const char *text36, int ratio36); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30, const char *text31, int ratio31, const char *text32, int ratio32, const char *text33, int ratio33, const char *text34, int ratio34, const char *text35, int ratio35, const char *text36, int ratio36, const char *text37, int ratio37); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30, const char *text31, int ratio31, const char *text32, int ratio32, const char *text33, int ratio33, const char *text34, int ratio34, const char *text35, int ratio35, const char *text36, int ratio36, const char *text37, int ratio37, const char *text38, int ratio38); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30, const char *text31, int ratio31, const char *text32, int ratio32, const char *text33, int ratio33, const char *text34, int ratio34, const char *text35, int ratio35, const char *text36, int ratio36, const char *text37, int ratio37, const char *text38, int ratio38, const char *text39, int ratio39); IdisTable& Header(const char *text1, int ratio1, const char *text2, int ratio2, const char *text3, int ratio3, const char *text4, int ratio4, const char *text5, int ratio5, const char *text6, int ratio6, const char *text7, int ratio7, const char *text8, int ratio8, const char *text9, int ratio9, const char *text10, int ratio10, const char *text11, int ratio11, const char *text12, int ratio12, const char *text13, int ratio13, const char *text14, int ratio14, const char *text15, int ratio15, const char *text16, int ratio16, const char *text17, int ratio17, const char *text18, int ratio18, const char *text19, int ratio19, const char *text20, int ratio20, const char *text21, int ratio21, const char *text22, int ratio22, const char *text23, int ratio23, const char *text24, int ratio24, const char *text25, int ratio25, const char *text26, int ratio26, const char *text27, int ratio27, const char *text28, int ratio28, const char *text29, int ratio29, const char *text30, int ratio30, const char *text31, int ratio31, const char *text32, int ratio32, const char *text33, int ratio33, const char *text34, int ratio34, const char *text35, int ratio35, const char *text36, int ratio36, const char *text37, int ratio37, const char *text38, int ratio38, const char *text39, int ratio39, const char *text40, int ratio40);;

	IdisTable& RowCell(const String& s, Font font = Roman(-100));


	IdisTable& Row(Font font, const String& s1); IdisTable& Row(Font font, const String& s1, const String& s2); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30, const String& s31); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30, const String& s31, const String& s32); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30, const String& s31, const String& s32, const String& s33); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30, const String& s31, const String& s32, const String& s33, const String& s34); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30, const String& s31, const String& s32, const String& s33, const String& s34, const String& s35); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30, const String& s31, const String& s32, const String& s33, const String& s34, const String& s35, const String& s36); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30, const String& s31, const String& s32, const String& s33, const String& s34, const String& s35, const String& s36, const String& s37); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30, const String& s31, const String& s32, const String& s33, const String& s34, const String& s35, const String& s36, const String& s37, const String& s38); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30, const String& s31, const String& s32, const String& s33, const String& s34, const String& s35, const String& s36, const String& s37, const String& s38, const String& s39); IdisTable& Row(Font font, const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30, const String& s31, const String& s32, const String& s33, const String& s34, const String& s35, const String& s36, const String& s37, const String& s38, const String& s39, const String& s40);;


	IdisTable& Row(const String& s1); IdisTable& Row(const String& s1, const String& s2); IdisTable& Row(const String& s1, const String& s2, const String& s3); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30, const String& s31); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30, const String& s31, const String& s32); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30, const String& s31, const String& s32, const String& s33); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30, const String& s31, const String& s32, const String& s33, const String& s34); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30, const String& s31, const String& s32, const String& s33, const String& s34, const String& s35); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30, const String& s31, const String& s32, const String& s33, const String& s34, const String& s35, const String& s36); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30, const String& s31, const String& s32, const String& s33, const String& s34, const String& s35, const String& s36, const String& s37); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30, const String& s31, const String& s32, const String& s33, const String& s34, const String& s35, const String& s36, const String& s37, const String& s38); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30, const String& s31, const String& s32, const String& s33, const String& s34, const String& s35, const String& s36, const String& s37, const String& s38, const String& s39); IdisTable& Row(const String& s1, const String& s2, const String& s3, const String& s4, const String& s5, const String& s6, const String& s7, const String& s8, const String& s9, const String& s10, const String& s11, const String& s12, const String& s13, const String& s14, const String& s15, const String& s16, const String& s17, const String& s18, const String& s19, const String& s20, const String& s21, const String& s22, const String& s23, const String& s24, const String& s25, const String& s26, const String& s27, const String& s28, const String& s29, const String& s30, const String& s31, const String& s32, const String& s33, const String& s34, const String& s35, const String& s36, const String& s37, const String& s38, const String& s39, const String& s40);;
};

void Prehled(DocReport& report, const char *name, const char *operace, Date dtm_od, Date dtm_do);
void Prehled(DocReport& report, const char *name, Date dtm_od, Date dtm_do);

String NotesCreate(int osoba_seq, int adresa_seq, bool samostatne,
                   const String& odbor, const String& cislo,
                   const String& rok, Date datum, const char *vec);

void SerializeTextMacros(Stream& s);

enum {
	EV_NAVRH             =  0,
	EV_OZNAMENI          =  1,
	EV_SPRAVPOPL         =  2,
	EV_NAKLAD            =  3,
	EV_BLOKPOKUTA        =  4,
	EV_PRIKNAPOMENUTI    =  5,
	EV_PRIKPOKUTA        =  6,
	EV_ODPOR             =  7,
	EV_ZAHAJENI          =  8,
	EV_PORADPOKUTA       =  9,
	EV_NAHRADAROZH       = 10,
	EV_NAHRADADOHOD      = 11,
	EV_NAHRADAODKAZ      = 12,
	EV_ODLOZEN           = 13,
	EV_ZASTAVENO         = 14,
	EV_SMIR              = 15,
	EV_BEZOPATRENI       = 16,
	EV_NAPOMENUTI        = 17,
	EV_POKUTA            = 18,
	EV_PROPAD            = 19,
	EV_ZAKAZ             = 20,
	EV_POSTOUPENO        = 21,
	EV_OMEZUJICI         = 22,
	EV_KONEC             = 23,
	EV_ODVOLANI          = 24,
	EV_AUTOREMEDURA      = 25,
	EV_ODVOLODESL        = 26,
	EV_ODVOLZAMITPOTVRZ  = 27,
	EV_ODVOLPRIJATZRUS   = 28,
	EV_ODVOLPRIJATVRAC   = 29,
	EV_ODVOLPRIJATZMEN   = 30,
	EV_ODROCENO          = 31,
	EV_PODNETKPREZKUMU   = 32,
	EV_OBNOVA            = 33,
	EV_PREZKOUMSOUD      = 34,
	EV_PORADPOKUTA60     = 35,
	EV_ZABRANI           = 36,
	EV_ARCHIVOVANO       = 37,
	EV_PRERUSENO         = 38,
	EV_PRODLOUZENI       = 39,
	EV_VRACENO           = 40,
	EV_ZADOSTOPROM       = 41,
	EV_RPVRACEN          = 42,
	EV_RPNEVRACEN        = 43,
	EV_BLOKVRIZ          = 44,
	EV_POSTOUPENO71      = 45,
	EV_POSTOUPENO12      = 46,
	EV_POSTOUPENO553     = 47,
	EV_ROZHODNUTI        = 48,
	EV_ODOVOLZRUSZAST    = 49,
	EV_ODVOLZAMITOPO     = 50,
	EV_PREZKUMVRA        = 51,
	EV_ZAPUJCENI         = 52,
	EV_JEDNANIODVOLANO   = 53,
};

enum {
	START  = 1,
	END    = 2,
	RESULT = 4,
};

struct ConEvent {
	int         udalost;
	const char *popis;
	const char *osoba_seq;
	const char *doruceno;
	const char *npm;
	const char *platba;
	const char *text;
	const char *cislo;
	const char *zapocitano;
	dword       flags;
	bool        common;
};

extern const ConEvent EventCon[];
extern const int CountOfEventCon;

bool  IsConEvent(int udalost);
const ConEvent& GetConEvent(int udalost);

void PhPrehled();




















struct CUserOsoba {
public:
	void DoModal()     { RunDlgUserOsoba(); }
};

class CRegistry {
public:
	void DoModal()     { RunDlgRegistry(); }
};

#line 793 "u:/idisapp\\IdisMisc/IdisMisc.h"
#line 5 "u:\\idisapp\\matrika2\\Matrika.h"
#line 1 "u:/uppsrc\\Esc/Esc.h"

























































































































































































































































































































#line 6 "u:\\idisapp\\matrika2\\Matrika.h"
#line 1 "u:/uppsrc\\RichText/RichText.h"











































































































































































































































































































































































































































































#line 7 "u:\\idisapp\\matrika2\\Matrika.h"
#line 1 "u:/idisapp\\IdisDoc/IdisDoc.h"



#line 1 "u:/idisapp\\IdisMisc/IdisMisc.h"
























































































































































































































































































































































































































































































































































































































































































































































































































#line 5 "u:/idisapp\\IdisDoc/IdisDoc.h"
#line 1 "u:/idisapp\\Notes/Notes.h"












































#line 6 "u:/idisapp\\IdisDoc/IdisDoc.h"
#line 1 "u:/uppsrc\\RichEdit/RichEdit.h"






































































































































































































































































































































































































































































































































































































































































































#line 7 "u:/idisapp\\IdisDoc/IdisDoc.h"
#line 1 "u:/uppsrc\\Esc/Esc.h"

























































































































































































































































































































#line 8 "u:/idisapp\\IdisDoc/IdisDoc.h"
#line 1 "u:/uppsrc\\PdfDraw/PdfDraw.h"



#line 1 "u:/uppsrc\\Draw/Draw.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 5 "u:/uppsrc\\PdfDraw/PdfDraw.h"
#line 1 "u:/uppsrc\\plugin/z/z.h"





#line 7 "u:/uppsrc\\plugin/z/z.h"
#line 6 "u:/uppsrc\\PdfDraw/PdfDraw.h"


namespace Upp {

class TTFReader {
	struct TTFStream {
		struct Fail {};

		virtual void Raw(void *ptr, int count) = 0;

		TTFStream& operator%(byte& q);
		TTFStream& operator%(int32& q);
		TTFStream& operator%(uint32& q);
		TTFStream& operator%(int16& q);
		TTFStream& operator%(uint16& q);

		virtual ~TTFStream() {}
	};

	struct TTFStreamIn : TTFStream {
		const char *beg;
		const char *s;
		const char *lim;

		virtual void Raw(void *ptr, int count);

		void   Seek(int offset);
		int    Get8();
		int    Get16();
		int    Get32();
		String Get(int n);

		virtual ~TTFStreamIn() {}
	};

	struct TTFStreamOut : TTFStream {
		String out;

		virtual void Raw(void *ptr, int count) { out.Cat((const char *)ptr, count); }

		void   Put8(int data)       { out.Cat(data); }
		void   Put16(int data)      { Put8(((BYTE)((DWORD_PTR)(data) >> 8))); Put8(((BYTE)((DWORD_PTR)(data) & 0xff))); }
		void   Put32(int data)      { Put16(((WORD)((DWORD_PTR)(data) >> 16))); Put16(((WORD)((DWORD_PTR)(data) & 0xffff))); }
		void   Put(const String& s) { out.Cat(s); }

		operator String() const     { return out; }

		virtual ~TTFStreamOut() {}
	};

	String font;

	struct Table : Moveable<Table> {
		int offset;
		int length;
	};
	VectorMap<String, Table> table;

	word  zero[256];
	word *cmap[256];

	struct GlyphInfo : Moveable<GlyphInfo> {
		int    offset;
		int    size;
    	uint16 advanceWidth;
    	int16  leftSideBearing;
	};

	Vector<GlyphInfo> glyphinfo;

	void   SetGlyph(wchar ch, word glyph);

	struct Fail {};

	static void Error() { throw Fail(); }

	int    Peek8(const char *s);
	int    Peek16(const char *s);
	int    Peek32(const char *s);
	int    Peek8(const char *s, int i);
	int    Peek16(const char *s, int i);
	int    Peek32(const char *s, int i);
	int    Read8(const char *&s);
	int    Read16(const char *&s);
	int    Read32(const char *&s);
	String Read(const char *&s, int n);

	void   Free();
	void   Reset();

	const char *Seek(const char *tab, int& len);
	const char *Seek(const char *tab);
	void        Seek(const char *tab, TTFStreamIn& s);
	String      GetTable(const char *tab);

	enum {
		ARG_1_AND_2_ARE_WORDS     = (1<<0),
		ARGS_ARE_XY_VALUES        = (1<<1),
		ROUND_XY_TO_GRID          = (1<<2),
		WE_HAVE_A_SCALE           = (1<<3),
		MORE_COMPONENTS           = (1<<5),
		WE_HAVE_AN_X_AND_Y_SCALE  = (1<<6),
		WE_HAVE_A_TWO_BY_TWO      = (1<<7),
		WE_HAVE_INSTRUCTIONS      = (1<<8),
		USE_MY_METRICS            = (1<<9),
	};

	struct NewTable {
		String name;
		String data;
		dword  checksum;
	};

	static void   Add(Array<NewTable>& t, const char *name, const String& data);
	static void   Set(NewTable& m, const String& data);
	static String CreateHeader(const Array<NewTable>& t);

	static inline int    Copy8(TTFStreamOut& out, TTFStreamIn& in)
		{ int q = in.Get8(); out.Put8(q); return q; }
	static inline int    Copy16(TTFStreamOut& out, TTFStreamIn& in)
		{ int q = in.Get16(); out.Put16(q); return q; }
	static inline int    Copy32(TTFStreamOut& out, TTFStreamIn& in)
		{ int q = in.Get32(); out.Put32(q); return q; }
	static inline String Copy(TTFStreamOut& out, TTFStreamIn& in, int n)
		{ String q = in.Get(n); out.Put(q); return q; }

public:
	struct Head {
		dword   version;
		dword   fontRevision;
		uint32  checkSumAdjustment;
		uint32  magicNumber;
		uint16 	flags;
		uint16 	unitsPerEm;
		byte    created[8];
		byte    modified[8];
		int16   xMin;
		int16   yMin;
		int16   xMax;
		int16   yMax;
		uint16  macStyle;
		uint16  lowestRecPPEM;
		int16   fontDirectionHint;
		int16   indexToLocFormat;
		int16   glyphDataFormat;

		void Serialize(TTFStream& s);
	};

	struct Hhea {
		uint32  version;
		int16   ascent;
		int16   descent;
		int16   lineGap;
		uint16  advanceWidthMax;
		int16   minLeftSideBearing;
		int16   minRightSideBearing;
		int16   xMaxExtent;
		int16   caretSlopeRise;
		int16   caretSlopeRun;
		int16   caretOffset;
		int16   reserved1;
		int16   reserved2;
		int16   reserved3;
		int16   reserved4;
		int16   metricDataFormat;
		uint16  numOfLongHorMetrics;

		void Serialize(TTFStream& s);
	};

	struct Maxp {
		uint32  version;
		uint16  numGlyphs;
		uint16  maxPoints;
		uint16  maxContours;
		uint16  maxComponentPoints;
		uint16  maxComponentContours;
		uint16  maxZones;
		uint16  maxTwilightPoints;
		uint16  maxStorage;
		uint16  maxFunctionDefs;
		uint16  maxInstructionDefs;
		uint16  maxStackElements;
		uint16  maxSizeOfInstructions;
		uint16  maxComponentElements;
		uint16  maxComponentDepth;

		void Serialize(TTFStream& s);
	};

	struct Post {
		uint32  format;
		int32   italicAngle;
		int16   underlinePosition;
		int16   underlineThickness;
		uint16  isFixedPitch;
		uint16  reserved;
		uint32  minMemType42;
		uint32  maxMemType42;
		uint32  minMemType1;
		uint32  maxMemType1;

		void Serialize(TTFStream& s);
	};

	Head   head;
	Hhea   hhea;
	Maxp   maxp;
	Post   post;
	String ps_name;

	int    GetGlyph(wchar chr)               { return cmap[((BYTE)((DWORD_PTR)(chr) >> 8))][((BYTE)((DWORD_PTR)(chr) & 0xff))]; }
	word   GetAdvanceWidth(wchar chr)        { return glyphinfo[GetGlyph(chr)].advanceWidth; }

	String Subset(const Vector<wchar>& chars, int first = 0, bool os2 = false);
	bool   Open(const String& fnt, bool symbol = false, bool justcheck = false);

	TTFReader();
	~TTFReader();
};

class PdfDraw : public Draw {
public:
	virtual void StartPage();
	virtual void EndPage();

	virtual void BeginOp();
	virtual void EndOp();
	virtual void OffsetOp(Point p);
	virtual bool ClipOp(const Rect& r);
	virtual bool ClipoffOp(const Rect& r);
	virtual bool ExcludeClipOp(const Rect& r);
	virtual bool IntersectClipOp(const Rect& r);
	virtual Rect GetClipOp() const;
	virtual bool IsPaintingOp(const Rect& r) const;

	virtual	void DrawRectOp(int x, int y, int cx, int cy, Color color);
	virtual void DrawImageOp(int x, int y, int cx, int cy, const Image& img, const Rect& src, Color color);
	virtual void DrawLineOp(int x1, int y1, int x2, int y2, int width, Color color);
	virtual void DrawPolyPolylineOp(const Point *vertices, int vertex_count,
	                                const int *counts, int count_count,
	                                int width, Color color, Color doxor);
	virtual void DrawPolyPolyPolygonOp(const Point *vertices, int vertex_count,
	                                   const int *subpolygon_counts, int scc,
	                                   const int *disjunct_polygon_counts, int dpcc,
	                                   Color color, int width, Color outline,
	                                   uint64 pattern, Color doxor);
	virtual void DrawEllipseOp(const Rect& r, Color color, int pen, Color pencolor);
	virtual void DrawArcOp(const Rect& rc, Point start, Point end, int width, Color color);
	virtual void DrawTextOp(int x, int y, int angle, const wchar *text, Font font,
		                    Color ink, int n, const int *dx);

private:
	struct CharPos : Moveable<CharPos>   { word fi, ci; };

	struct OutlineInfo : Moveable<OutlineInfo> {
		bool ttf;
		bool sitalic;
	};

	VectorMap<Font, OutlineInfo>                outline_info;
	VectorMap<Font, Vector<wchar> >             pdffont;
	VectorMap<Font, VectorMap<wchar, CharPos> > fontchars;
	Vector<Image>                               image;
	Vector<Rect>                                imagerect;

	Vector<int>   offset;
	Vector<Point> offstack;
	Vector<Rect> clipstack;
	Rect        actual_clip;
	String      out;
	String      page;
	Size        pgsz;
	Color       rgcolor;
	Color       RGcolor;
	int         fontid;
	double      textht;
	double      linewidth;
	int         margin;

	inline double Pt(double dot)        { return 0.12 * dot; }

	int    Pos()                        { return offset.GetCount() + 1; }
	int    BeginObj();
	void   EndObj();
	int    PutStream(const String& data, const String& keys = Null);

	void    PutRect(const Rect& rc);
	void    PutrgColor(Color rg);
	void    PutRGColor(Color RG);
	void    PutFontHeight(int fi, double ht);
	void    PutLineWidth(int lw);

	CharPos GetCharPos(Font fnt, wchar chr);
	void    FlushText(int dx, int fi, int height, const String& txt);
	static String PdfColor(Color c);

	OutlineInfo GetOutlineInfo(Font fnt);

	struct M22 {
		double a, b, c, d;

		void Mul(double a1, double b1, double c1, double d1) {
			M22 t;
			t.a = a * a1 + b * c1;
			t.b = a * b1 + b * d1;
			t.c = c * a1 + d * c1;
			t.d = c * b1 + d * d1;
			*this = t;
		}

		M22(double a, double b, double c, double d) : a(a), b(b), c(c), d(d) {}
		M22() : a(1), b(0), c(0), d(1) {}
	};

	void Init(int pagecx, int pagecy, int margin);

	struct RGlyph : Moveable<RGlyph> {
		String data;
		Size   sz;
		int    x;
	};

	RGlyph RasterGlyph(Font fnt, int chr);

public:
	String Finish();
	void   Clear();

	PdfDraw(int pagecx, int pagecy)                { Init(pagecx, pagecy, 0); }
	PdfDraw(Size pgsz = Size(5100, 6600))          { Init(pgsz.cx, pgsz.cy, 0); }
};

String Pdf(const Array<Drawing>& report, Size pagesize, int margin);

};

#line 345 "u:/uppsrc\\PdfDraw/PdfDraw.h"
#line 9 "u:/idisapp\\IdisDoc/IdisDoc.h"
#line 1 "u:/idisapp\\IdisTDoc/IdisTDoc.h"



#line 1 "u:/idisapp\\IdisMisc/IdisMisc.h"
























































































































































































































































































































































































































































































































































































































































































































































































































#line 5 "u:/idisapp\\IdisTDoc/IdisTDoc.h"
#line 1 "u:/uppsrc\\RichEdit/RichEdit.h"






































































































































































































































































































































































































































































































































































































































































































#line 6 "u:/idisapp\\IdisTDoc/IdisTDoc.h"
#line 1 "u:/uppsrc\\PdfDraw/PdfDraw.h"
























































































































































































































































































































































#line 7 "u:/idisapp\\IdisTDoc/IdisTDoc.h"


#line 1 "u:/uppsrc\\CtrlCore/lay.h"







#line 1 "u:/idisapp\\IdisTDoc/IdisTDoc.lay"
struct DataLayout__layid {};






struct SablonaNameLayout__layid {};







struct SablonyLayout__layid {};

















struct MacroLayout__layid {};





struct SaveSablonaLayout__layid {};








struct SkupinaListLayout__layid {};




#line 9 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/idisapp\\IdisTDoc/IdisTDoc.lay"
template<class T> struct WithDataLayout : public T, public DataLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(736, 500); }
	ArrayCtrl field;
	RichTextView text;
	Button ok;
	Button cancel;
};

template<class T> struct WithSablonaNameLayout : public T, public SablonaNameLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(312, 224); }
	SqlArray skupina;
	Label dv___1;
	EditString sablona;
	Button ok;
	Button cancel;
};

template<class T> struct WithSablonyLayout : public T, public SablonyLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(748, 544); }
	SqlArray skupina;
	Button screate;
	Button srename;
	Button sremove;
	SqlArray sablona;
	LabelBox dv___5;
	Button create;
	Button createas;
	Button rename;
	Button remove;
	Button move;
	Label pristup_lbl;
	DropList pristup;
	DropList typ;
	RichTextView view;
};

template<class T> struct WithMacroLayout : public T, public MacroLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(796, 544); }
	SqlArray macro;
	RichTextView view;
	DocEdit ltext;
};

template<class T> struct WithSaveSablonaLayout : public T, public SaveSablonaLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(780, 544); }
	SqlArray skupina;
	SqlArray sablona;
	RichTextView view;
	Button save;
	Button insert;
	Button cancel;
};

template<class T> struct WithSkupinaListLayout : public T, public SkupinaListLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(216, 336); }
	ArrayCtrl list;
	Button ok;
	Button cancel;
};
#line 23 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/idisapp\\IdisTDoc/IdisTDoc.lay"
template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, DataLayout__layid&) { parent.LayoutId("DataLayout");
	layout.field.LeftPosZ(8, 150).TopPosZ(8, 452); layout.field.LayoutId("field"); parent.Add(layout.field);
	layout.text.LeftPosZ(164, 564).TopPosZ(8, 452); layout.text.LayoutId("text"); parent.Add(layout.text);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(596, 64).TopPosZ(468, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(664, 64).TopPosZ(468, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, SablonaNameLayout__layid&) { parent.LayoutId("SablonaNameLayout");
	layout.skupina.LeftPosZ(4, 304).TopPosZ(4, 156); layout.skupina.LayoutId("skupina"); parent.Add(layout.skupina);
	layout.dv___1.SetLabel(t_GetLngString("Nzev")).LeftPosZ(4, 52).TopPosZ(164, 19); layout.dv___1.LayoutId("dv___1"); parent.Add(layout.dv___1);
	layout.sablona.LeftPosZ(60, 248).TopPosZ(164, 19); layout.sablona.LayoutId("sablona"); parent.Add(layout.sablona);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(172, 64).TopPosZ(192, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(244, 64).TopPosZ(192, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, SablonyLayout__layid&) { parent.LayoutId("SablonyLayout");
	layout.skupina.LeftPosZ(4, 184).TopPosZ(4, 184); layout.skupina.LayoutId("skupina"); parent.Add(layout.skupina);
	layout.screate.SetLabel(t_GetLngString("Nov")).LeftPosZ(4, 56).TopPosZ(188, 24); layout.screate.LayoutId("screate"); parent.Add(layout.screate);
	layout.srename.SetLabel(t_GetLngString("Pejmenovat")).LeftPosZ(60, 80).TopPosZ(188, 24); layout.srename.LayoutId("srename"); parent.Add(layout.srename);
	layout.sremove.SetLabel(t_GetLngString("Smazat")).LeftPosZ(140, 48).TopPosZ(188, 24); layout.sremove.LayoutId("sremove"); parent.Add(layout.sremove);
	layout.sablona.LeftPosZ(4, 184).TopPosZ(248, 220); layout.sablona.LayoutId("sablona"); parent.Add(layout.sablona);
	layout.dv___5.LeftPosZ(4, 184).TopPosZ(236, 8); layout.dv___5.LayoutId("dv___5"); parent.Add(layout.dv___5);
	layout.create.SetLabel(t_GetLngString("Nov")).LeftPosZ(4, 48).TopPosZ(468, 24); layout.create.LayoutId("create"); parent.Add(layout.create);
	layout.createas.SetLabel(t_GetLngString("Odvodit")).LeftPosZ(52, 88).TopPosZ(468, 24); layout.createas.LayoutId("createas"); parent.Add(layout.createas);
	layout.rename.SetLabel(t_GetLngString("Pejmenovat")).LeftPosZ(4, 88).TopPosZ(492, 24); layout.rename.LayoutId("rename"); parent.Add(layout.rename);
	layout.remove.SetLabel(t_GetLngString("Smazat")).LeftPosZ(140, 48).TopPosZ(468, 24); layout.remove.LayoutId("remove"); parent.Add(layout.remove);
	layout.move.SetLabel(t_GetLngString("-> Skupina..")).LeftPosZ(92, 96).TopPosZ(492, 24); layout.move.LayoutId("move"); parent.Add(layout.move);
	layout.pristup_lbl.SetLabel(t_GetLngString("Pstup")).LeftPosZ(4, 40).TopPosZ(216, 19); layout.pristup_lbl.LayoutId("pristup_lbl"); parent.Add(layout.pristup_lbl);
	layout.pristup.LeftPosZ(44, 144).TopPosZ(216, 19); layout.pristup.LayoutId("pristup"); parent.Add(layout.pristup);
	layout.typ.LeftPosZ(4, 184).TopPosZ(520, 19); layout.typ.LayoutId("typ"); parent.Add(layout.typ);
	layout.view.LeftPosZ(192, 552).TopPosZ(4, 536); layout.view.LayoutId("view"); parent.Add(layout.view);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, MacroLayout__layid&) { parent.LayoutId("MacroLayout");
	layout.macro.LeftPosZ(4, 288).TopPosZ(4, 536); layout.macro.LayoutId("macro"); parent.Add(layout.macro);
	layout.view.LeftPosZ(296, 496).TopPosZ(4, 408); layout.view.LayoutId("view"); parent.Add(layout.view);
	layout.ltext.LeftPosZ(296, 496).TopPosZ(416, 124); layout.ltext.LayoutId("ltext"); parent.Add(layout.ltext);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, SaveSablonaLayout__layid&) { parent.LayoutId("SaveSablonaLayout");
	layout.skupina.LeftPosZ(4, 188).TopPosZ(4, 176); layout.skupina.LayoutId("skupina"); parent.Add(layout.skupina);
	layout.sablona.LeftPosZ(4, 188).TopPosZ(184, 324); layout.sablona.LayoutId("sablona"); parent.Add(layout.sablona);
	layout.view.LeftPosZ(196, 580).TopPosZ(4, 504); layout.view.LayoutId("view"); parent.Add(layout.view);
	layout.save.SetLabel(t_GetLngString("Uloit do vybran")).LeftPosZ(4, 124).TopPosZ(516, 24); layout.save.LayoutId("save"); parent.Add(layout.save);
	layout.insert.SetLabel(t_GetLngString("Uloit do nov")).LeftPosZ(132, 124).TopPosZ(516, 24); layout.insert.LayoutId("insert"); parent.Add(layout.insert);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(712, 64).TopPosZ(516, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, SkupinaListLayout__layid&) { parent.LayoutId("SkupinaListLayout");
	layout.list.LeftPosZ(4, 208).TopPosZ(4, 300); layout.list.LayoutId("list"); parent.Add(layout.list);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(76, 64).TopPosZ(308, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(148, 64).TopPosZ(308, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};
#line 37 "u:/uppsrc\\CtrlCore/lay.h"







#line 10 "u:/idisapp\\IdisTDoc/IdisTDoc.h"

VectorMap<String, Value> QtfText(const VectorMap<String, Value>& var);

struct NamedText : Moveable<NamedText> {
	String name;
	String text;
};

RichText Expand(const char *qtf, const VectorMap<String, NamedText>& map);
RichText Purify(const RichText& text);

String MacroExpand(const char *term, const VectorMap<String, String>& macro);
String ExpandText(const String& text, const VectorMap<String, Value>& var, const VectorMap<String, String>& macro);
VectorMap<String, NamedText> MakeTData(const VectorMap<String, Value>& data,
                                       const VectorMap<String, String>& macro,
                                       const Vector<String>& name);

struct DataFieldCtrl : public Ctrl {
	virtual void Paint(Draw& w);
	virtual void LeftDouble(Point, dword);
	virtual Size GetMinSize() const         { int q = EditField::GetStdHeight(); return Size(q, q); }

	String text;

	Callback DblClick;

	void   Set(const String& t)             { text = t; Refresh(); }

	DataFieldCtrl()                         { SetFrame(InsetFrame()); }
};

struct SablonaName : WithSablonaNameLayout<TopWindow> {
	EditString edit;
	SablonaName(const char *name = "Jmno ablony");
};

struct DocPrint {
	String watermark_qtf;
	String footer;
	String header;

	void Print(Draw& w, const RichText& text, const Rect& page, int firstpage, int lastpage, int copies, bool collate, bool report = false);
	void Print(HDC hdc, const RichText& text, const Rect& page, int firstpage, int lastpage, int copies, bool collate, const char *name);
	bool Print(const RichText& text, const Rect& page, int currentpage);
	void Preview(const RichText& text, const Rect& page);
};

class TDoc : public Ctrl {
public:
	virtual void GotFocus()              { editor.SetFocus(); }

private:
	ToolBar                      toolbar;
	DataFieldCtrl                dfc;

	void ToolBar(Bar& bar);
	void SetToolBar();
	void NextField();
	void InsertDataField();
	void RemoveDataFieldStyle();
	void VarField();
	void Regen();
	void Repair();

	void Print(Draw& w, const RichText& text, const Rect& page, int firstpage, int lastpage,
	           int copies, bool collate);
	void Print(HDC hdc, const RichText& text, const Rect& page, int firstpage, int lastpage,
	           int copies, bool collate, const char *name);
	bool Print(const RichText& text, const Rect& page, int currentpage);

public:
	RichEdit                     editor;
	VectorMap<String, NamedText> data;
	VectorMap<String, Index<String> > *repair_base[2];

	String notes_odbor;
	String notes_cj;
	String notes_rok;

	String notes_vec;
	String notes_adresat;
	String notes_ulice;
	String notes_mesto;
	String notes_zeme;
	String notes_psc;

	String notes_ccj;

	String header;
	String footer;

	bool   notes;


	void   SetText(const char *qtf)      { editor.SetQTF(qtf); }

	String GetText() const;
	String GetPurifiedText() const;

	bool   Execute();

	void   Pdf();
	void   DoPrint(bool preview = false);

	Callback WhenNotes;
	Callback WhenSaveTDoc;

	typedef TDoc CLASSNAME;

	TDoc();
};

void   SablonyEdit(const VectorMap<String, Value>& vars);



struct TDocS {
	SqlId SABLONA, SABLONA_SEQ, NAZEV, TEXT, SKUPINA, SKUPINA_SEQ, SNAZEV;
	SqlId MACRO, MACRO_SEQ, ID, MNAZEV, LTEXT;
	SqlSequence *Seq;
	SqlId TYP, PRISTUP;
	WithDeepCopy< VectorMap<Value, String> > typlist;
};

void EditMacros(const TDocS& ids, const VectorMap<String, Value>& data);

void LoadMacros(TDocS& ts, VectorMap<String, String>& macro, Vector<String>& name);

void EditSablony(const TDocS& ids, const VectorMap<String, NamedText>& data);
void SaveSablona(const String& text, const TDocS& ids,
                 const VectorMap<String, NamedText>& data, Value typ = Null);

void ExportDocs(const TDocS& ids);
void ImportDocs(const TDocS& ids);

extern int tdoc_skupina_seq;

struct TDocDlg {
	TDocS         ts;
	TimeCallback  tm;
	ArrayCtrl     skupina, sablona;
	RichTextView  view;

	virtual void SablonaChanged() {}
	virtual VectorMap<String, Value> MakeVars() = 0;

	void Skupina();
	void SablonaCursor();

	void CreateMode(Ctrl& p);
	void SablonaRefresh();
	void EndCreateMode();

	Callback DataCall() {
		return callback2(&tm, &TimeCallback::KillSet, 300, callback(this, &CLASSNAME::SablonaRefresh));
	}

	typedef TDocDlg CLASSNAME;

	TDocDlg(TDocS ts);
};

extern String DocSettings;
void LoadDocSettings(TopWindow& win, RichEdit& e);
void SaveDocSettings(TopWindow& win, RichEdit& e);

#line 177 "u:/idisapp\\IdisTDoc/IdisTDoc.h"
#line 10 "u:/idisapp\\IdisDoc/IdisDoc.h"


#line 1 "u:/uppsrc\\CtrlCore/lay.h"







#line 1 "u:\\idisapp\\idisdoc\\IdisDoc.lay"
struct SablonaLayout__layid {};












struct LoadFsLayout__layid {};





#line 9 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:\\idisapp\\idisdoc\\IdisDoc.lay"
template<class T> struct WithSablonaLayout : public T, public SablonaLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(784, 568); }
	SqlArray sablona;
	Label dv___1;
	DropList skupina;
	SqlArray makro;
	DocEdit text;
	RichTextView view;
	DropList polozka;
	DropList kategorie;
	DocEdit makrod;
	LabelBox dv___9;
};

template<class T> struct WithLoadFsLayout : public T, public LoadFsLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(692, 592); }
	ArrayCtrl list;
	RichTextView preview;
	Button ok;
	Button cancel;
};
#line 23 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:\\idisapp\\idisdoc\\IdisDoc.lay"
template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, SablonaLayout__layid&) { parent.LayoutId("SablonaLayout");
	layout.sablona.LeftPosZ(4, 180).VSizePosZ(8, 344); layout.sablona.LayoutId("sablona"); parent.Add(layout.sablona);
	layout.dv___1.SetLabel(t_GetLngString("Skupina")).LeftPosZ(4, 48).BottomPosZ(321, 19); layout.dv___1.LayoutId("dv___1"); parent.Add(layout.dv___1);
	layout.skupina.LeftPosZ(52, 132).BottomPosZ(321, 19); layout.skupina.LayoutId("skupina"); parent.Add(layout.skupina);
	layout.makro.LeftPosZ(4, 180).BottomPosZ(8, 296); layout.makro.LayoutId("makro"); parent.Add(layout.makro);
	layout.text.HSizePosZ(192, 8).TopPosZ(8, 168); layout.text.LayoutId("text"); parent.Add(layout.text);
	layout.view.HSizePosZ(192, 8).VSizePosZ(180, 144); layout.view.LayoutId("view"); parent.Add(layout.view);
	layout.polozka.LeftPosZ(192, 584).TopPosZ(428, 19); layout.polozka.LayoutId("polozka"); parent.Add(layout.polozka);
	layout.kategorie.LeftPosZ(192, 584).TopPosZ(452, 19); layout.kategorie.LayoutId("kategorie"); parent.Add(layout.kategorie);
	layout.makrod.HSizePosZ(192, 8).BottomPosZ(8, 84); layout.makrod.LayoutId("makrod"); parent.Add(layout.makrod);
	layout.dv___9.LeftPosZ(4, 180).BottomPosZ(312, 4); layout.dv___9.LayoutId("dv___9"); parent.Add(layout.dv___9);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, LoadFsLayout__layid&) { parent.LayoutId("LoadFsLayout");
	layout.list.LeftPosZ(4, 160).TopPosZ(4, 584); layout.list.LayoutId("list"); parent.Add(layout.list);
	layout.preview.LeftPosZ(168, 520).TopPosZ(4, 544); layout.preview.LayoutId("preview"); parent.Add(layout.preview);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(552, 64).TopPosZ(560, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(620, 64).TopPosZ(560, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};
#line 37 "u:/uppsrc\\CtrlCore/lay.h"







#line 13 "u:/idisapp\\IdisDoc/IdisDoc.h"

struct SablonaIds {
	SqlId MAKRO;
	SqlId MAKRO_SEQ;

	SqlId SKUPINA;
	SqlId SKUPINA_SEQ;

	SqlId SABLONA;
	SqlId SABLONA_SEQ;

	SqlId NAZEV;
	SqlId TEXT;

	SqlId SEQ;

	SqlId POLOZKA_SEQ;
	SqlId KATEGORIE;

	bool  notes;
	bool  notescj;
	bool  longraw;
	bool  typ;

	void  (*lib)(ArrayMap<String, EscValue>&);
};

extern SablonaIds ids;

void   RefreshDocMacro();
String GetDocMacro(const String& key);
String ExpandDoc(const String& doc, const VectorMap<String, Value>& var, bool keepcrlf = false);
String ExpandDocW(const String& doc, VectorMap<String, Value>& var);

void SetDocIds(SqlId makro, SqlId skupina, SqlId sablona, SqlId seq,
               bool notes = false, bool longraw = false, bool typ = false);
void SetDocLib(void (*lib)(ArrayMap<String, EscValue>&));

void EditSablony(const VectorMap<String, Value>& vars,
                 const VectorMap<Value, String>& polozka, const VectorMap<Value, String>& kategorie);
void EditSablony(const VectorMap<String, Value>& vars);

struct DocCtrls : StaticRect {
	ArrayCtrl     skupina;
	ArrayCtrl     sablona;
	RichTextView  preview;
	RichEdit      editor;
	RichTextView  view;
	Button        edit;
	Button        create;
	ToolBar       toolbar;

	void DocBar(Bar& bar);
	void NextField();
	void Notes(bool samostatne);
	void RefreshBar();
	void Create(const String& g);
	void EditView();
	void LoadSablony();
	void View();

	String backupfile;

	void AutoBackup();
	void Save(bool autob);
	void Load();
	void Pdf();

	typedef DocCtrls CLASSNAME;

	Callback WhenNotes;

	void   SetAdresa(int adresa_seq);
	void   SetOsoba(int osoba_seq);


	String prijmeni, jmeno;
	String ulice;
	String mesto;
	String zeme;
	String psc;

	String vec;
	String odbor;
	String cj;
	String rok;
	Date   datum;
	bool   createspis;

	String ccj;

	DocCtrls();
};

void DocPortMenu(Bar& bar);

void TConvert(TDocS& ts, int jskupina_seq = 0, const char *snazev = "Jin");

#line 112 "u:/idisapp\\IdisDoc/IdisDoc.h"
#line 8 "u:\\idisapp\\matrika2\\Matrika.h"
#line 1 "u:/idisapp\\FormDesign/FormDesign.h"



#line 1 "u:/idisapp\\IdisMisc/IdisMisc.h"
























































































































































































































































































































































































































































































































































































































































































































































































































#line 5 "u:/idisapp\\FormDesign/FormDesign.h"
#line 1 "u:/uppsrc\\Esc/Esc.h"

























































































































































































































































































































#line 6 "u:/idisapp\\FormDesign/FormDesign.h"
#line 1 "u:/idisapp\\IdisDoc/IdisDoc.h"















































































































#line 7 "u:/idisapp\\FormDesign/FormDesign.h"
#line 1 "u:/uppsrc\\plugin/tif/tif.h"



#line 1 "u:/uppsrc\\Draw/Draw.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 5 "u:/uppsrc\\plugin/tif/tif.h"


namespace Upp {

class TIFRaster : public StreamRaster {
public:
	struct Data;
	One<Data> data;

public:
	TIFRaster();
	~TIFRaster();

	virtual bool                Create();
	virtual Size                GetSize();
	virtual Info                GetInfo();
	virtual Line                GetLine(int line);
	virtual int                 GetPaletteCount();
	virtual const RGBA         *GetPalette();
	virtual const RasterFormat *GetFormat();

	virtual int                 GetPageCount();
	virtual void                SeekPage(int n);

private:
	bool                        Init();
};

class TIFEncoder : public StreamRasterEncoder {
public:
	class Data;
	One<Data> data;

public:
	TIFEncoder(int bpp = 24);
	~TIFEncoder();

	TIFEncoder&  Bpp(int b)       { bpp = b; return *this; }

	virtual int  GetPaletteCount();
	virtual void Start(Size sz);
	virtual void WriteLineRaw(const byte *s);

private:
	int bpp;
};

};

#line 55 "u:/uppsrc\\plugin/tif/tif.h"
#line 8 "u:/idisapp\\FormDesign/FormDesign.h"
#line 1 "u:/uppsrc\\plugin/gif/gif.h"



#line 1 "u:/uppsrc\\Draw/Draw.h"







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 5 "u:/uppsrc\\plugin/gif/gif.h"


namespace Upp {

class GIFRaster : public StreamRaster {
public:
	class Data;
	One<Data> data;

public:
	GIFRaster();
	~GIFRaster();

	virtual bool               Create();
	virtual Size               GetSize();
	virtual Info               GetInfo();
	virtual Line               GetLine(int line);
	virtual const RasterFormat *GetFormat();
	virtual int                GetPaletteCount();
	virtual RGBA               *GetPalette();

private:
	bool                       Init();
};

class GIFEncoder : public StreamRasterEncoder {
public:
	class Data;
	One<Data> data;

public:
	GIFEncoder(bool ignore_alpha = false, String comment = Null);
	~GIFEncoder();

	GIFEncoder&  IgnoreAlpha(bool ia = true) { ignore_alpha = ia; return *this; }
	GIFEncoder&  Comment(String c)           { comment = c; return *this; }

	virtual int  GetPaletteCount();
	virtual void Start(Size sz);
	virtual void WriteLineRaw(const byte *s);

private:
	bool         ignore_alpha;
	String       comment;
};

};

#line 54 "u:/uppsrc\\plugin/gif/gif.h"
#line 9 "u:/idisapp\\FormDesign/FormDesign.h"



#line 1 "u:/uppsrc\\Sql/sch_header.h"

































#line 1 "u:/uppsrc\\Oracle/OracleSchema.h"


























































#line 60 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 65 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 70 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 75 "u:/uppsrc\\Oracle/OracleSchema.h"















#line 1 "u:/uppsrc\\Sql/sch_model.h"








#line 10 "u:/uppsrc\\Sql/sch_model.h"
















#line 27 "u:/uppsrc\\Sql/sch_model.h"
















#line 44 "u:/uppsrc\\Sql/sch_model.h"







#line 52 "u:/uppsrc\\Sql/sch_model.h"











#line 64 "u:/uppsrc\\Sql/sch_model.h"







#line 72 "u:/uppsrc\\Sql/sch_model.h"







#line 80 "u:/uppsrc\\Sql/sch_model.h"



#line 84 "u:/uppsrc\\Sql/sch_model.h"



#line 88 "u:/uppsrc\\Sql/sch_model.h"



#line 92 "u:/uppsrc\\Sql/sch_model.h"



#line 96 "u:/uppsrc\\Sql/sch_model.h"



#line 100 "u:/uppsrc\\Sql/sch_model.h"



#line 104 "u:/uppsrc\\Sql/sch_model.h"



#line 108 "u:/uppsrc\\Sql/sch_model.h"



#line 112 "u:/uppsrc\\Sql/sch_model.h"



#line 116 "u:/uppsrc\\Sql/sch_model.h"







#line 124 "u:/uppsrc\\Sql/sch_model.h"




















#line 145 "u:/uppsrc\\Sql/sch_model.h"



#line 149 "u:/uppsrc\\Sql/sch_model.h"



#line 153 "u:/uppsrc\\Sql/sch_model.h"



#line 157 "u:/uppsrc\\Sql/sch_model.h"



#line 161 "u:/uppsrc\\Sql/sch_model.h"

#line 1 "u:\\idisapp\\formdesign\\FormDesign.sch"
 struct S_MAT_FORM  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_MAT_FORM::FieldLayout); } S_MAT_FORM();
	 enum { MAT_FORM_SEQ_WIDTH = 0, MAT_FORM_SEQ_PRECISION = 0 }; int MAT_FORM_SEQ;
	enum { NAZEV_WIDTH = 200, NAZEV_PRECISION = 0 }; String NAZEV;
	 enum { LANDSCAPE_WIDTH = 0, LANDSCAPE_PRECISION = 0 }; bool LANDSCAPE;
	 enum { IMAGE_WIDTH = 0, IMAGE_PRECISION = 0 }; String IMAGE;
	 enum { CX_WIDTH = 0, CX_PRECISION = 0 }; int CX;
	 enum { CY_WIDTH = 0, CY_PRECISION = 0 }; int CY;
	 enum { DX_WIDTH = 0, DX_PRECISION = 0 }; double DX;
	 enum { DY_WIDTH = 0, DY_PRECISION = 0 }; double DY;
};

 struct S_MAT_FORM_ITEM  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_MAT_FORM_ITEM::FieldLayout); } S_MAT_FORM_ITEM();
	enum { MAT_FORM_SEQ_WIDTH = 0, MAT_FORM_SEQ_PRECISION = 0 }; int MAT_FORM_SEQ;
	 enum { NDX_WIDTH = 0, NDX_PRECISION = 0 }; int NDX;
	 enum { X_WIDTH = 0, X_PRECISION = 0 }; int X;
	 enum { Y_WIDTH = 0, Y_PRECISION = 0 }; int Y;
	 enum { XX_WIDTH = 0, XX_PRECISION = 0 }; int XX;
	 enum { YY_WIDTH = 0, YY_PRECISION = 0 }; int YY;
	enum { TEXT_WIDTH = 2000, TEXT_PRECISION = 0 }; String TEXT;
};
#line 163 "u:/uppsrc\\Sql/sch_model.h"




































#line 91 "u:/uppsrc\\Oracle/OracleSchema.h"





















































#line 35 "u:/uppsrc\\Sql/sch_header.h"










#line 1 "u:/uppsrc\\Oracle/OracleSchema.h"


























































#line 60 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 65 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 70 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 75 "u:/uppsrc\\Oracle/OracleSchema.h"















#line 1 "u:/uppsrc\\Sql/sch_model.h"








#line 10 "u:/uppsrc\\Sql/sch_model.h"
















#line 27 "u:/uppsrc\\Sql/sch_model.h"




















#line 48 "u:/uppsrc\\Sql/sch_model.h"



#line 52 "u:/uppsrc\\Sql/sch_model.h"



#line 56 "u:/uppsrc\\Sql/sch_model.h"



#line 60 "u:/uppsrc\\Sql/sch_model.h"



#line 64 "u:/uppsrc\\Sql/sch_model.h"



#line 68 "u:/uppsrc\\Sql/sch_model.h"



#line 72 "u:/uppsrc\\Sql/sch_model.h"



#line 76 "u:/uppsrc\\Sql/sch_model.h"



#line 80 "u:/uppsrc\\Sql/sch_model.h"



#line 84 "u:/uppsrc\\Sql/sch_model.h"



#line 88 "u:/uppsrc\\Sql/sch_model.h"



#line 92 "u:/uppsrc\\Sql/sch_model.h"



#line 96 "u:/uppsrc\\Sql/sch_model.h"



#line 100 "u:/uppsrc\\Sql/sch_model.h"



#line 104 "u:/uppsrc\\Sql/sch_model.h"



#line 108 "u:/uppsrc\\Sql/sch_model.h"



#line 112 "u:/uppsrc\\Sql/sch_model.h"



#line 116 "u:/uppsrc\\Sql/sch_model.h"



#line 120 "u:/uppsrc\\Sql/sch_model.h"



#line 124 "u:/uppsrc\\Sql/sch_model.h"



#line 128 "u:/uppsrc\\Sql/sch_model.h"







#line 136 "u:/uppsrc\\Sql/sch_model.h"








#line 145 "u:/uppsrc\\Sql/sch_model.h"



#line 149 "u:/uppsrc\\Sql/sch_model.h"



#line 153 "u:/uppsrc\\Sql/sch_model.h"



#line 157 "u:/uppsrc\\Sql/sch_model.h"



#line 161 "u:/uppsrc\\Sql/sch_model.h"

#line 1 "u:\\idisapp\\formdesign\\FormDesign.sch"
extern SqlId MAT_FORM;
	extern SqlId MAT_FORM_SEQ;

	extern SqlId LANDSCAPE;
	extern SqlId IMAGE;
	extern SqlId CX;
	extern SqlId CY;
	extern SqlId DX;
	extern SqlId DY;


extern SqlId MAT_FORM_ITEM;

	extern SqlId NDX;
	extern SqlId X;
	extern SqlId Y;
	extern SqlId XX;
	extern SqlId YY;


#line 163 "u:/uppsrc\\Sql/sch_model.h"




































#line 91 "u:/uppsrc\\Oracle/OracleSchema.h"





















































#line 46 "u:/uppsrc\\Sql/sch_header.h"
#line 13 "u:/idisapp\\FormDesign/FormDesign.h"




#line 1 "u:/uppsrc\\CtrlCore/lay.h"







#line 1 "u:/idisapp\\FormDesign/FormDesign.lay"
struct FormsLayout__layid {};







struct DrawingPreviewLayout__layid {};





#line 9 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/idisapp\\FormDesign/FormDesign.lay"
template<class T> struct WithFormsLayout : public T, public FormsLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(400, 212); }
	SqlArray list;
	Button png;
	Button edit;
	Button save;
	Button exit;
};

template<class T> struct WithDrawingPreviewLayout : public T, public DrawingPreviewLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(680, 692); }

	Button ok;
	Button cancel;
};

#line 23 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/idisapp\\FormDesign/FormDesign.lay"
template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, FormsLayout__layid&) { parent.LayoutId("FormsLayout");
	layout.list.LeftPosZ(8, 384).TopPosZ(8, 164); layout.list.LayoutId("list"); parent.Add(layout.list);
	layout.png.SetLabel(t_GetLngString("Nast pozad..")).RightPosZ(300, 92).BottomPosZ(8, 24); layout.png.LayoutId("png"); parent.Add(layout.png);
	layout.edit.SetLabel(t_GetLngString("Editor...")).RightPosZ(204, 92).BottomPosZ(8, 24); layout.edit.LayoutId("edit"); parent.Add(layout.edit);
	layout.save.SetLabel(t_GetLngString("Uloit pozad..")).RightPosZ(108, 92).BottomPosZ(8, 24); layout.save.LayoutId("save"); parent.Add(layout.save);
	layout.exit.SetLabel(t_GetLngString("Zavt")).RightPosZ(8, 64).BottomPosZ(8, 24); layout.exit.LayoutId("exit"); parent.Add(layout.exit);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, DrawingPreviewLayout__layid&) { parent.LayoutId("DrawingPreviewLayout");
	uts.drawing.LeftPosZ(8, 664).TopPosZ(8, 644); uts.drawing.LayoutId("drawing"); parent.Add(uts.drawing);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(540, 64).TopPosZ(660, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(608, 64).TopPosZ(660, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

#line 37 "u:/uppsrc\\CtrlCore/lay.h"







#line 18 "u:/idisapp\\FormDesign/FormDesign.h"



#line 1 "u:/uppsrc\\Draw/iml_header.h"













class FormDesignImg {
public:


	enum {
#line 1 "u:/idisapp\\FormDesign/FormDesign.iml"
I_Select,

















I_Lib,
















I_Field,














I_DeleteField,

















I_ZoomIn,
















I_ZoomOut,
















I_Grid,
















I_Landscape,













#line 20 "u:/uppsrc\\Draw/iml_header.h"
		COUNT
	};



public:
	static Upp::Iml&   Iml();

	static void        Register__()                { Register("FormDesignImg", Iml()); }

	static int         Find(const Upp::String& s);
	static int         Find(const char *s);
	static int         GetCount()                  { return Iml().GetCount(); }
	static Upp::String GetId(int i)                { return Iml().GetId(i); }

	static Upp::Image  Get(int i);
	static Upp::Image  Get(const char *s);
	static Upp::Image  Get(const Upp::String& s);

	static void   Set(int i, const Upp::Image& m);
	static void   Set(const char *s, const Upp::Image& m);

	static void   Reset()                     { Iml().Reset(); }



#line 1 "u:/idisapp\\FormDesign/FormDesign.iml"
static Upp::Image Select() { return Get(I_Select); }

















static Upp::Image Lib() { return Get(I_Lib); }
















static Upp::Image Field() { return Get(I_Field); }














static Upp::Image DeleteField() { return Get(I_DeleteField); }

















static Upp::Image ZoomIn() { return Get(I_ZoomIn); }
















static Upp::Image ZoomOut() { return Get(I_ZoomOut); }
















static Upp::Image Grid() { return Get(I_Grid); }
















static Upp::Image Landscape() { return Get(I_Landscape); }













#line 47 "u:/uppsrc\\Draw/iml_header.h"



};












#line 64 "u:/uppsrc\\Draw/iml_header.h"
#line 22 "u:/idisapp\\FormDesign/FormDesign.h"

void FormModel(SqlSchema& sch);

extern String EscLib;
extern int    mat_seq_low;
extern int    mat_seq_high;

class FormDesign : public StaticRect {
public:
	virtual void  Paint(Draw& w);
	virtual bool  Key(dword key, int);
	virtual void  LeftDown(Point p, dword);
	virtual void  RightDown(Point p, dword);
	virtual void  MouseMove(Point p, dword);
	virtual void  LeftUp(Point p, dword);
	virtual Image CursorImage(Point p, dword flags);
	virtual void  GotFocus();
	virtual void  LostFocus();
	virtual void  Layout();

protected:

	String     image;


#line 48 "u:/idisapp\\FormDesign/FormDesign.h"
	Image      imagecache;
	Size       pgsz;
	ScrollBars sb;
	int        zoom;
	ToolBar    bar;
	DocEdit    text;
	Button     id;
	PopUpTable textid;
	ArrayCtrl  item;
	Splitter   form_text;
	EditDoubleSpin dx, dy;
	Label      dxlbl, dylbl;

	int             draghandle;
	Point           dragbase;
	Rect            dragrect;

	bool            grid;
	bool            landscape;

	FrameRight<Label> position;

	Point        Isz();
	Point        Origin();
	Point        PagePos(Point p);
	Rect         GetItemRect(int i);
	Vector<Rect> GetHandles(const Rect& r);
	void         SetSb();
	void         Scroll();
	void         Delete();
	void         ChangeZoom(int d);
	int          FindHandle(Point p);
	void         MainBar(Bar& bar);
	void         SetBar();
	void         ToggleGrid();
	void         ToggleLandscape()                           { landscape = !landscape; SetBar(); }
	void         SetCursor(int c);
	void         Text();
	void         ItemAction();
	void         EnterItem();
	int          Grid(int x);
	void         Id();
	void         TextId();
	void         TestPrint();
	void         UserLib();

public:

	void Set(const String& image, Size dots);


#line 100 "u:/idisapp\\FormDesign/FormDesign.h"

	Splitter                  ctrl;
	VectorMap<String, Value>  var;
	void                    (*lib)(ArrayMap<String, EscValue>&);
	String                    userlib;

	int                       GetCount() const                      { return item.GetCount(); }
	Rect                      GetRect(int i) const                  { return item.Get(i, 1); }
	String                    GetText(int i) const                  { return item.Get(i, 0); }

	void                      Clear()                               { item.Clear(); Refresh(); }
	void                      Add(const Rect& r, const String& text){ item.Add(text, r); Refresh(); }

	void                      SetOffset(double _dx, double _dy)     { dx <<= _dx; dy <<= _dy; }
	Pointf                    GetOffset() const                     { return Pointf(dx, dy); }

	void                      SetLandscape(bool b = true)           { landscape = b; SetBar(); }
	bool                      GetLandscape() const                  { return landscape; }

	void                      PaintPage(Draw& w, Point off, bool img);
	Size                      GetPageSize() const                   { return pgsz; }

	void                      Print(bool img);

	typedef FormDesign CLASSNAME;

	FormDesign();
};

struct Forms : public WithFormsLayout<TopWindow> {
	EditString               text;
	VectorMap<String, Value> var;

	void ListCursor();
	void LoadPng();
	void Edit();
	void SavePng();

	typedef Forms CLASSNAME;

	Forms();
};


bool PreviewDrawing(const Drawing& g);

void Print(int type, const VectorMap<String, Value>& vars, bool kopie);

#line 149 "u:/idisapp\\FormDesign/FormDesign.h"
#line 9 "u:\\idisapp\\matrika2\\Matrika.h"



#line 1 "u:/uppsrc\\Draw/iml_header.h"













class MatrikaImg {
public:


	enum {
#line 1 "u:/idisapp\\Matrika2/Matrika.iml"

I_Latin,
I_Narozeni,
I_OsvCr,
I_Vysvedceni,
I_List,
I_Osvedceni,
I_Matrika,

I_Manzelstvi,
I_Umrti,
I_Vypis,
I_Rejstrik,
I_Dots,
I_Dots1,





























#line 20 "u:/uppsrc\\Draw/iml_header.h"
		COUNT
	};



public:
	static Upp::Iml&   Iml();

	static void        Register__()                { Register("MatrikaImg", Iml()); }

	static int         Find(const Upp::String& s);
	static int         Find(const char *s);
	static int         GetCount()                  { return Iml().GetCount(); }
	static Upp::String GetId(int i)                { return Iml().GetId(i); }

	static Upp::Image  Get(int i);
	static Upp::Image  Get(const char *s);
	static Upp::Image  Get(const Upp::String& s);

	static void   Set(int i, const Upp::Image& m);
	static void   Set(const char *s, const Upp::Image& m);

	static void   Reset()                     { Iml().Reset(); }



#line 1 "u:/idisapp\\Matrika2/Matrika.iml"

static Upp::Image Latin() { return Get(I_Latin); }
static Upp::Image Narozeni() { return Get(I_Narozeni); }
static Upp::Image OsvCr() { return Get(I_OsvCr); }
static Upp::Image Vysvedceni() { return Get(I_Vysvedceni); }
static Upp::Image List() { return Get(I_List); }
static Upp::Image Osvedceni() { return Get(I_Osvedceni); }
static Upp::Image Matrika() { return Get(I_Matrika); }

static Upp::Image Manzelstvi() { return Get(I_Manzelstvi); }
static Upp::Image Umrti() { return Get(I_Umrti); }
static Upp::Image Vypis() { return Get(I_Vypis); }
static Upp::Image Rejstrik() { return Get(I_Rejstrik); }
static Upp::Image Dots() { return Get(I_Dots); }
static Upp::Image Dots1() { return Get(I_Dots1); }





























#line 47 "u:/uppsrc\\Draw/iml_header.h"



};












#line 64 "u:/uppsrc\\Draw/iml_header.h"
#line 13 "u:\\idisapp\\matrika2\\Matrika.h"



#line 1 "u:/uppsrc\\Sql/sch_header.h"

































#line 1 "u:/uppsrc\\Oracle/OracleSchema.h"


























































#line 60 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 65 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 70 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 75 "u:/uppsrc\\Oracle/OracleSchema.h"















#line 1 "u:/uppsrc\\Sql/sch_model.h"








#line 10 "u:/uppsrc\\Sql/sch_model.h"
















#line 27 "u:/uppsrc\\Sql/sch_model.h"
















#line 44 "u:/uppsrc\\Sql/sch_model.h"







#line 52 "u:/uppsrc\\Sql/sch_model.h"











#line 64 "u:/uppsrc\\Sql/sch_model.h"







#line 72 "u:/uppsrc\\Sql/sch_model.h"







#line 80 "u:/uppsrc\\Sql/sch_model.h"



#line 84 "u:/uppsrc\\Sql/sch_model.h"



#line 88 "u:/uppsrc\\Sql/sch_model.h"



#line 92 "u:/uppsrc\\Sql/sch_model.h"



#line 96 "u:/uppsrc\\Sql/sch_model.h"



#line 100 "u:/uppsrc\\Sql/sch_model.h"



#line 104 "u:/uppsrc\\Sql/sch_model.h"



#line 108 "u:/uppsrc\\Sql/sch_model.h"



#line 112 "u:/uppsrc\\Sql/sch_model.h"



#line 116 "u:/uppsrc\\Sql/sch_model.h"







#line 124 "u:/uppsrc\\Sql/sch_model.h"




















#line 145 "u:/uppsrc\\Sql/sch_model.h"



#line 149 "u:/uppsrc\\Sql/sch_model.h"



#line 153 "u:/uppsrc\\Sql/sch_model.h"



#line 157 "u:/uppsrc\\Sql/sch_model.h"



#line 161 "u:/uppsrc\\Sql/sch_model.h"

#line 1 "u:\\idisapp\\matrika2\\Matrika.sch"


struct S_MOSOBA  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_MOSOBA::FieldLayout); } S_MOSOBA();
	enum { OSOBA_SEQ_WIDTH = 0, OSOBA_SEQ_PRECISION = 0 }; int OSOBA_SEQ;
	enum { JMENO_WIDTH = 200, JMENO_PRECISION = 0 }; String JMENO;
	 enum { JMENO_Z_WIDTH = 0, JMENO_Z_PRECISION = 0 }; bool JMENO_Z;
	 enum { PRIJMENI_WIDTH = 200, PRIJMENI_PRECISION = 0 }; String PRIJMENI;
	 enum { PRIJMENI_Z_WIDTH = 0, PRIJMENI_Z_PRECISION = 0 }; bool PRIJMENI_Z;
	 enum { RPRIJMENI_WIDTH = 200, RPRIJMENI_PRECISION = 0 }; String RPRIJMENI;
	 enum { RPRIJMENI_Z_WIDTH = 0, RPRIJMENI_Z_PRECISION = 0 }; bool RPRIJMENI_Z;
	 enum { RPRIJMENIO_WIDTH = 0, RPRIJMENIO_PRECISION = 0 }; bool RPRIJMENIO;
	enum { RC_WIDTH = 200, RC_PRECISION = 0 }; String RC;
	 enum { RC_Z_WIDTH = 0, RC_Z_PRECISION = 0 }; bool RC_Z;
	enum { DAT_NAR_WIDTH = 0, DAT_NAR_PRECISION = 0 }; Date DAT_NAR;
	 enum { DAT_NAR_Z_WIDTH = 0, DAT_NAR_Z_PRECISION = 0 }; bool DAT_NAR_Z;
	 enum { POHLAVI_WIDTH = 10, POHLAVI_PRECISION = 0 }; String POHLAVI;
	 enum { POHLAVI_Z_WIDTH = 0, POHLAVI_Z_PRECISION = 0 }; bool POHLAVI_Z;
	enum { MISTO_NAR_WIDTH = 200, MISTO_NAR_PRECISION = 0 }; String MISTO_NAR;
	 enum { MISTO_NAR_Z_WIDTH = 0, MISTO_NAR_Z_PRECISION = 0 }; bool MISTO_NAR_Z;
	 enum { OKRES_NAR_WIDTH = 200, OKRES_NAR_PRECISION = 0 }; String OKRES_NAR;
	 enum { OKRES_NAR_Z_WIDTH = 0, OKRES_NAR_Z_PRECISION = 0 }; bool OKRES_NAR_Z;
	 enum { OBCANSTVI_WIDTH = 200, OBCANSTVI_PRECISION = 0 }; String OBCANSTVI;
	 enum { OBCANSTVI_Z_WIDTH = 0, OBCANSTVI_Z_PRECISION = 0 }; bool OBCANSTVI_Z;
	enum { STAV_WIDTH = 1, STAV_PRECISION = 0 }; String STAV;
	 enum { STAV_Z_WIDTH = 0, STAV_Z_PRECISION = 0 }; bool STAV_Z;
	 enum { ULICE_WIDTH = 200, ULICE_PRECISION = 0 }; String ULICE;
	 enum { ULICE_Z_WIDTH = 0, ULICE_Z_PRECISION = 0 }; bool ULICE_Z;
	enum { CISLO_WIDTH = 200, CISLO_PRECISION = 0 }; String CISLO;
	 enum { CISLO_Z_WIDTH = 0, CISLO_Z_PRECISION = 0 }; bool CISLO_Z;
	 enum { OBEC_WIDTH = 200, OBEC_PRECISION = 0 }; String OBEC;
	 enum { OBEC_Z_WIDTH = 0, OBEC_Z_PRECISION = 0 }; bool OBEC_Z;
	 enum { OKRES_WIDTH = 200, OKRES_PRECISION = 0 }; String OKRES;
	 enum { OKRES_Z_WIDTH = 0, OKRES_Z_PRECISION = 0 }; bool OKRES_Z;
	 enum { DOKLAD_WIDTH = 200, DOKLAD_PRECISION = 0 }; String DOKLAD;
	 enum { DOKLAD_Z_WIDTH = 0, DOKLAD_Z_PRECISION = 0 }; bool DOKLAD_Z;

	enum { JMENOA_WIDTH = 200, JMENOA_PRECISION = 0 }; String JMENOA;
	 enum { PRIJMENIA_WIDTH = 200, PRIJMENIA_PRECISION = 0 }; String PRIJMENIA;
};

struct S_MOSOBA2  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_MOSOBA2::FieldLayout); } S_MOSOBA2();
	enum { OSOBA_SEQ_WIDTH = 0, OSOBA_SEQ_PRECISION = 0 }; int OSOBA_SEQ;
	enum { JMENO_WIDTH = 200, JMENO_PRECISION = 0 }; String JMENO;
	 enum { JMENO_Z_WIDTH = 0, JMENO_Z_PRECISION = 0 }; bool JMENO_Z;
	enum { PRIJMENI_WIDTH = 200, PRIJMENI_PRECISION = 0 }; String PRIJMENI;
	 enum { PRIJMENI_Z_WIDTH = 0, PRIJMENI_Z_PRECISION = 0 }; bool PRIJMENI_Z;
	enum { RPRIJMENI_WIDTH = 200, RPRIJMENI_PRECISION = 0 }; String RPRIJMENI;
	 enum { RPRIJMENI_Z_WIDTH = 0, RPRIJMENI_Z_PRECISION = 0 }; bool RPRIJMENI_Z;
	enum { RPRIJMENIO_WIDTH = 0, RPRIJMENIO_PRECISION = 0 }; bool RPRIJMENIO;
	enum { RC_WIDTH = 200, RC_PRECISION = 0 }; String RC;
	 enum { RC_Z_WIDTH = 0, RC_Z_PRECISION = 0 }; bool RC_Z;
	enum { DAT_NAR_WIDTH = 200, DAT_NAR_PRECISION = 0 }; String DAT_NAR;
	 enum { DAT_NAR_Z_WIDTH = 0, DAT_NAR_Z_PRECISION = 0 }; bool DAT_NAR_Z;
	enum { POHLAVI_WIDTH = 200, POHLAVI_PRECISION = 0 }; String POHLAVI;
	  enum { POHLAVI_Z_WIDTH = 0, POHLAVI_Z_PRECISION = 0 }; bool POHLAVI_Z;
	enum { MISTO_NAR_WIDTH = 200, MISTO_NAR_PRECISION = 0 }; String MISTO_NAR;
	 enum { MISTO_NAR_Z_WIDTH = 0, MISTO_NAR_Z_PRECISION = 0 }; bool MISTO_NAR_Z;
	enum { OKRES_NAR_WIDTH = 200, OKRES_NAR_PRECISION = 0 }; String OKRES_NAR;
	 enum { OKRES_NAR_Z_WIDTH = 0, OKRES_NAR_Z_PRECISION = 0 }; bool OKRES_NAR_Z;
	enum { OBCANSTVI_WIDTH = 200, OBCANSTVI_PRECISION = 0 }; String OBCANSTVI;
	 enum { OBCANSTVI_Z_WIDTH = 0, OBCANSTVI_Z_PRECISION = 0 }; bool OBCANSTVI_Z;
	enum { STAV_WIDTH = 200, STAV_PRECISION = 0 }; String STAV;
	  enum { STAV_Z_WIDTH = 0, STAV_Z_PRECISION = 0 }; bool STAV_Z;
	enum { ULICE_WIDTH = 200, ULICE_PRECISION = 0 }; String ULICE;
	 enum { ULICE_Z_WIDTH = 0, ULICE_Z_PRECISION = 0 }; bool ULICE_Z;
	enum { CISLO_WIDTH = 200, CISLO_PRECISION = 0 }; String CISLO;
	 enum { CISLO_Z_WIDTH = 0, CISLO_Z_PRECISION = 0 }; bool CISLO_Z;
	enum { OBEC_WIDTH = 200, OBEC_PRECISION = 0 }; String OBEC;
	 enum { OBEC_Z_WIDTH = 0, OBEC_Z_PRECISION = 0 }; bool OBEC_Z;
	enum { OKRES_WIDTH = 200, OKRES_PRECISION = 0 }; String OKRES;
	 enum { OKRES_Z_WIDTH = 0, OKRES_Z_PRECISION = 0 }; bool OKRES_Z;
	enum { DOKLAD_WIDTH = 200, DOKLAD_PRECISION = 0 }; String DOKLAD;
	 enum { DOKLAD_Z_WIDTH = 0, DOKLAD_Z_PRECISION = 0 }; bool DOKLAD_Z;

	enum { JMENOA_WIDTH = 200, JMENOA_PRECISION = 0 }; String JMENOA;
	enum { PRIJMENIA_WIDTH = 200, PRIJMENIA_PRECISION = 0 }; String PRIJMENIA;
};

struct S_DOKUMENT  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_DOKUMENT::FieldLayout); } S_DOKUMENT();
	enum { DATUM_WIDTH = 0, DATUM_PRECISION = 0 }; Date DATUM;
	 enum { MATRIKAR_WIDTH = 200, MATRIKAR_PRECISION = 0 }; String MATRIKAR;
	enum { IDC_WIDTH = 200, IDC_PRECISION = 0 }; String IDC;
	enum { TEXT_WIDTH = 2000, TEXT_PRECISION = 0 }; String TEXT;
	 enum { TEXT1_WIDTH = 2000, TEXT1_PRECISION = 0 }; String TEXT1;
	 enum { TEXT2_WIDTH = 2000, TEXT2_PRECISION = 0 }; String TEXT2;
	 enum { TEXT3_WIDTH = 2000, TEXT3_PRECISION = 0 }; String TEXT3;
	 enum { TEXT4_WIDTH = 2000, TEXT4_PRECISION = 0 }; String TEXT4;
	 enum { TEXT5_WIDTH = 2000, TEXT5_PRECISION = 0 }; String TEXT5;
	 enum { TEXT6_WIDTH = 2000, TEXT6_PRECISION = 0 }; String TEXT6;
	 enum { TEXT7_WIDTH = 2000, TEXT7_PRECISION = 0 }; String TEXT7;
	 enum { TEXT8_WIDTH = 2000, TEXT8_PRECISION = 0 }; String TEXT8;
	 enum { TEXT9_WIDTH = 2000, TEXT9_PRECISION = 0 }; String TEXT9;
	 enum { OP_WIDTH = 2000, OP_PRECISION = 0 }; String OP;
	 enum { OP_DM_WIDTH = 2000, OP_DM_PRECISION = 0 }; String OP_DM;
	 enum { OP_PLATNOST_WIDTH = 2000, OP_PLATNOST_PRECISION = 0 }; String OP_PLATNOST;
	 enum { CD_WIDTH = 2000, CD_PRECISION = 0 }; String CD;
	 enum { CD_DM_WIDTH = 2000, CD_DM_PRECISION = 0 }; String CD_DM;
	 enum { CD_PLATNOST_WIDTH = 2000, CD_PLATNOST_PRECISION = 0 }; String CD_PLATNOST;
	 enum { CJ_WIDTH = 200, CJ_PRECISION = 0 }; String CJ;
	 enum { TOTOZNOST_CD_WIDTH = 0, TOTOZNOST_CD_PRECISION = 0 }; bool TOTOZNOST_CD;
	 enum { DATUM_VT_WIDTH = 0, DATUM_VT_PRECISION = 0 }; Date DATUM_VT;
	enum { CISLO_WIDTH = 0, CISLO_PRECISION = 0 }; int CISLO;
};

 struct S_MATRIKA_OBEC  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_MATRIKA_OBEC::FieldLayout); } S_MATRIKA_OBEC();
	 enum { MATRIKA_OBEC_SEQ_WIDTH = 0, MATRIKA_OBEC_SEQ_PRECISION = 0 }; int MATRIKA_OBEC_SEQ;
	enum { TEXT_WIDTH = 200, TEXT_PRECISION = 0 }; String TEXT;
};

 struct S_MATRIKA  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_MATRIKA::FieldLayout); } S_MATRIKA();
	 enum { MATRIKA_SEQ_WIDTH = 0, MATRIKA_SEQ_PRECISION = 0 }; int MATRIKA_SEQ;
	enum { TYP_WIDTH = 0, TYP_PRECISION = 0 }; int TYP;
	enum { DATUM_WIDTH = 0, DATUM_PRECISION = 0 }; Date DATUM;
	 enum { DATUM_Z_WIDTH = 0, DATUM_Z_PRECISION = 0 }; bool DATUM_Z;
	enum { MATRIKA_OBEC_SEQ_WIDTH = 0, MATRIKA_OBEC_SEQ_PRECISION = 0 }; int MATRIKA_OBEC_SEQ;
	 enum { ROCNIK_WIDTH = 0, ROCNIK_PRECISION = 0 }; int ROCNIK;
	 enum { SVAZEK_WIDTH = 0, SVAZEK_PRECISION = 0 }; int SVAZEK;
	 enum { STRANA_WIDTH = 0, STRANA_PRECISION = 0 }; int STRANA;
	enum { CISLO_WIDTH = 0, CISLO_PRECISION = 0 }; int CISLO;
	 enum { ZMENA_WIDTH = 0, ZMENA_PRECISION = 0 }; int ZMENA;
	 enum { DUPLIKAT_WIDTH = 0, DUPLIKAT_PRECISION = 0 }; bool DUPLIKAT;
	enum { CJ_WIDTH = 200, CJ_PRECISION = 0 }; String CJ;

	S_MOSOBA OSOBA;
	 S_MOSOBA OTEC;
	 S_MOSOBA MATKA;
	S_MOSOBA OSOBA1;
	 S_MOSOBA OTEC1;
	 S_MOSOBA MATKA1;
	S_MOSOBA OSOBA2;
	 S_MOSOBA OSOBA3;

	 enum { PRED_WIDTH = 200, PRED_PRECISION = 0 }; String PRED;
	 enum { MISTO_WIDTH = 200, MISTO_PRECISION = 0 }; String MISTO;
	 enum { MISTO_Z_WIDTH = 0, MISTO_Z_PRECISION = 0 }; bool MISTO_Z;
	 enum { MISTO1_WIDTH = 200, MISTO1_PRECISION = 0 }; String MISTO1;
	 enum { MISTO1_Z_WIDTH = 0, MISTO1_Z_PRECISION = 0 }; bool MISTO1_Z;
	 enum { VZDELANIM_WIDTH = 0, VZDELANIM_PRECISION = 0 }; int VZDELANIM;

	 enum { SPOLECNEM_WIDTH = 200, SPOLECNEM_PRECISION = 0 }; String SPOLECNEM;
	 enum { SPOLECNEM_Z_WIDTH = 200, SPOLECNEM_Z_PRECISION = 0 }; String SPOLECNEM_Z;
	 enum { SPOLECNEZ_WIDTH = 200, SPOLECNEZ_PRECISION = 0 }; String SPOLECNEZ;
	 enum { SPOLECNEZ_Z_WIDTH = 200, SPOLECNEZ_Z_PRECISION = 0 }; String SPOLECNEZ_Z;
	 enum { DETIM_WIDTH = 200, DETIM_PRECISION = 0 }; String DETIM;
	 enum { DETIM_Z_WIDTH = 200, DETIM_Z_PRECISION = 0 }; String DETIM_Z;
	 enum { DETIZ_WIDTH = 200, DETIZ_PRECISION = 0 }; String DETIZ;
	 enum { DETIZ_Z_WIDTH = 200, DETIZ_Z_PRECISION = 0 }; String DETIZ_Z;
	 enum { NAVICM_WIDTH = 200, NAVICM_PRECISION = 0 }; String NAVICM;
	 enum { NAVICM_Z_WIDTH = 200, NAVICM_Z_PRECISION = 0 }; String NAVICM_Z;
	 enum { NAVICZ_WIDTH = 200, NAVICZ_PRECISION = 0 }; String NAVICZ;
	 enum { NAVICZ_Z_WIDTH = 200, NAVICZ_Z_PRECISION = 0 }; String NAVICZ_Z;
	 enum { VZDELANIZ_WIDTH = 0, VZDELANIZ_PRECISION = 0 }; int VZDELANIZ;
	 enum { PORADIM_WIDTH = 0, PORADIM_PRECISION = 0 }; int PORADIM;
	 enum { PORADIZ_WIDTH = 0, PORADIZ_PRECISION = 0 }; int PORADIZ;
	 enum { ROZM_WIDTH = 0, ROZM_PRECISION = 0 }; Date ROZM;
	 enum { ROZZ_WIDTH = 0, ROZZ_PRECISION = 0 }; Date ROZZ;
	 enum { ODDAVAJICI_WIDTH = 200, ODDAVAJICI_PRECISION = 0 }; String ODDAVAJICI;

	 enum { DATUM_DO_WIDTH = 0, DATUM_DO_PRECISION = 0 }; Date DATUM_DO;
	 enum { NEMOC_WIDTH = 200, NEMOC_PRECISION = 0 }; String NEMOC;
	 enum { NEMOC_DOBA_WIDTH = 200, NEMOC_DOBA_PRECISION = 0 }; String NEMOC_DOBA;
	 enum { NEMOC_KOD_WIDTH = 200, NEMOC_KOD_PRECISION = 0 }; String NEMOC_KOD;
	 enum { PREDCHOZI_WIDTH = 200, PREDCHOZI_PRECISION = 0 }; String PREDCHOZI;
	 enum { PREDCHOZI_DOBA_WIDTH = 200, PREDCHOZI_DOBA_PRECISION = 0 }; String PREDCHOZI_DOBA;
	 enum { PREDCHOZI_KOD_WIDTH = 200, PREDCHOZI_KOD_PRECISION = 0 }; String PREDCHOZI_KOD;
	 enum { PRVOTNI_WIDTH = 200, PRVOTNI_PRECISION = 0 }; String PRVOTNI;
	 enum { PRVOTNI_DOBA_WIDTH = 200, PRVOTNI_DOBA_PRECISION = 0 }; String PRVOTNI_DOBA;
	 enum { PRVOTNI_KOD_WIDTH = 200, PRVOTNI_KOD_PRECISION = 0 }; String PRVOTNI_KOD;
	 enum { JINE_WIDTH = 200, JINE_PRECISION = 0 }; String JINE;
	 enum { JINE_DOBA_WIDTH = 200, JINE_DOBA_PRECISION = 0 }; String JINE_DOBA;
	 enum { JINE_KOD_WIDTH = 200, JINE_KOD_PRECISION = 0 }; String JINE_KOD;
	 enum { URAZO_WIDTH = 0, URAZO_PRECISION = 0 }; bool URAZO;
	 enum { URAZ_WIDTH = 200, URAZ_PRECISION = 0 }; String URAZ;
	 enum { URAZ_KOD_WIDTH = 200, URAZ_KOD_PRECISION = 0 }; String URAZ_KOD;
	 enum { PRENOSNA_WIDTH = 0, PRENOSNA_PRECISION = 0 }; bool PRENOSNA;
	 enum { ZPOVOLANI_WIDTH = 0, ZPOVOLANI_PRECISION = 0 }; bool ZPOVOLANI;
	 enum { PITVA_WIDTH = 0, PITVA_PRECISION = 0 }; bool PITVA;
	 enum { MUDR_WIDTH = 200, MUDR_PRECISION = 0 }; String MUDR;
	enum { DELKA_WIDTH = 0, DELKA_PRECISION = 0 }; int DELKA;
	 enum { DITEMISTO_WIDTH = 1, DITEMISTO_PRECISION = 0 }; String DITEMISTO;
	 enum { SMISTO_WIDTH = 1, SMISTO_PRECISION = 0 }; String SMISTO;
	 enum { HMOTNOST_WIDTH = 0, HMOTNOST_PRECISION = 0 }; int HMOTNOST;
	 enum { OBRAD_WIDTH = 200, OBRAD_PRECISION = 0 }; String OBRAD;
	 enum { OBRAD1_WIDTH = 200, OBRAD1_PRECISION = 0 }; String OBRAD1;
	 enum { SPOLECNE_WIDTH = 0, SPOLECNE_PRECISION = 0 }; bool SPOLECNE;

	enum { DUVOD_WIDTH = 200, DUVOD_PRECISION = 0 }; String DUVOD;
	 enum { COP_WIDTH = 200, COP_PRECISION = 0 }; String COP;
	 enum { OPDNE_WIDTH = 0, OPDNE_PRECISION = 0 }; Date OPDNE;
	 enum { OPKYM_WIDTH = 200, OPKYM_PRECISION = 0 }; String OPKYM;
	 enum { ZASTUPCE_WIDTH = 200, ZASTUPCE_PRECISION = 0 }; String ZASTUPCE;
	 enum { BYDLISTE_WIDTH = 200, BYDLISTE_PRECISION = 0 }; String BYDLISTE;

	 S_DOKUMENT PROTOKOL;
	 S_DOKUMENT LIST;
	 S_DOKUMENT KNIHA;
	 S_DOKUMENT HLASENI;
	 S_DOKUMENT A;
	 S_DOKUMENT B;

	enum { TEXT_WIDTH = 2000, TEXT_PRECISION = 0 }; String TEXT;
};

 struct S_MATRIKA_ZAZNAM  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_MATRIKA_ZAZNAM::FieldLayout); } S_MATRIKA_ZAZNAM();
	enum { MATRIKA_SEQ_WIDTH = 0, MATRIKA_SEQ_PRECISION = 0 }; int MATRIKA_SEQ;

	 enum { ZDATUM_WIDTH = 0, ZDATUM_PRECISION = 0 }; Date ZDATUM;
	enum { TYP_WIDTH = 0, TYP_PRECISION = 0 }; int TYP;
	enum { NDX_WIDTH = 0, NDX_PRECISION = 0 }; int NDX;

	S_MOSOBA2 OSOBA;
	S_MOSOBA2 OTEC;
	S_MOSOBA2 MATKA;
	S_MOSOBA2 OSOBA1;
	S_MOSOBA2 OTEC1;
	S_MOSOBA2 MATKA1;
	S_MOSOBA2 OSOBA2;
	S_MOSOBA2 OSOBA3;

	enum { PRED_WIDTH = 200, PRED_PRECISION = 0 }; String PRED;
	enum { MISTO_WIDTH = 200, MISTO_PRECISION = 0 }; String MISTO;
	enum { MISTO_Z_WIDTH = 0, MISTO_Z_PRECISION = 0 }; bool MISTO_Z;
	enum { MISTO1_WIDTH = 200, MISTO1_PRECISION = 0 }; String MISTO1;
	enum { MISTO1_Z_WIDTH = 0, MISTO1_Z_PRECISION = 0 }; bool MISTO1_Z;
	enum { VZDELANIM_WIDTH = 0, VZDELANIM_PRECISION = 0 }; int VZDELANIM;

	enum { DATUM_WIDTH = 200, DATUM_PRECISION = 0 }; String DATUM;
	enum { DATUM_Z_WIDTH = 0, DATUM_Z_PRECISION = 0 }; bool DATUM_Z;
	enum { DATUM_DO_WIDTH = 200, DATUM_DO_PRECISION = 0 }; String DATUM_DO;
	enum { DATUM_DO_Z_WIDTH = 200, DATUM_DO_Z_PRECISION = 0 }; String DATUM_DO_Z;


	enum { SPOLECNEM_WIDTH = 200, SPOLECNEM_PRECISION = 0 }; String SPOLECNEM;
	enum { SPOLECNEM_Z_WIDTH = 200, SPOLECNEM_Z_PRECISION = 0 }; String SPOLECNEM_Z;
	enum { SPOLECNEZ_WIDTH = 200, SPOLECNEZ_PRECISION = 0 }; String SPOLECNEZ;
	enum { SPOLECNEZ_Z_WIDTH = 200, SPOLECNEZ_Z_PRECISION = 0 }; String SPOLECNEZ_Z;
	enum { DETIM_WIDTH = 200, DETIM_PRECISION = 0 }; String DETIM;
	enum { DETIM_Z_WIDTH = 200, DETIM_Z_PRECISION = 0 }; String DETIM_Z;
	enum { DETIZ_WIDTH = 200, DETIZ_PRECISION = 0 }; String DETIZ;
	enum { DETIZ_Z_WIDTH = 200, DETIZ_Z_PRECISION = 0 }; String DETIZ_Z;
	enum { NAVICM_WIDTH = 200, NAVICM_PRECISION = 0 }; String NAVICM;
	enum { NAVICM_Z_WIDTH = 200, NAVICM_Z_PRECISION = 0 }; String NAVICM_Z;
	enum { NAVICZ_WIDTH = 200, NAVICZ_PRECISION = 0 }; String NAVICZ;
	enum { NAVICZ_Z_WIDTH = 200, NAVICZ_Z_PRECISION = 0 }; String NAVICZ_Z;
	enum { VZDELANIZ_WIDTH = 0, VZDELANIZ_PRECISION = 0 }; int VZDELANIZ;
	enum { PORADIM_WIDTH = 0, PORADIM_PRECISION = 0 }; int PORADIM;
	enum { PORADIZ_WIDTH = 0, PORADIZ_PRECISION = 0 }; int PORADIZ;
	enum { ROZM_WIDTH = 0, ROZM_PRECISION = 0 }; Date ROZM;
	enum { ROZZ_WIDTH = 0, ROZZ_PRECISION = 0 }; Date ROZZ;
	enum { ODDAVAJICI_WIDTH = 200, ODDAVAJICI_PRECISION = 0 }; String ODDAVAJICI;

	enum { NEMOC_WIDTH = 200, NEMOC_PRECISION = 0 }; String NEMOC;
	enum { NEMOC_DOBA_WIDTH = 200, NEMOC_DOBA_PRECISION = 0 }; String NEMOC_DOBA;
	enum { NEMOC_KOD_WIDTH = 200, NEMOC_KOD_PRECISION = 0 }; String NEMOC_KOD;
	enum { PREDCHOZI_WIDTH = 200, PREDCHOZI_PRECISION = 0 }; String PREDCHOZI;
	enum { PREDCHOZI_DOBA_WIDTH = 200, PREDCHOZI_DOBA_PRECISION = 0 }; String PREDCHOZI_DOBA;
	enum { PREDCHOZI_KOD_WIDTH = 200, PREDCHOZI_KOD_PRECISION = 0 }; String PREDCHOZI_KOD;
	enum { PRVOTNI_WIDTH = 200, PRVOTNI_PRECISION = 0 }; String PRVOTNI;
	enum { PRVOTNI_DOBA_WIDTH = 200, PRVOTNI_DOBA_PRECISION = 0 }; String PRVOTNI_DOBA;
	enum { PRVOTNI_KOD_WIDTH = 200, PRVOTNI_KOD_PRECISION = 0 }; String PRVOTNI_KOD;
	enum { JINE_WIDTH = 200, JINE_PRECISION = 0 }; String JINE;
	enum { JINE_DOBA_WIDTH = 200, JINE_DOBA_PRECISION = 0 }; String JINE_DOBA;
	enum { JINE_KOD_WIDTH = 200, JINE_KOD_PRECISION = 0 }; String JINE_KOD;
	enum { URAZO_WIDTH = 0, URAZO_PRECISION = 0 }; bool URAZO;
	enum { URAZ_WIDTH = 200, URAZ_PRECISION = 0 }; String URAZ;
	enum { URAZ_KOD_WIDTH = 200, URAZ_KOD_PRECISION = 0 }; String URAZ_KOD;
	enum { PRENOSNA_WIDTH = 0, PRENOSNA_PRECISION = 0 }; bool PRENOSNA;
	enum { ZPOVOLANI_WIDTH = 0, ZPOVOLANI_PRECISION = 0 }; bool ZPOVOLANI;
	enum { PITVA_WIDTH = 0, PITVA_PRECISION = 0 }; bool PITVA;
	enum { MUDR_WIDTH = 200, MUDR_PRECISION = 0 }; String MUDR;
	enum { DELKA_WIDTH = 0, DELKA_PRECISION = 0 }; int DELKA;
	enum { DITEMISTO_WIDTH = 1, DITEMISTO_PRECISION = 0 }; String DITEMISTO;
	enum { HMOTNOST_WIDTH = 0, HMOTNOST_PRECISION = 0 }; int HMOTNOST;
	enum { OBRAD_WIDTH = 200, OBRAD_PRECISION = 0 }; String OBRAD;
	enum { OBRAD1_WIDTH = 200, OBRAD1_PRECISION = 0 }; String OBRAD1;
	enum { SPOLECNE_WIDTH = 0, SPOLECNE_PRECISION = 0 }; bool SPOLECNE;
	 enum { TLUMOCNIK_WIDTH = 200, TLUMOCNIK_PRECISION = 0 }; String TLUMOCNIK;
	 enum { SOUD_WIDTH = 200, SOUD_PRECISION = 0 }; String SOUD;
	 enum { ZEDNE_WIDTH = 0, ZEDNE_PRECISION = 0 }; Date ZEDNE;
	enum { CJ_WIDTH = 200, CJ_PRECISION = 0 }; String CJ;
	 enum { DNE_WIDTH = 0, DNE_PRECISION = 0 }; Date DNE;

	enum { DUVOD_WIDTH = 200, DUVOD_PRECISION = 0 }; String DUVOD;
	enum { COP_WIDTH = 200, COP_PRECISION = 0 }; String COP;
	enum { OPDNE_WIDTH = 0, OPDNE_PRECISION = 0 }; Date OPDNE;
	enum { OPKYM_WIDTH = 200, OPKYM_PRECISION = 0 }; String OPKYM;
	enum { ZASTUPCE_WIDTH = 200, ZASTUPCE_PRECISION = 0 }; String ZASTUPCE;
	enum { BYDLISTE_WIDTH = 200, BYDLISTE_PRECISION = 0 }; String BYDLISTE;

	enum { DATUM_VT_WIDTH = 0, DATUM_VT_PRECISION = 0 }; Date DATUM_VT;

	S_DOKUMENT PROTOKOL;
	S_DOKUMENT LIST;
	S_DOKUMENT KNIHA;
	S_DOKUMENT HLASENI;
	S_DOKUMENT A;
	S_DOKUMENT B;
	S_DOKUMENT ZMENA;
	S_DOKUMENT DUPLIKAT;
	 S_DOKUMENT ZAPIS;
	 S_DOKUMENT ZADOST;
	 S_DOKUMENT TOTOZNOST;

	enum { TEXT_WIDTH = 2000, TEXT_PRECISION = 0 }; String TEXT;
	 enum { IMPORTED_WIDTH = 20, IMPORTED_PRECISION = 0 }; String IMPORTED;
};

 struct S_MATRIKA_DUPLIKAT  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_MATRIKA_DUPLIKAT::FieldLayout); } S_MATRIKA_DUPLIKAT();
	enum { MATRIKA_SEQ_WIDTH = 0, MATRIKA_SEQ_PRECISION = 0 }; int MATRIKA_SEQ;
	enum { DATUM_WIDTH = 0, DATUM_PRECISION = 0 }; Date DATUM;
	enum { MATRIKAR_WIDTH = 200, MATRIKAR_PRECISION = 0 }; String MATRIKAR;
};

 struct S_MAT_VYPIS  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_MAT_VYPIS::FieldLayout); } S_MAT_VYPIS();
	enum { MATRIKA_SEQ_WIDTH = 0, MATRIKA_SEQ_PRECISION = 0 }; int MATRIKA_SEQ;
	enum { JMENO_WIDTH = 200, JMENO_PRECISION = 0 }; String JMENO;
	 enum { NAROZENI_WIDTH = 200, NAROZENI_PRECISION = 0 }; String NAROZENI;
	enum { RC_WIDTH = 200, RC_PRECISION = 0 }; String RC;
	enum { OTEC_WIDTH = 200, OTEC_PRECISION = 0 }; String OTEC;
	enum { MATKA_WIDTH = 200, MATKA_PRECISION = 0 }; String MATKA;
	 enum { ZAZNAM_WIDTH = 200, ZAZNAM_PRECISION = 0 }; String ZAZNAM;
};

 struct S_MAT_MAKRO  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_MAT_MAKRO::FieldLayout); } S_MAT_MAKRO();
	 enum { MAT_MAKRO_SEQ_WIDTH = 0, MAT_MAKRO_SEQ_PRECISION = 0 }; int MAT_MAKRO_SEQ;
	enum { NAZEV_WIDTH = 2000, NAZEV_PRECISION = 0 }; String NAZEV;
	enum { TEXT_WIDTH = 2000, TEXT_PRECISION = 0 }; String TEXT;
};

 struct S_MAT_SKUPINA  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_MAT_SKUPINA::FieldLayout); } S_MAT_SKUPINA();
	 enum { MAT_SKUPINA_SEQ_WIDTH = 0, MAT_SKUPINA_SEQ_PRECISION = 0 }; int MAT_SKUPINA_SEQ;
	enum { TEXT_WIDTH = 200, TEXT_PRECISION = 0 }; String TEXT;
};

 struct S_MAT_SABLONA  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_MAT_SABLONA::FieldLayout); } S_MAT_SABLONA();
	 enum { MAT_SABLONA_SEQ_WIDTH = 0, MAT_SABLONA_SEQ_PRECISION = 0 }; int MAT_SABLONA_SEQ;
	enum { MAT_SKUPINA_SEQ_WIDTH = 0, MAT_SKUPINA_SEQ_PRECISION = 0 }; int MAT_SKUPINA_SEQ;
	enum { NAZEV_WIDTH = 2000, NAZEV_PRECISION = 0 }; String NAZEV;
	enum { TEXT_WIDTH = 0, TEXT_PRECISION = 0 }; String TEXT;
};

 struct S_MAT_IRC  { public: void Shrink(); void Clear(); static const char TableName[]; static const SqlSet& ColumnSet(); static SqlSet ColumnSet(const String& prefix); static SqlSet Of(SqlId table); void FieldLayoutRaw(FieldOperator& f, const String& prefix = String()); void FieldLayout(FieldOperator& f); operator Fields() { return callback(this, &S_MAT_IRC::FieldLayout); } S_MAT_IRC();
	enum { RC_WIDTH = 200, RC_PRECISION = 0 }; String RC;
	enum { DATUM_WIDTH = 0, DATUM_PRECISION = 0 }; Date DATUM;
	 enum { PRIDELENE_WIDTH = 1, PRIDELENE_PRECISION = 0 }; String PRIDELENE;
	enum { POHLAVI_WIDTH = 1, POHLAVI_PRECISION = 0 }; String POHLAVI;
	 enum { PRIDELENO_WIDTH = 0, PRIDELENO_PRECISION = 0 }; Date PRIDELENO;
	enum { JMENO_WIDTH = 200, JMENO_PRECISION = 0 }; String JMENO;
	enum { PRIJMENI_WIDTH = 200, PRIJMENI_PRECISION = 0 }; String PRIJMENI;
	enum { MISTO_WIDTH = 200, MISTO_PRECISION = 0 }; String MISTO;
	enum { OKRES_WIDTH = 200, OKRES_PRECISION = 0 }; String OKRES;
};
#line 163 "u:/uppsrc\\Sql/sch_model.h"




































#line 91 "u:/uppsrc\\Oracle/OracleSchema.h"





















































#line 35 "u:/uppsrc\\Sql/sch_header.h"










#line 1 "u:/uppsrc\\Oracle/OracleSchema.h"


























































#line 60 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 65 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 70 "u:/uppsrc\\Oracle/OracleSchema.h"




#line 75 "u:/uppsrc\\Oracle/OracleSchema.h"















#line 1 "u:/uppsrc\\Sql/sch_model.h"








#line 10 "u:/uppsrc\\Sql/sch_model.h"
















#line 27 "u:/uppsrc\\Sql/sch_model.h"




















#line 48 "u:/uppsrc\\Sql/sch_model.h"



#line 52 "u:/uppsrc\\Sql/sch_model.h"



#line 56 "u:/uppsrc\\Sql/sch_model.h"



#line 60 "u:/uppsrc\\Sql/sch_model.h"



#line 64 "u:/uppsrc\\Sql/sch_model.h"



#line 68 "u:/uppsrc\\Sql/sch_model.h"



#line 72 "u:/uppsrc\\Sql/sch_model.h"



#line 76 "u:/uppsrc\\Sql/sch_model.h"



#line 80 "u:/uppsrc\\Sql/sch_model.h"



#line 84 "u:/uppsrc\\Sql/sch_model.h"



#line 88 "u:/uppsrc\\Sql/sch_model.h"



#line 92 "u:/uppsrc\\Sql/sch_model.h"



#line 96 "u:/uppsrc\\Sql/sch_model.h"



#line 100 "u:/uppsrc\\Sql/sch_model.h"



#line 104 "u:/uppsrc\\Sql/sch_model.h"



#line 108 "u:/uppsrc\\Sql/sch_model.h"



#line 112 "u:/uppsrc\\Sql/sch_model.h"



#line 116 "u:/uppsrc\\Sql/sch_model.h"



#line 120 "u:/uppsrc\\Sql/sch_model.h"



#line 124 "u:/uppsrc\\Sql/sch_model.h"



#line 128 "u:/uppsrc\\Sql/sch_model.h"







#line 136 "u:/uppsrc\\Sql/sch_model.h"








#line 145 "u:/uppsrc\\Sql/sch_model.h"



#line 149 "u:/uppsrc\\Sql/sch_model.h"



#line 153 "u:/uppsrc\\Sql/sch_model.h"



#line 157 "u:/uppsrc\\Sql/sch_model.h"



#line 161 "u:/uppsrc\\Sql/sch_model.h"

#line 1 "u:\\idisapp\\matrika2\\Matrika.sch"
extern SqlId SEQ_MAT;





	extern SqlId PRIJMENI;

	extern SqlId RPRIJMENI;

	extern SqlId RPRIJMENIO;




	extern SqlId POHLAVI;



	extern SqlId OKRES_NAR;

	extern SqlId OBCANSTVI;



	extern SqlId ULICE;



	extern SqlId OBEC;

	extern SqlId OKRES;

	extern SqlId DOKLAD;



	extern SqlId PRIJMENIA;
















	 extern SqlId POHLAVI_Z;







	 extern SqlId STAV_Z;

















	extern SqlId MATRIKAR;


	extern SqlId TEXT1;
	extern SqlId TEXT2;
	extern SqlId TEXT3;
	extern SqlId TEXT4;
	extern SqlId TEXT5;
	extern SqlId TEXT6;
	extern SqlId TEXT7;
	extern SqlId TEXT8;
	extern SqlId TEXT9;
	extern SqlId OP;
	extern SqlId OP_DM;
	extern SqlId OP_PLATNOST;
	extern SqlId CD;
	extern SqlId CD_DM;
	extern SqlId CD_PLATNOST;
	extern SqlId CJ;
	extern SqlId TOTOZNOST_CD;
	extern SqlId DATUM_VT;



extern SqlId MATRIKA_OBEC;
	extern SqlId MATRIKA_OBEC_SEQ;



extern SqlId MATRIKA;
	extern SqlId MATRIKA_SEQ;


	extern SqlId DATUM_Z;

	extern SqlId ROCNIK;
	extern SqlId SVAZEK;
	extern SqlId STRANA;

	extern SqlId ZMENA;
	extern SqlId DUPLIKAT;



	extern SqlId OTEC;
	extern SqlId MATKA;

	extern SqlId OTEC1;
	extern SqlId MATKA1;

	extern SqlId OSOBA3;

	extern SqlId PRED;
	extern SqlId MISTO;
	extern SqlId MISTO_Z;
	extern SqlId MISTO1;
	extern SqlId MISTO1_Z;
	extern SqlId VZDELANIM;

	extern SqlId SPOLECNEM;
	extern SqlId SPOLECNEM_Z;
	extern SqlId SPOLECNEZ;
	extern SqlId SPOLECNEZ_Z;
	extern SqlId DETIM;
	extern SqlId DETIM_Z;
	extern SqlId DETIZ;
	extern SqlId DETIZ_Z;
	extern SqlId NAVICM;
	extern SqlId NAVICM_Z;
	extern SqlId NAVICZ;
	extern SqlId NAVICZ_Z;
	extern SqlId VZDELANIZ;
	extern SqlId PORADIM;
	extern SqlId PORADIZ;
	extern SqlId ROZM;
	extern SqlId ROZZ;
	extern SqlId ODDAVAJICI;

	extern SqlId DATUM_DO;
	extern SqlId NEMOC;
	extern SqlId NEMOC_DOBA;
	extern SqlId NEMOC_KOD;
	extern SqlId PREDCHOZI;
	extern SqlId PREDCHOZI_DOBA;
	extern SqlId PREDCHOZI_KOD;
	extern SqlId PRVOTNI;
	extern SqlId PRVOTNI_DOBA;
	extern SqlId PRVOTNI_KOD;
	extern SqlId JINE;
	extern SqlId JINE_DOBA;
	extern SqlId JINE_KOD;
	extern SqlId URAZO;
	extern SqlId URAZ;
	extern SqlId URAZ_KOD;
	extern SqlId PRENOSNA;
	extern SqlId ZPOVOLANI;
	extern SqlId PITVA;
	extern SqlId MUDR;

	extern SqlId DITEMISTO;
	extern SqlId SMISTO;
	extern SqlId HMOTNOST;
	extern SqlId OBRAD;
	extern SqlId OBRAD1;
	extern SqlId SPOLECNE;


	extern SqlId COP;
	extern SqlId OPDNE;
	extern SqlId OPKYM;
	extern SqlId ZASTUPCE;
	extern SqlId BYDLISTE;

	extern SqlId PROTOKOL;
	extern SqlId LIST;
	extern SqlId KNIHA;
	extern SqlId HLASENI;
	extern SqlId A;
	extern SqlId B;




extern SqlId MATRIKA_ZAZNAM;


	extern SqlId ZDATUM;





































































	extern SqlId TLUMOCNIK;
	extern SqlId SOUD;
	extern SqlId ZEDNE;

	extern SqlId DNE;


















	extern SqlId ZAPIS;
	extern SqlId ZADOST;
	extern SqlId TOTOZNOST;


	extern SqlId IMPORTED;


extern SqlId MATRIKA_DUPLIKAT;





extern SqlId MAT_VYPIS;


	extern SqlId NAROZENI;



	extern SqlId ZAZNAM;


extern SqlId MAT_MAKRO;
	extern SqlId MAT_MAKRO_SEQ;




extern SqlId MAT_SKUPINA;
	extern SqlId MAT_SKUPINA_SEQ;



extern SqlId MAT_SABLONA;
	extern SqlId MAT_SABLONA_SEQ;





extern SqlId MAT_IRC;


	extern SqlId PRIDELENE;

	extern SqlId PRIDELENO;





#line 163 "u:/uppsrc\\Sql/sch_model.h"




































#line 91 "u:/uppsrc\\Oracle/OracleSchema.h"





















































#line 46 "u:/uppsrc\\Sql/sch_header.h"
#line 17 "u:\\idisapp\\matrika2\\Matrika.h"

struct DashEdit : public RichEdit {
	virtual void  SetData(const Value& data);
	virtual Value GetData() const;

	Button dash;

	void Dash();

	typedef DashEdit CLASSNAME;

	DashEdit();
};


#line 1 "u:/uppsrc\\CtrlCore/lay.h"







#line 1 "u:/idisapp\\Matrika2/Matrika.lay"
struct MatrikaLayout__layid {};




struct MOsobaLayout__layid {};




































struct NarozeniLayout__layid {};























struct ListLayout__layid {};














struct OtcovstviLayout__layid {};































struct OtcovstviNLayout__layid {};





































struct KnihaLayout__layid {};














struct KnihaNarozeniLayout__layid {};
















struct SelectLayout__layid {};




































struct ManzelstviLayout__layid {};





































































struct HlaseniLayout__layid {};








struct UmrtiLayout__layid {};



































































struct ManzelstviPotvrzeniLayout__layid {};
















struct PotvrzeniUmrtiLayout__layid {};














struct PrintDocLayout__layid {};





struct VysvedceniLayout__layid {};








struct IndexLayout__layid {};










struct VypisLayout__layid {};



























struct VypisLineLayout__layid {};
















struct DuplikatyLayout__layid {};






struct DatumMatrikarLayout__layid {};








struct OdDoLayout__layid {};










struct RejstrikLayout__layid {};


















struct RejstrikVypisLayout__layid {};






struct OsvedceniLayout__layid {};


























struct ZaznamDlgLayout__layid {};







struct ZapisNarozeniLayout__layid {};





























struct ZapisManzelstviLayout__layid {};





























struct ZapisUmrtiLayout__layid {};


































struct DatumVTLayout__layid {};






struct ZadostLayout__layid {};




























struct OdDo2Layout__layid {};








struct TotoznostLayout__layid {};






























struct OsvCrLayout__layid {};












struct RcListLayout__layid {};








#line 9 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/idisapp\\Matrika2/Matrika.lay"
template<class T> struct WithMatrikaLayout : public T, public MatrikaLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(780, 540); }
	MenuBar menu;
	SqlArray matrika;
};

template<class T> struct WithMOsobaLayout : public T, public MOsobaLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(440, 196); }
	Label dv___0;
	OsobaCtrl osoba_seq;
	Label dv___2;
	EditString jmeno;
	Label dv___4;
	EditString prijmeni;
	Label dv___6;
	Option rprijmenio;
	EditString rprijmeni;
	Label dv___9;
	EditString rc;
	Label dv___11;
	ParentCtrl dat_nar;
	Label dv___13;
	ParentCtrl pohlavi;
	Label dv___15;
	EditString misto_nar;
	Label dv___17;
	EditString okres_nar;
	Label dv___19;
	EditString obcanstvi;
	Label dv___21;
	ParentCtrl stav;
	Label dv___23;
	EditString ulice;
	Label dv___25;
	EditString cislo;
	Label dv___27;
	EditString obec;
	Label dv___29;
	EditString okres;
	Label dv___31;
	EditString doklad;
	Button prirc;
};

template<class T> struct WithNarozeniLayout : public T, public NarozeniLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(472, 564); }
	DropList obec_seq;
	Label dv___1;
	EditInt rocnik;
	Label dv___3;
	EditInt svazek;
	Label dv___5;
	EditInt strana;
	Label dv___7;
	EditInt cislo;
	SqlOption duplikat;
	Button pc;








	Button ok;
	Button cancel;
};

template<class T> struct WithListLayout : public T, public ListLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(448, 192); }
	Label cj_lbl;
	EditString cj;
	DocEdit text;
	Label label;
	Label dv___4;
	Label dv___5;
	EditDate datum;
	EditString matrikar;
	Button original;
	Button kopie;
	Button original2;
	Button kopie2;
};

template<class T> struct WithOtcovstviLayout : public T, public OtcovstviLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(448, 192); }
	Label dv___0;
	Label dv___1;
	EditDate datum;
	EditString matrikar;
	Button print;
	Label dv___5;
	EditString dcera;
	Label dv___7;
	EditString dceraroz;
	Label dv___9;
	EditString adcera;
	Label dv___11;
	EditString adceraroz;
	Label dv___13;
	EditString syn;
	Label dv___15;
	EditString synroz;
	Label dv___17;
	EditString asyn;
	Label dv___19;
	EditString asynroz;
	Label dv___21;
	EditString soud;
	Label dv___23;
	EditDate sdatum;
	Label dv___25;
	EditString scj;
	Label dv___27;
	EditDate spm;
};

template<class T> struct WithOtcovstviNLayout : public T, public OtcovstviNLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(448, 192); }
	Label dv___0;
	EditString dcera;
	Label dv___2;
	EditString dceraroz;
	Label dv___4;
	EditString adcera;
	Label dv___6;
	EditString adceraroz;
	Label dv___8;
	EditString syn;
	Label dv___10;
	EditString synroz;
	Label dv___12;
	EditString asyn;
	Label dv___14;
	EditString asynroz;
	Label dv___16;
	EditString text;
	Label dv___18;
	EditDate porod;
	Label dv___20;
	EditString soud;
	Label dv___22;
	EditDate sdatum;
	Label dv___24;
	EditString scj;
	Label dv___26;
	EditDate spm;
	Label dv___28;
	EditString text1;
	Label dv___30;
	EditDate datum;
	Label dv___32;
	EditString matrikar;
	Button print;
};

template<class T> struct WithKnihaLayout : public T, public KnihaLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(448, 192); }
	Label lbl;

	DashEdit text;
	Label dv___3;
	EditDate datum;
	Label dv___5;
	EditString matrikar;
	EditString idc;
	Button print;
	Button datum_vt;
	Label cislo_txt;
	EditInt cislo;
};

template<class T> struct WithKnihaNarozeniLayout : public T, public KnihaNarozeniLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(448, 192); }
	Label lbl;
	DashEdit text;

	Label dv___3;
	EditDate datum;
	Label dv___5;
	EditString matrikar;
	EditString idc;
	Button print;
	Button otcovstvi;
	Button otcovstvin;
	Button datum_vt;
	Label cislo_txt;
	EditInt cislo;
};

template<class T> struct WithSelectLayout : public T, public SelectLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(248, 344); }
	Label dv___0;
	DropList typ;
	Label dv___2;
	DropList obec_seq;
	Label dv___4;
	EditInt rocnik;
	Label dv___6;
	EditInt rocnikdo;
	Label dv___8;
	EditInt svazek;
	Label dv___10;
	EditInt svazekdo;
	Label dv___12;
	EditInt strana;
	Label dv___14;
	EditInt stranado;
	Label dv___16;
	EditInt cislo;
	Label dv___18;
	EditInt cislodo;
	Label dv___20;
	EditDate datum;
	Label dv___22;
	EditDate datumdo;
	Label dv___24;
	EditString rc;
	Label dv___26;
	Button clear;
	EditString prijmeni;
	Option knihy;
	Option neuzavrene;
	Option nkniha;
	Button ok;
	Button cancel;
};

template<class T> struct WithManzelstviLayout : public T, public ManzelstviLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(768, 532); }
	DropList obec_seq;
	Label dv___1;
	EditInt rocnik;
	Label dv___3;
	EditInt svazek;
	Label dv___5;
	EditInt strana;
	Label dv___7;
	EditInt cislo;
	SqlOption duplikat;
	Button pc;








	Label dv___19;
	EditString pred;
	Label dv___21;
	EditString misto;
	EditString misto1;
	Label dv___24;
	EditString datum;
	Label dv___26;
	Label dv___27;
	Label dv___28;
	DropList vzdelanim;
	DropList vzdelaniz;
	Label dv___31;
	EditIntSpin poradim;
	EditIntSpin poradiz;
	Label dv___34;
	EditDate rozm;
	EditDate rozz;
	LabelBox dv___37;
	Label dv___38;
	Label dv___39;
	Label dv___40;
	EditString spolecnem;
	EditString spolecnez;
	Label dv___43;
	EditString detim;
	EditString detiz;
	Label dv___46;
	EditString navicm;
	EditString navicz;
	SqlOption spolecne;
	LabelBox dv___50;
	EditString obrad;
	DocEdit obrad1;
	Label dv___53;
	EditString oddavajici;
	Label dv___55;
	EditString tlumocnik;
	Label dv___57;
	EditString soud;
	Label dv___59;
	EditDate zedne;
	Label dv___61;
	EditString cj;
	Label dv___63;
	EditDate dne;
	Button ok;
	Button cancel;
};

template<class T> struct WithHlaseniLayout : public T, public HlaseniLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(448, 196); }
	Label dv___0;
	Label dv___1;
	EditDate datum;
	EditString matrikar;
	Button original;
	Button kopie;
};

template<class T> struct WithUmrtiLayout : public T, public UmrtiLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(768, 532); }
	DropList obec_seq;
	Label dv___1;
	EditInt rocnik;
	Label dv___3;
	EditInt svazek;
	Label dv___5;
	EditInt strana;
	Label dv___7;
	EditInt cislo;
	Button pc;
	SqlOption duplikat;








	Label dv___19;
	EditString misto;
	EditString misto1;
	Label dv___22;
	DropList vzdelanim;
	Label dv___24;
	EditString datum;
	Label dv___26;
	EditString datum_do;
	Label dv___28;
	Label dv___29;
	Label dv___30;
	EditString nemoc;
	EditString nemoc_doba;
	EditString nemoc_kod;
	Label dv___34;
	EditString predchozi;
	EditString predchozi_doba;
	EditString predchozi_kod;
	Label dv___38;
	EditString prvotni;
	EditString prvotni_doba;
	EditString prvotni_kod;
	Label dv___42;
	EditString jine;
	EditString jine_doba;
	EditString jine_kod;
	SqlOption urazo;
	EditString uraz;
	EditString uraz_kod;
	SqlOption prenosna;
	SqlOption zpovolani;
	SqlOption pitva;
	Label dv___52;
	EditString mudr;
	Label dv___54;
	DropList smisto;
	LabelBox dv___56;
	Label dv___57;
	EditInt delka;
	Label dv___59;
	DropList ditemisto;
	Label dv___61;
	EditInt hmotnost;
	Button ok;
	Button cancel;
};

template<class T> struct WithManzelstviPotvrzeniLayout : public T, public ManzelstviPotvrzeniLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(448, 196); }
	Label dv___0;
	Label dv___1;
	EditDate datum;
	EditString matrikar;
	Button original;
	Button kopie;
	Label dv___6;
	EditString text;
	Label dv___8;
	EditString text1;
	Label dv___10;
	EditString text2;
	Label dv___12;
	EditString text3;
};

template<class T> struct WithPotvrzeniUmrtiLayout : public T, public PotvrzeniUmrtiLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(448, 196); }
	Label dv___0;
	Label dv___1;
	EditDate datum;
	EditString matrikar;
	Button original;
	Button kopie;
	Label dv___6;
	EditString text;
	Label dv___8;
	EditString text1;
	Label dv___10;
	EditString text2;
};

template<class T> struct WithPrintDocLayout : public T, public PrintDocLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(616, 664); }
	RichTextView view;
	Button ok;
	Button cancel;
};

template<class T> struct WithVysvedceniLayout : public T, public VysvedceniLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(472, 564); }
	EditString cj;

	TabCtrl dokument;
	Button ok;
	Button cancel;
	Label dv___5;
};

template<class T> struct WithIndexLayout : public T, public IndexLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(232, 108); }
	Label dv___0;
	DropList typ;
	Label dv___2;
	DropList obec_seq;
	Label dv___4;
	EditInt rocnik;
	Button ok;
	Button cancel;
};

template<class T> struct WithVypisLayout : public T, public VypisLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(764, 304); }
	Label dv___0;
	EditString cj;
	Label dv___2;
	OsobaCtrl osoba_seq;
	Button deti;
	Button add;
	Button edit;
	Button remove;
	ArrayCtrl list;
	Label dv___9;
	EditDate datum;
	Label dv___11;
	EditString op;
	Label dv___13;
	EditString opvydan;
	Label dv___15;
	EditString opdne;
	Label dv___17;
	EditString opplatny;
	Label dv___19;
	EditString matrikar;
	Button print;
	Button zadost;
	Button ok;
	Button cancel;
};

template<class T> struct WithVypisLineLayout : public T, public VypisLineLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(316, 188); }
	Label dv___0;

	Label dv___2;

	Label dv___4;

	Label dv___6;

	Label dv___8;

	Label dv___10;

	Button ok;
	Button cancel;
};

template<class T> struct WithDuplikatyLayout : public T, public DuplikatyLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(448, 192); }
	ArrayCtrl duplikat;
	Button novy;
	Button original;
	Button kopie;
};

template<class T> struct WithDatumMatrikarLayout : public T, public DatumMatrikarLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(428, 68); }
	Label dv___0;
	EditDate datum;
	Label dv___2;
	EditString matrikar;
	Button ok;
	Button cancel;
};

template<class T> struct WithOdDoLayout : public T, public OdDoLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(220, 92); }
	Label dv___0;
	EditDate dtm_od;
	Label dv___2;
	EditDate dtm_do;
	Label dv___4;
	DropList typ;
	Button ok;
	Button cancel;
};

template<class T> struct WithRejstrikLayout : public T, public RejstrikLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(240, 188); }
	Label dv___0;
	EditIntSpin rok;
	Label dv___2;
	EditIntSpin cislo;
	Label dv___4;
	EditString jmeno;
	Label dv___6;
	EditString prijmeni;
	Label dv___8;
	EditDate dat_nar;
	Label dv___10;
	EditString bydliste;
	Button ok;
	Button cancel;
	Label dv___14;
	EditDate datum;
};

template<class T> struct WithRejstrikVypisLayout : public T, public RejstrikVypisLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(116, 68); }
	Label dv___0;
	EditIntSpin rok;
	Button ok;
	Button cancel;
};

template<class T> struct WithOsvedceniLayout : public T, public OsvedceniLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(472, 504); }
	EditString cislo;

	Label dv___2;
	Label dv___3;
	EditString duvod;
	LabelBox dv___5;
	Label dv___6;
	EditString zastupce;
	Button matka;
	Button otec;
	Label dv___10;
	EditString bydliste;
	Label dv___12;
	EditString cop;
	Label dv___14;
	EditDate opdne;
	EditString opkym;
	Label dv___17;
	EditString matrikar;
	Label dv___19;
	EditDate dne;
	Button print;
	Button ok;
	Button cancel;
};

template<class T> struct WithZaznamDlgLayout : public T, public ZaznamDlgLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(268, 68); }
	Label dv___0;
	EditDate datum;
	DropList typ;
	Button ok;
	Button cancel;
};

template<class T> struct WithZapisNarozeniLayout : public T, public ZapisNarozeniLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(448, 196); }
	Label dv___0;
	EditString text;
	Label dv___2;
	EditString text1;
	Label dv___4;
	EditString text2;
	Button gos;
	Label dv___7;
	EditString op;
	Label dv___9;
	EditString op_dm;
	Label dv___11;
	EditString op_platnost;
	Label dv___13;
	EditString cd;
	Label dv___15;
	EditString cd_dm;
	Label dv___17;
	EditString cd_platnost;
	Label dv___19;
	DocEdit text3;
	SqlOption totoznost_cd;
	Label dv___22;
	EditDate datum;
	Label dv___24;
	EditString matrikar;
	Button print;
};

template<class T> struct WithZapisManzelstviLayout : public T, public ZapisManzelstviLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(448, 196); }
	Label dv___0;
	EditString text;
	Label dv___2;
	EditString text1;
	Label dv___4;
	EditString text2;
	Button gos;
	Label dv___7;
	EditString op;
	Label dv___9;
	EditString op_dm;
	Label dv___11;
	EditString op_platnost;
	Label dv___13;
	EditString cd;
	Label dv___15;
	EditString cd_dm;
	Label dv___17;
	EditString cd_platnost;
	Label dv___19;
	DocEdit text3;
	SqlOption totoznost_cd;
	Label dv___22;
	EditDate datum;
	Label dv___24;
	EditString matrikar;
	Button print;
};

template<class T> struct WithZapisUmrtiLayout : public T, public ZapisUmrtiLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(448, 196); }
	Label dv___0;
	EditString text;
	Label dv___2;
	EditString text1;
	Label dv___4;
	EditString text2;
	Button gos;
	Label dv___7;
	EditString op;
	Label dv___9;
	EditString op_dm;
	Label dv___11;
	EditString text8;
	Label dv___13;
	EditString text9;
	Label dv___15;
	EditString op_platnost;
	Label dv___17;
	DocEdit text3;
	Label dv___19;
	EditDate datum;
	Label dv___21;
	EditString matrikar;
	Button print;
	Label dv___24;
	EditString text4;
	Label dv___26;
	EditString text5;
	Label dv___28;
	EditString text6;
	Label dv___30;
	EditString text7;
};

template<class T> struct WithDatumVTLayout : public T, public DatumVTLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(204, 72); }
	Label dv___0;
	EditDate datum;
	Button ok;
	Button cancel;
};

template<class T> struct WithZadostLayout : public T, public ZadostLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(452, 200); }
	Label dv___0;
	EditString text;
	Label dv___2;
	EditString text1;
	Button gos;
	Label dv___5;
	EditString op;
	Label dv___7;
	EditString op_dm;
	Label dv___9;
	EditString op_platnost;
	Label dv___11;
	DocEdit text3;
	Label dv___13;
	EditString cd;
	Label dv___15;
	EditDouble cislo;
	Label dv___17;
	EditString text2;
	Label dv___19;
	EditString cj;
	Label dv___21;
	EditDate datum;
	Label dv___23;
	EditString matrikar;
	Button print;
};

template<class T> struct WithOdDo2Layout : public T, public OdDo2Layout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(220, 68); }
	Label dv___0;
	EditDate dtm_od;
	Label dv___2;
	EditDate dtm_do;
	Button ok;
	Button cancel;
};

template<class T> struct WithTotoznostLayout : public T, public TotoznostLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(448, 196); }
	Label dv___0;
	EditString text;
	Label dv___2;
	EditString text1;
	Button gos1;
	Label dv___5;
	EditString text2;
	Label dv___7;
	EditString text3;
	Label dv___9;
	EditString text4;
	Label dv___11;
	EditString op;
	Label dv___13;
	EditString text5;
	Label dv___15;
	EditString text6;
	Label dv___17;
	EditString text7;
	Label dv___19;
	EditString text8;
	Label dv___21;
	EditString text9;
	Label dv___23;
	EditDate datum;
	Label dv___25;
	EditString matrikar;
	Button print;
};

template<class T> struct WithOsvCrLayout : public T, public OsvCrLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(472, 364); }
	EditString cislo;

	Label dv___2;
	Label dv___3;
	EditString kde;
	Label dv___5;
	EditDate dne;
	Button print;
	Button ok;
	Button cancel;
};

template<class T> struct WithRcListLayout : public T, public RcListLayout__layid { static Upp::Size GetLayoutSize() { return Upp::Ctrl::LayoutZoom(612, 488); }
	DropList mesic;
	Option pridelene;
	ArrayCtrl list;
	Button exit;
	Button unpri;
	Button export;
};

#line 23 "u:/uppsrc\\CtrlCore/lay.h"













#line 1 "u:/idisapp\\Matrika2/Matrika.lay"
template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, MatrikaLayout__layid&) { parent.LayoutId("MatrikaLayout");
	layout.menu.LeftPosZ(4, 368).TopPosZ(4, 20); layout.menu.LayoutId("menu"); parent.Add(layout.menu);
	layout.matrika.LeftPosZ(4, 772).TopPosZ(28, 508); layout.matrika.LayoutId("matrika"); parent.Add(layout.matrika);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, MOsobaLayout__layid&) { parent.LayoutId("MOsobaLayout");
	layout.dv___0.SetLabel(t_GetLngString("Evidence")).LeftPosZ(4, 52).TopPosZ(4, 20); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.osoba_seq.LeftPosZ(60, 376).TopPosZ(4, 20); layout.osoba_seq.LayoutId("osoba_seq"); parent.Add(layout.osoba_seq);
	layout.dv___2.SetLabel(t_GetLngString("Jmno")).LeftPosZ(4, 52).TopPosZ(32, 13); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.jmeno.LeftPosZ(4, 100).TopPosZ(48, 19); layout.jmeno.LayoutId("jmeno"); parent.Add(layout.jmeno);
	layout.dv___4.SetLabel(t_GetLngString("Pjmen")).LeftPosZ(108, 40).TopPosZ(32, 13); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.prijmeni.LeftPosZ(108, 92).TopPosZ(48, 19); layout.prijmeni.LayoutId("prijmeni"); parent.Add(layout.prijmeni);
	layout.dv___6.SetLabel(t_GetLngString("R. pjmen")).LeftPosZ(204, 52).TopPosZ(32, 13); layout.dv___6.LayoutId("dv___6"); parent.Add(layout.dv___6);
	layout.rprijmenio.LeftPosZ(260, 16).TopPosZ(32, 16); layout.rprijmenio.LayoutId("rprijmenio"); parent.Add(layout.rprijmenio);
	layout.rprijmeni.LeftPosZ(204, 72).TopPosZ(48, 19); layout.rprijmeni.LayoutId("rprijmeni"); parent.Add(layout.rprijmeni);
	layout.dv___9.SetLabel(t_GetLngString("R")).LeftPosZ(280, 24).TopPosZ(32, 13); layout.dv___9.LayoutId("dv___9"); parent.Add(layout.dv___9);
	layout.rc.LeftPosZ(280, 76).TopPosZ(48, 19); layout.rc.LayoutId("rc"); parent.Add(layout.rc);
	layout.dv___11.SetLabel(t_GetLngString("Datum narozen")).LeftPosZ(360, 80).TopPosZ(32, 13); layout.dv___11.LayoutId("dv___11"); parent.Add(layout.dv___11);
	layout.dat_nar.LeftPosZ(360, 76).TopPosZ(48, 19); layout.dat_nar.LayoutId("dat_nar"); parent.Add(layout.dat_nar);
	layout.dv___13.SetLabel(t_GetLngString("Pohlav")).LeftPosZ(4, 52).TopPosZ(72, 13); layout.dv___13.LayoutId("dv___13"); parent.Add(layout.dv___13);
	layout.pohlavi.LeftPosZ(4, 64).TopPosZ(88, 19); layout.pohlavi.LayoutId("pohlavi"); parent.Add(layout.pohlavi);
	layout.dv___15.SetLabel(t_GetLngString("Msto narozen")).LeftPosZ(72, 72).TopPosZ(72, 13); layout.dv___15.LayoutId("dv___15"); parent.Add(layout.dv___15);
	layout.misto_nar.LeftPosZ(72, 168).TopPosZ(88, 19); layout.misto_nar.LayoutId("misto_nar"); parent.Add(layout.misto_nar);
	layout.dv___17.SetLabel(t_GetLngString("- okres/stt")).LeftPosZ(244, 60).TopPosZ(72, 13); layout.dv___17.LayoutId("dv___17"); parent.Add(layout.dv___17);
	layout.okres_nar.LeftPosZ(244, 192).TopPosZ(88, 19); layout.okres_nar.LayoutId("okres_nar"); parent.Add(layout.okres_nar);
	layout.dv___19.SetLabel(t_GetLngString("Obanstv")).LeftPosZ(4, 60).TopPosZ(112, 13); layout.dv___19.LayoutId("dv___19"); parent.Add(layout.dv___19);
	layout.obcanstvi.LeftPosZ(4, 136).TopPosZ(128, 19); layout.obcanstvi.LayoutId("obcanstvi"); parent.Add(layout.obcanstvi);
	layout.dv___21.SetLabel(t_GetLngString("Stav")).LeftPosZ(144, 52).TopPosZ(112, 13); layout.dv___21.LayoutId("dv___21"); parent.Add(layout.dv___21);
	layout.stav.LeftPosZ(144, 96).TopPosZ(128, 19); layout.stav.LayoutId("stav"); parent.Add(layout.stav);
	layout.dv___23.SetLabel(t_GetLngString("Ulice")).LeftPosZ(4, 60).TopPosZ(156, 13); layout.dv___23.LayoutId("dv___23"); parent.Add(layout.dv___23);
	layout.ulice.LeftPosZ(4, 136).TopPosZ(172, 19); layout.ulice.LayoutId("ulice"); parent.Add(layout.ulice);
	layout.dv___25.SetLabel(t_GetLngString("slo")).LeftPosZ(144, 26).TopPosZ(156, 13); layout.dv___25.LayoutId("dv___25"); parent.Add(layout.dv___25);
	layout.cislo.LeftPosZ(144, 56).TopPosZ(172, 19); layout.cislo.LayoutId("cislo"); parent.Add(layout.cislo);
	layout.dv___27.SetLabel(t_GetLngString("Obec")).LeftPosZ(204, 28).TopPosZ(156, 13); layout.dv___27.LayoutId("dv___27"); parent.Add(layout.dv___27);
	layout.obec.LeftPosZ(204, 104).TopPosZ(172, 19); layout.obec.LayoutId("obec"); parent.Add(layout.obec);
	layout.dv___29.SetLabel(t_GetLngString("Okres/stt")).LeftPosZ(312, 60).TopPosZ(156, 13); layout.dv___29.LayoutId("dv___29"); parent.Add(layout.dv___29);
	layout.okres.LeftPosZ(312, 124).TopPosZ(172, 19); layout.okres.LayoutId("okres"); parent.Add(layout.okres);
	layout.dv___31.SetLabel(t_GetLngString("Doklad totonosti")).LeftPosZ(244, 100).TopPosZ(112, 13); layout.dv___31.LayoutId("dv___31"); parent.Add(layout.dv___31);
	layout.doklad.LeftPosZ(244, 192).TopPosZ(128, 19); layout.doklad.LayoutId("doklad"); parent.Add(layout.doklad);
	layout.prirc.SetLabel(t_GetLngString("Pidlit")).SetFont(StdFontZ(10)).LeftPosZ(304, 52).TopPosZ(32, 15); layout.prirc.LayoutId("prirc"); parent.Add(layout.prirc);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, NarozeniLayout__layid&) { parent.LayoutId("NarozeniLayout");
	layout.obec_seq.LeftPosZ(8, 156).TopPosZ(4, 19); layout.obec_seq.LayoutId("obec_seq"); parent.Add(layout.obec_seq);
	layout.dv___1.SetLabel(t_GetLngString("Ronk")).LeftPosZ(8, 36).TopPosZ(28, 20); layout.dv___1.LayoutId("dv___1"); parent.Add(layout.dv___1);
	layout.rocnik.LeftPosZ(44, 36).TopPosZ(28, 19); layout.rocnik.LayoutId("rocnik"); parent.Add(layout.rocnik);
	layout.dv___3.SetLabel(t_GetLngString("Svazek")).LeftPosZ(92, 40).TopPosZ(28, 20); layout.dv___3.LayoutId("dv___3"); parent.Add(layout.dv___3);
	layout.svazek.LeftPosZ(132, 32).TopPosZ(28, 19); layout.svazek.LayoutId("svazek"); parent.Add(layout.svazek);
	layout.dv___5.SetLabel(t_GetLngString("Strana")).LeftPosZ(8, 36).TopPosZ(52, 20); layout.dv___5.LayoutId("dv___5"); parent.Add(layout.dv___5);
	layout.strana.LeftPosZ(44, 36).TopPosZ(52, 19); layout.strana.LayoutId("strana"); parent.Add(layout.strana);
	layout.dv___7.SetLabel(t_GetLngString("slo")).LeftPosZ(92, 40).TopPosZ(52, 20); layout.dv___7.LayoutId("dv___7"); parent.Add(layout.dv___7);
	layout.cislo.LeftPosZ(132, 32).TopPosZ(52, 19); layout.cislo.LayoutId("cislo"); parent.Add(layout.cislo);
	layout.duplikat.SetLabel(t_GetLngString("Duplikt")).LeftPosZ(8, 76).TopPosZ(76, 24); layout.duplikat.LayoutId("duplikat"); parent.Add(layout.duplikat);
	layout.pc.SetLabel(t_GetLngString("Piadit slo")).LeftPosZ(88, 76).TopPosZ(76, 24); layout.pc.LayoutId("pc"); parent.Add(layout.pc);
	uts.zaznam.list.LeftPosZ(172, 224).TopPosZ(4, 96); uts.zaznam.list.LayoutId("zaznam.list"); parent.Add(uts.zaznam.list);
	uts.zaznam.add.LeftPosZ(400, 68).TopPosZ(4, 20); uts.zaznam.add.LayoutId("zaznam.add"); parent.Add(uts.zaznam.add);
	uts.zaznam.edit.LeftPosZ(400, 68).TopPosZ(28, 20); uts.zaznam.edit.LayoutId("zaznam.edit"); parent.Add(uts.zaznam.edit);
	uts.zaznam.remove.LeftPosZ(400, 68).TopPosZ(52, 20); uts.zaznam.remove.LayoutId("zaznam.remove"); parent.Add(uts.zaznam.remove);
	uts.zaznam.up.LeftPosZ(400, 32).TopPosZ(80, 20); uts.zaznam.up.LayoutId("zaznam.up"); parent.Add(uts.zaznam.up);
	uts.zaznam.down.LeftPosZ(436, 32).TopPosZ(80, 20); uts.zaznam.down.LayoutId("zaznam.down"); parent.Add(uts.zaznam.down);
	uts.osoby.LeftPosZ(8, 456).TopPosZ(104, 236); uts.osoby.LayoutId("osoby"); parent.Add(uts.osoby);
	uts.zaznam.doc.LeftPosZ(8, 456).TopPosZ(336, 196); uts.zaznam.doc.LayoutId("zaznam.doc"); parent.Add(uts.zaznam.doc);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(332, 64).TopPosZ(532, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(400, 64).TopPosZ(532, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, ListLayout__layid&) { parent.LayoutId("ListLayout");
	layout.cj_lbl.SetLabel(t_GetLngString(".j.")).LeftPosZ(308, 20).TopPosZ(4, 19); layout.cj_lbl.LayoutId("cj_lbl"); parent.Add(layout.cj_lbl);
	layout.cj.LeftPosZ(332, 108).TopPosZ(4, 19); layout.cj.LayoutId("cj"); parent.Add(layout.cj);
	layout.text.LeftPosZ(8, 432).TopPosZ(28, 96); layout.text.LayoutId("text"); parent.Add(layout.text);
	layout.label.SetLabel(t_GetLngString("Poznmka")).LeftPosZ(8, 172).TopPosZ(4, 19); layout.label.LayoutId("label"); parent.Add(layout.label);
	layout.dv___4.SetLabel(t_GetLngString("Matrik")).LeftPosZ(196, 52).TopPosZ(132, 19); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.dv___5.SetLabel(t_GetLngString("Datum vydn")).LeftPosZ(8, 72).TopPosZ(132, 19); layout.dv___5.LayoutId("dv___5"); parent.Add(layout.dv___5);
	layout.datum.LeftPosZ(80, 76).TopPosZ(132, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.matrikar.LeftPosZ(252, 188).TopPosZ(132, 19); layout.matrikar.LayoutId("matrikar"); parent.Add(layout.matrikar);
	layout.original.SetLabel(t_GetLngString("Originl")).LeftPosZ(8, 64).TopPosZ(164, 24); layout.original.LayoutId("original"); parent.Add(layout.original);
	layout.kopie.SetLabel(t_GetLngString("Kopie")).LeftPosZ(76, 64).TopPosZ(164, 24); layout.kopie.LayoutId("kopie"); parent.Add(layout.kopie);
	layout.original2.SetLabel(t_GetLngString("2: Originl")).LeftPosZ(160, 76).TopPosZ(164, 24); layout.original2.LayoutId("original2"); parent.Add(layout.original2);
	layout.kopie2.SetLabel(t_GetLngString("2: Kopie")).LeftPosZ(240, 76).TopPosZ(164, 24); layout.kopie2.LayoutId("kopie2"); parent.Add(layout.kopie2);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, OtcovstviLayout__layid&) { parent.LayoutId("OtcovstviLayout");
	layout.dv___0.SetLabel(t_GetLngString("Matrik")).LeftPosZ(196, 52).TopPosZ(144, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.dv___1.SetLabel(t_GetLngString("Datum zpisu")).LeftPosZ(8, 72).TopPosZ(144, 19); layout.dv___1.LayoutId("dv___1"); parent.Add(layout.dv___1);
	layout.datum.LeftPosZ(80, 76).TopPosZ(144, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.matrikar.LeftPosZ(252, 188).TopPosZ(144, 19); layout.matrikar.LayoutId("matrikar"); parent.Add(layout.matrikar);
	layout.print.SetLabel(t_GetLngString("Tisk")).LeftPosZ(8, 64).TopPosZ(164, 24); layout.print.LayoutId("print"); parent.Add(layout.print);
	layout.dv___5.SetLabel(t_GetLngString("M. je dcera")).LeftPosZ(8, 60).TopPosZ(4, 19); layout.dv___5.LayoutId("dv___5"); parent.Add(layout.dv___5);
	layout.dcera.LeftPosZ(68, 88).TopPosZ(4, 19); layout.dcera.LayoutId("dcera"); parent.Add(layout.dcera);
	layout.dv___7.SetLabel(t_GetLngString("r.")).LeftPosZ(160, 12).TopPosZ(4, 19); layout.dv___7.LayoutId("dv___7"); parent.Add(layout.dv___7);
	layout.dceraroz.LeftPosZ(176, 48).TopPosZ(4, 19); layout.dceraroz.LayoutId("dceraroz"); parent.Add(layout.dceraroz);
	layout.dv___9.SetLabel(t_GetLngString("a")).LeftPosZ(232, 12).TopPosZ(4, 19); layout.dv___9.LayoutId("dv___9"); parent.Add(layout.dv___9);
	layout.adcera.LeftPosZ(248, 88).TopPosZ(4, 19); layout.adcera.LayoutId("adcera"); parent.Add(layout.adcera);
	layout.dv___11.SetLabel(t_GetLngString("r.")).LeftPosZ(340, 12).TopPosZ(4, 19); layout.dv___11.LayoutId("dv___11"); parent.Add(layout.dv___11);
	layout.adceraroz.LeftPosZ(356, 84).TopPosZ(4, 19); layout.adceraroz.LayoutId("adceraroz"); parent.Add(layout.adceraroz);
	layout.dv___13.SetLabel(t_GetLngString("Otec je syn")).LeftPosZ(8, 60).TopPosZ(28, 19); layout.dv___13.LayoutId("dv___13"); parent.Add(layout.dv___13);
	layout.syn.LeftPosZ(68, 88).TopPosZ(28, 19); layout.syn.LayoutId("syn"); parent.Add(layout.syn);
	layout.dv___15.SetLabel(t_GetLngString("r.")).LeftPosZ(160, 12).TopPosZ(28, 19); layout.dv___15.LayoutId("dv___15"); parent.Add(layout.dv___15);
	layout.synroz.LeftPosZ(176, 48).TopPosZ(28, 19); layout.synroz.LayoutId("synroz"); parent.Add(layout.synroz);
	layout.dv___17.SetLabel(t_GetLngString("a")).LeftPosZ(232, 12).TopPosZ(28, 19); layout.dv___17.LayoutId("dv___17"); parent.Add(layout.dv___17);
	layout.asyn.LeftPosZ(248, 88).TopPosZ(28, 19); layout.asyn.LayoutId("asyn"); parent.Add(layout.asyn);
	layout.dv___19.SetLabel(t_GetLngString("r.")).LeftPosZ(340, 12).TopPosZ(28, 19); layout.dv___19.LayoutId("dv___19"); parent.Add(layout.dv___19);
	layout.asynroz.LeftPosZ(356, 84).TopPosZ(28, 19); layout.asynroz.LayoutId("asynroz"); parent.Add(layout.asynroz);
	layout.dv___21.SetLabel(t_GetLngString("Rozv. r. soudu v")).LeftPosZ(8, 88).TopPosZ(64, 19); layout.dv___21.LayoutId("dv___21"); parent.Add(layout.dv___21);
	layout.soud.LeftPosZ(108, 228).TopPosZ(64, 19); layout.soud.LayoutId("soud"); parent.Add(layout.soud);
	layout.dv___23.SetLabel(t_GetLngString("ze")).LeftPosZ(344, 16).TopPosZ(64, 19); layout.dv___23.LayoutId("dv___23"); parent.Add(layout.dv___23);
	layout.sdatum.LeftPosZ(364, 76).TopPosZ(64, 19); layout.sdatum.LayoutId("sdatum"); parent.Add(layout.sdatum);
	layout.dv___25.SetLabel(t_GetLngString(".j.")).HCenterPosZ(24, -140).TopPosZ(84, 19); layout.dv___25.LayoutId("dv___25"); parent.Add(layout.dv___25);
	layout.scj.LeftPosZ(108, 128).TopPosZ(84, 19); layout.scj.LayoutId("scj"); parent.Add(layout.scj);
	layout.dv___27.SetLabel(t_GetLngString("PM")).LeftPosZ(244, 30).TopPosZ(84, 19); layout.dv___27.LayoutId("dv___27"); parent.Add(layout.dv___27);
	layout.spm.LeftPosZ(276, 76).TopPosZ(84, 19); layout.spm.LayoutId("spm"); parent.Add(layout.spm);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, OtcovstviNLayout__layid&) { parent.LayoutId("OtcovstviNLayout");
	layout.dv___0.SetLabel(t_GetLngString("M. je dcera")).LeftPosZ(8, 60).TopPosZ(4, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.dcera.LeftPosZ(68, 88).TopPosZ(4, 19); layout.dcera.LayoutId("dcera"); parent.Add(layout.dcera);
	layout.dv___2.SetLabel(t_GetLngString("r.")).LeftPosZ(160, 12).TopPosZ(4, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.dceraroz.LeftPosZ(176, 48).TopPosZ(4, 19); layout.dceraroz.LayoutId("dceraroz"); parent.Add(layout.dceraroz);
	layout.dv___4.SetLabel(t_GetLngString("a")).LeftPosZ(232, 12).TopPosZ(4, 19); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.adcera.LeftPosZ(248, 88).TopPosZ(4, 19); layout.adcera.LayoutId("adcera"); parent.Add(layout.adcera);
	layout.dv___6.SetLabel(t_GetLngString("r.")).LeftPosZ(340, 12).TopPosZ(4, 19); layout.dv___6.LayoutId("dv___6"); parent.Add(layout.dv___6);
	layout.adceraroz.LeftPosZ(356, 84).TopPosZ(4, 19); layout.adceraroz.LayoutId("adceraroz"); parent.Add(layout.adceraroz);
	layout.dv___8.SetLabel(t_GetLngString("Otec je syn")).LeftPosZ(8, 60).TopPosZ(28, 19); layout.dv___8.LayoutId("dv___8"); parent.Add(layout.dv___8);
	layout.syn.LeftPosZ(68, 88).TopPosZ(28, 19); layout.syn.LayoutId("syn"); parent.Add(layout.syn);
	layout.dv___10.SetLabel(t_GetLngString("r.")).LeftPosZ(160, 12).TopPosZ(28, 19); layout.dv___10.LayoutId("dv___10"); parent.Add(layout.dv___10);
	layout.synroz.LeftPosZ(176, 48).TopPosZ(28, 19); layout.synroz.LayoutId("synroz"); parent.Add(layout.synroz);
	layout.dv___12.SetLabel(t_GetLngString("a")).LeftPosZ(232, 12).TopPosZ(28, 19); layout.dv___12.LayoutId("dv___12"); parent.Add(layout.dv___12);
	layout.asyn.LeftPosZ(248, 88).TopPosZ(28, 19); layout.asyn.LayoutId("asyn"); parent.Add(layout.asyn);
	layout.dv___14.SetLabel(t_GetLngString("r.")).LeftPosZ(340, 12).TopPosZ(28, 19); layout.dv___14.LayoutId("dv___14"); parent.Add(layout.dv___14);
	layout.asynroz.LeftPosZ(356, 84).TopPosZ(28, 19); layout.asynroz.LayoutId("asynroz"); parent.Add(layout.asynroz);
	layout.dv___16.SetLabel(t_GetLngString("Thotensk prkaz")).LeftPosZ(8, 100).TopPosZ(52, 19); layout.dv___16.LayoutId("dv___16"); parent.Add(layout.dv___16);
	layout.text.LeftPosZ(108, 176).TopPosZ(52, 19); layout.text.LayoutId("text"); parent.Add(layout.text);
	layout.dv___18.SetLabel(t_GetLngString("Termn porodu")).LeftPosZ(288, 72).TopPosZ(52, 19); layout.dv___18.LayoutId("dv___18"); parent.Add(layout.dv___18);
	layout.porod.LeftPosZ(364, 76).TopPosZ(52, 19); layout.porod.LayoutId("porod"); parent.Add(layout.porod);
	layout.dv___20.SetLabel(t_GetLngString("Rozv. r. soudu v")).LeftPosZ(8, 88).TopPosZ(76, 19); layout.dv___20.LayoutId("dv___20"); parent.Add(layout.dv___20);
	layout.soud.LeftPosZ(108, 228).TopPosZ(76, 19); layout.soud.LayoutId("soud"); parent.Add(layout.soud);
	layout.dv___22.SetLabel(t_GetLngString("ze")).LeftPosZ(344, 16).TopPosZ(76, 19); layout.dv___22.LayoutId("dv___22"); parent.Add(layout.dv___22);
	layout.sdatum.LeftPosZ(364, 76).TopPosZ(76, 19); layout.sdatum.LayoutId("sdatum"); parent.Add(layout.sdatum);
	layout.dv___24.SetLabel(t_GetLngString(".j.")).HCenterPosZ(24, -140).TopPosZ(96, 19); layout.dv___24.LayoutId("dv___24"); parent.Add(layout.dv___24);
	layout.scj.LeftPosZ(108, 128).TopPosZ(96, 19); layout.scj.LayoutId("scj"); parent.Add(layout.scj);
	layout.dv___26.SetLabel(t_GetLngString("PM")).LeftPosZ(244, 30).TopPosZ(96, 19); layout.dv___26.LayoutId("dv___26"); parent.Add(layout.dv___26);
	layout.spm.LeftPosZ(276, 76).TopPosZ(96, 19); layout.spm.LayoutId("spm"); parent.Add(layout.spm);
	layout.dv___28.SetLabel(t_GetLngString("Budouc pjmen")).LeftPosZ(8, 96).TopPosZ(120, 19); layout.dv___28.LayoutId("dv___28"); parent.Add(layout.dv___28);
	layout.text1.LeftPosZ(108, 152).TopPosZ(120, 19); layout.text1.LayoutId("text1"); parent.Add(layout.text1);
	layout.dv___30.SetLabel(t_GetLngString("Datum zpisu")).LeftPosZ(8, 72).TopPosZ(140, 19); layout.dv___30.LayoutId("dv___30"); parent.Add(layout.dv___30);
	layout.datum.LeftPosZ(108, 76).TopPosZ(140, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.dv___32.SetLabel(t_GetLngString("Matrik")).LeftPosZ(196, 52).TopPosZ(140, 19); layout.dv___32.LayoutId("dv___32"); parent.Add(layout.dv___32);
	layout.matrikar.LeftPosZ(252, 188).TopPosZ(140, 19); layout.matrikar.LayoutId("matrikar"); parent.Add(layout.matrikar);
	layout.print.SetLabel(t_GetLngString("Tisk")).LeftPosZ(8, 64).TopPosZ(164, 24); layout.print.LayoutId("print"); parent.Add(layout.print);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, KnihaLayout__layid&) { parent.LayoutId("KnihaLayout");
	layout.lbl.SetLabel(t_GetLngString("Zznamy a opravy ped podpisem")).LeftPosZ(4, 176).TopPosZ(4, 19); layout.lbl.LayoutId("lbl"); parent.Add(layout.lbl);
	uts.text.dash.SetLabel(t_GetLngString("...................")).LeftPosZ(352, 88).TopPosZ(8, 16); uts.text.dash.LayoutId("text.dash"); parent.Add(uts.text.dash);
	layout.text.LeftPosZ(4, 436).TopPosZ(24, 104); layout.text.LayoutId("text"); parent.Add(layout.text);
	layout.dv___3.SetLabel(t_GetLngString("Datum zpisu")).LeftPosZ(8, 72).TopPosZ(136, 19); layout.dv___3.LayoutId("dv___3"); parent.Add(layout.dv___3);
	layout.datum.LeftPosZ(84, 76).TopPosZ(136, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.dv___5.SetLabel(t_GetLngString("Matrik")).LeftPosZ(196, 52).TopPosZ(136, 19); layout.dv___5.LayoutId("dv___5"); parent.Add(layout.dv___5);
	layout.matrikar.LeftPosZ(252, 136).TopPosZ(136, 19); layout.matrikar.LayoutId("matrikar"); parent.Add(layout.matrikar);
	layout.idc.LeftPosZ(392, 48).TopPosZ(136, 19); layout.idc.LayoutId("idc"); parent.Add(layout.idc);
	layout.print.SetLabel(t_GetLngString("Tisk")).LeftPosZ(8, 64).TopPosZ(164, 24); layout.print.LayoutId("print"); parent.Add(layout.print);
	layout.datum_vt.SetLabel(t_GetLngString("Zapsat do V.T.")).LeftPosZ(76, 96).TopPosZ(164, 24); layout.datum_vt.LayoutId("datum_vt"); parent.Add(layout.datum_vt);
	layout.cislo_txt.SetLabel(t_GetLngString("Poadov slo zmny")).LeftPosZ(280, 108).TopPosZ(164, 19); layout.cislo_txt.LayoutId("cislo_txt"); parent.Add(layout.cislo_txt);
	layout.cislo.LeftPosZ(392, 48).TopPosZ(164, 19); layout.cislo.LayoutId("cislo"); parent.Add(layout.cislo);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, KnihaNarozeniLayout__layid&) { parent.LayoutId("KnihaNarozeniLayout");
	layout.lbl.SetLabel(t_GetLngString("Zznamy a opravy ped podpisem")).LeftPosZ(4, 176).TopPosZ(4, 19); layout.lbl.LayoutId("lbl"); parent.Add(layout.lbl);
	layout.text.LeftPosZ(4, 436).TopPosZ(24, 104); layout.text.LayoutId("text"); parent.Add(layout.text);
	uts.text.dash.SetLabel("...................").LeftPosZ(352, 88).TopPosZ(8, 16); uts.text.dash.LayoutId("text.dash"); parent.Add(uts.text.dash);
	layout.dv___3.SetLabel(t_GetLngString("Datum zpisu")).LeftPosZ(8, 72).TopPosZ(136, 19); layout.dv___3.LayoutId("dv___3"); parent.Add(layout.dv___3);
	layout.datum.LeftPosZ(84, 76).TopPosZ(136, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.dv___5.SetLabel(t_GetLngString("Matrik")).LeftPosZ(196, 52).TopPosZ(136, 19); layout.dv___5.LayoutId("dv___5"); parent.Add(layout.dv___5);
	layout.matrikar.LeftPosZ(252, 136).TopPosZ(136, 19); layout.matrikar.LayoutId("matrikar"); parent.Add(layout.matrikar);
	layout.idc.LeftPosZ(392, 48).TopPosZ(136, 19); layout.idc.LayoutId("idc"); parent.Add(layout.idc);
	layout.print.SetLabel(t_GetLngString("Tisk")).LeftPosZ(8, 64).TopPosZ(164, 24); layout.print.LayoutId("print"); parent.Add(layout.print);
	layout.otcovstvi.SetLabel(t_GetLngString("Otcovstv")).LeftPosZ(292, 72).TopPosZ(164, 24); layout.otcovstvi.LayoutId("otcovstvi"); parent.Add(layout.otcovstvi);
	layout.otcovstvin.SetLabel(t_GetLngString("Otcovstv n.")).LeftPosZ(368, 72).TopPosZ(164, 24); layout.otcovstvin.LayoutId("otcovstvin"); parent.Add(layout.otcovstvin);
	layout.datum_vt.SetLabel(t_GetLngString("Zapsat do V.T.")).LeftPosZ(76, 96).TopPosZ(164, 24); layout.datum_vt.LayoutId("datum_vt"); parent.Add(layout.datum_vt);
	layout.cislo_txt.SetLabel(t_GetLngString("P. . zmny")).LeftPosZ(176, 60).TopPosZ(166, 19); layout.cislo_txt.LayoutId("cislo_txt"); parent.Add(layout.cislo_txt);
	layout.cislo.LeftPosZ(240, 48).TopPosZ(166, 19); layout.cislo.LayoutId("cislo"); parent.Add(layout.cislo);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, SelectLayout__layid&) { parent.LayoutId("SelectLayout");
	layout.dv___0.SetLabel(t_GetLngString("Matrika")).LeftPosZ(8, 52).TopPosZ(4, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.typ.LeftPosZ(64, 176).TopPosZ(4, 19); layout.typ.LayoutId("typ"); parent.Add(layout.typ);
	layout.dv___2.SetLabel(t_GetLngString("Obec")).LeftPosZ(8, 52).TopPosZ(32, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.obec_seq.LeftPosZ(64, 160).TopPosZ(32, 19); layout.obec_seq.LayoutId("obec_seq"); parent.Add(layout.obec_seq);
	layout.dv___4.SetLabel(t_GetLngString("Ronk")).LeftPosZ(8, 52).TopPosZ(56, 20); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.rocnik.LeftPosZ(64, 56).TopPosZ(56, 19); layout.rocnik.LayoutId("rocnik"); parent.Add(layout.rocnik);
	layout.dv___6.SetLabel(t_GetLngString("a")).LeftPosZ(140, 16).TopPosZ(56, 19); layout.dv___6.LayoutId("dv___6"); parent.Add(layout.dv___6);
	layout.rocnikdo.LeftPosZ(168, 56).TopPosZ(56, 19); layout.rocnikdo.LayoutId("rocnikdo"); parent.Add(layout.rocnikdo);
	layout.dv___8.SetLabel(t_GetLngString("Svazek")).LeftPosZ(8, 52).TopPosZ(80, 20); layout.dv___8.LayoutId("dv___8"); parent.Add(layout.dv___8);
	layout.svazek.LeftPosZ(64, 56).TopPosZ(80, 19); layout.svazek.LayoutId("svazek"); parent.Add(layout.svazek);
	layout.dv___10.SetLabel(t_GetLngString("a")).LeftPosZ(140, 16).TopPosZ(80, 19); layout.dv___10.LayoutId("dv___10"); parent.Add(layout.dv___10);
	layout.svazekdo.LeftPosZ(168, 56).TopPosZ(80, 19); layout.svazekdo.LayoutId("svazekdo"); parent.Add(layout.svazekdo);
	layout.dv___12.SetLabel(t_GetLngString("Strana")).LeftPosZ(8, 52).TopPosZ(104, 20); layout.dv___12.LayoutId("dv___12"); parent.Add(layout.dv___12);
	layout.strana.LeftPosZ(64, 56).TopPosZ(104, 19); layout.strana.LayoutId("strana"); parent.Add(layout.strana);
	layout.dv___14.SetLabel(t_GetLngString("a")).LeftPosZ(140, 16).TopPosZ(104, 19); layout.dv___14.LayoutId("dv___14"); parent.Add(layout.dv___14);
	layout.stranado.LeftPosZ(168, 56).TopPosZ(104, 19); layout.stranado.LayoutId("stranado"); parent.Add(layout.stranado);
	layout.dv___16.SetLabel(t_GetLngString("slo")).LeftPosZ(8, 52).TopPosZ(128, 20); layout.dv___16.LayoutId("dv___16"); parent.Add(layout.dv___16);
	layout.cislo.LeftPosZ(64, 56).TopPosZ(128, 19); layout.cislo.LayoutId("cislo"); parent.Add(layout.cislo);
	layout.dv___18.SetLabel(t_GetLngString("a")).LeftPosZ(140, 16).TopPosZ(128, 19); layout.dv___18.LayoutId("dv___18"); parent.Add(layout.dv___18);
	layout.cislodo.LeftPosZ(168, 56).TopPosZ(128, 19); layout.cislodo.LayoutId("cislodo"); parent.Add(layout.cislodo);
	layout.dv___20.SetLabel(t_GetLngString("Datum")).LeftPosZ(8, 52).TopPosZ(160, 20); layout.dv___20.LayoutId("dv___20"); parent.Add(layout.dv___20);
	layout.datum.LeftPosZ(64, 68).TopPosZ(160, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.dv___22.SetLabel(t_GetLngString("a")).LeftPosZ(140, 16).TopPosZ(160, 19); layout.dv___22.LayoutId("dv___22"); parent.Add(layout.dv___22);
	layout.datumdo.LeftPosZ(168, 72).TopPosZ(160, 19); layout.datumdo.LayoutId("datumdo"); parent.Add(layout.datumdo);
	layout.dv___24.SetLabel(t_GetLngString("R")).LeftPosZ(8, 52).TopPosZ(192, 19); layout.dv___24.LayoutId("dv___24"); parent.Add(layout.dv___24);
	layout.rc.LeftPosZ(64, 176).TopPosZ(192, 19); layout.rc.LayoutId("rc"); parent.Add(layout.rc);
	layout.dv___26.SetLabel(t_GetLngString("Pjmen")).LeftPosZ(8, 52).TopPosZ(216, 19); layout.dv___26.LayoutId("dv___26"); parent.Add(layout.dv___26);
	layout.clear.SetLabel(t_GetLngString("Smazat")).LeftPosZ(8, 64).TopPosZ(312, 24); layout.clear.LayoutId("clear"); parent.Add(layout.clear);
	layout.prijmeni.LeftPosZ(64, 176).TopPosZ(216, 19); layout.prijmeni.LayoutId("prijmeni"); parent.Add(layout.prijmeni);
	layout.knihy.SetLabel(t_GetLngString("Pouze knihy")).LeftPosZ(64, 120).TopPosZ(244, 15); layout.knihy.LayoutId("knihy"); parent.Add(layout.knihy);
	layout.neuzavrene.SetLabel(t_GetLngString("Neuzaven zznamy")).LeftPosZ(64, 148).TopPosZ(264, 15); layout.neuzavrene.LayoutId("neuzavrene"); parent.Add(layout.neuzavrene);
	layout.nkniha.SetLabel(t_GetLngString("Zznamy bez knihy")).LeftPosZ(64, 148).TopPosZ(284, 15); layout.nkniha.LayoutId("nkniha"); parent.Add(layout.nkniha);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(108, 64).TopPosZ(312, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(176, 64).TopPosZ(312, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, ManzelstviLayout__layid&) { parent.LayoutId("ManzelstviLayout");
	layout.obec_seq.LeftPosZ(8, 156).TopPosZ(4, 19); layout.obec_seq.LayoutId("obec_seq"); parent.Add(layout.obec_seq);
	layout.dv___1.SetLabel(t_GetLngString("Ronk")).LeftPosZ(8, 36).TopPosZ(28, 20); layout.dv___1.LayoutId("dv___1"); parent.Add(layout.dv___1);
	layout.rocnik.LeftPosZ(44, 36).TopPosZ(28, 19); layout.rocnik.LayoutId("rocnik"); parent.Add(layout.rocnik);
	layout.dv___3.SetLabel(t_GetLngString("Svazek")).LeftPosZ(92, 40).TopPosZ(28, 20); layout.dv___3.LayoutId("dv___3"); parent.Add(layout.dv___3);
	layout.svazek.LeftPosZ(132, 32).TopPosZ(28, 19); layout.svazek.LayoutId("svazek"); parent.Add(layout.svazek);
	layout.dv___5.SetLabel(t_GetLngString("Strana")).LeftPosZ(8, 36).TopPosZ(52, 20); layout.dv___5.LayoutId("dv___5"); parent.Add(layout.dv___5);
	layout.strana.LeftPosZ(44, 36).TopPosZ(52, 19); layout.strana.LayoutId("strana"); parent.Add(layout.strana);
	layout.dv___7.SetLabel(t_GetLngString("slo")).LeftPosZ(92, 40).TopPosZ(52, 20); layout.dv___7.LayoutId("dv___7"); parent.Add(layout.dv___7);
	layout.cislo.LeftPosZ(132, 32).TopPosZ(52, 19); layout.cislo.LayoutId("cislo"); parent.Add(layout.cislo);
	layout.duplikat.SetLabel(t_GetLngString("Duplikt")).LeftPosZ(8, 60).TopPosZ(76, 24); layout.duplikat.LayoutId("duplikat"); parent.Add(layout.duplikat);
	layout.pc.SetLabel(t_GetLngString("Piadit slo")).LeftPosZ(88, 76).TopPosZ(76, 24); layout.pc.LayoutId("pc"); parent.Add(layout.pc);
	uts.zaznam.list.LeftPosZ(172, 224).TopPosZ(4, 96); uts.zaznam.list.LayoutId("zaznam.list"); parent.Add(uts.zaznam.list);
	uts.zaznam.add.LeftPosZ(400, 68).TopPosZ(4, 20); uts.zaznam.add.LayoutId("zaznam.add"); parent.Add(uts.zaznam.add);
	uts.zaznam.edit.LeftPosZ(400, 68).TopPosZ(28, 20); uts.zaznam.edit.LayoutId("zaznam.edit"); parent.Add(uts.zaznam.edit);
	uts.zaznam.remove.LeftPosZ(400, 68).TopPosZ(52, 20); uts.zaznam.remove.LayoutId("zaznam.remove"); parent.Add(uts.zaznam.remove);
	uts.zaznam.up.LeftPosZ(400, 32).TopPosZ(80, 20); uts.zaznam.up.LayoutId("zaznam.up"); parent.Add(uts.zaznam.up);
	uts.zaznam.down.LeftPosZ(436, 32).TopPosZ(80, 20); uts.zaznam.down.LayoutId("zaznam.down"); parent.Add(uts.zaznam.down);
	uts.osoby.LeftPosZ(8, 456).TopPosZ(104, 236); uts.osoby.LayoutId("osoby"); parent.Add(uts.osoby);
	uts.zaznam.doc.LeftPosZ(8, 456).TopPosZ(336, 196); uts.zaznam.doc.LayoutId("zaznam.doc"); parent.Add(uts.zaznam.doc);
	layout.dv___19.SetLabel(t_GetLngString("Ped")).LeftPosZ(472, 28).TopPosZ(4, 19); layout.dv___19.LayoutId("dv___19"); parent.Add(layout.dv___19);
	layout.pred.LeftPosZ(500, 264).TopPosZ(4, 19); layout.pred.LayoutId("pred"); parent.Add(layout.pred);
	layout.dv___21.SetLabel(t_GetLngString("Msto uzaven manelstv")).LeftPosZ(472, 128).TopPosZ(28, 19); layout.dv___21.LayoutId("dv___21"); parent.Add(layout.dv___21);
	layout.misto.LeftPosZ(472, 292).TopPosZ(48, 19); layout.misto.LayoutId("misto"); parent.Add(layout.misto);
	layout.misto1.LeftPosZ(472, 292).TopPosZ(68, 19); layout.misto1.LayoutId("misto1"); parent.Add(layout.misto1);
	layout.dv___24.SetLabel(t_GetLngString("Datum uzaven manelstv")).LeftPosZ(472, 140).TopPosZ(92, 19); layout.dv___24.LayoutId("dv___24"); parent.Add(layout.dv___24);
	layout.datum.LeftPosZ(612, 84).TopPosZ(92, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.dv___26.SetLabel(t_GetLngString("enich")).LeftPosZ(580, 36).TopPosZ(116, 13); layout.dv___26.LayoutId("dv___26"); parent.Add(layout.dv___26);
	layout.dv___27.SetLabel(t_GetLngString("Nevsta")).LeftPosZ(668, 56).TopPosZ(116, 13); layout.dv___27.LayoutId("dv___27"); parent.Add(layout.dv___27);
	layout.dv___28.SetLabel(t_GetLngString("Vzdln")).LeftPosZ(472, 64).TopPosZ(132, 19); layout.dv___28.LayoutId("dv___28"); parent.Add(layout.dv___28);
	layout.vzdelanim.LeftPosZ(580, 84).TopPosZ(132, 19); layout.vzdelanim.LayoutId("vzdelanim"); parent.Add(layout.vzdelanim);
	layout.vzdelaniz.LeftPosZ(668, 84).TopPosZ(132, 19); layout.vzdelaniz.LayoutId("vzdelaniz"); parent.Add(layout.vzdelaniz);
	layout.dv___31.SetLabel(t_GetLngString("Poad manelstv")).LeftPosZ(472, 88).TopPosZ(152, 19); layout.dv___31.LayoutId("dv___31"); parent.Add(layout.dv___31);
	layout.poradim.LeftPosZ(580, 84).TopPosZ(152, 19); layout.poradim.LayoutId("poradim"); parent.Add(layout.poradim);
	layout.poradiz.LeftPosZ(668, 84).TopPosZ(152, 19); layout.poradiz.LayoutId("poradiz"); parent.Add(layout.poradiz);
	layout.dv___34.SetLabel(t_GetLngString("Datum roz./ovd.")).LeftPosZ(472, 88).TopPosZ(172, 19); layout.dv___34.LayoutId("dv___34"); parent.Add(layout.dv___34);
	layout.rozm.LeftPosZ(580, 84).TopPosZ(172, 19); layout.rozm.LayoutId("rozm"); parent.Add(layout.rozm);
	layout.rozz.LeftPosZ(668, 84).TopPosZ(172, 19); layout.rozz.LayoutId("rozz"); parent.Add(layout.rozz);
	layout.dv___37.SetLabel(t_GetLngString("Dohoda o pjmen")).LeftPosZ(472, 288).TopPosZ(208, 116); layout.dv___37.LayoutId("dv___37"); parent.Add(layout.dv___37);
	layout.dv___38.SetLabel(t_GetLngString("Mu")).LeftPosZ(580, 36).TopPosZ(220, 13); layout.dv___38.LayoutId("dv___38"); parent.Add(layout.dv___38);
	layout.dv___39.SetLabel(t_GetLngString("ena")).LeftPosZ(668, 36).TopPosZ(220, 13); layout.dv___39.LayoutId("dv___39"); parent.Add(layout.dv___39);
	layout.dv___40.SetLabel(t_GetLngString("Manel")).LeftPosZ(484, 92).TopPosZ(236, 19); layout.dv___40.LayoutId("dv___40"); parent.Add(layout.dv___40);
	layout.spolecnem.LeftPosZ(580, 84).TopPosZ(236, 19); layout.spolecnem.LayoutId("spolecnem"); parent.Add(layout.spolecnem);
	layout.spolecnez.LeftPosZ(668, 84).TopPosZ(236, 19); layout.spolecnez.LayoutId("spolecnez"); parent.Add(layout.spolecnez);
	layout.dv___43.SetLabel(t_GetLngString("Dti")).LeftPosZ(484, 92).TopPosZ(260, 19); layout.dv___43.LayoutId("dv___43"); parent.Add(layout.dv___43);
	layout.detim.LeftPosZ(580, 84).TopPosZ(260, 19); layout.detim.LayoutId("detim"); parent.Add(layout.detim);
	layout.detiz.LeftPosZ(668, 84).TopPosZ(260, 19); layout.detiz.LayoutId("detiz"); parent.Add(layout.detiz);
	layout.dv___46.SetLabel(t_GetLngString("Na druhm mst")).LeftPosZ(484, 92).TopPosZ(284, 19); layout.dv___46.LayoutId("dv___46"); parent.Add(layout.dv___46);
	layout.navicm.LeftPosZ(580, 84).TopPosZ(284, 19); layout.navicm.LayoutId("navicm"); parent.Add(layout.navicm);
	layout.navicz.LeftPosZ(668, 84).TopPosZ(284, 19); layout.navicz.LayoutId("navicz"); parent.Add(layout.navicz);
	layout.spolecne.SetLabel(t_GetLngString("Manel budou uvat spolen pjmen")).LeftPosZ(484, 268).TopPosZ(304, 15); layout.spolecne.LayoutId("spolecne"); parent.Add(layout.spolecne);
	layout.dv___50.SetLabel(t_GetLngString("Obad")).LeftPosZ(472, 288).TopPosZ(332, 88); layout.dv___50.LayoutId("dv___50"); parent.Add(layout.dv___50);
	layout.obrad.LeftPosZ(480, 272).TopPosZ(348, 19); layout.obrad.LayoutId("obrad"); parent.Add(layout.obrad);
	layout.obrad1.LeftPosZ(480, 272).TopPosZ(372, 44); layout.obrad1.LayoutId("obrad1"); parent.Add(layout.obrad1);
	layout.dv___53.SetLabel(t_GetLngString("Oddvajc")).LeftPosZ(472, 56).TopPosZ(424, 19); layout.dv___53.LayoutId("dv___53"); parent.Add(layout.dv___53);
	layout.oddavajici.LeftPosZ(532, 124).TopPosZ(424, 19); layout.oddavajici.LayoutId("oddavajici"); parent.Add(layout.oddavajici);
	layout.dv___55.SetLabel(t_GetLngString("tl.")).LeftPosZ(660, 12).TopPosZ(424, 19); layout.dv___55.LayoutId("dv___55"); parent.Add(layout.dv___55);
	layout.tlumocnik.LeftPosZ(676, 84).TopPosZ(424, 19); layout.tlumocnik.LayoutId("tlumocnik"); parent.Add(layout.tlumocnik);
	layout.dv___57.SetLabel(t_GetLngString("Okr. soud")).LeftPosZ(472, 56).TopPosZ(448, 19); layout.dv___57.LayoutId("dv___57"); parent.Add(layout.dv___57);
	layout.soud.HSizePosZ(532, 112).TopPosZ(448, 19); layout.soud.LayoutId("soud"); parent.Add(layout.soud);
	layout.dv___59.SetLabel(t_GetLngString("ze")).LeftPosZ(660, 16).TopPosZ(448, 19); layout.dv___59.LayoutId("dv___59"); parent.Add(layout.dv___59);
	layout.zedne.LeftPosZ(676, 84).TopPosZ(448, 19); layout.zedne.LayoutId("zedne"); parent.Add(layout.zedne);
	layout.dv___61.SetLabel(t_GetLngString(".j.")).LeftPosZ(472, 56).TopPosZ(468, 19); layout.dv___61.LayoutId("dv___61"); parent.Add(layout.dv___61);
	layout.cj.HSizePosZ(532, 120).TopPosZ(468, 19); layout.cj.LayoutId("cj"); parent.Add(layout.cj);
	layout.dv___63.SetLabel(t_GetLngString("dne")).LeftPosZ(652, 24).TopPosZ(468, 19); layout.dv___63.LayoutId("dv___63"); parent.Add(layout.dv___63);
	layout.dne.LeftPosZ(676, 84).TopPosZ(468, 19); layout.dne.LayoutId("dne"); parent.Add(layout.dne);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(628, 64).TopPosZ(500, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(696, 64).TopPosZ(500, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, HlaseniLayout__layid&) { parent.LayoutId("HlaseniLayout");
	layout.dv___0.SetLabel(t_GetLngString("Matrik")).LeftPosZ(196, 52).TopPosZ(8, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.dv___1.SetLabel(t_GetLngString("Datum zpisu")).LeftPosZ(8, 72).TopPosZ(8, 19); layout.dv___1.LayoutId("dv___1"); parent.Add(layout.dv___1);
	layout.datum.LeftPosZ(80, 76).TopPosZ(8, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.matrikar.LeftPosZ(252, 188).TopPosZ(8, 19); layout.matrikar.LayoutId("matrikar"); parent.Add(layout.matrikar);
	layout.original.SetLabel(t_GetLngString("Originl")).LeftPosZ(8, 64).TopPosZ(164, 24); layout.original.LayoutId("original"); parent.Add(layout.original);
	layout.kopie.SetLabel(t_GetLngString("Kopie")).LeftPosZ(76, 64).TopPosZ(164, 24); layout.kopie.LayoutId("kopie"); parent.Add(layout.kopie);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, UmrtiLayout__layid&) { parent.LayoutId("UmrtiLayout");
	layout.obec_seq.LeftPosZ(8, 156).TopPosZ(4, 19); layout.obec_seq.LayoutId("obec_seq"); parent.Add(layout.obec_seq);
	layout.dv___1.SetLabel(t_GetLngString("Ronk")).LeftPosZ(8, 36).TopPosZ(28, 20); layout.dv___1.LayoutId("dv___1"); parent.Add(layout.dv___1);
	layout.rocnik.LeftPosZ(44, 36).TopPosZ(28, 19); layout.rocnik.LayoutId("rocnik"); parent.Add(layout.rocnik);
	layout.dv___3.SetLabel(t_GetLngString("Svazek")).LeftPosZ(92, 40).TopPosZ(28, 20); layout.dv___3.LayoutId("dv___3"); parent.Add(layout.dv___3);
	layout.svazek.LeftPosZ(132, 32).TopPosZ(28, 19); layout.svazek.LayoutId("svazek"); parent.Add(layout.svazek);
	layout.dv___5.SetLabel(t_GetLngString("Strana")).LeftPosZ(8, 36).TopPosZ(52, 20); layout.dv___5.LayoutId("dv___5"); parent.Add(layout.dv___5);
	layout.strana.LeftPosZ(44, 36).TopPosZ(52, 19); layout.strana.LayoutId("strana"); parent.Add(layout.strana);
	layout.dv___7.SetLabel(t_GetLngString("slo")).LeftPosZ(92, 40).TopPosZ(52, 20); layout.dv___7.LayoutId("dv___7"); parent.Add(layout.dv___7);
	layout.cislo.LeftPosZ(132, 32).TopPosZ(52, 19); layout.cislo.LayoutId("cislo"); parent.Add(layout.cislo);
	layout.pc.SetLabel(t_GetLngString("Piadit slo")).LeftPosZ(8, 76).TopPosZ(76, 24); layout.pc.LayoutId("pc"); parent.Add(layout.pc);
	layout.duplikat.SetLabel(t_GetLngString("Duplikt")).LeftPosZ(104, 60).TopPosZ(76, 24); layout.duplikat.LayoutId("duplikat"); parent.Add(layout.duplikat);
	uts.zaznam.list.LeftPosZ(172, 224).TopPosZ(4, 96); uts.zaznam.list.LayoutId("zaznam.list"); parent.Add(uts.zaznam.list);
	uts.zaznam.add.LeftPosZ(400, 68).TopPosZ(4, 20); uts.zaznam.add.LayoutId("zaznam.add"); parent.Add(uts.zaznam.add);
	uts.zaznam.edit.LeftPosZ(400, 68).TopPosZ(28, 20); uts.zaznam.edit.LayoutId("zaznam.edit"); parent.Add(uts.zaznam.edit);
	uts.zaznam.remove.LeftPosZ(400, 68).TopPosZ(52, 20); uts.zaznam.remove.LayoutId("zaznam.remove"); parent.Add(uts.zaznam.remove);
	uts.zaznam.up.LeftPosZ(400, 32).TopPosZ(80, 20); uts.zaznam.up.LayoutId("zaznam.up"); parent.Add(uts.zaznam.up);
	uts.zaznam.down.LeftPosZ(436, 32).TopPosZ(80, 20); uts.zaznam.down.LayoutId("zaznam.down"); parent.Add(uts.zaznam.down);
	uts.osoby.LeftPosZ(8, 456).TopPosZ(104, 236); uts.osoby.LayoutId("osoby"); parent.Add(uts.osoby);
	uts.zaznam.doc.LeftPosZ(8, 456).TopPosZ(336, 196); uts.zaznam.doc.LayoutId("zaznam.doc"); parent.Add(uts.zaznam.doc);
	layout.dv___19.SetLabel(t_GetLngString("Msto mrt")).LeftPosZ(472, 128).TopPosZ(4, 19); layout.dv___19.LayoutId("dv___19"); parent.Add(layout.dv___19);
	layout.misto.LeftPosZ(472, 292).TopPosZ(24, 19); layout.misto.LayoutId("misto"); parent.Add(layout.misto);
	layout.misto1.LeftPosZ(472, 152).TopPosZ(44, 19); layout.misto1.LayoutId("misto1"); parent.Add(layout.misto1);
	layout.dv___22.SetLabel(t_GetLngString("Vzdln")).LeftPosZ(632, 48).TopPosZ(44, 19); layout.dv___22.LayoutId("dv___22"); parent.Add(layout.dv___22);
	layout.vzdelanim.LeftPosZ(680, 84).TopPosZ(44, 19); layout.vzdelanim.LayoutId("vzdelanim"); parent.Add(layout.vzdelanim);
	layout.dv___24.SetLabel(t_GetLngString("Datum umrt")).LeftPosZ(472, 68).TopPosZ(68, 19); layout.dv___24.LayoutId("dv___24"); parent.Add(layout.dv___24);
	layout.datum.LeftPosZ(548, 76).TopPosZ(68, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.dv___26.SetLabel(t_GetLngString("a")).LeftPosZ(628, 16).TopPosZ(68, 19); layout.dv___26.LayoutId("dv___26"); parent.Add(layout.dv___26);
	layout.datum_do.LeftPosZ(644, 76).TopPosZ(68, 19); layout.datum_do.LayoutId("datum_do"); parent.Add(layout.datum_do);
	layout.dv___28.SetLabel(t_GetLngString("Nemoc (stav) kter vedla k smrti")).LeftPosZ(472, 172).TopPosZ(96, 19); layout.dv___28.LayoutId("dv___28"); parent.Add(layout.dv___28);
	layout.dv___29.SetLabel(t_GetLngString("Doba")).LeftPosZ(672, 44).TopPosZ(96, 19); layout.dv___29.LayoutId("dv___29"); parent.Add(layout.dv___29);
	layout.dv___30.SetLabel(t_GetLngString("Kd")).LeftPosZ(720, 44).TopPosZ(96, 19); layout.dv___30.LayoutId("dv___30"); parent.Add(layout.dv___30);
	layout.nemoc.LeftPosZ(472, 196).TopPosZ(116, 19); layout.nemoc.LayoutId("nemoc"); parent.Add(layout.nemoc);
	layout.nemoc_doba.LeftPosZ(672, 44).TopPosZ(116, 19); layout.nemoc_doba.LayoutId("nemoc_doba"); parent.Add(layout.nemoc_doba);
	layout.nemoc_kod.LeftPosZ(720, 44).TopPosZ(116, 19); layout.nemoc_kod.LayoutId("nemoc_kod"); parent.Add(layout.nemoc_kod);
	layout.dv___34.SetLabel(t_GetLngString("Pedchoz piny")).LeftPosZ(472, 172).TopPosZ(140, 19); layout.dv___34.LayoutId("dv___34"); parent.Add(layout.dv___34);
	layout.predchozi.LeftPosZ(472, 196).TopPosZ(160, 19); layout.predchozi.LayoutId("predchozi"); parent.Add(layout.predchozi);
	layout.predchozi_doba.LeftPosZ(672, 44).TopPosZ(160, 19); layout.predchozi_doba.LayoutId("predchozi_doba"); parent.Add(layout.predchozi_doba);
	layout.predchozi_kod.LeftPosZ(720, 44).TopPosZ(160, 19); layout.predchozi_kod.LayoutId("predchozi_kod"); parent.Add(layout.predchozi_kod);
	layout.dv___38.SetLabel(t_GetLngString("Prvotn pina")).LeftPosZ(472, 196).TopPosZ(184, 19); layout.dv___38.LayoutId("dv___38"); parent.Add(layout.dv___38);
	layout.prvotni.LeftPosZ(472, 196).TopPosZ(204, 19); layout.prvotni.LayoutId("prvotni"); parent.Add(layout.prvotni);
	layout.prvotni_doba.LeftPosZ(672, 44).TopPosZ(204, 19); layout.prvotni_doba.LayoutId("prvotni_doba"); parent.Add(layout.prvotni_doba);
	layout.prvotni_kod.LeftPosZ(720, 44).TopPosZ(204, 19); layout.prvotni_kod.LayoutId("prvotni_kod"); parent.Add(layout.prvotni_kod);
	layout.dv___42.SetLabel(t_GetLngString("Jin zvan chorobn stavy a zmny")).LeftPosZ(472, 196).TopPosZ(228, 19); layout.dv___42.LayoutId("dv___42"); parent.Add(layout.dv___42);
	layout.jine.LeftPosZ(472, 192).TopPosZ(248, 19); layout.jine.LayoutId("jine"); parent.Add(layout.jine);
	layout.jine_doba.LeftPosZ(672, 44).TopPosZ(248, 19); layout.jine_doba.LayoutId("jine_doba"); parent.Add(layout.jine_doba);
	layout.jine_kod.LeftPosZ(720, 44).TopPosZ(248, 19); layout.jine_kod.LayoutId("jine_kod"); parent.Add(layout.jine_kod);
	layout.urazo.SetLabel(t_GetLngString("Pracovn raz, nhodn raz, vrada, sebevrada")).LeftPosZ(472, 272).TopPosZ(272, 19); layout.urazo.LayoutId("urazo"); parent.Add(layout.urazo);
	layout.uraz.LeftPosZ(472, 212).TopPosZ(292, 19); layout.uraz.LayoutId("uraz"); parent.Add(layout.uraz);
	layout.uraz_kod.LeftPosZ(688, 76).TopPosZ(292, 19); layout.uraz_kod.LayoutId("uraz_kod"); parent.Add(layout.uraz_kod);
	layout.prenosna.SetLabel(t_GetLngString("lo o penosnou nemoc")).LeftPosZ(472, 200).TopPosZ(320, 20); layout.prenosna.LayoutId("prenosna"); parent.Add(layout.prenosna);
	layout.zpovolani.SetLabel(t_GetLngString("lo o nemoc z povoln")).LeftPosZ(472, 200).TopPosZ(340, 20); layout.zpovolani.LayoutId("zpovolani"); parent.Add(layout.zpovolani);
	layout.pitva.SetLabel(t_GetLngString("Byla vykonna pitva")).LeftPosZ(472, 200).TopPosZ(360, 20); layout.pitva.LayoutId("pitva"); parent.Add(layout.pitva);
	layout.dv___52.SetLabel(t_GetLngString("MUDr")).LeftPosZ(472, 40).TopPosZ(384, 19); layout.dv___52.LayoutId("dv___52"); parent.Add(layout.dv___52);
	layout.mudr.LeftPosZ(516, 92).TopPosZ(384, 19); layout.mudr.LayoutId("mudr"); parent.Add(layout.mudr);
	layout.dv___54.SetLabel(t_GetLngString("Msto")).LeftPosZ(612, 28).TopPosZ(384, 19); layout.dv___54.LayoutId("dv___54"); parent.Add(layout.dv___54);
	layout.smisto.LeftPosZ(644, 116).TopPosZ(384, 19); layout.smisto.LayoutId("smisto"); parent.Add(layout.smisto);
	layout.dv___56.SetLabel(t_GetLngString("Dti do 1 roku")).LeftPosZ(472, 288).TopPosZ(408, 88); layout.dv___56.LayoutId("dv___56"); parent.Add(layout.dv___56);
	layout.dv___57.SetLabel(t_GetLngString("Dlka ivota v hodinch (mrt do 24 h)")).LeftPosZ(480, 200).TopPosZ(424, 19); layout.dv___57.LayoutId("dv___57"); parent.Add(layout.dv___57);
	layout.delka.LeftPosZ(680, 72).TopPosZ(424, 19); layout.delka.LayoutId("delka"); parent.Add(layout.delka);
	layout.dv___59.SetLabel(t_GetLngString("Kde nastalo mrt")).HSizePosZ(480, 180).TopPosZ(448, 19); layout.dv___59.LayoutId("dv___59"); parent.Add(layout.dv___59);
	layout.ditemisto.HSizePosZ(680, 16).TopPosZ(448, 19); layout.ditemisto.LayoutId("ditemisto"); parent.Add(layout.ditemisto);
	layout.dv___61.SetLabel(t_GetLngString("Porodn hmotnost")).LeftPosZ(480, 112).TopPosZ(472, 19); layout.dv___61.LayoutId("dv___61"); parent.Add(layout.dv___61);
	layout.hmotnost.LeftPosZ(680, 72).TopPosZ(472, 19); layout.hmotnost.LayoutId("hmotnost"); parent.Add(layout.hmotnost);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(628, 64).TopPosZ(500, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(696, 64).TopPosZ(500, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, ManzelstviPotvrzeniLayout__layid&) { parent.LayoutId("ManzelstviPotvrzeniLayout");
	layout.dv___0.SetLabel(t_GetLngString("Matrik")).LeftPosZ(212, 52).TopPosZ(84, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.dv___1.SetLabel(t_GetLngString("Datum zpisu")).LeftPosZ(8, 72).TopPosZ(84, 19); layout.dv___1.LayoutId("dv___1"); parent.Add(layout.dv___1);
	layout.datum.LeftPosZ(80, 76).TopPosZ(84, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.matrikar.LeftPosZ(272, 168).TopPosZ(84, 19); layout.matrikar.LayoutId("matrikar"); parent.Add(layout.matrikar);
	layout.original.SetLabel(t_GetLngString("Originl")).LeftPosZ(8, 64).TopPosZ(164, 24); layout.original.LayoutId("original"); parent.Add(layout.original);
	layout.kopie.SetLabel(t_GetLngString("Kopie")).LeftPosZ(76, 64).TopPosZ(164, 24); layout.kopie.LayoutId("kopie"); parent.Add(layout.kopie);
	layout.dv___6.SetLabel(t_GetLngString(".j.")).LeftPosZ(8, 26).TopPosZ(8, 19); layout.dv___6.LayoutId("dv___6"); parent.Add(layout.dv___6);
	layout.text.LeftPosZ(80, 124).TopPosZ(8, 19); layout.text.LayoutId("text"); parent.Add(layout.text);
	layout.dv___8.SetLabel(t_GetLngString("adatel")).LeftPosZ(8, 68).TopPosZ(36, 19); layout.dv___8.LayoutId("dv___8"); parent.Add(layout.dv___8);
	layout.text1.LeftPosZ(80, 124).TopPosZ(36, 19); layout.text1.LayoutId("text1"); parent.Add(layout.text1);
	layout.dv___10.SetLabel(t_GetLngString("Bydlit")).LeftPosZ(212, 52).TopPosZ(36, 19); layout.dv___10.LayoutId("dv___10"); parent.Add(layout.dv___10);
	layout.text2.LeftPosZ(272, 168).TopPosZ(36, 19); layout.text2.LayoutId("text2"); parent.Add(layout.text2);
	layout.dv___12.SetLabel(t_GetLngString("Vztah")).LeftPosZ(8, 68).TopPosZ(60, 19); layout.dv___12.LayoutId("dv___12"); parent.Add(layout.dv___12);
	layout.text3.LeftPosZ(80, 124).TopPosZ(60, 19); layout.text3.LayoutId("text3"); parent.Add(layout.text3);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, PotvrzeniUmrtiLayout__layid&) { parent.LayoutId("PotvrzeniUmrtiLayout");
	layout.dv___0.SetLabel(t_GetLngString("Matrik")).LeftPosZ(212, 52).TopPosZ(60, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.dv___1.SetLabel(t_GetLngString("Datum zpisu")).LeftPosZ(8, 72).TopPosZ(60, 19); layout.dv___1.LayoutId("dv___1"); parent.Add(layout.dv___1);
	layout.datum.LeftPosZ(80, 76).TopPosZ(60, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.matrikar.LeftPosZ(272, 168).TopPosZ(60, 19); layout.matrikar.LayoutId("matrikar"); parent.Add(layout.matrikar);
	layout.original.SetLabel(t_GetLngString("Originl")).LeftPosZ(8, 64).TopPosZ(164, 24); layout.original.LayoutId("original"); parent.Add(layout.original);
	layout.kopie.SetLabel(t_GetLngString("Kopie")).LeftPosZ(76, 64).TopPosZ(164, 24); layout.kopie.LayoutId("kopie"); parent.Add(layout.kopie);
	layout.dv___6.SetLabel(t_GetLngString(".j.")).LeftPosZ(8, 26).TopPosZ(8, 19); layout.dv___6.LayoutId("dv___6"); parent.Add(layout.dv___6);
	layout.text.LeftPosZ(80, 124).TopPosZ(8, 19); layout.text.LayoutId("text"); parent.Add(layout.text);
	layout.dv___8.SetLabel(t_GetLngString("adatel")).LeftPosZ(8, 68).TopPosZ(36, 19); layout.dv___8.LayoutId("dv___8"); parent.Add(layout.dv___8);
	layout.text1.LeftPosZ(80, 124).TopPosZ(36, 19); layout.text1.LayoutId("text1"); parent.Add(layout.text1);
	layout.dv___10.SetLabel(t_GetLngString("Bydlit")).LeftPosZ(212, 52).TopPosZ(36, 19); layout.dv___10.LayoutId("dv___10"); parent.Add(layout.dv___10);
	layout.text2.LeftPosZ(272, 168).TopPosZ(36, 19); layout.text2.LayoutId("text2"); parent.Add(layout.text2);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, PrintDocLayout__layid&) { parent.LayoutId("PrintDocLayout");
	layout.view.LeftPosZ(4, 608).TopPosZ(4, 624); layout.view.LayoutId("view"); parent.Add(layout.view);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(480, 64).TopPosZ(632, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(548, 64).TopPosZ(632, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, VysvedceniLayout__layid&) { parent.LayoutId("VysvedceniLayout");
	layout.cj.LeftPosZ(196, 264).TopPosZ(4, 19); layout.cj.LayoutId("cj"); parent.Add(layout.cj);
	uts.osoby.LeftPosZ(8, 456).TopPosZ(28, 268); uts.osoby.LayoutId("osoby"); parent.Add(uts.osoby);
	layout.dokument.LeftPosZ(8, 456).TopPosZ(304, 220); layout.dokument.LayoutId("dokument"); parent.Add(layout.dokument);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(332, 64).TopPosZ(532, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(400, 64).TopPosZ(532, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
	layout.dv___5.SetLabel(t_GetLngString("slo jednac")).LeftPosZ(124, 72).TopPosZ(4, 20); layout.dv___5.LayoutId("dv___5"); parent.Add(layout.dv___5);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, IndexLayout__layid&) { parent.LayoutId("IndexLayout");
	layout.dv___0.SetLabel(t_GetLngString("Matrika")).LeftPosZ(8, 52).TopPosZ(4, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.typ.LeftPosZ(64, 160).TopPosZ(4, 19); layout.typ.LayoutId("typ"); parent.Add(layout.typ);
	layout.dv___2.SetLabel(t_GetLngString("Obec")).LeftPosZ(8, 52).TopPosZ(28, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.obec_seq.LeftPosZ(64, 160).TopPosZ(28, 19); layout.obec_seq.LayoutId("obec_seq"); parent.Add(layout.obec_seq);
	layout.dv___4.SetLabel(t_GetLngString("Ronk")).LeftPosZ(8, 52).TopPosZ(52, 20); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.rocnik.LeftPosZ(64, 56).TopPosZ(52, 19); layout.rocnik.LayoutId("rocnik"); parent.Add(layout.rocnik);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(92, 64).TopPosZ(76, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(160, 64).TopPosZ(76, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, VypisLayout__layid&) { parent.LayoutId("VypisLayout");
	layout.dv___0.SetLabel(t_GetLngString("slo jednac")).LeftPosZ(8, 64).TopPosZ(4, 20); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.cj.LeftPosZ(72, 136).TopPosZ(4, 19); layout.cj.LayoutId("cj"); parent.Add(layout.cj);
	layout.dv___2.SetLabel(t_GetLngString("Matka")).LeftPosZ(304, 52).TopPosZ(4, 20); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.osoba_seq.LeftPosZ(368, 388).TopPosZ(4, 20); layout.osoba_seq.LayoutId("osoba_seq"); parent.Add(layout.osoba_seq);
	layout.deti.SetLabel(t_GetLngString("Pidat dti dle EO")).LeftPosZ(8, 132).TopPosZ(32, 24); layout.deti.LayoutId("deti"); parent.Add(layout.deti);
	layout.add.SetLabel(t_GetLngString("Pidat")).LeftPosZ(556, 64).TopPosZ(32, 24); layout.add.LayoutId("add"); parent.Add(layout.add);
	layout.edit.SetLabel(t_GetLngString("Opravit")).LeftPosZ(624, 64).TopPosZ(32, 24); layout.edit.LayoutId("edit"); parent.Add(layout.edit);
	layout.remove.SetLabel(t_GetLngString("Odebrat")).LeftPosZ(692, 64).TopPosZ(32, 24); layout.remove.LayoutId("remove"); parent.Add(layout.remove);
	layout.list.LeftPosZ(8, 748).TopPosZ(64, 172); layout.list.LayoutId("list"); parent.Add(layout.list);
	layout.dv___9.SetLabel(t_GetLngString("Datum")).LeftPosZ(8, 36).TopPosZ(240, 20); layout.dv___9.LayoutId("dv___9"); parent.Add(layout.dv___9);
	layout.datum.LeftPosZ(40, 76).TopPosZ(240, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.dv___11.SetLabel(t_GetLngString("OP")).LeftPosZ(132, 20).TopPosZ(240, 19); layout.dv___11.LayoutId("dv___11"); parent.Add(layout.dv___11);
	layout.op.LeftPosZ(156, 72).TopPosZ(240, 19); layout.op.LayoutId("op"); parent.Add(layout.op);
	layout.dv___13.SetLabel(t_GetLngString("vydn")).LeftPosZ(236, 36).TopPosZ(240, 19); layout.dv___13.LayoutId("dv___13"); parent.Add(layout.dv___13);
	layout.opvydan.LeftPosZ(272, 72).TopPosZ(240, 19); layout.opvydan.LayoutId("opvydan"); parent.Add(layout.opvydan);
	layout.dv___15.SetLabel(t_GetLngString("dne")).LeftPosZ(348, 20).TopPosZ(240, 19); layout.dv___15.LayoutId("dv___15"); parent.Add(layout.dv___15);
	layout.opdne.LeftPosZ(368, 72).TopPosZ(240, 19); layout.opdne.LayoutId("opdne"); parent.Add(layout.opdne);
	layout.dv___17.SetLabel(t_GetLngString("platn")).LeftPosZ(444, 36).TopPosZ(240, 19); layout.dv___17.LayoutId("dv___17"); parent.Add(layout.dv___17);
	layout.opplatny.LeftPosZ(480, 72).TopPosZ(240, 19); layout.opplatny.LayoutId("opplatny"); parent.Add(layout.opplatny);
	layout.dv___19.SetLabel(t_GetLngString("Matrik")).LeftPosZ(564, 52).TopPosZ(240, 19); layout.dv___19.LayoutId("dv___19"); parent.Add(layout.dv___19);
	layout.matrikar.LeftPosZ(620, 136).TopPosZ(240, 19); layout.matrikar.LayoutId("matrikar"); parent.Add(layout.matrikar);
	layout.print.SetLabel(t_GetLngString("Vpis")).LeftPosZ(8, 64).TopPosZ(272, 24); layout.print.LayoutId("print"); parent.Add(layout.print);
	layout.zadost.SetLabel(t_GetLngString("dost")).LeftPosZ(76, 64).TopPosZ(272, 24); layout.zadost.LayoutId("zadost"); parent.Add(layout.zadost);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(620, 64).TopPosZ(268, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(692, 64).TopPosZ(268, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, VypisLineLayout__layid&) { parent.LayoutId("VypisLineLayout");
	layout.dv___0.SetLabel(t_GetLngString("Jmno a pjmen")).LeftPosZ(8, 88).TopPosZ(8, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	uts.v[0].LeftPosZ(112, 196).TopPosZ(8, 19); uts.v[0].LayoutId("v[0]"); parent.Add(uts.v[0]);
	layout.dv___2.SetLabel(t_GetLngString("Datum a msto nar.")).LeftPosZ(8, 96).TopPosZ(32, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	uts.v[1].LeftPosZ(112, 196).TopPosZ(32, 19); uts.v[1].LayoutId("v[1]"); parent.Add(uts.v[1]);
	layout.dv___4.SetLabel(t_GetLngString("R")).LeftPosZ(8, 48).TopPosZ(56, 19); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	uts.v[2].LeftPosZ(112, 196).TopPosZ(56, 19); uts.v[2].LayoutId("v[2]"); parent.Add(uts.v[2]);
	layout.dv___6.SetLabel(t_GetLngString("Otec")).LeftPosZ(8, 88).TopPosZ(80, 19); layout.dv___6.LayoutId("dv___6"); parent.Add(layout.dv___6);
	uts.v[3].LeftPosZ(112, 196).TopPosZ(80, 19); uts.v[3].LayoutId("v[3]"); parent.Add(uts.v[3]);
	layout.dv___8.SetLabel(t_GetLngString("Matka")).LeftPosZ(8, 88).TopPosZ(104, 19); layout.dv___8.LayoutId("dv___8"); parent.Add(layout.dv___8);
	uts.v[4].LeftPosZ(112, 196).TopPosZ(104, 19); uts.v[4].LayoutId("v[4]"); parent.Add(uts.v[4]);
	layout.dv___10.SetLabel(t_GetLngString("Matrika")).LeftPosZ(8, 88).TopPosZ(128, 19); layout.dv___10.LayoutId("dv___10"); parent.Add(layout.dv___10);
	uts.v[5].LeftPosZ(112, 196).TopPosZ(128, 19); uts.v[5].LayoutId("v[5]"); parent.Add(uts.v[5]);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(176, 64).TopPosZ(156, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(244, 64).TopPosZ(156, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, DuplikatyLayout__layid&) { parent.LayoutId("DuplikatyLayout");
	layout.duplikat.LeftPosZ(4, 440).TopPosZ(4, 156); layout.duplikat.LayoutId("duplikat"); parent.Add(layout.duplikat);
	layout.novy.SetLabel(t_GetLngString("Nov")).LeftPosZ(4, 64).TopPosZ(164, 24); layout.novy.LayoutId("novy"); parent.Add(layout.novy);
	layout.original.SetLabel(t_GetLngString("Originl")).LeftPosZ(72, 64).TopPosZ(164, 24); layout.original.LayoutId("original"); parent.Add(layout.original);
	layout.kopie.SetLabel(t_GetLngString("Kopie")).LeftPosZ(140, 64).TopPosZ(164, 24); layout.kopie.LayoutId("kopie"); parent.Add(layout.kopie);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, DatumMatrikarLayout__layid&) { parent.LayoutId("DatumMatrikarLayout");
	layout.dv___0.SetLabel(t_GetLngString("Datum vydn")).LeftPosZ(8, 72).TopPosZ(8, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.datum.LeftPosZ(80, 76).TopPosZ(8, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.dv___2.SetLabel(t_GetLngString("Matrik")).LeftPosZ(176, 52).TopPosZ(8, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.matrikar.LeftPosZ(232, 188).TopPosZ(8, 19); layout.matrikar.LayoutId("matrikar"); parent.Add(layout.matrikar);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(288, 64).TopPosZ(36, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(356, 64).TopPosZ(36, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, OdDoLayout__layid&) { parent.LayoutId("OdDoLayout");
	layout.dv___0.SetLabel(t_GetLngString("Od")).LeftPosZ(8, 20).TopPosZ(8, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.dtm_od.LeftPosZ(44, 72).TopPosZ(8, 19); layout.dtm_od.LayoutId("dtm_od"); parent.Add(layout.dtm_od);
	layout.dv___2.SetLabel(t_GetLngString("do")).LeftPosZ(120, 16).TopPosZ(8, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.dtm_do.LeftPosZ(140, 72).TopPosZ(8, 19); layout.dtm_do.LayoutId("dtm_do"); parent.Add(layout.dtm_do);
	layout.dv___4.SetLabel(t_GetLngString("Druh")).LeftPosZ(8, 25).TopPosZ(32, 19); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.typ.LeftPosZ(44, 168).TopPosZ(32, 19); layout.typ.LayoutId("typ"); parent.Add(layout.typ);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(80, 64).TopPosZ(60, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(148, 64).TopPosZ(60, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, RejstrikLayout__layid&) { parent.LayoutId("RejstrikLayout");
	layout.dv___0.SetLabel(t_GetLngString("Rok")).LeftPosZ(8, 32).TopPosZ(8, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.rok.LeftPosZ(60, 64).TopPosZ(8, 19); layout.rok.LayoutId("rok"); parent.Add(layout.rok);
	layout.dv___2.SetLabel(t_GetLngString("slo")).LeftPosZ(132, 32).TopPosZ(8, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.cislo.LeftPosZ(168, 64).TopPosZ(8, 19); layout.cislo.LayoutId("cislo"); parent.Add(layout.cislo);
	layout.dv___4.SetLabel(t_GetLngString("Jmno")).LeftPosZ(8, 48).TopPosZ(56, 19); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.jmeno.LeftPosZ(60, 172).TopPosZ(56, 19); layout.jmeno.LayoutId("jmeno"); parent.Add(layout.jmeno);
	layout.dv___6.SetLabel(t_GetLngString("Pjmen")).LeftPosZ(8, 48).TopPosZ(80, 19); layout.dv___6.LayoutId("dv___6"); parent.Add(layout.dv___6);
	layout.prijmeni.LeftPosZ(60, 172).TopPosZ(80, 19); layout.prijmeni.LayoutId("prijmeni"); parent.Add(layout.prijmeni);
	layout.dv___8.SetLabel(t_GetLngString("Datum narozen")).LeftPosZ(8, 84).TopPosZ(104, 19); layout.dv___8.LayoutId("dv___8"); parent.Add(layout.dv___8);
	layout.dat_nar.LeftPosZ(156, 76).TopPosZ(104, 19); layout.dat_nar.LayoutId("dat_nar"); parent.Add(layout.dat_nar);
	layout.dv___10.SetLabel(t_GetLngString("Bydlit")).LeftPosZ(8, 48).TopPosZ(128, 19); layout.dv___10.LayoutId("dv___10"); parent.Add(layout.dv___10);
	layout.bydliste.LeftPosZ(60, 172).TopPosZ(128, 19); layout.bydliste.LayoutId("bydliste"); parent.Add(layout.bydliste);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(100, 64).TopPosZ(156, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(168, 64).TopPosZ(156, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
	layout.dv___14.SetLabel(t_GetLngString("Datum")).LeftPosZ(8, 44).TopPosZ(32, 19); layout.dv___14.LayoutId("dv___14"); parent.Add(layout.dv___14);
	layout.datum.LeftPosZ(60, 80).TopPosZ(32, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, RejstrikVypisLayout__layid&) { parent.LayoutId("RejstrikVypisLayout");
	layout.dv___0.SetLabel(t_GetLngString("Rok")).LeftPosZ(8, 28).TopPosZ(8, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.rok.LeftPosZ(40, 68).TopPosZ(8, 19); layout.rok.LayoutId("rok"); parent.Add(layout.rok);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(8, 48).TopPosZ(36, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(60, 48).TopPosZ(36, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, OsvedceniLayout__layid&) { parent.LayoutId("OsvedceniLayout");
	layout.cislo.LeftPosZ(320, 144).TopPosZ(4, 19); layout.cislo.LayoutId("cislo"); parent.Add(layout.cislo);
	uts.osoby.LeftPosZ(8, 456).TopPosZ(28, 268); uts.osoby.LayoutId("osoby"); parent.Add(uts.osoby);
	layout.dv___2.SetLabel(t_GetLngString("slo rejstku")).LeftPosZ(244, 72).TopPosZ(4, 20); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.dv___3.SetLabel(t_GetLngString("Dvod")).LeftPosZ(8, 48).TopPosZ(304, 19); layout.dv___3.LayoutId("dv___3"); parent.Add(layout.dv___3);
	layout.duvod.LeftPosZ(56, 408).TopPosZ(304, 19); layout.duvod.LayoutId("duvod"); parent.Add(layout.duvod);
	layout.dv___5.SetLabel(t_GetLngString("Zkonn zstupce")).LeftPosZ(8, 456).TopPosZ(332, 100); layout.dv___5.LayoutId("dv___5"); parent.Add(layout.dv___5);
	layout.dv___6.SetLabel(t_GetLngString("Pjmen, jmno")).LeftPosZ(16, 80).TopPosZ(352, 19); layout.dv___6.LayoutId("dv___6"); parent.Add(layout.dv___6);
	layout.zastupce.LeftPosZ(100, 224).TopPosZ(352, 19); layout.zastupce.LayoutId("zastupce"); parent.Add(layout.zastupce);
	layout.matka.SetLabel(t_GetLngString("Matka")).LeftPosZ(332, 60).TopPosZ(352, 20); layout.matka.LayoutId("matka"); parent.Add(layout.matka);
	layout.otec.SetLabel(t_GetLngString("Otec")).LeftPosZ(396, 60).TopPosZ(352, 20); layout.otec.LayoutId("otec"); parent.Add(layout.otec);
	layout.dv___10.SetLabel(t_GetLngString("Bydlit")).LeftPosZ(16, 80).TopPosZ(376, 19); layout.dv___10.LayoutId("dv___10"); parent.Add(layout.dv___10);
	layout.bydliste.LeftPosZ(100, 356).TopPosZ(376, 19); layout.bydliste.LayoutId("bydliste"); parent.Add(layout.bydliste);
	layout.dv___12.SetLabel(t_GetLngString("slo ob. pr.")).LeftPosZ(16, 80).TopPosZ(400, 19); layout.dv___12.LayoutId("dv___12"); parent.Add(layout.dv___12);
	layout.cop.LeftPosZ(100, 88).TopPosZ(400, 19); layout.cop.LayoutId("cop"); parent.Add(layout.cop);
	layout.dv___14.SetLabel(t_GetLngString("vydan dne")).LeftPosZ(192, 60).TopPosZ(400, 19); layout.dv___14.LayoutId("dv___14"); parent.Add(layout.dv___14);
	layout.opdne.LeftPosZ(252, 68).TopPosZ(400, 19); layout.opdne.LayoutId("opdne"); parent.Add(layout.opdne);
	layout.opkym.LeftPosZ(324, 132).TopPosZ(400, 19); layout.opkym.LayoutId("opkym"); parent.Add(layout.opkym);
	layout.dv___17.SetLabel(t_GetLngString("Matrik")).LeftPosZ(8, 52).TopPosZ(440, 19); layout.dv___17.LayoutId("dv___17"); parent.Add(layout.dv___17);
	layout.matrikar.LeftPosZ(64, 260).TopPosZ(440, 19); layout.matrikar.LayoutId("matrikar"); parent.Add(layout.matrikar);
	layout.dv___19.SetLabel(t_GetLngString("Dne")).LeftPosZ(352, 24).TopPosZ(440, 19); layout.dv___19.LayoutId("dv___19"); parent.Add(layout.dv___19);
	layout.dne.LeftPosZ(380, 84).TopPosZ(440, 19); layout.dne.LayoutId("dne"); parent.Add(layout.dne);
	layout.print.SetLabel(t_GetLngString("Tisk")).LeftPosZ(8, 64).TopPosZ(472, 24); layout.print.LayoutId("print"); parent.Add(layout.print);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(332, 64).TopPosZ(472, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(400, 64).TopPosZ(472, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, ZaznamDlgLayout__layid&) { parent.LayoutId("ZaznamDlgLayout");
	layout.dv___0.SetLabel(t_GetLngString("Datum")).LeftPosZ(8, 44).TopPosZ(8, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.datum.LeftPosZ(52, 76).TopPosZ(8, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.typ.LeftPosZ(132, 128).TopPosZ(8, 19); layout.typ.LayoutId("typ"); parent.Add(layout.typ);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(128, 64).TopPosZ(36, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(196, 64).TopPosZ(36, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, ZapisNarozeniLayout__layid&) { parent.LayoutId("ZapisNarozeniLayout");
	layout.dv___0.SetLabel(t_GetLngString("adatel")).LeftPosZ(8, 44).TopPosZ(4, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.text.LeftPosZ(52, 88).TopPosZ(4, 19); layout.text.LayoutId("text"); parent.Add(layout.text);
	layout.dv___2.SetLabel(t_GetLngString("Bytem")).LeftPosZ(144, 36).TopPosZ(4, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.text1.LeftPosZ(180, 244).TopPosZ(4, 19); layout.text1.LayoutId("text1"); parent.Add(layout.text1);
	layout.dv___4.SetLabel(t_GetLngString("Osv.ob.")).LeftPosZ(8, 44).TopPosZ(28, 19); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.text2.LeftPosZ(52, 392).TopPosZ(28, 19); layout.text2.LayoutId("text2"); parent.Add(layout.text2);
	layout.gos.SetLabel(t_GetLngString("*")).LeftPosZ(428, 16).TopPosZ(4, 20); layout.gos.LayoutId("gos"); parent.Add(layout.gos);
	layout.dv___7.SetLabel(t_GetLngString("OP .")).LeftPosZ(8, 25).TopPosZ(52, 19); layout.dv___7.LayoutId("dv___7"); parent.Add(layout.dv___7);
	layout.op.LeftPosZ(52, 76).TopPosZ(52, 19); layout.op.LayoutId("op"); parent.Add(layout.op);
	layout.dv___9.SetLabel(t_GetLngString("dat. a m.")).LeftPosZ(132, 48).TopPosZ(52, 19); layout.dv___9.LayoutId("dv___9"); parent.Add(layout.dv___9);
	layout.op_dm.LeftPosZ(180, 136).TopPosZ(52, 19); layout.op_dm.LayoutId("op_dm"); parent.Add(layout.op_dm);
	layout.dv___11.SetLabel(t_GetLngString("plat. do")).LeftPosZ(320, 40).TopPosZ(52, 19); layout.dv___11.LayoutId("dv___11"); parent.Add(layout.dv___11);
	layout.op_platnost.LeftPosZ(360, 84).TopPosZ(52, 19); layout.op_platnost.LayoutId("op_platnost"); parent.Add(layout.op_platnost);
	layout.dv___13.SetLabel(t_GetLngString("CD .")).LeftPosZ(8, 25).TopPosZ(76, 19); layout.dv___13.LayoutId("dv___13"); parent.Add(layout.dv___13);
	layout.cd.LeftPosZ(52, 76).TopPosZ(76, 19); layout.cd.LayoutId("cd"); parent.Add(layout.cd);
	layout.dv___15.SetLabel(t_GetLngString("dat. a m.")).LeftPosZ(132, 48).TopPosZ(76, 19); layout.dv___15.LayoutId("dv___15"); parent.Add(layout.dv___15);
	layout.cd_dm.LeftPosZ(180, 136).TopPosZ(76, 19); layout.cd_dm.LayoutId("cd_dm"); parent.Add(layout.cd_dm);
	layout.dv___17.SetLabel(t_GetLngString("plat. do")).LeftPosZ(320, 40).TopPosZ(76, 19); layout.dv___17.LayoutId("dv___17"); parent.Add(layout.dv___17);
	layout.cd_platnost.LeftPosZ(360, 84).TopPosZ(76, 19); layout.cd_platnost.LayoutId("cd_platnost"); parent.Add(layout.cd_platnost);
	layout.dv___19.SetLabel(t_GetLngString("Doklady")).LeftPosZ(8, 44).TopPosZ(100, 19); layout.dv___19.LayoutId("dv___19"); parent.Add(layout.dv___19);
	layout.text3.LeftPosZ(52, 392).TopPosZ(100, 36); layout.text3.LayoutId("text3"); parent.Add(layout.text3);
	layout.totoznost_cd.SetLabel(t_GetLngString("Totonost ovena dle CD")).LeftPosZ(52, 148).TopPosZ(140, 20); layout.totoznost_cd.LayoutId("totoznost_cd"); parent.Add(layout.totoznost_cd);
	layout.dv___22.SetLabel(t_GetLngString("Datum zpisu")).LeftPosZ(284, 72).TopPosZ(144, 19); layout.dv___22.LayoutId("dv___22"); parent.Add(layout.dv___22);
	layout.datum.LeftPosZ(356, 88).TopPosZ(144, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.dv___24.SetLabel(t_GetLngString("Matrik")).LeftPosZ(228, 52).TopPosZ(172, 19); layout.dv___24.LayoutId("dv___24"); parent.Add(layout.dv___24);
	layout.matrikar.LeftPosZ(284, 160).TopPosZ(172, 19); layout.matrikar.LayoutId("matrikar"); parent.Add(layout.matrikar);
	layout.print.SetLabel(t_GetLngString("Tisk")).LeftPosZ(8, 64).TopPosZ(164, 24); layout.print.LayoutId("print"); parent.Add(layout.print);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, ZapisManzelstviLayout__layid&) { parent.LayoutId("ZapisManzelstviLayout");
	layout.dv___0.SetLabel(t_GetLngString("adatel")).LeftPosZ(8, 44).TopPosZ(4, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.text.LeftPosZ(52, 88).TopPosZ(4, 19); layout.text.LayoutId("text"); parent.Add(layout.text);
	layout.dv___2.SetLabel(t_GetLngString("Bytem")).LeftPosZ(144, 36).TopPosZ(4, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.text1.LeftPosZ(180, 244).TopPosZ(4, 19); layout.text1.LayoutId("text1"); parent.Add(layout.text1);
	layout.dv___4.SetLabel(t_GetLngString("Osv.ob.")).LeftPosZ(8, 44).TopPosZ(28, 19); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.text2.LeftPosZ(52, 392).TopPosZ(28, 19); layout.text2.LayoutId("text2"); parent.Add(layout.text2);
	layout.gos.SetLabel(t_GetLngString("*")).LeftPosZ(428, 16).TopPosZ(4, 20); layout.gos.LayoutId("gos"); parent.Add(layout.gos);
	layout.dv___7.SetLabel(t_GetLngString("OP .")).LeftPosZ(8, 25).TopPosZ(52, 19); layout.dv___7.LayoutId("dv___7"); parent.Add(layout.dv___7);
	layout.op.LeftPosZ(52, 76).TopPosZ(52, 19); layout.op.LayoutId("op"); parent.Add(layout.op);
	layout.dv___9.SetLabel(t_GetLngString("dat. a m.")).LeftPosZ(132, 48).TopPosZ(52, 19); layout.dv___9.LayoutId("dv___9"); parent.Add(layout.dv___9);
	layout.op_dm.LeftPosZ(180, 136).TopPosZ(52, 19); layout.op_dm.LayoutId("op_dm"); parent.Add(layout.op_dm);
	layout.dv___11.SetLabel(t_GetLngString("plat. do")).LeftPosZ(320, 40).TopPosZ(52, 19); layout.dv___11.LayoutId("dv___11"); parent.Add(layout.dv___11);
	layout.op_platnost.LeftPosZ(360, 84).TopPosZ(52, 19); layout.op_platnost.LayoutId("op_platnost"); parent.Add(layout.op_platnost);
	layout.dv___13.SetLabel(t_GetLngString("CD .")).LeftPosZ(8, 25).TopPosZ(76, 19); layout.dv___13.LayoutId("dv___13"); parent.Add(layout.dv___13);
	layout.cd.LeftPosZ(52, 76).TopPosZ(76, 19); layout.cd.LayoutId("cd"); parent.Add(layout.cd);
	layout.dv___15.SetLabel(t_GetLngString("dat. a m.")).LeftPosZ(132, 48).TopPosZ(76, 19); layout.dv___15.LayoutId("dv___15"); parent.Add(layout.dv___15);
	layout.cd_dm.LeftPosZ(180, 136).TopPosZ(76, 19); layout.cd_dm.LayoutId("cd_dm"); parent.Add(layout.cd_dm);
	layout.dv___17.SetLabel(t_GetLngString("plat. do")).LeftPosZ(320, 40).TopPosZ(76, 19); layout.dv___17.LayoutId("dv___17"); parent.Add(layout.dv___17);
	layout.cd_platnost.LeftPosZ(360, 84).TopPosZ(76, 19); layout.cd_platnost.LayoutId("cd_platnost"); parent.Add(layout.cd_platnost);
	layout.dv___19.SetLabel(t_GetLngString("Doklady")).LeftPosZ(8, 44).TopPosZ(100, 19); layout.dv___19.LayoutId("dv___19"); parent.Add(layout.dv___19);
	layout.text3.LeftPosZ(52, 392).TopPosZ(100, 36); layout.text3.LayoutId("text3"); parent.Add(layout.text3);
	layout.totoznost_cd.SetLabel(t_GetLngString("Totonost ovena dle CD")).LeftPosZ(52, 148).TopPosZ(140, 20); layout.totoznost_cd.LayoutId("totoznost_cd"); parent.Add(layout.totoznost_cd);
	layout.dv___22.SetLabel(t_GetLngString("Datum zpisu")).LeftPosZ(284, 72).TopPosZ(144, 19); layout.dv___22.LayoutId("dv___22"); parent.Add(layout.dv___22);
	layout.datum.LeftPosZ(356, 88).TopPosZ(144, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.dv___24.SetLabel(t_GetLngString("Matrik")).LeftPosZ(228, 52).TopPosZ(172, 19); layout.dv___24.LayoutId("dv___24"); parent.Add(layout.dv___24);
	layout.matrikar.LeftPosZ(284, 160).TopPosZ(172, 19); layout.matrikar.LayoutId("matrikar"); parent.Add(layout.matrikar);
	layout.print.SetLabel(t_GetLngString("Tisk")).LeftPosZ(8, 64).TopPosZ(164, 24); layout.print.LayoutId("print"); parent.Add(layout.print);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, ZapisUmrtiLayout__layid&) { parent.LayoutId("ZapisUmrtiLayout");
	layout.dv___0.SetLabel(t_GetLngString("adatel")).LeftPosZ(8, 44).TopPosZ(4, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.text.LeftPosZ(52, 88).TopPosZ(4, 19); layout.text.LayoutId("text"); parent.Add(layout.text);
	layout.dv___2.SetLabel(t_GetLngString("Bytem")).LeftPosZ(144, 36).TopPosZ(4, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.text1.LeftPosZ(180, 244).TopPosZ(4, 19); layout.text1.LayoutId("text1"); parent.Add(layout.text1);
	layout.dv___4.SetLabel(t_GetLngString("Osv.ob.")).LeftPosZ(8, 44).TopPosZ(28, 19); layout.dv___4.LayoutId("dv___4"); parent.Add(layout.dv___4);
	layout.text2.LeftPosZ(52, 392).TopPosZ(28, 19); layout.text2.LayoutId("text2"); parent.Add(layout.text2);
	layout.gos.SetLabel(t_GetLngString("*")).LeftPosZ(428, 16).TopPosZ(4, 20); layout.gos.LayoutId("gos"); parent.Add(layout.gos);
	layout.dv___7.SetLabel(t_GetLngString("OP .")).LeftPosZ(8, 25).TopPosZ(52, 19); layout.dv___7.LayoutId("dv___7"); parent.Add(layout.dv___7);
	layout.op.LeftPosZ(52, 76).TopPosZ(52, 19); layout.op.LayoutId("op"); parent.Add(layout.op);
	layout.dv___9.SetLabel(t_GetLngString("kde km")).LeftPosZ(132, 48).TopPosZ(52, 19); layout.dv___9.LayoutId("dv___9"); parent.Add(layout.dv___9);
	layout.op_dm.LeftPosZ(180, 136).TopPosZ(52, 19); layout.op_dm.LayoutId("op_dm"); parent.Add(layout.op_dm);
	layout.dv___11.SetLabel(t_GetLngString("Zznam ob. vyzn.")).LeftPosZ(8, 92).TopPosZ(76, 19); layout.dv___11.LayoutId("dv___11"); parent.Add(layout.dv___11);
	layout.text8.LeftPosZ(104, 168).TopPosZ(76, 19); layout.text8.LayoutId("text8"); parent.Add(layout.text8);
	layout.dv___13.SetLabel(t_GetLngString("(platnost)")).LeftPosZ(280, 56).TopPosZ(76, 19); layout.dv___13.LayoutId("dv___13"); parent.Add(layout.dv___13);
	layout.text9.LeftPosZ(336, 108).TopPosZ(76, 19); layout.text9.LayoutId("text9"); parent.Add(layout.text9);
	layout.dv___15.SetLabel(t_GetLngString("plat. do")).LeftPosZ(320, 40).TopPosZ(52, 19); layout.dv___15.LayoutId("dv___15"); parent.Add(layout.dv___15);
	layout.op_platnost.LeftPosZ(360, 84).TopPosZ(52, 19); layout.op_platnost.LayoutId("op_platnost"); parent.Add(layout.op_platnost);
	layout.dv___17.SetLabel(t_GetLngString("Doklady")).LeftPosZ(8, 44).TopPosZ(100, 19); layout.dv___17.LayoutId("dv___17"); parent.Add(layout.dv___17);
	layout.text3.LeftPosZ(52, 148).TopPosZ(100, 60); layout.text3.LayoutId("text3"); parent.Add(layout.text3);
	layout.dv___19.SetLabel(t_GetLngString("Datum zpisu")).LeftPosZ(92, 72).TopPosZ(168, 19); layout.dv___19.LayoutId("dv___19"); parent.Add(layout.dv___19);
	layout.datum.LeftPosZ(164, 88).TopPosZ(168, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.dv___21.SetLabel(t_GetLngString("Matrik")).LeftPosZ(264, 52).TopPosZ(168, 19); layout.dv___21.LayoutId("dv___21"); parent.Add(layout.dv___21);
	layout.matrikar.LeftPosZ(320, 124).TopPosZ(168, 19); layout.matrikar.LayoutId("matrikar"); parent.Add(layout.matrikar);
	layout.print.SetLabel(t_GetLngString("Tisk")).LeftPosZ(8, 64).TopPosZ(164, 24); layout.print.LayoutId("print"); parent.Add(layout.print);
	layout.dv___24.SetLabel(t_GetLngString("Zizovatel p.")).LeftPosZ(204, 60).TopPosZ(100, 19); layout.dv___24.LayoutId("dv___24"); parent.Add(layout.dv___24);
	layout.text4.LeftPosZ(268, 176).TopPosZ(100, 19); layout.text4.LayoutId("text4"); parent.Add(layout.text4);
	layout.dv___26.SetLabel(t_GetLngString("Adresa")).LeftPosZ(204, 60).TopPosZ(120, 19); layout.dv___26.LayoutId("dv___26"); parent.Add(layout.dv___26);
	layout.text5.LeftPosZ(268, 176).TopPosZ(120, 19); layout.text5.LayoutId("text5"); parent.Add(layout.text5);
	layout.dv___28.SetLabel(t_GetLngString("Vztah")).LeftPosZ(204, 60).TopPosZ(140, 19); layout.dv___28.LayoutId("dv___28"); parent.Add(layout.dv___28);
	layout.text6.LeftPosZ(268, 76).TopPosZ(140, 19); layout.text6.LayoutId("text6"); parent.Add(layout.text6);
	layout.dv___30.SetLabel(t_GetLngString("ZP")).LeftPosZ(352, 16).TopPosZ(140, 19); layout.dv___30.LayoutId("dv___30"); parent.Add(layout.dv___30);
	layout.text7.LeftPosZ(368, 76).TopPosZ(140, 19); layout.text7.LayoutId("text7"); parent.Add(layout.text7);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, DatumVTLayout__layid&) { parent.LayoutId("DatumVTLayout");
	layout.dv___0.SetLabel(t_GetLngString("Datum zpisu do V.T.")).LeftPosZ(8, 112).TopPosZ(8, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.datum.LeftPosZ(124, 72).TopPosZ(8, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(64, 64).TopPosZ(40, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(132, 64).TopPosZ(40, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, ZadostLayout__layid&) { parent.LayoutId("ZadostLayout");
	layout.dv___0.SetLabel(t_GetLngString("adatel")).LeftPosZ(8, 44).TopPosZ(4, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.text.LeftPosZ(52, 88).TopPosZ(4, 19); layout.text.LayoutId("text"); parent.Add(layout.text);
	layout.dv___2.SetLabel(t_GetLngString("Bytem")).LeftPosZ(144, 36).TopPosZ(4, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.text1.LeftPosZ(180, 244).TopPosZ(4, 19); layout.text1.LayoutId("text1"); parent.Add(layout.text1);
	layout.gos.SetLabel(t_GetLngString("*")).LeftPosZ(428, 16).TopPosZ(4, 20); layout.gos.LayoutId("gos"); parent.Add(layout.gos);
	layout.dv___5.SetLabel(t_GetLngString("OP .")).LeftPosZ(8, 25).TopPosZ(28, 19); layout.dv___5.LayoutId("dv___5"); parent.Add(layout.dv___5);
	layout.op.LeftPosZ(52, 76).TopPosZ(28, 19); layout.op.LayoutId("op"); parent.Add(layout.op);
	layout.dv___7.SetLabel(t_GetLngString("dat. a m.")).LeftPosZ(132, 48).TopPosZ(28, 19); layout.dv___7.LayoutId("dv___7"); parent.Add(layout.dv___7);
	layout.op_dm.LeftPosZ(180, 136).TopPosZ(28, 19); layout.op_dm.LayoutId("op_dm"); parent.Add(layout.op_dm);
	layout.dv___9.SetLabel(t_GetLngString("plat. do")).LeftPosZ(320, 40).TopPosZ(28, 19); layout.dv___9.LayoutId("dv___9"); parent.Add(layout.dv___9);
	layout.op_platnost.LeftPosZ(360, 84).TopPosZ(28, 19); layout.op_platnost.LayoutId("op_platnost"); parent.Add(layout.op_platnost);
	layout.dv___11.SetLabel(t_GetLngString("Doklady")).LeftPosZ(8, 44).TopPosZ(52, 19); layout.dv___11.LayoutId("dv___11"); parent.Add(layout.dv___11);
	layout.text3.LeftPosZ(52, 392).TopPosZ(52, 56); layout.text3.LayoutId("text3"); parent.Add(layout.text3);
	layout.dv___13.SetLabel(t_GetLngString("P. vztah")).LeftPosZ(8, 44).TopPosZ(112, 20); layout.dv___13.LayoutId("dv___13"); parent.Add(layout.dv___13);
	layout.cd.LeftPosZ(52, 392).TopPosZ(112, 19); layout.cd.LayoutId("cd"); parent.Add(layout.cd);
	layout.dv___15.SetLabel(t_GetLngString("Poplatek")).LeftPosZ(8, 44).TopPosZ(136, 19); layout.dv___15.LayoutId("dv___15"); parent.Add(layout.dv___15);
	layout.cislo.LeftPosZ(52, 56).TopPosZ(136, 19); layout.cislo.LayoutId("cislo"); parent.Add(layout.cislo);
	layout.dv___17.SetLabel(t_GetLngString(". stvrzenky")).LeftPosZ(120, 68).TopPosZ(136, 19); layout.dv___17.LayoutId("dv___17"); parent.Add(layout.dv___17);
	layout.text2.LeftPosZ(192, 108).TopPosZ(136, 19); layout.text2.LayoutId("text2"); parent.Add(layout.text2);
	layout.dv___19.SetLabel(t_GetLngString(".j.")).LeftPosZ(92, 20).TopPosZ(164, 19); layout.dv___19.LayoutId("dv___19"); parent.Add(layout.dv___19);
	layout.cj.LeftPosZ(112, 108).TopPosZ(164, 19); layout.cj.LayoutId("cj"); parent.Add(layout.cj);
	layout.dv___21.SetLabel(t_GetLngString("Datum")).LeftPosZ(316, 40).TopPosZ(136, 19); layout.dv___21.LayoutId("dv___21"); parent.Add(layout.dv___21);
	layout.datum.LeftPosZ(356, 88).TopPosZ(136, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.dv___23.SetLabel(t_GetLngString("Matrik")).LeftPosZ(228, 52).TopPosZ(164, 19); layout.dv___23.LayoutId("dv___23"); parent.Add(layout.dv___23);
	layout.matrikar.LeftPosZ(284, 160).TopPosZ(164, 19); layout.matrikar.LayoutId("matrikar"); parent.Add(layout.matrikar);
	layout.print.SetLabel(t_GetLngString("Tisk")).LeftPosZ(8, 64).TopPosZ(164, 24); layout.print.LayoutId("print"); parent.Add(layout.print);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, OdDo2Layout__layid&) { parent.LayoutId("OdDo2Layout");
	layout.dv___0.SetLabel(t_GetLngString("Od")).LeftPosZ(8, 20).TopPosZ(8, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.dtm_od.LeftPosZ(44, 72).TopPosZ(8, 19); layout.dtm_od.LayoutId("dtm_od"); parent.Add(layout.dtm_od);
	layout.dv___2.SetLabel(t_GetLngString("do")).LeftPosZ(120, 16).TopPosZ(8, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.dtm_do.LeftPosZ(140, 72).TopPosZ(8, 19); layout.dtm_do.LayoutId("dtm_do"); parent.Add(layout.dtm_do);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(80, 64).TopPosZ(36, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(148, 64).TopPosZ(36, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, TotoznostLayout__layid&) { parent.LayoutId("TotoznostLayout");
	layout.dv___0.SetLabel(t_GetLngString("adatel")).LeftPosZ(8, 44).TopPosZ(4, 19); layout.dv___0.LayoutId("dv___0"); parent.Add(layout.dv___0);
	layout.text.LeftPosZ(52, 88).TopPosZ(4, 19); layout.text.LayoutId("text"); parent.Add(layout.text);
	layout.dv___2.SetLabel(t_GetLngString("Bytem")).LeftPosZ(144, 36).TopPosZ(4, 19); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.text1.LeftPosZ(180, 244).TopPosZ(4, 19); layout.text1.LayoutId("text1"); parent.Add(layout.text1);
	layout.gos1.SetLabel(t_GetLngString("*")).LeftPosZ(428, 16).TopPosZ(4, 20); layout.gos1.LayoutId("gos1"); parent.Add(layout.gos1);
	layout.dv___5.SetLabel(t_GetLngString("Datum a msto narozen")).LeftPosZ(52, 120).TopPosZ(28, 19); layout.dv___5.LayoutId("dv___5"); parent.Add(layout.dv___5);
	layout.text2.LeftPosZ(180, 264).TopPosZ(28, 19); layout.text2.LayoutId("text2"); parent.Add(layout.text2);
	layout.dv___7.SetLabel(t_GetLngString("Svdek 1")).LeftPosZ(8, 44).TopPosZ(60, 19); layout.dv___7.LayoutId("dv___7"); parent.Add(layout.dv___7);
	layout.text3.LeftPosZ(52, 88).TopPosZ(60, 19); layout.text3.LayoutId("text3"); parent.Add(layout.text3);
	layout.dv___9.SetLabel(t_GetLngString("Bytem")).LeftPosZ(144, 36).TopPosZ(60, 19); layout.dv___9.LayoutId("dv___9"); parent.Add(layout.dv___9);
	layout.text4.LeftPosZ(180, 264).TopPosZ(60, 19); layout.text4.LayoutId("text4"); parent.Add(layout.text4);
	layout.dv___11.SetLabel(t_GetLngString("D. a m. narozen")).LeftPosZ(8, 88).TopPosZ(84, 19); layout.dv___11.LayoutId("dv___11"); parent.Add(layout.dv___11);
	layout.op.LeftPosZ(100, 164).TopPosZ(84, 19); layout.op.LayoutId("op"); parent.Add(layout.op);
	layout.dv___13.SetLabel(t_GetLngString("Doklad")).LeftPosZ(268, 40).TopPosZ(84, 19); layout.dv___13.LayoutId("dv___13"); parent.Add(layout.dv___13);
	layout.text5.LeftPosZ(312, 132).TopPosZ(84, 19); layout.text5.LayoutId("text5"); parent.Add(layout.text5);
	layout.dv___15.SetLabel(t_GetLngString("Svdek 2")).LeftPosZ(8, 44).TopPosZ(116, 19); layout.dv___15.LayoutId("dv___15"); parent.Add(layout.dv___15);
	layout.text6.LeftPosZ(52, 88).TopPosZ(116, 19); layout.text6.LayoutId("text6"); parent.Add(layout.text6);
	layout.dv___17.SetLabel(t_GetLngString("Bytem")).LeftPosZ(144, 36).TopPosZ(116, 19); layout.dv___17.LayoutId("dv___17"); parent.Add(layout.dv___17);
	layout.text7.LeftPosZ(180, 264).TopPosZ(116, 19); layout.text7.LayoutId("text7"); parent.Add(layout.text7);
	layout.dv___19.SetLabel(t_GetLngString("D. a m. narozen")).LeftPosZ(8, 88).TopPosZ(140, 19); layout.dv___19.LayoutId("dv___19"); parent.Add(layout.dv___19);
	layout.text8.LeftPosZ(100, 164).TopPosZ(140, 19); layout.text8.LayoutId("text8"); parent.Add(layout.text8);
	layout.dv___21.SetLabel(t_GetLngString("Doklad")).LeftPosZ(268, 40).TopPosZ(140, 19); layout.dv___21.LayoutId("dv___21"); parent.Add(layout.dv___21);
	layout.text9.LeftPosZ(312, 132).TopPosZ(140, 19); layout.text9.LayoutId("text9"); parent.Add(layout.text9);
	layout.dv___23.SetLabel(t_GetLngString("Datum")).LeftPosZ(84, 40).TopPosZ(168, 19); layout.dv___23.LayoutId("dv___23"); parent.Add(layout.dv___23);
	layout.datum.LeftPosZ(124, 88).TopPosZ(168, 19); layout.datum.LayoutId("datum"); parent.Add(layout.datum);
	layout.dv___25.SetLabel(t_GetLngString("Matrik")).LeftPosZ(228, 52).TopPosZ(168, 19); layout.dv___25.LayoutId("dv___25"); parent.Add(layout.dv___25);
	layout.matrikar.LeftPosZ(284, 160).TopPosZ(168, 19); layout.matrikar.LayoutId("matrikar"); parent.Add(layout.matrikar);
	layout.print.SetLabel(t_GetLngString("Tisk")).LeftPosZ(8, 64).TopPosZ(164, 24); layout.print.LayoutId("print"); parent.Add(layout.print);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, OsvCrLayout__layid&) { parent.LayoutId("OsvCrLayout");
	layout.cislo.LeftPosZ(320, 144).TopPosZ(4, 19); layout.cislo.LayoutId("cislo"); parent.Add(layout.cislo);
	uts.osoby.LeftPosZ(8, 456).TopPosZ(28, 268); uts.osoby.LayoutId("osoby"); parent.Add(uts.osoby);
	layout.dv___2.SetLabel(t_GetLngString(".j.")).LeftPosZ(292, 24).TopPosZ(4, 20); layout.dv___2.LayoutId("dv___2"); parent.Add(layout.dv___2);
	layout.dv___3.SetLabel(t_GetLngString("V")).LeftPosZ(8, 52).TopPosZ(304, 19); layout.dv___3.LayoutId("dv___3"); parent.Add(layout.dv___3);
	layout.kde.LeftPosZ(64, 260).TopPosZ(304, 19); layout.kde.LayoutId("kde"); parent.Add(layout.kde);
	layout.dv___5.SetLabel(t_GetLngString("Dne")).LeftPosZ(352, 24).TopPosZ(304, 19); layout.dv___5.LayoutId("dv___5"); parent.Add(layout.dv___5);
	layout.dne.LeftPosZ(380, 84).TopPosZ(304, 19); layout.dne.LayoutId("dne"); parent.Add(layout.dne);
	layout.print.SetLabel(t_GetLngString("Tisk")).LeftPosZ(8, 64).TopPosZ(332, 24); layout.print.LayoutId("print"); parent.Add(layout.print);
	layout.ok.SetLabel(t_GetLngString("OK")).LeftPosZ(332, 64).TopPosZ(332, 24); layout.ok.LayoutId("ok"); parent.Add(layout.ok);
	layout.cancel.SetLabel(t_GetLngString("Storno")).LeftPosZ(400, 64).TopPosZ(332, 24); layout.cancel.LayoutId("cancel"); parent.Add(layout.cancel);
};

template <class L, class D> void InitLayout(Upp::Ctrl& parent, L& layout, D& uts, RcListLayout__layid&) { parent.LayoutId("RcListLayout");
	layout.mesic.LeftPosZ(8, 96).TopPosZ(8, 19); layout.mesic.LayoutId("mesic"); parent.Add(layout.mesic);
	layout.pridelene.SetLabel(t_GetLngString("Pouze pidlen")).LeftPosZ(108, 108).TopPosZ(8, 20); layout.pridelene.LayoutId("pridelene"); parent.Add(layout.pridelene);
	layout.list.LeftPosZ(8, 596).TopPosZ(32, 416); layout.list.LayoutId("list"); parent.Add(layout.list);
	layout.exit.SetLabel(t_GetLngString("Zavt")).LeftPosZ(540, 64).TopPosZ(456, 24); layout.exit.LayoutId("exit"); parent.Add(layout.exit);
	layout.unpri.SetLabel(t_GetLngString("Odstranit pidlen")).LeftPosZ(492, 112).TopPosZ(8, 20); layout.unpri.LayoutId("unpri"); parent.Add(layout.unpri);
	layout.export.SetLabel(t_GetLngString("Export..")).LeftPosZ(8, 56).TopPosZ(456, 24); layout.export.LayoutId("export"); parent.Add(layout.export);
};

#line 37 "u:/uppsrc\\CtrlCore/lay.h"







#line 33 "u:\\idisapp\\matrika2\\Matrika.h"

extern SqlSequence SeqMat;

enum {
	MATRIKA_RODNYLIST = 0,
	MATRIKA_KNIHA_NAROZENI = 1,
	MATRIKA_ZAPIS_OTCOVSTVI = 2,
	MATRIKA_ZAPIS_OTCOVSTVI_NENAROZENEHO = 3,
	MATRIKA_ZMENA_NAROZENI = 4,
	MATRIKA_RODNYLIST_DUPLIKAT = 5,
	MATRIKA_TEXT_KNIHY = 10,
	MATRIKA_TEXT_KNIHY_N = 11,
	MATRIKA_TEXT_KNIHY_NN = 12,
	MATRIKA_ZAPIS_NAROZENI = 13,
	MATRIKA_ZADOST_NAROZENI = 14,
	MATRIKA_TOTOZNOST_NAROZENI = 15,

	MATRIKA_ODDACILIST = 100,
	MATRIKA_KNIHA_MANZELSTVI = 101,
	MATRIKA_HLASENI_MANZELSTVI = 103,
	MATRIKA_POTVRZENI_MANZELSTVI = 104,
	MATRIKA_PROTOKOL_MANZELSTVI = 105,
	MATRIKA_ZMENA_MANZELSTVI = 106,
	MATRIKA_PROTOKOL_MANZELSTVI2 = 107,
	MATRIKA_TEXT_KNIHY_MANZELSTVI = 108,
	MATRIKA_ODDACILIST_DUPLIKAT = 109,
	MATRIKA_ZAPIS_MANZELSTVI = 110,
	MATRIKA_ZADOST_MANZELSTVI = 111,
	MATRIKA_TOTOZNOST_MANZELSTVI = 112,

	MATRIKA_UMRTNILIST = 200,
	MATRIKA_KNIHA_UMRTI = 201,
	MATRIKA_HLASENI_UMRTI = 202,
	MATRIKA_ZMENA_UMRTI = 203,
	MATRIKA_TEXT_KNIHY_UMRTI = 204,
	MATRIKA_UMRTNILIST_DUPLIKAT = 205,
	MATRIKA_POTVRZENI_UMRTI = 206,
	MATRIKA_ZAPIS_UMRTI = 210,
	MATRIKA_ZADOST_UMRTI = 211,
	MATRIKA_TOTOZNOST_UMRTI = 212,

	MATRIKA_VYSVEDCENI = 300,

	MATRIKA_VYPIS = 400,
	MATRIKA_REJSTRIK = 500,
	MATRIKA_OSVEDCENI = 600,
	MATRIKA_OSVCR = 700,
};

enum {
	MATRIKA_USERLIB = -1000,
};

bool PrintDoc(int sablona_seq, VectorMap<String, Value>& vars);

VectorMap<String, Value> MakeVarsO(SqlCtrls& matrika, SqlCtrls& zaznam, int rev_seq = Null);

bool InvalidRC(const Value& rc);

WString UniStr(const String& q);

struct Zdoc : ParentCtrl {
	virtual void SetDatum(Date d) = 0;
};

struct ZaznamTyp : Moveable<ZaznamTyp> {
	Zdoc           *ctrl;
	String          name;
	Callback        WhenNew;
};

struct LatinButton : FrameRight<Button> {
	TopWindow    win;
	int          value;

	void        Invoke();
	void        SetValue(const String& link);

	typedef LatinButton CLASSNAME;

	LatinButton();
};

struct UniConvert : public Convert {
	virtual Value Format(const Value& q) const {
		return UniStr(q);
	}

	virtual Value Scan(const Value& text) const {
		return StrUni(text);
	}
};

struct OsobaTabs;

struct Zaznam {
	VectorMap<int, ZaznamTyp> typ;

	ArrayCtrl              list;
	ParentCtrl             doc;
	Button                 add;
	Button                 edit;
	Button                 remove;
	Button                 up, down;
	int                    ndup;
	SqlCtrls               ctrls;
	OsobaTabs             *osobatabs;

	void Insert();
	void InsertTyp(int typ);
	void Edit();
	void Remove();
	void Menu(Bar& bar);
	void ListCursor();
	void Up();
	void Down();

	void AddDoc(int typid, Zdoc& ctrl, const char *name, Callback whenew);
	void AddDoc(int typid, Zdoc& ctrl, const char *name);

	void EndDuplicate()                { ndup = ctrls.GetCount(); }
	void FinishList();

	void Save(int matrika_seq);
	void Load(int matrika_seq);

	operator SqlCtrls&()  { return ctrls; }

	Callback WhenNew;

	typedef Zaznam CLASSNAME;

	Zaznam();
};

struct MOsobaCtrl : public WithMOsobaLayout<ParentCtrl> {
	bool insert;
	int  dyear;
	Array< FrameLeft<ButtonOption> > chopt;

	bool                       type2;
	DropList                   pohlavi1;
	WithDropChoice<EditString> pohlavi2;
	EditDate                   dat_nar1;
	EditString                 dat_nar2;
	DropList                   stav1;
	WithDropChoice<EditString> stav2;
	Array<LatinButton>         lb;

	void Uni(EditString& x);
	void NewOsoba();
	void NewRC();
	void PriRC();
	void IdCtrls(SqlId id, Vector<SqlId>& tid, Vector<Ctrl *>& tctrl);
	void Ctrls(SqlId id, SqlCtrls& ctrls);
	void LoadList(bool set = false);

	void Type2();

	void Init();

	Callback WhenOsobaSeq;
	Callback WhenRC;

	typedef MOsobaCtrl CLASSNAME;

	MOsobaCtrl();
};

struct OsobaTabs : public TabCtrl {
	bool              type2;
	Array<MOsobaCtrl> osoba;
	bool              insert;

	MOsobaCtrl&      operator[](int i)  { return osoba[i]; }
	int   Get(int i)                    { return ~osoba[i].osoba_seq; }
	void  SetWhen(int i, Callback cb)   { osoba[i].WhenOsobaSeq = cb; }
	void  Set(int i, int osoba_seq);

	bool  Check();

	void  Add(SqlId id, const char *text, SqlCtrls& ctrls);
	void  Init();
	void  Sync();

	OsobaTabs(bool type2 = false) : type2(type2) {}
};

struct OsobaTabs2 : public OsobaTabs {
	OsobaTabs2() : OsobaTabs(true) {}
};

enum {
	MATRIKA_NAROZENI = 0,
	MATRIKA_MANZELSTVI = 1,
	MATRIKA_UMRTI = 2
};

struct SelectDlg : WithSelectLayout<TopWindow> {
	void    Serialize(Stream& s);
	SqlBool GetWhere();
	void    Clear();

	typedef SelectDlg CLASSNAME;

	SelectDlg();
};


struct VTCtrl : ParentCtrl {
	Button    *vt;
	Value      datum;
	Label      label;

	virtual void  SetData(const Value& data);
	virtual Value GetData() const;

	void Sync();
	void Set();
};

template <class T>
struct WithTabInit : T {
	int        sablona;
	int        sablona2;
	SqlCtrls  *matrika;
	SqlCtrls  *zaznam;
	OsobaTabs *tabs;
	VTCtrl     vt;
	ParentCtrl vtp;

	virtual void SetDatum(Date d) {
		datum <<= d;
	}

	void VTSync() {
		vt.Sync();
	}

	void VTSet() {
		vt.Set();
		vt.Sync();
	}

	void VT(SqlId pid, Button& b) {
		Add(vt.SetPos(b.GetPos()));
		vt.Add(b.SizePos());
		vt.Add(vt.label.SizePos());
		b <<= callback(this, &CLASSNAME::VTSet);
		vt.vt = &b;
		zaznam->Add(pid&DATUM_VT, vt);
	}

	void Init0(int _sablona, SqlCtrls& _matrika, SqlCtrls& _zaznam, OsobaTabs& _tabs) {
		sablona = _sablona;
		matrika = &_matrika;
		zaznam = &_zaznam;
		tabs = &_tabs;
	}

	void InitM(SqlId pid, int sablona, SqlCtrls& matrika, SqlCtrls& zaznam, OsobaTabs& tabs) {
		Init0(sablona, matrika, zaznam, tabs);
		zaznam.Add(pid&DATUM, datum);
		zaznam.Add(pid&MATRIKAR, matrikar);
	}

	void InitT(SqlId pid, int sablona, SqlCtrls& matrika, SqlCtrls& zaznam, OsobaTabs& tabs) {
		InitM(pid, sablona, matrika, zaznam, tabs);
		zaznam.Add(pid&TEXT, text);
	}

	void InitT1(SqlId pid, int sablona, SqlCtrls& matrika, SqlCtrls& zaznam, OsobaTabs& tabs) {
		InitT(pid, sablona, matrika, zaznam, tabs);
		zaznam.Add(pid&TEXT1, text1);
	}

	void InitT2(SqlId pid, int sablona, SqlCtrls& matrika, SqlCtrls& zaznam, OsobaTabs& tabs) {
		InitT1(pid, sablona, matrika, zaznam, tabs);
		zaznam.Add(pid&TEXT2, text2);
	}

	void InitT3(SqlId pid, int sablona, SqlCtrls& matrika, SqlCtrls& zaznam, OsobaTabs& tabs) {
		InitT2(pid, sablona, matrika, zaznam, tabs);
		zaznam.Add(pid&TEXT3, text3);
	}

	void SetSablona(int _sablona) {
		sablona = _sablona;
	}

	typedef WithTabInit CLASSNAME;

	WithTabInit() {
		CtrlLayout(*this);
		vt.vt = 0;
	}
};



template <class T>
struct WithSablona : WithTabInit<T> {
	Gate WhenCheck;
	void Print0(int sablonaq, bool kopie)
	{
		if(!tabs->Check())
			return;
		if(!WhenCheck())
			return;
		if(IsNull(matrikar))
			matrikar <<= Osoba::GetDesc(GetUserOsobaSeq());
		::Print(sablonaq, MakeVarsO(*matrika, *zaznam), kopie);
	}

	void Print(bool kopie)
	{
		Print0(sablona, kopie);
	}


	typedef WithSablona CLASSNAME;

	WithSablona() {
		original.SetImage(CtrlImg::print());
		original <<= callback1(this, &CLASSNAME::Print, false);
		kopie.SetImage(CtrlImg::print());
		kopie <<= callback1(this, &CLASSNAME::Print, true);
		WhenCheck = true;
	}
};

struct List : WithSablona< WithListLayout<Zdoc> > {
	void Init(int sablona, SqlCtrls& matrika, SqlCtrls& zaznam, OsobaTabs& tabs) {
		InitT(LIST, sablona, matrika, zaznam, tabs);
	}

	void Set2(int q) { sablona2 = q; original2.Show(); kopie2.Show(); }

	void Print2(bool kopie)
	{
		Print0(sablona2, kopie);
	}

	typedef List CLASSNAME;

	List() {
		original2.SetImage(CtrlImg::print());
		original2 <<= callback1(this, &CLASSNAME::Print2, false);
		kopie2.SetImage(CtrlImg::print());
		kopie2 <<= callback1(this, &CLASSNAME::Print2, true);
		original2.Hide();
		kopie2.Hide();
		cj_lbl.Hide();
		cj.Hide();
	}
};

int RevSeq(int matrika_seq);

template <class T>
struct WithDoc : WithTabInit<T> {
	Callback WhenPrint;
	Gate     WhenCheck;
	int      rev_seq;

	bool Print0()
	{
		if(!WhenCheck())
			return false;
		if(IsNull(matrikar))
			matrikar <<= Osoba::GetDesc(GetUserOsobaSeq());
		if(PrintDoc(sablona, MakeVarsO(*matrika, *zaznam, rev_seq))) {
			WhenPrint();
			return true;
		}
		return false;
	}

	void Print() { Print0(); }

	typedef WithDoc CLASSNAME;

	WithDoc() {
		print.SetImage(CtrlImg::print());
		print <<= callback(this, &CLASSNAME::Print);
		rev_seq = Null;
		WhenCheck = true;
	}
};

struct Kniha : WithDoc< WithKnihaLayout<Zdoc> > {
	typedef Kniha CLASSNAME;

	void PrintKniha() {
		if(!tabs->Check())
			return;
		if(IsNull(idc))
			idc <<= AppCursor() % Select(IDC).From(USEROSOBA).Where(OSOBA_SEQ == GetUserOsobaSeq());
		Print0();
	}

	void Init(int sablona, SqlCtrls& matrika, SqlCtrls& zaznam, OsobaTabs& tabs) {
		InitT(KNIHA, sablona, matrika, zaznam, tabs);
		zaznam.Add(KNIHA&IDC, idc);
		print <<= callback(this, &CLASSNAME::PrintKniha);
	}

	void Zmena(SqlCtrls& zaznam) {
		cislo_txt.Show();
		cislo.Show();
		zaznam.Add(ZMENA&IDC, idc);
		zaznam.Add(ZMENA&CISLO, cislo);
		print <<= callback(this, &CLASSNAME::PrintKniha);
	}

	Kniha() {
		cislo_txt.Hide();
		cislo.Hide();
	}
};

struct Hlaseni : WithSablona< WithHlaseniLayout<Zdoc> > {
	void Init(int sablona, SqlCtrls& matrika, SqlCtrls& zaznam, OsobaTabs& tabs) {
		InitM(HLASENI, sablona, matrika, zaznam, tabs);
	}
};

void DlVzdelani(DropList& dl);

void Obec(DropList& dl);
void Next(int typ, DropList& obec_seq, EditInt& rocnik, EditInt& svazek,
          EditInt& strana, EditInt& cislo);

template <class T>
void Next(int typ, T& dlg)
{
	Next(typ, dlg.obec_seq, dlg.rocnik, dlg.svazek, dlg.strana, dlg.cislo);
}

struct MInfo : Moveable<MInfo> {
	String osoba, osoba1;
	int    zaznamy;
	int    mindx;
	String datum;
	String datnar;
	String detail;

	MInfo() { zaznamy = 0; mindx = 2147483647; datum = Null; }
};

struct ConvertOsoby : public Convert {
	VectorMap<int, MInfo>& minfo;

	virtual Value Format(const Value& v) const;

	ConvertOsoby(VectorMap<int, MInfo>& minfo) : minfo(minfo) {}
};

struct ConvertZaznamy : public Convert {
	VectorMap<int, MInfo>& minfo;

	virtual Value Format(const Value& q) const;

	ConvertZaznamy(VectorMap<int, MInfo>& minfo) : minfo(minfo) {}
};

struct ConvertDatum : public Convert {
	VectorMap<int, MInfo>& minfo;

	virtual Value Format(const Value& q) const;

	ConvertDatum(VectorMap<int, MInfo>& minfo) : minfo(minfo) {}
};

bool RunCancel(TopWindow &dlg);
void   EndCJ(int q);
String MakeCJ(int q);

struct Matrika : public WithMatrikaLayout<TopWindow> {
	VectorMap<int, MInfo> minfo;
	ConvertOsoby   cvosoby;
	ConvertZaznamy cvzaznamy;
	ConvertDatum   cvdatum;

	SelectDlg select;

	void ReQuery(int matrika_seq, int typ);
	void Query();
	void SetupQuery();

	void PostQuery();

	void Exit();
	void About();

	VectorMap<String, Value> Vars();
	void                     Designer();
	void                     Sablony();

	void NewNarozeni();
	void EditNarozeni();

	void NewManzelstvi();
	void EditManzelstvi();

	void NewUmrti();
	void ZmenaUmrti();
	void EditUmrti();
	void UmrtiOp();

	void NewVysvedceni();
	void EditVysvedceni();

	void NewOsvedceni();
	void EditOsvedceni();

	void NewOsvCr();
	void EditOsvCr();

	void NewVypis();
	void EditVypis();

	void NewRejstrik();
	void EditRejstrik();
	void RejstrikVypis();

	void ReportDuplikaty();

	int  GetActual();
	void Edit();

	void Remove();

	void MatrikaMenu(Bar& bar);
	void SetupMenu(Bar& bar);
	void SestavaMenu(Bar& bar);
	void AboutMenu(Bar& bar);
	void MainMenu(Bar& bar);

	void IndexSvazku();

	void Import2();

	void RCList();

	void StatZaznam();

	void Serialize(Stream& s);

	typedef Matrika CLASSNAME;

	Matrika();
};

FileSel& IrcFs();
FileSel& IrcExpFs();
void ImportRC();
String FormatRc(const String& _s);

Date ScanDate(const char *s);

#line 595 "u:\\idisapp\\matrika2\\Matrika.h"
#line 2 "u:\\idisapp\\Matrika2\\Form.cpp"

bool IsTrue(const Value& v)
{
	return IsString(v) ? String(v) == "1" : IsNumber(v) ? int(v) : false;
}

void AddRev(VectorMap<String, Value>& m, int rev_seq)
{
	VectorMap<String, String> rev;
	if(!IsNull(rev_seq)) {
		S_MATRIKA mat;
		Sql sql;
		sql * Select(mat).From(MATRIKA).Where(MATRIKA_SEQ == rev_seq);
		if(sql.Fetch())
			for(int i = 0; i < sql.GetColumns(); i++)
				rev.Add(Filter(sql.GetColumnInfo(i).name, StringToUnderline),
				        StdFormat(sql[i]));
	}
	int n = m.GetCount();
	for(int i = 0; i < n; i++) {
		String key = m.GetKey(i);
		if(key.EndsWith("RPRIJMENI")) {
			int q = m.Find(key + "O");
			if(q >= 0) {
				;
				;
			}
			if(q >= 0 && AsString(m[q]) == "1" && IsString(m[i]))
				m[i] = String(m[i]) + " ";
		}
		if(key[0] == '_') {
			String v = StdFormat(m[i]);
			int q = m.Find(key + "_Z");
			key = key.Mid(1);
			if(q >= 0 && IsTrue(m[q]))
				v = "[d " + Qtlf(v) + "]";
			else {
				q = rev.Find(key);
				if(q >= 0 && rev[q] != v && v.GetCount())
					v = "[d " + Qtlf(v) + "]";
				else
					v = Qtlf(v);
			}
			m.Add(key + "_R", v);
		}
	}
	int q = m.Find("_KNIHA_TEXT");
	if(q >= 0) {
		String r;
		String d = m[q];
		bool dashed = false;
		for(const char *s = d; *s; s++)
			if(*s == '\n')
				r.Cat('&');
			else
			if(*s == '~') {
				dashed = !dashed;
				if(dashed)
					r << "[d ";
				else
					r << "]";
			}
			else
			if((byte)*s >= ' ') {
				r.Cat('`');
				r.Cat(*s);
			}
		m.GetAdd("KNIHA_TEXT") = r;
	}
}

VectorMap<String, Value> Matrika::Vars()
{
	VectorMap<String, Value> var;
	if(matrika.IsCursor()) {
		S_MATRIKA m;
		AppCursor() * Select(m).From(MATRIKA).Where(MATRIKA_SEQ == matrika.GetKey());
		if(AppCursor().Fetch(m))
			var = MakeVars(m);
		var.GetAdd("MATRIKA_OBEC") = AppCursor() % Select(TEXT).From(MATRIKA_OBEC)
		                                   .Where(MATRIKA_OBEC_SEQ == m.MATRIKA_OBEC_SEQ);
		S_MATRIKA_ZAZNAM z;
		AppCursor() * Select(z).From(MATRIKA_ZAZNAM).Where(MATRIKA_SEQ == matrika.GetKey()).OrderBy(Descending(NDX));
		if(AppCursor().Fetch(z)) {
			VectorMap<String, Value> h = MakeVars(z);
			for(int i = 0; i < h.GetCount(); i++)
				var.GetAdd(h.GetKey(i)) = h[i];
		}
		AddRev(var, RevSeq(matrika.GetKey()));
	}
	return var;
}

VectorMap<String, Value> MakeVarsO(SqlCtrls& matrika, SqlCtrls& zaznam, int rev_seq)
{
	VectorMap<String, Value> m = MakeVars(matrika);
	VectorMap<String, Value> h = MakeVars(zaznam);
	for(int i = 0; i < h.GetCount(); i++)
		m.GetAdd(h.GetKey(i)) = h[i];
	int q = m.Find("MATRIKA_OBEC_SEQ");
	if(q >= 0)
		m.GetAdd("MATRIKA_OBEC") = DeQtf((String)(AppCursor() % Select(TEXT).From(MATRIKA_OBEC)
		                                          .Where(MATRIKA_OBEC_SEQ == m[q])));
	else
		m.GetAdd("MATRIKA_OBEC") = Null;
	AddRev(m, rev_seq);
	for(int i = 0; i < m.GetCount(); i++)
		;
	return m;
}

void Matrika::Designer()
{
	Forms f;
	f.var = Vars();
	f.list.Query();
	f.Execute();
}

void Matrika::Sablony()
{
	EditSablony(Vars());
}

bool PrintDoc(int seq, VectorMap<String, Value>& vars)
{
	RefreshDocMacro();
	WithPrintDocLayout<TopWindow> dlg;
	CtrlLayoutOKCancel(dlg, "Nhled");
	dlg.view.SetQTF(ExpandDoc(AppCursor() % Select(TEXT).From(MAT_SABLONA).Where(MAT_SABLONA_SEQ == seq), vars));
	if(dlg.Run() != 1)
		return false;
	Print(dlg.view.Get(), Size(3968, 6074), 1);
	return true;
}

bool InvalidRC(const Value& rc)
{
	return IsError(ConvertRodneCislo(rc));
}

int RevSeq(int matrika_seq)
{
	Sql sql;
	sql * Select(TYP, MATRIKA_OBEC_SEQ, ROCNIK, SVAZEK, STRANA, CISLO, ZMENA)
	      .From(MATRIKA)
	      .Where(MATRIKA_SEQ == matrika_seq);
	if(!sql.Fetch() || !IsNull(sql[ZMENA]))
		return Null;
	return AppCursor() % Select(MATRIKA_SEQ).From(MATRIKA)
	             .Where(TYP == sql[TYP] && MATRIKA_OBEC_SEQ == sql[MATRIKA_OBEC_SEQ] &&
	                    ROCNIK == sql[ROCNIK] && SVAZEK == sql[SVAZEK] && STRANA == sql[STRANA]
	                    && CISLO == sql[CISLO] && MATRIKA_SEQ != matrika_seq)
	             .OrderBy(Descending(ZMENA));
}
