topic "Draw";
[2 $$0,0#00000000000000000000000000000000:Default]
[i448;a25;kKO9;*@(64)2 $$1,0#37138531426314131252341829483380:class]
[l288;2 $$2,0#27521748481378242620020725143825:desc]
[a83;*R6 $$3,0#31310162474203024125188417583966:caption]
[l288;i1121;b17;O9;~~~.1408;2 $$4,0#10431211400427159095818037425705:param]
[i448;a25;kKO9;*@(64)2 $$5,0#37138531426314131252341829483370:item]
[*+117 $$6,6#14700283458701402223321329925657:header]
[{_}%EN-US 
[s3;:`:`:Draw`:`:class`:`:Draw: Draw&]
[s0; class_[* Draw]&]
[s2; &]
[s0; 
@@image:1640&2219
‚ƒ…‚€€€€€€€€€ø÷œíİÁ²ãªË–…áÏÿêÕ©¬æãŒàÕƒÃñœÊàí¡‰‰½Ğÿµ²Èü°‚¼«­ÚóñÿóŸé·ÿş÷ÿô“€
»ğœÏìã©¹æï» á×ö±Àœß÷ÿÆÈ¸ú³â‚ˆ©ÇïÆœ¼¡•âèÍˆ£É¤Âœ½™ñ„æÔˆ£·‹â¨ÓşïïÌ¼ÄñôæñœÕ
·ûä‘­‰÷¢·Ş¬¿š­İÀØÄÑ›Šı£íã÷Áöò“ú¶î»‚úŒÀì‘Çïö¥×Š„©ƒ‡¸Â®ÑÄÑ›İüôµ¤º×Ÿ¢şÚ˜™…”ˆ£·›
œ•ÇõÚö£çĞ‰¸ú³Îñ´ıÅ‘ñ„–óˆ£·ãæÁ©Çïö¨Á‚ßÇ“Ç˜‚Ì¸ú³ş¸êşÏ·³æÁÏ²¼ˆ±âèÍâ¸œª”Ïªşÿº
»‚ˆ£Äˆ£·Â‹âˆøñôâæÄ‘Ò¡ŞñŒ¸ÂªÄÑ›ˆ‘ÇÈ…¸ú³…âˆ©Çï¶‚¼ˆ·ÜÁœõ½ÙıßóéÈæŸ‹Ì±ûßÌ³…–Á
„Ş‚„ñ„ ¢‰âˆÀ’Ä‘…€¤ˆ£€É”Ç€’ €¤ĞÁœÈÂ¥õ¦ıÃ¸ÇìÆ£•‘ËÙæïŒà°ÙÇª£û—²üßÁÙÿˆà”˜€¸ÒÜ
áÊÂœá™Ä‘©âÒ–âˆË ”—²ÇØ¼†ñ¤¸”…¸µÂ²ˆ£Å¥¬…Ä‘–Áœ©®¬å¡°ŒâÈ ñ©ËœÇÅ·ÆºÜÚê„„§”âÈñ©Ë
ğÀë§¦ÄÁá½†’‰ÍÄ‘•âÒ–¸öÛ²ä™È¸äÒÜÊò¨ê½·şÛçû¸îàìÎ‘ßŞ·«ŸµÕ“Ö·õêğ´âí±Ä‘âŞÒ–øŞ§§©
éŠœ¨öÆ³ÿ‚îûß•¸ê»Á¤ÿ›°Š×±µÇÊÇÊ·üşÖš—”¿êÇ‹í×Æµ»Õÿâ¥ß­½ºûèçäÒÍ–¸Š·úûúã³ÏÏ·Æ
Ñ‘Ú³ñô†ÄÛ‘âÒ–Î¸úÿ½İÅƒæ³Û¡½Ñÿ†‹ÚÏßÌÕüäö›–ˆ¸ú•âÈñ©£Ë­ñ”Òùˆ¹·ëèÄœ©ø®å‰â¨ùÁĞÃ½Õ·Ş÷³
‚–Ü¶’ÇïÆ°œ©®åé£ •‚½ŸÔ¾¿‡íŒ£ §ŠÙ´¤âÈñ©œËü³Öü¥Ï×ñÔ¶¥¸ü·Æ½ˆ£ø™êÒ¯¿îèÃšˆ£ƒÅ¥¬ñœÆ
­ˆ£Å¥¬Ä‘–Áœ©®å¡‹°ŒâÈñ©Ä‹ñ„åÇŠ¤ËÙˆ£¬ƒ¸„ÒÜÊÂœá™§Ä‘âÒ–âˆµË ”—²ğÇØ†ñ¤¸”Ç¥ş’¡àíö
ï‘ÊÈ¥¬³÷¬°Øì£•‘„å„ñ„ ¢‰âˆÀ’Ä‘…€¤ˆ£€É”Ç€’ €¤ĞÁœÈÂ¥ñ¦ıÙ¸ÇìÆ£•‘ËÙæïŒà°ÙÇª£
û—²üßÁÙÿ‰ö‘˜€¸ÒÜáÊÂœá™Ä‘©âÒ–âˆË ”—²ÇØ¼†ñ¤¸”…¸µÂ²ˆ£Å¥¬…Ä‘–Áœ©®¬å¡°ŒâÈ ñ©ËœÇÅ·
ÖºÜÚÛµôô¡×Áœ©®ğå‰ÎñıÔ”£óŞ™Ç¬„ÉÉ‘ÇŠËÙâÂ¸Úíù€ñ„®ÎÄ‘âÒ–ÃÜñÔ¿õÛ¾ßñÇõãóŠøò•º½èÓßÎÎ
÷¿ÁÄ”Ä‘âÒ–øÌö¤Õì‘‚ÅŞèöß”í¯†½Úç÷ÑıØ’ñ¤ü¬›Äïïİ¡ùÉÛÑ¨ş¼Òş¥ş–÷İ«³ğşÆ®å‰ã¨æø£·¿¶ûô
éüÈœá¦Ä‘íâÒ–Î¸ú½ÿİÅƒæ³Û½ĞÑÿ†‹Ú÷çÒ¢ ”—Ó²ÜšÇñ ‰—“ÇèÄœ©è®å‰â¨ø•‘·ëÈˆ¸ÒæÜÊÒŸÇêÈ
ßïæÉ‰ÇêØÍ£ıÈ¢×¡Î”—²Ä·ëÍÂßò”ÏíÛ‚•Ë÷ÛÇÅÑ°‚¯ÖÆœ©®åóáÌâ™Ä‘âÔÒ–âˆË †”—²ÇØ†Şñ¤¸”…¸Â
Ú²ˆ£Å¥¬Ä‚‘–Áœ©®å–¡°ŒâÈñˆ©‹ñ„åÇÉŠËÙˆ£¬ƒØ¸ÒÜÊòÖÒ²ûÈåäÒ–áÙû‡˜ìö‘§Êˆ²€È‚¸‚‚„ñ„ ‰
ÑâˆÀ’Ä‘€‚¤ˆ£€ÉÇÊ€’ €¤áÜ’ÇÓ¾¬†Ü¾ãö‘ÊÈ¥¬³³÷°Øì£ó•‘ËÙ¾ïà…ìÿûˆŒÀœ°©®å¡°ŒÁâÈñ©‹ñ„
ÈåÇŠËÙˆÄ£¬ƒ¸ÒÜÊğÂœá™Ä‘âÔÒ–âˆË †”—²ÇØ†îñ¤¸”ÅÅ‘ÛÊ¨ïûÅ„«á¿«òå´à‹È¸ÒÜÊò®…®ï›ú—İŸ
€–¯Çœ©®å†‰¢ îŸ•š§÷Œ·£”ÿ—²œ‹£æÇÿ›æ³ÍÇñçÿ±ßıà¶åèˆ”ø¡âÈñ©ãËÅ¸êÆÄõÌ¸ª®ª‡¡üĞ£”ú·µ
õ™…ïïü¸¸¹öÓıÂùÛ‹£ş±Í—úîæÙÇ¿£ß—²ä£ú¿¥õÌ—¢”»—²Ü£æ‡«­±ñ´œ¸Á‚Âœ©®å‰»ãèÏœôİÏ
î²Ü¬áùÄ‘ÍâÒ–±ñôú¥ÓÑğ¬ñ„Î·Ä‘âÒ–İ¸×úëş¯şÁŒéì¦Ìÿ¸»÷‰ø­âÈñ©»ËÅ¸úíúñœ¸áŠ»ÓıÑº‘ÇĞˆ£Å
¥¬½ñ„Ø ”—²ÇØ¼†ñ¤¸”…¸µÂ²ˆ£Å¥¬…Ä‘–Áœ©®¬å¡°ŒâÈñ©‹ñ„å’ÇŠËÙˆ£¬‘ƒ¸ÒÜÊÒÿ”…ˆ°¶ûÈå
äÒ–Ùû‡˜¾ìö‘Êˆ²€’È‚¸‚„ñˆ„ ‰âˆÀ’•Ä‘€¤ˆ£€ĞÉÇ€’ À€¤ÁœÈÂÂ¥æıõ–¸›Éì£•‘ËÙ²æïà°ÙÇ
ìª£—²üßÁ£Ùÿ”›˜€¸„ÒÜÊÂœá™§Ä‘âÒ–âˆµË ”—²ğÇØ†ñ¤¸”Õ…¸Â²ˆ£Å•¥¬Ä‘–Áœ°©®å¡°ŒâÈñ©ËÇ
ìÓâªşšÉóŠë€©âÈñ©ÂËÂ¸ªş¤‘ãĞ‰¸ÒÜÊ’â¼æ­ƒˆÖ£Å¥¬ñôÆı¼íÜß˜ÜªáıšÕ¥ÍÉëÆµŒ¢¥øğ‰Ø˜ñ¤Ô¿
ºƒÉÌ½¹Å›±İüÜ·Ö×ö†ò×‘ÇêÕ¾ÿ›°Š—Õşı÷Ãì£Ÿ‘ŒËÙúã¨şÜ¼Œ²ª½óªæ›·úÏ¬¸Ò²ÜÊ²ªêİ³Ñì°¶âÉ
×‰£·¡”—½²ŒŒ£í­ßúÏì”šıë«Åš»°¹©ñô®¶Ä‘âÒ–¤œ·ëÍÁûÇëœö£Ş†¸ÒöÜÊ’¤âÏ¿ÍÇ»ƒÇÀïÃœ©®å¹
Ö£Š±‹›´ßşÁƒ¡ú§­ï¯Âªˆ£Å¥Ş¬£âè·™šñŸÆ¾›ıõ¿ÚšŸš“’€Ç¯Äœ©®åî‰âè¦óØˆÜø›âÈñ©“Ëİñ”ÜÏ
ˆã‘ÇŠËÙ©ˆˆõç…ŒÅÀœ©®å¡¥°‚ŒâÈñ©‹ñ‘„åÇŠËÙ‰ˆ£¬ƒ¸ÒÜáÊÂœá™Ä‘ÍâÒ–úû¾€ãµÙÇª£—²ëÌŞ»Àà³
ÄÔÆ”…À’ÄŠ‘€¤ˆ£€É¨Ç€’ € ¤ÁœÈ‚¸‚‚„ñ„ ‰Í—¸šöåµà†³ÔÆ®å›™½÷€ÁæŸ›©ŒÜÊòı‡ÆçÿÛÇà€â
 Èñ©‹ñ„å¤ÇŠËÙˆ£¢¬ƒ¸ÒÜÊÂ¸œá™Ä‘âÒª–âˆË ”ƒ—²ÇØ†ñ¯¤¸”…¸Â²ˆ£Å¥¬ÁœÍ‰©±‹éŞ¸ÕÿÓåÄÈÈ
±ˆ¸ÒÜÊ’°óêùÏ‡†Š¥£¡ƒ£›âÈğñ©‹ñ¤ºÁ¼ñ¤¸”¥³¿¾·ë‹÷ƒÛŸß£º¤¡¨îéÎ¤Æ–‹†ªûª×Úµ´´§ Öæ¢
½”—²ôÇÑÂ³ˆÔºµŸïÆò×‘Çê¢Öóñ¢ÕôÄüÑÎÄ‘ò±¢ŸŞÜşÇÅ —‹Ûë©˜¼÷Ûß³óõšÒ±Å÷³Ï¾úÆ™¹”åÔœÕ
¿»¢Ù¡¿ı÷§ÆƒÃÌÔœ†ä·§úÖÍÇ‚œ¥Âœ©®å˜™˜ÇÛÏÚ½Ÿ±Óü„¦¾¦¹íÎÔ´«–úúÉÍù‹§ÔëÒ¢Ò¡”—ÿ²ŒŠ£ÓŸ‚
ÛÔ¤ªÎåËùéÏÇñú‰£šÔˆ£Å¥¬Éóâ¨™ Á§¦µæââÙâÏ¿ÌêÀâÈˆñ¤ï¸”å¸ªï·˜êöÃƒ÷ÌÇÔÓ¹îŒÖÛÿºê«°…ñ
Ç¤¸”åÔœıœ¶Ãó£Âçã×·ñôÄñè¿ØŸ¿•õª÷§Ş‹®Âóˆ£Å±¥¬Áœİ´á‚›‹ïÃœ©ô®å¹»‚›ˆà¬âÈñ©éËƒ‘¡î‹€
Û±ˆ£Å¥¬¤‚„–Áœ©®å–¡°ŒâÈñˆ©‹ñ„åÇÉŠËÙˆ£¬ƒˆ¸ÒÜÊÂœáî™Ä‘âÒ–ú»€µÙÇªŞ£—²ÌŞ»À¦à³ÔÆ”…
ÔÀ’Ä‘€¤ˆÀ£€ÉÇ€’‚ €¤Áœ’È‚¸‚„ñè„ ‰—¸šö´åµà³ÔØÆ®å™½÷€ÙÁæŸ©ŒÜÊ±òı‡çÿÛÇ„à€âÈñ©‹
¢ñ„åÇŠË’Ùˆ£¬ƒ¸ÒÂÜÊÂœá™ÄÓ‘âÒ–âˆËš ”—²ÇøØ†ñ¤¸”…ê¸Â²ˆ£Å¥ø¬ÁœÕßè¸şãÿœ¾ğîµ¹Áñ¤¸”¥
£ú½şäÛ—íË¼¶ÌÂœ¸©®åé£æİË¬™×†Ùˆ¶£Å¥¬‡âèûÛøı°½¼¾®õÚĞüÜœé­™µ¿­´öˆ£Å¥¬ö×â¨¸Åõ¡
ğ¾”Ç½ûã—èúÚà‡¸ÒŒ¾ÖÔ››´–óÏªŸ¿›³ÿ±Ñ¹ß¾Ûş»ÇÚàç»™ç–ŸıŒÜÊ²ª›êİ±í¶·§Î­öˆ£ÓÅ¥¬ƒãèû
Ù«ÛœØ›ÉìÇŠËÙ¸ŒÙ£–Áœ© ®å¹”ÇÍ¤ñ‰ÿü¬†¯´öˆ£Å¥¬©ıñÔôŒüËĞóèì”ı‚çşÃ×†»Ä‘ÕâÒ–¸ŠÅ
¯³ªÿŸ¾æ§Ëâ¨ØÉãëƒ‚âÈñ©Ë Ç‰™­•Ï£í”—²¤£Áà¾‹¨ÇŠŒËÙòŸñõÇ´†”ˆ£Å¥¬ˆœó¬ƒ¸ÒÜáÊÂœá™Ä‘
©âÒ–âˆË ”—²ÇØü†ñ¤¸”¥şğ‚àíö‘Ê›È¥¬³÷°ËØì£•‘å¡€‚À’œÆª€Š¤Áá¤‚À’ œÆª€¤Áá¤‚À’œÆª
ô€¤Áá´¨ÀûŒÿõÍŞ§×¥„Ëú˜ÅĞ…æïÛ¬éö±¾®¥ÜÒÃ¬¶ªğİ¼³ÿñ’ƒÖÁœåäÑ‚âˆã‘Ç¹ÔÙÔ€¸ÂØÄ ÑÎ–• °
Ì–ñ”“Å…ˆ’£ŒÅœåäÑ‚âˆã‘Ç¹ÔÙÔ€¸ÂØÄàÑÎ–•ˆâ¨İùı’‡÷ö½ó¤ç÷×ÙóîÂ®¿Ø¡åÊ„³ÈÿÜ‰÷ş™Â¥½Ì¢‚ñ
øœµ÷Úİ›ù…ÄÓöûş¯şı¿Úõöğı½×†éœåé±Ä¢ò²¨“À¡¸Òã·çó‰§º»ìöÖ¤®£ò²×¨ÀÅ¸ªïâç¾›·÷Í›
£¾¢ÿğ×Ø¹ƒµêÙ÷¨Æ¨ˆæ¯®Ù­Ëóò½ê•­ºÒ°÷÷Ù÷øÎ½ûß—’®éá–•Ğçß–íàâ Ô½û¶¢¢§ÿ¼˜øŠŠõìóñüá
ÀÏœıéÇëÓÜÿîŒ½«ù¿ƒñ”ÓÇ‡éÚ×ÁËÇäÃÓ¨öø±Íîõá˜×–“·ö¬¿­³½³ó¡µû÷üø“ïš²ıøÊ‰—„ÚÀœÇÁğ‘Ç»
¬ë£òÈ¸¤Ôº¿µ¿©®µ“ê™¸Ú®à ˜³çœÅ‹ÔŞËîÁÕŸÆàñÃ‘Ç¸­²³öÿÜí¶ş¼‚¡ÆÆÑïñ¨—üîÉ½³ÇÃœ¡
Ë¹ş¸ú‹÷ş¿óŸ‚¡ŞªÇ»ëîÜÀğÁÄ‘Î›’ÇõõıÂıÔÏµÍÌÉ÷»Å§÷Û©øÀœ®Åî¬ıº‹ßü¬Ú™îÀœá´Ãñ³ô×ºîõ¡ë
Í¶‡ı›ıö×„“Œµ»ïÇõ¿î¹¹ûÒâÒô’÷¨¢Şšš¼ØÿÀÛß©çïëÒÂş¥¡¦Îş•İŒ¸ğ´±£ß™§á±ãü“âèÕö’°ïí¸ª
Ü¿Åœš¸ê­Ÿ¨áÙÏ¸¤ÿÔŒâèÜàê·æåèˆç®Í‡âÉõ“Ç¸í×³†Ôˆ£œĞÆœá¬âˆ§¨‘Ç˜‹¸ÂéÕÄ‘Æ¢ğÚ‡¸ÁìıİÊ
Å¸¤ÔæïÛ¬†éö¾®¥Ü’‰€÷¢€¤ÁÈœÈ‚¸‚ „ñ„ ‰âˆÔÀ’Ä‘€¤ˆÀ£€ÉÇ€’†ğ‰£ÙßÛ…¤î²ûÈåäÒÃ–Ùû‡˜ìö
¯‘ÊÈ¥¬ß÷Šğö¿ƒ†† ”—²ÇØ¼†ñ¤¸”…¸µÂ²ˆ£Å¥¬…Ä‘–Áœ©®¬å¡°ŒâÈñ©‹ñ„å’ÇŠËÙˆ£¬ñƒ¸ÒÜÊ¢â
Ñ¨îÔ­»é¦œºŒ‰Áæ·Ï÷¶ƒ÷¬¯¾üúîªô§‹üëÜ¿„á¯­öçâßîÄ‘â†Ò–Î¸êö» ôÆúšÏŒÿæı×º–ŠáÊÑÅ®Çã
Ÿ°ä»ƒñ÷¤¸”¥Ø¢ÅìÎî¶ôï’ùÆà§ûœè¡ğØœµŸŸ®ŠòóÇÕş…ñöäÇ¥¬×ã¨ÔøĞß—¨ëÕ”½ÅñãĞÒÔ’¬¯¹‹š¡
Ïù¢‚…µÇë¯ì±×ğªÔ³‘ƒ©ºÛƒ·’î÷Õ«ı˜ñ¤¸”åìœ¬…‚ÑºöÚ¼»Úü¡ÙšË—ï®ãĞœÕëñØ³Úî‘‹¼±ÅÑ¹š‡
Êñ¤¦º›ñ¤–ü¬¨··øÜñ·´Ÿ´ÛƒÑâ‹ûûÄÓ°ûÕ³Ûı¸ç°òıã•¢éÿşŒŞĞµªßÎÊÄ‹‰—ö«ŒïëŸıô³˜ò©ËÏî½ú
œäÔûïÚ“ñÔïºíãºÚ¦ïŠ£à™Í¿Ÿƒ‘‹–‹ÅÖ–‹ÛíœŒÉœæ­Ã¥¬Óâ¨šî£¥è–ÌæšÏŞ³Ëü¢Ùâå¤‰£à–ÏÎÄÑúÜÊ
’¤‚Ù»‡Ê××šå÷ü¸ø™ï‹£æÒæ÷§»ñ¤¸‡”åá¸êş¬ÿéßö»“Æ³Ş÷Ğÿ—şò¸êÜçÏ’ˆï£õ¸”¥£Ç¿öºÕú
–»Ô¯ÆÑœò¸ñ”ôìÿ‚¨¢šÇ•¹ŞĞÌü­ñ´Œ—İ²äˆ£ßÆª”ø‘¼¿ŸÏ×ÄÑî¬õÓê‡å×Ëˆ‡ëµëïÙ­ò¹×í·ûíÑµ¨–
”çü×¿ûÈåµäÒ–à‹â¦õ‹•œ¸ÊÏ¥¬ÄÑóÖªøòóÿÇÙ¸”õ…¸šâš§‹Ê¢¿âÈó©Ä‹ñ„åÇŠ¤ËÙˆ£¬ƒ¸„ÒÜÊÂœá™
§Ä‘âÒ–âˆõË ”—²Ô™ßË¬Í¾Ò¶™¹”åöŞª†›ı¤²¢¬Š€’ €¤ÁÈœÈ‚¸‚ „ñ„ ‰âˆÔÀ’Ä‘€¤ˆø£€É¸ÄÑ´
Ú¯«÷˜ı¤¸²ò©Ëì½ƒ¤Œ¶ûÈåäÒ³–ï»¸ûß¾‚ƒÇŠËÙ‰ˆ£¬ƒ¸ÒÜáÊÂœá™Ä‘©âÒ–âˆË ”—²ÇØ¼†ñ¤¸”…¸
µÂ²ˆ£Å¥¬…Ä‘–Áœ©®œå‰â¨şÆÇ½°î™áµÃˆ£Å¥¬¼ñœí¶ôï“¬µˆ‰„Ñˆ£ûÅ¥¬ÓãèÊó°À–ñ¤¸”áåÜœıŸü®
Òí¶ï›·­ÍŸéÔÈõåÿº¯Üˆµ—£”Ÿ—²œ£æŞ„íÁ°ñˆõÛµÄ‘šˆ£å¼ãÅ½¹ª¥ø±êĞûóºİ‘×šİê¿ñæß­Í¼ûèçäÒ
…–¸Ôê½–ºÇõú¶İˆ£ˆì‘ÇŠËÙıºÒÏİšÇÉÛ°¤ –”—²¤£îÇÖĞ¸ÒÜÊÅ’¡úîƒ›¨ƒ’ÇØ¢”û—²Ì£Îß
ªÊÅ½É¢ü‘âÇšËÙ‹£óíïÿŠñ¤ÍÙß…ñÚÄ«‘âÒ– €Î¯Ä‘âÒ–âêˆË ”—²àÇØ†ñ¤¸«”…¸Â²ˆ£«Å¥¬Ä‘–Á
àœ©®å¡°‚ŒâÈñ©‹ñ‘„åÇŠËÙ‰ˆ£¬ƒ¸ÒÜ¡ÊÒÿ©‘°¶éûÈåäÒ–Ùğû‡˜ìö‘Ê“ˆ²€È‚¸‚Á„ñ„ ‰â¨ˆÀ’Ä‘€¤
ˆ£€ÉÇ€¥’ €¤á’®ÇÓ¾¬†Üãßö‘ÊÈ¥¬³Ù÷°Øì£•ù‘ËÙ¾ïàì‚ÿûˆŒÀœ©Ø®å¡°Œâ Èñ©‹ñ„å¤ÇŠËÙˆ£
¢¬ƒ¸ÒÜÊÂ¸œá™Ä‘âÒª–âˆË ”ƒ—²ÇØ†ñ÷¤¸”¥ˆ£úØ›·íŸÛ§°èÎÚ¼è¼ª Øí¼Ôÿ…¯–Öàåÿ³Ç©ŠËÙâ¸Úí
›¹¾ÿêí´öåŠøÆ«—ö¯Îö·Û•×İ×ÛğôĞîˆ£Å½¥¬©âè©Æß¼¸Ê‘…¸ÒÜÊòºÏ‚û‹ßãó‡ÃÏî½Îñ³ïµ½¤ÔÖ
×ó¢š“õ×£ø¡ş™ÁøªæÑ½ÒúÌÕíÚÕˆ£Å¥¬çéâ¨È•æŸî€é™¥ùÆãüå„¯¨çåôø¯µØÃîøõ©Âö‡ìŸí½åˆ£åãÅ½¹
ÿªå£Ïõ•öŸÎ«šİê¿÷ôßÑçÄªñ³Ì—”»óöö¨°‡ïÎ¯ÿû¾›ùöÑÏÈá¥¬ñœõ¦Ö³ñ”ÏúÀœğ……ù¦şşıá£½‡ñ
ÿ¤¸”åĞ§£Ëú­¯ÿğŞÅ›‡ùèœ…“°¾ÇÁ‡áñ’”äñ¤ÇùŠËÙÎÅÑÑøóıèŠÎ”˜ä˜ÇıÃõß·³€ßÓÄ‘Âœ©®å™’Ç
ïñçŸİÙšƒĞ¼œÇê©÷ÄèÑ½øçÇµ·Ú¡”—²ÜË£úî¢î×ÇÉ§¾÷ñ”ô–œ˜¢ñãîœ»õŸ¿ÒÎÙçâõ¿ñ¤¸ó”åÜœıŞú
æ§‘ÏÆÿãÇ½’æÁëÎÚœ™Çªç¹¸ÒÀ£´ßæ¼Ôğ€Ê÷—™÷û•âÈñ©ËÇæÃ¶ÇÍ£Ÿ–ğÉã­ÿ‚ƒ·Ä‘âÒ–±ñ ÔÿÈ˜µò¨
š‰—´Öò¯°€Àœ©®å™¶šêÎ«´‹½»îá—Öƒ¸ÌÒÜÊ’¹·€ÚÃˆ£Å¥¬Ä‚‘–Áœ©®å–¡°ŒâÈñˆ©‹ñ„åÇÉŠËÙˆ£¬ƒ
Ø¸ÒÜÊòÖÒ²ûÈåäÒ–áÙû‡˜ìö‘‡Êˆ²Ğ ‰°£•€’à°€Ò ‰£•†€’à°Ò ä‰£Å…æüµ·Ÿ¬îö¾®Œ¥ÜÒÃ¬ª°
²ûÛâÍ³÷õÆ©á’æÑÏïæ™ıíâ¬İƒ¸ÊÉ¢‚Äê‘Æ¢ò²¨ü€ñ„±ˆ£œÀ¬ªÀœá¬â„¨§‹ŠÇ˜İ‹¸ÊÉ¢‚Äê‘Æ¢ò²¨
ü€ñ„±ˆ£œ¨¬ªÇÑñåí’íûõÍÛ³¿«›³òÀ”È¯ÄœåäÑÅà˜ÖÏ¼°¸½ñôô’‹ëÖ ‘† ò²‘¨ÀœÇ»­×æ¶íÑ÷ÇÑ
äÓ¼ñ”“èÅ…ÅÑıÔÛ÷ÁöæíİÛîíŞÏıàñï¬ºÃúµ˜‡¢ç¥•­êù£õÈ¯ÁœåäÆÑøå·©¬ÔÅé”ŒúÌ½»æ¡…©
¼×—ÌÒŒÙøğ™¯ÄœåôñÜ‘ï­ºÃçïô·»´Û÷»œ˜óô”½×¶µ»Õÿ¾Ö÷³ÃÌ¾ü¥„Ë’ú˜Å…â¸ª¿öØöÇâúÄü¥ú²óû
ƒÔ­ñ”ÏÊœÁıÇ¹ÙÔ ‚³ş»Í½ĞÍûâ¨™»ñçª¶Ï§ÛÑĞ¸Š¦¥şˆÓ£œ¬ª¡«â¹öŸº÷©¾ÈµïÖìÆ‚œıÇ¹ÙÔ
Ş ˆ£æÇƒõÀÀ½¾šÇ½Ÿµ®ÆÑüùç¶÷–æ ÄÑæñ”“Å…úãğè·íÔ‡øÂ­İ‘â……ãŸÉÂÕ¿é¼ëì— ò²¨üÀü³öù×¶
µ½ø ïĞÁôéöˆ–Ö÷ÎÔ£ÅõêÚ…¨É‰£­â”¨§‹ŠÄñ´ääóŞ·øÚ©»ßŒ¸ÊÉ¢‚ú«ÅÑıÉç±“©ñÃœåäÑï•âèÏÜ”
…áÉÄÑÎ–•“àäâ¬â¨§¡‹ŠÇ˜‹¸×ÊÉ¢‚Ä‘Æš¢ò²¨€ñŸ„±ˆ£œ¬ªÀœá¬â¨§é‹Šü€›ÌŞ§×¥„Ëú˜ÅĞ…æïÛ¬éö
ñ¾®¥ÜÒÃ¨š€„‡‘Š€¨Éğ˜©€„ƒ‡‘Š€Éğ˜õ©€„‡Ñ¢Œ‚óş»‹Ö·¤ûß—’®éáì–•˜½í±¦Ùûº”ğÉ÷³¨À÷óÌş
¤¦¯ÖÁœåä„Ñâˆã‘Ç¨¹ÙÔ€¸ÂØÁÄÑÎ–• ˜°–ñ”“Å…¥ˆ£ŒÅœåä„Ñâˆã‘Ç¨¹ÙÔ€¸ÂØÁÄÑÎ–•ˆâÓ¨ş²É°ƒ
†î×áÏûà„Š¨ÄÑÎ–•Ûˆãè·¥ÿ‹ÉŞ±ìÏôÿü¦¿×ÅœåäšÑ·ÄÑÓôÀ¡ò²¨À½¹¸úü÷ÿÓÉÿûĞ·ï›·€­ñÖ„÷Øê
ë„ºÿó•©ÅÈ·§Õ£‘ë»‡ˆ£œ¬ªğº§š‡´è¿²Ç¬êÓ“ ½³“Ô×’Ç§‘Ç¨¹ıü¨ı¥Ú›Š§µß´ìÓĞŞùÕ³Ûıä§âßµûğ
Ñ•’®‰µ¸¸ÔêİŒ£Î°ìü¦âÉ‰£ë£ˆ£œöèÓ½‘úêâ§£úä³—Ç¿˜¶™´ìÇã¨˜”¸êºŠ¸Âé©â¶èÈ§ Õ¾»‚Ú³›ñô”ñ
û„ÓÖŠ£øóëÏî¬ÍÁˆ£Û£ˆ£œ–¶ãŠ…•·èñ°©õ²ºã¨èÉ¨–õ¢ğÚãäñÔÿò¦ØÌÿÍŸşÆú€…¶¿»µ§¥‰Î ğÚ
ÔÇéÙ­øÕˆâ£œæ‘ÇÁıê”²¡ğšË±éÖ÷ŞÈ†¸‘ÂéœğŒÅœ…á´âˆã‘Çª¸¸ÂØÄ‘ÄÎ£°–ñ„ïÓê¯è€×ÍŞ×¥„ËÂí
ïö¶ÅšæïëÂÒÂ¥ø§â¨ˆÀ’Ä‘€¤ˆ£€ÉÇ€…’ €¤Áœ¤È‚¸‚„Ğñ„ ‰—¸šëõµÕà¦³°ÔÆ®å™½÷³€ÁæŸ©ŒÜ
£Êòı‡çÿ³ˆèà€âÈñ©Ä‹ñ„åÇŠ¤ËÙˆ£¬ƒ¸„ÒÜÊÂœá™§Ä‘âÒ–âˆµË ”—²ğÇØ†ñ¤¸”Õ…¸Â²ˆ£Åñ¥¬ÁœÕßè
òˆ¶ÁñÉ¡Ë‡Ú®äĞÕ×´ŞéÜó·¥ó›©Í™‡—·ö§ùßÜÄ‘âÊÒ–¸öÛŠİöí‡æÁ¹¿µÕºœÿâ«í™³ùò…’Ñóñ¼ş‰Ç
¸ß×ªÄ‘âÒ×–Çâ¨¸ü”œÔñô×ªÆÜŸÎå©µÇ·Ä‘âÒ–ÓñÇôïÍÍù÷Öç¼ü¯ºÊõßÿûÁßşÁÂ‚®¾ÅÚîø¥ÊÀçœÚêóµ
Ï»íõ˜ê®õ­Şµß”ìˆ£‹Å¥¬çéı¾Ú›íÁ˜õ©­è¼¼»£ïÎİ´ûíßÁ×ªßœˆ£¥Šï£ †Áâ‚‚ó¨‰² ”¾•õæª–¾
ÇûÁå½£´»Õÿî®¶ó¢Õøè•ªõµ¯šõé¯Éğæ¡©¥­ËÏÛ¿ÙóÚ§øÖçÇöÑÇùñœ©ñÔšÇõ¼ÛœîÄÑ•×š¸Ğ©”çÒîÒ
ÕÄ»íÄ‘²³‹ã¨øß›¿†Ş‰£í”¼ŸºÇÍ±û‡¯øŸ˜ÇÍöëëÖ§Á’¸ŠÜ‡¤âö»â¿¨¹Ôİéæ¢£Ü½™Çıÿ‘á’Ç½í½«
Š¡àäúœíêÇˆƒ§³‚Ñƒ¿†ì¶Æú‹ë¿’»ÇùìÄÄô¬¼¾–ø¸ÂÂçâè÷©Ö—»¶¾¼Û÷ñàÍƒÇñ‚ÇÅ‘ÚØÿÜ¬Ü£¿ÿ‹
ıÙìŒßÇæµÖÇ× Úò ½Ü…ÛØÎÄ—Ñ²Ì‹Ä‘äÄœ¹ÏıŸæ—ŞÈüÊ‰£÷ö«ÅÑßîÃâÅ®‹şˆ£ÿ›‹Å‘ŞŒ¸ò°Çœá™Ä‘»
µâˆË Ü‘ğÇØ†ñä®şñîŠàíö‘Âæù³÷°Øì€£…€€€€€Ô€€À¢şŸßƒß˜Ë
&]
[s0; &]
[s0; The class encapsulates system`-dependent internals of graphical 
output. Whenever you need to paint something in a window, you 
need a Draw object for it. The standard Paint method of the Ctrl 
class takes a Draw`& parameter as well. In that case the underlying 
mechanism passes a Draw which is already initialized for output 
into the respective control, knows about the current clipping, 
resolution etc. In a similar manner you can create your own Draw 
objects to draw onto Images, Drawings (vector metafiles used 
for serialization of graphical operations) or to perform printer 
output. You can also use a Draw to query graphics`-related properties 
of various output devices, like pixel size, resolution, supported 
color model, available fonts etc.&]
[s0; &]
[s0; Although the internals of graphical output are very system`-dependent, 
the Draw class is designed so as to hide most of the OS`-specific 
details and present a unified portable interface regardless of 
the actual target device or object. The downside of this approach 
is that Draw capabilities are somewhat limited to cover most 
frequently used graphical objects and attributes. It is quite 
possible (and in certain situations rather common) that its interface 
lacks some advanced capabilities, although they are supported 
in the target operating system. For these situations the Draw 
object supports also methods which allow you to extend its capabilities 
by utilizing low`-level, system specific code, and accessing 
the output device at the native system level. Of course, heavy 
use of such capabilities makes writing portable code very difficult.&]
[s0;= &]
[s0; The operations supported by the Draw class can be divided into 
several categories:&]
[s0; &]
[s0;i150;O0; initialization and configuration of the output device&]
[s0;i150;O0; querying output device properties&]
[s0;i150;O0; managing colors&]
[s0;i150;O0; managing text styles&]
[s0;i150;O0; controlling current clipping region and drawing offset&]
[s0;i150;O0; drawing basic vector primitives (lines, polygons)&]
[s0;i150;O0; drawing raster primitives&]
[s0;i150;O0; drawing text&]
[s0;i150;O0; accessing [*/ Drawing]`-specific functions&]
[s0;i150;O0; accessing unified virtual output interface&]
[s0;i150;O0; accessing the underlying physical output device interface&]
[s0;i150;O0; accessing device`-secific functions&]
[s0; &]
[s0; Initialization and configuration of the output device&]
[s0;3 &]
[s0;:`:`:Draw`:`:Draw`(`): [* Draw](HDC_[*@3 hdc])&]
[s2; Win32`-specific: initializes the Draw object to output on a Window 
device context (HDC). This is the usual Windows method to paint 
into windows, on memory`-mapped bitmaps and on the printer.&]
[s2; [* Note:] it is seldom necessary to construct the Draw object in 
this way. System`-independent U`+`+ layer hides such system`-specific 
internals within upper`-level abstract objects (PrintDraw, ImageDraw, 
ViewDraw). Remember that, by directly handling device contexts, 
you are deprived of a multitude of U`+`+ internal housekeeping 
chores and checks which ensure that the device context and potentially 
its attributes are properly allocated and destroyed as necessary. 
For a complete set of rules for working with device contexts, 
see Microsoft Windows documentation.&]
[s4; [*C@3 hdc]-|handle to output device context&]
[s0;3 &]
[s0;:`:`:Draw`:`:Draw`(`:`:Draw able`,GC`,XftDraw`*`,const`:`:Vector`<`:`:Rect`>`&`): [* D
raw](Drawable_[*@3 dw], GC_[*@3 gc], XftDraw_`*[*@3 xftdraw], const_Vector<Rect>`&_[*@3 c
lip])&]
[s2; X11`-specific: initializes the draw object to output on a X`-Windows 
drawable using a given graphics context (GC). This is the usual 
X`-Windows method to paint into windows and on memory`-mapped 
bitmaps.&]
[s2; [* Note:] it is seldom necessary to construct the Draw object in 
this way. System`-independent U`+`+ layer hides such system`-specific 
internals within upper`-level abstract objects (ImageDraw, ViewDraw). 
Remember that, by directly handling device contexts, you are 
deprived of a multitude of U`+`+ internal housekeeping chores 
and checks which ensure that the device context and potentially 
its attributes are properly allocated and destroyed as necessary. 
For a complete set of rules for working with device contexts, 
see X Windows documentation.&]
[s4; [*C@3 dw]-|output drawable&]
[s4; [*C@3 gc]-|output graphic context&]
[s4; [*C@3 xftdraw]-|XFT interface object&]
[s4; [*C@3 clip]-|clipping region&]
[s0;3 &]
[s0;:`:`:Draw`:`:Draw`(`:`:Draw able`,GC`,const`:`:Vector`<`:`:Rect`>`&`): [* Draw](Dra
wable_[*@3 dw], GC_[*@3 gc], const_Vector<Rect>`&_[*@3 clip])&]
[s2; X11`-specific: initializes the draw object to output on a X`-Windows 
drawable using a given graphics context (GC). This is the usual 
X`-Windows method to paint into windows and on memory`-mapped 
bitmaps.&]
[s2; [* Note:] it is seldom necessary to construct the Draw object in 
this way. System`-independent U`+`+ layer hides such system`-specific 
internals within upper`-level abstract objects (ImageDraw, ViewDraw). 
Remember that, by directly handling device contexts, you are 
deprived of a multitude of U`+`+ internal housekeeping chores 
and checks which ensure that the device context and potentially 
its attributes are properly allocated and destroyed as necessary. 
For a complete set of rules for working with device contexts, 
see X Windows documentation.&]
[s4; [*C@3 dw]-|output drawable&]
[s4; [*C@3 gc]-|output graphic context&]
[s4; [*C@3 clip]-|clipping region&]
[s0;3 &]
[s0;:`:`:Draw`:`:Draw`(Drawable`,GC`,XftDraw`*`,const`:`:Vector`<`:`:Rect`>`&`): void
_[* Init]()&]
[s2; Initializes internal variables for output on a previously set 
output device.&]
[s2; [* Note:] this is normally not necessary. This function is called 
only from derived classes which need to set the output device 
handle (HDC under Win32, GC under X Windows) manually.&]
[s0;3 &]
[s0;:`:`:Draw`:`:Init`(const`:`:Vector`<`:`:Rect`>`&`,`:`:Point: void_[* Init](const_Ve
ctor<Rect>`&_[*@3 clip], Point_[*@3 offset]_`=_Point([@3 0], [@3 0]))&]
[s2; X Windows`-specific: initializes Draw internals for output on 
a previously set output device. The parameters give clipping 
region and output offset to initialize the clipping stack with.&]
[s4; [*C@3 clip]-|clipping region of the output device (in device coordinates)&]
[s4; [*C@3 offset]-|initial output offset (device coordinates)&]
[s0; &]
[s0; Querying output device properties&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 PaletteMode]()_[@(0.0.255) const]&]
[s2; Checks whether the current output device is palette`-based or 
RGB`-based. Monochrome devices are treated as RGB`-based.&]
[s4; [*/ Return value]-|[/ true] `= device uses palette`-based color management, 
[/ false] `= device pixels contain direct RGB color values.&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 IsMono]()_[@(0.0.255) const]&]
[s2; Check whether the current output device is monochrome.&]
[s4; [*/ Return value]-|[/ true] `= monochrome, [/ false] `= grayscale or 
color device.&]
[s0;3 &]
[s5;K%- [^`:`:Size^ Size]_[@0 GetPagePixels]()_[@(0.0.255) const]&]
[s2; Returns pixel page size. For virtual output devices (like Drawings), 
this is the same as dot page size.&]
[s4; [*/ Return value]-|Pixel width and height of the output page.&]
[s0;3 &]
[s5;K%- [^`:`:Size^ Size]_[@0 GetPageMMs]()_[@(0.0.255) const]&]
[s2; Returns physical output page size in millimeters.&]
[s4; [*/ Return value]-|Output page width and height in millimeters.&]
[s0;3 &]
[s5;K%- [^`:`:Size^ Size]_[@0 GetPixelsPerInch]()_[@(0.0.255) const]&]
[s2; Returns the resolution of the output device.&]
[s4; [*/ Return value]-|Number of pixels horizontally and vertically 
across a squared inch.&]
[s0;3 &]
[s5;K%- [^`:`:Size^ Size]_[@0 GetSheetPixels]()_[@(0.0.255) const]&]
[s2; Returns pixel size of the output page including physical margins. 
This is meaningful only for printers for which the printable 
area is sometimes smaller than the actual paper size. For such 
devices [* GetSheetPixels] returns pixel size of the original (full) 
paper including the margins unsuitable for printing, whereas 
[* GetPagePixels] returns the printable area size (paper size minus 
physically enforced margins).&]
[s4; [*/ Return value]-|Pixel width and height of the physical output 
medium (paper in printer)&]
[s0;3 &]
[s5;K%- [^`:`:Point^ Point]_[@0 GetPageOffset]()_[@(0.0.255) const]&]
[s2; Returns pixel offset of the topleft corner of the printable 
output area from the topleft corner of the physical output medium 
(printer paper). This is meaningful only for printers where the 
printable area is sometimes smaller than the actual paper size 
(see also [* GetSheetPixels]). By subtracting [* GetPageOffset()] 
from a pair of coordinates it is possible to position objects 
absolutely with respect to the paper edges.&]
[s4; [*/ Return value]-|Horizontal and vertical displacement from the 
topleft corner of the physical output medium to the topleft corner 
of the printable area. &]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 Pixels]()_[@(0.0.255) const]&]
[s2; Checks whether the output device coordinates are pixel`-based 
or dot`-based. This is the negation of the [* Dots()] function. 
Window and image draws are pixel`-based, whereas printer and 
Drawing draws are normally dot`-based.&]
[s4; [*/ Return value]-|[/ true] `= device is pixel`-based, [/ false] `= 
device is dot`-based.&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 Dots]()_[@(0.0.255) const]&]
[s2; Checks whether the output device coordinates are pixel`-based 
or dot`-based. This is the negation of the [* Pixels()] function. 
Window and image draws are pixel`-based, whereas printer and 
Drawing draws are normally dot`-based.&]
[s4; [*/ Return value]-|[/ true] `= device is dot`-based, [/ false] `= device 
is pixel`-based.&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 IsPrinter]()_[@(0.0.255) const]&]
[s2; Checks whether the output device is a printer.&]
[s4; [*/ Return value]-|[/ true] `= device is a printer.&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 IsAborted]()_[@(0.0.255) const]&]
[s2; Checks whether the output job has been aborted. This is meaningful 
mainly for printers.&]
[s4; [*/ Return value]-|[/ true] `= job has been aborted.&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 IsBack]()_[@(0.0.255) const]&]
[s2; Checks whether output device supports double`-buffering. For 
devices with double`-buffering it is not necessary (and is usually 
counterproductive) to take measures to prevent flickering as 
the whole output is composed offscreen. Output devices without 
direct video output (like Drawings or Images) are return [/ true] 
(as there is no direct video output, it is not necessary to prevent 
flickering).&]
[s4; [*/ Return value]-|[/ true] `= device is double`-buffered, [/ false] 
`= output goes directly to video&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 IsDrawing]()_[@(0.0.255) const]&]
[s2; Checks whether the output device is a Drawing.&]
[s4; [*/ Return value]-|[/ true] `= device is a Drawing.&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 IsMetaFile]()_[@(0.0.255) const]&]
[s2; Win32`-specific: Checks whether the output device is a Windows 
Metafile.&]
[s4; [*/ Return value]-|[/ true `= ]device is a Windows Enhanced Metafile.&]
[s0; &]
[s0; Managing colors&]
[s0; &]
[s0; Different output devices and their technologies pose natural 
limitations on producing color output. The basic classes of devices 
with respect to their color management are:&]
[s0; &]
[s0;i150;O0; Monochrome devices (like monochrome laser printers or 
certains specialized displays) support no color at all. Every 
pixel of the output device can be black or white.&]
[s0;i150;O0; Palette`-based devices (like old 16`- or 256`-color 
displays) support a fixed set of distinct color slots, called 
a [/ palette]. Colors of the individual slots can be either user`-settable 
or fixed (system`-set). Every pixel of the output device is an 
index into the palette.&]
[s0;i150;O0; RGB`-based devices (HiColor or TrueColor displays), 
in which every pixel of the output device can be set to any of 
the colors displayable by the device. Typically each pixel has 
at least 16 bits comprising of 5`- or 8`-bit subfields for the 
red, green, and blue color component.&]
[s0; &]
[s0; Logical color model used by the Draw class communicates colors 
using device`-independent color values (as represented by the 
[* Color] class). Graphical output functions convert these colors 
on`-the`-fly to physical colors supported by the system. Pixel`- 
and line`-oriented output objects (lines, polylines, ellipses) 
paint the requested objects with the nearest available physical 
color to the requested logical color, whereas area`- and raster`-oriented 
output objects (rectangles, polygons, and images) use dithering 
to approximate logical colors not directly produceable by the 
device.&]
[s0; &]
[s0; Draw supports two ways of using palette`-based output devices:&]
[s0; &]
[s0;i150;O0; [* Automatic palette]: upon initialization Draw sets up 
the system palette to contain a matrix of 6x6x6 RGB triplets 
for all combinations of 6 equidistant intensities of the color 
components, a 16`-level gray scale plus 16 basic system colors. 
This fixed color palette enables the system to closely mimic 
the behaviour of RGB`-based color systems.&]
[s0;i150;O0; [* User palette]: Draw works with the current palette as 
set by the system / user. Nearest match is used for logical color 
mapping.&]
[s0;3 &]
[s5;K%- static [@(0.0.255) bool]_[@0 AutoPalette]()&]
[s2; Checks palette mode of the active output device.&]
[s4; [*/ Return value]-|[* true] `= automatic palette mode, [* false] `= 
user palette mode&]
[s0;3 &]
[s5;K%- static [@(0.0.255) void]_[@0 SetAutoPalette]([@(0.0.255) bool]_[@3 ap])&]
[s2; Turns automatic palette mode on or off.&]
[s4; [*C@3 ap]-|[* true] `= activate automatic palette, [* false] `= activate 
user palette mode&]
[s0;3 &]
[s0;:`:`:Draw`:`:Win32UpdateSColors`(`): void_[* Win32UpdateSColors]()&]
[s2; Updates logical palette of basic system`-dependent colors ([* SLtGray], 
[* SWhite], [* SBlack] etc.).&]
[s0; &]
[s0; Managing text styles&]
[s0;3 &]
[s5;K%- static [@(0.0.255) int]_CALLBACK_[@0 AddFace]([@(0.0.255) const]_[^LOGFONT^ LOGFONT]_
`*[@3 logfont], [@(0.0.255) const]_[^TEXTMETRIC^ TEXTMETRIC]_`*, [^`:`:dword^ dword]_[@3 ty
pe], [^LPARAM^ LPARAM]_[@3 param])&]
[s2; &]
[s4; [*C@3 font]-|&]
[s4; [*C@3 angle]-|&]
[s4; [*C@3 device]-|&]
[s4; [*/ Return value]-|&]
[s0;3 &]
[s5;K%- static [@(0.0.255) void]_[@0 SetStdFont]([^`:`:Font^ Font]_[@3 font])&]
[s2; Sets the font to be used as the standard font (StdFont, Font`::STDFONT).&]
[s4; [*C@3 font]-|new standard font&]
[s0;3 &]
[s5;K%- static [^`:`:Font^ Font]_[@0 GetStdFont]()&]
[s2; Returns the current standard font.&]
[s4; [*/ Return value]-|previously set or system`-default standard font&]
[s0;3 &]
[s5;K%- static [^`:`:Size^ Size]_[@0 GetStdFontSize]()&]
[s2; Returns the letter box width and height of the current standard 
font.&]
[s4; [*/ Return value]-|[/ cx `= GetWidth(), cy `= GetHeight()] of the 
current standard font. When [/ cx `=`= 0], standard font has default 
width.&]
[s0;3 &]
[s5;K%- static [@(0.0.255) int]_[@0 GetStdFontCy]()&]
[s2; Returns letter box width and height of the current standard 
font&]
[s4; [*/ Return value]-|[/ cx `= GetWidth(), cy `= GetHeight()] of the 
current standard font. When [/ cx `=`= 0], standard font has default 
width.&]
[s0;3 &]
[s0;:`:`:Draw`:`:GetFontInfo`(`:`:byte`,`:`:Font: FontInfo_[* GetFontInfo](byte_[*@3 char
set], Font_[*@3 font]_`=_StdFont())&]
[s2; Returns font information object describing given font and charset.&]
[s4; [*C@3 charset]-|character set to use (from the CHARSET`_xxx enumeration)&]
[s4; [*C@3 font]-|font to retrieve information for.&]
[s4; [*/ Return value]-|FontInfo structure describing metrics of system`-allocated 
font for the given font object.&]
[s0;3 &]
[s0;:`:`:Draw`:`:GetFontInfo`(`:`:Font: FontInfo_[* GetFontInfo](Font_[*@3 font]_`=_StdFo
nt())&]
[s2; Returns font information object describing given font.&]
[s4; [*C@3 font]-|font to retrieve information for.&]
[s4; [*/ Return value]-|FontInfo structure describing metrics of system`-allocated 
font for the given Font object.&]
[s0;3 &]
[s0;:`:`:Draw`:`:GetFontInfoW`(`:`:Font: FontInfo_[* GetFontInfoW](Font_[*@3 font]_`=_Std
Font())&]
[s2; Returns Unicode font information for a given font.&]
[s4; [*C@3 font]-|font to retrieve information for.&]
[s4; [*/ Return value]-|FontInfo structure describing Unicode metrics 
of system`-allocated font for the given Font object.&]
[s0; &]
[s0; Controlling current clipping region and drawing offset&]
[s0; Sometimes it is necessary or at least handy to move the logical 
coordinate origin and limit output clipping for a part of the 
drawing process. For this reason, coordinate origin displacement 
together with current clipping region is kept as a stack in the 
Draw object. Certain function push a new offset / clipping entry 
to the stack, other functions manipulate the current top of stack. 
Actual coordinate origin and clipping in effect while drawing 
corresponds to the entry on top of the stack. At the beginning 
the coordinate origin is usually set to topleft corner of the 
output medium and the clipping box encapsulates all available 
output area (or, like in case of [* Ctrl`::Paint], the current `"dirty`" 
area that needs to be repainted in a window).&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 Begin]()&]
[s2; Duplicates the current entry on the top of the coordinate / 
clipping stack. This effectively doesn`'t change the current 
coordinate / clipping setting but creates a new entry which can 
be further manipulated by other methods like [* IntersectClip] 
or [* ExcludeClip].&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 End]()&]
[s2; Discards one coordinate / clipping entry from top of the stack.&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 Offset]([^`:`:Point^ Point]_[@3 p])&]
[s2; Creates a new coordinate / clipping entry on top of the stack 
equal to the previous entry with coordinate origin shifted by 
[* p] pixels.&]
[s4; [*C@3 p]-|number of pixels to add to coordinate origin ([/ p.x_>_0] 
`= right, [/ p.x_<_0] `= left, [/ p.y_>_0] `= down, [/ p.y_<_0] `= 
up).&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 Offset]([@(0.0.255) int]_[@3 x], [@(0.0.255) int]_[@3 y])&]
[s2; Creates a new coordinate / clipping entry on top of the stack 
equal to the previous entry with coordinate origin shifted by 
[/ (x, y)] pixels.&]
[s4; [*C@3 x]-|number of pixels to add to horizontal coordinate origin 
([/ x_>_0] `= right, [/ x_<_0] `= left).&]
[s4; [*C@3 y]-|number of pixels to add to vertical coordinate origin 
([/ y_>_0] `= down, [/ y_<_0] `= up).&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 Clip]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 r])&]
[s2; Creates a new coordinate / clipping entry on top of the stack 
with coordinate origin equal to the previous value and clipping 
equal to the intersection of the previous clipping region with 
the rectangle [/ r].&]
[s4; [*C@3 r]-|rectangle to intersect with current clipping region (relative 
to the current coordinate origin)&]
[s4; [*/ Return value]-|[/ true] `= the new clipping region is non`-empty, 
[/ false] `= the new clipping is empty (it is not necessary to 
draw anything as nothing is visible)&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 Clip]([@(0.0.255) int]_[@3 x], [@(0.0.255) int]_[@3 y], 
[@(0.0.255) int]_[@3 cx], [@(0.0.255) int]_[@3 cy])&]
[s2; Creates a new coordinate / clipping entry on top of the stack 
with coordinate origin equal to the previous value and clipping 
equal to the intersection of the previous clipping region with 
the rectangle given by its topleft origin (relative to the current 
coordinate origin) [/ (x, y)], width [/ cx] and height [/ cy].&]
[s2; &]
[s4; [*C@3 x]-|left side of rectangle to intersect with current clipping 
region (relative to current coordinate origin)&]
[s4; [*C@3 y]-|top side of rectangle to intersect with current clipping 
region (relative to current coordinate origin)&]
[s4; [*C@3 cx]-|rectangle width&]
[s4; [*C@3 cy]-|rectangle height&]
[s4; [*/ Return value]-|[/ true] `= the new clipping region is non`-empty, 
[/ false] `= the new clipping is empty (it is not necessary to 
draw anything as nothing is visible)&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 Clipoff]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 r])&]
[s2; Creates a new coordinate / clipping entry on top of the stack 
with clipping equal to the intersection of the previous clipping 
region with the rectangle [/ r] and with the coordinate origin 
shifted by [/ r.TopLeft()] pixels. For further drawing operations 
the current pixel [/ r.TopLeft()] will correspond to [/ (0,_0) ]and 
[/ r.BottomRight()] to [/ (r.Width(),_r.Height())].&]
[s4; [*C@3 r]-|rectangle to intersect with current clipping region (relative 
to current coordinate origin); [/ r.left] is added to the horizontal 
coordinate origin and [/ r.top] to the vertical coordinate origin.&]
[s4; [*/ Return value]-|[/ true] `= the new clipping region is non`-empty, 
[/ false] `= the new clipping is empty (it is not necessary to 
draw anything as nothing is visible)&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 Clipoff]([@(0.0.255) int]_[@3 x], [@(0.0.255) int]_[@3 y], 
[@(0.0.255) int]_[@3 cx], [@(0.0.255) int]_[@3 cy])&]
[s2; Creates a new coordinate / clipping entry on top of the stack 
with clipping equal to the intersection of the previous clipping 
region with the rectangle [/ r] and with the coordinate origin 
shifted by [/ (x,_y)] pixels. For further drawing operations the 
current pixel [/ (x, y)] will correspond to [/ (0,_0)].&]
[s2; &]
[s4; [*C@3 x]-|left side of rectangle to intersect with current clipping 
region (relative to current coordinate origin) and the amount 
to add to horizontal coordinate origin&]
[s4; [*C@3 y]-|top side of rectangle to intersect with current clipping 
region (relative to current coordinate origin) and the amount 
to add to vertical coordinate origin&]
[s4; [*C@3 cx]-|rectangle width&]
[s4; [*C@3 cy]-|rectangle height&]
[s4; [*/ Return value]-|[/ true] `= the new clipping region is non`-empty, 
[/ false] `= the new clipping is empty (it is not necessary to 
draw anything as nothing is visible)&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 ExcludeClip]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 r])&]
[s2; Updates the current clipping region on top of the coordinate 
/ clipping stack by subtracting the rectangle [/ r] from the current 
clipping region.&]
[s4; [*C@3 r]-|rectangle to subtract from current clipping region (relative 
to current coordinate origin)&]
[s4; [*/ Return value]-|[/ true] `= the new clipping region is non`-empty, 
[/ false] `= the new clipping is empty (it is not necessary to 
draw anything as nothing is visible)&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 ExcludeClip]([@(0.0.255) int]_[@3 x], [@(0.0.255) int]_[@3 y], 
[@(0.0.255) int]_[@3 cx], [@(0.0.255) int]_[@3 cy])&]
[s2; Updates the current clipping region on top of the coordinate 
/ clipping stack by subtracting the rectangle [/ RectC(x,_y,_cx,_cy)] 
from the current clipping region.&]
[s4; [*C@3 x]-|left side of rectangle to subtract from current clipping 
region (relative to current coordinate origin)&]
[s4; [*C@3 y]-|top side of rectangle to subtract from current clipping 
region (relative to current coordinate origin)&]
[s4; [*C@3 cx]-|rectangle width&]
[s4; [*C@3 cy]-|rectangle height&]
[s4; [*/ Return value]-|[/ true] `= the new clipping region is non`-empty, 
[/ false] `= the new clipping is empty (it is not necessary to 
draw anything as nothing is visible)&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 IntersectClip]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 r])&]
[s2; Updates the current clipping region on top of the coordinate 
/ clipping stack by intersecting the rectangle [/ r] with the current 
clipping region.&]
[s4; [*C@3 r]-|rectangle to intersect with current clipping region (relative 
to current coordinate origin)&]
[s4; [*/ Return value]-|[/ true] `= the new clipping region is non`-empty, 
[/ false] `= the new clipping is empty (it is not necessary to 
draw anything as nothing is visible)&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 IntersectClip]([@(0.0.255) int]_[@3 x], [@(0.0.255) int]_[@3 y], 
[@(0.0.255) int]_[@3 cx], [@(0.0.255) int]_[@3 cy])&]
[s2; Updates the current clipping region on top of the coordinate 
/ clipping stack by intersecting the rectangle [/ RectC(x,_y,_cx,_cy)] 
with the current clipping region.&]
[s4; [*C@3 x]-|left side of rectangle to intersect with current clipping 
region (relative to current coordinate origin)&]
[s4; [*C@3 y]-|top side of rectangle to intersect with current clipping 
region (relative to current coordinate origin)&]
[s4; [*C@3 cx]-|rectangle width&]
[s4; [*C@3 cy]-|rectangle height&]
[s4; [*/ Return value]-|[/ true] `= the new clipping region is non`-empty, 
[/ false] `= the new clipping is empty (it is not necessary to 
draw anything as nothing is visible)&]
[s0;3 &]
[s5;K%- [^`:`:Rect^ Rect]_[@0 GetClip]()_[@(0.0.255) const]&]
[s2; Returns the smallest rectangle fully covering the current clipping 
region. The value can be used to limit output to the visible 
area. Take care not to mix the current clipping region with the 
output rectangle as the clipping region can be just a subset 
of this output rectangle (like in case of [* Ctrl`::Paint] when 
a part of the window is obscured).&]
[s4; [*/ Return value]-|Smallest rectangle fully covering the current 
clipping region (relative to current coordinate origin)&]
[s0;3 &]
[s5;K%- [^`:`:Point^ Point]_[@0 GetOffset]()_[@(0.0.255) const]&]
[s2; Returns the current coordinate origin. This is naturally in 
absolute coordinates relative to the topleft corner of the output 
medium.&]
[s4; [*/ Return value]-|Current coordinate origin (relative to topleft 
corner of the output medium)&]
[s0;3 &]
[s5;K%- [@(0.0.255) int]_[@0 GetCloffLevel]()_[@(0.0.255) const]&]
[s2; Returns the number of entries on the coordinate / clipping stack. 
This is normally used for self`-consistency check where the drawing 
routine ASSERTs that after drawing something the stack depth 
is the same as it was before (to check whether there is not a 
stack `'leak`' when the drawing routine forgets to [* End] some 
coordinate / clipping entries it has previously pushed on the 
stack).&]
[s4; [*/ Return value]-|number of entries on the coordinate / clipping 
stack&]
[s0;3 &]
[s5;K%- [^`:`:Point^ Point]_[@0 LPtoDP]([^`:`:Point^ Point]_[@3 p])_[@(0.0.255) const]&]
[s2; Converts a point from coordinates relative to current coordinate 
origin to absolute coordinates from the topleft corner of the 
output medium. This effectively adds the current coordinate origin 
to the given point [/ p].&]
[s4; [*C@3 p]-|Point to convert (relative to current coordinate origin)&]
[s4; [*/ Return value]-|Absolute coordinates of point [/ p] from the topleft 
corner of the output medium&]
[s0;3 &]
[s5;K%- [^`:`:Point^ Point]_[@0 DPtoLP]([^`:`:Point^ Point]_[@3 p])_[@(0.0.255) const]&]
[s2; Converts a point from the absolute coordinates (from the topleft 
corner of the output medium) to coordinates relative to current 
coordinate origin. This effectively subtracts the current coordinate 
origin from the point [/ p].&]
[s4; [*C@3 p]-|Point to convert (absolute coordinates)&]
[s4; [*/ Return value]-|Relative coordinates of [/ p] with respect to 
the current coordinate origin&]
[s0;3 &]
[s5;K%- [^`:`:Rect^ Rect]_[@0 LPtoDP]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 r])_[@(0.0.255) c
onst]&]
[s2; Converts a rectangle from coordinates relative to current coordinate 
origin to absolute coordinates from the topleft corner of the 
output medium. This effectively offsets the rectangle [/ r] by 
the amount given by the current coordinate origin.&]
[s4; [*C@3 r]-|Rectangle to convert (relative to current coordinate 
origin)&]
[s4; [*/ Return value]-|Rectangle [/ r] in absolute coordinates with respect 
to the topleft corner of the output medium&]
[s0;3 &]
[s5;K%- [^`:`:Rect^ Rect]_[@0 DPtoLP]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 r])_[@(0.0.255) c
onst]&]
[s2; Converts a rectangle from the absolute coordinates (with respect 
to the topleft corner of the output medium) to coordinates relative 
to current coordinate origin. This effectively offsets the rectangle 
[/ r] by the negative value of the current coordinate origin.&]
[s4; [*C@3 r]-|Rectangle to convert (absolute coordinates)&]
[s4; [*/ Return value]-|Rectangle [/ r] in coordinates relative to current 
coordinate origin&]
[s0; &]
[s0; Drawing basic vector primitives (lines, polygons)&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 DrawRect]([@(0.0.255) int]_[@3 x], [@(0.0.255) int]_[@3 y], 
[@(0.0.255) int]_[@3 cx], [@(0.0.255) int]_[@3 cy], [^`:`:Color^ Color]_[@3 color])&]
[s2; Fills rectangle [/ RectC(x,_y,_cx,_cy)] with the color [/ color]. 
On palette`-based devices dithering is sometimes used for approximation 
when the given color doesn`'t closely correnspond to one of the 
available colors (see [* Managing colors]).&]
[s4; [*C@3 x]-|left side to rectangle to fill (relative to coordinate 
origin)&]
[s4; [*C@3 y]-|top side of rectangle to fill&]
[s4; [*C@3 cx]-|rectangle width&]
[s4; [*C@3 cy]-|rectangle height&]
[s4; [*C@3 color]-|color used for filling. When [/ color `=`= Null], nothing 
is done. The special color [* InvertColor()] can be used to logically 
invert all pixel bits within the given area. This has the effect 
of changing white to black and vice versa and changing color 
hues to their complements. Note, however, that due to [/ gamma]`-correction, 
the output image is not a photometrical complement of the original 
image. &]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 DrawRect]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 rect], 
[^`:`:Color^ Color]_[@3 color])&]
[s2; Fills rectangle [/ rect] with the color [/ color]. On palette`-based 
devices dithering is sometimes used for approximation when the 
given color doesn`'t closely correnspond to one of the available 
colors (see [* Managing colors]).&]
[s4; [*C@3 rect]-|area to fill (relative to coordinate origin)&]
[s4; [*C@3 color]-|color used for filling. When [/ color `=`= Null], nothing 
is done. The special color [* InvertColor()] can be used to logically 
invert all pixel bits within the given area.&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 DrawLine]([@(0.0.255) int]_[@3 x1], [@(0.0.255) int]_[@3 y1], 
[@(0.0.255) int]_[@3 x2], [@(0.0.255) int]_[@3 y2], [@(0.0.255) int]_[@3 width]_`=_[@3 0], 
[^`:`:Color^ Color]_[@3 color]_`=_DefaultInk)&]
[s2; Draws a line from the point [/ (x1,_y1)] to [/ (x2,_y2)] with color 
[/ color]. When [/ width] is positive, solid line [/ width] pixels 
wide is drawn. When [/ width] is negative, function draws a dashed 
line 1 pixel wide. [/ width] is then one of the [/ PEN`_...] enumeration 
constants defining the desired line pattern. The fact that the 
function doesn`'t support wide dashed lines is a sad limitation 
of the older Win32 GDI which under Windows 95, 98 and ME doesn`'t 
support this. When wide dashed lines are needed, it is necessary 
to generate the segments manually and split the line patterns 
into individual line segments or into polygonal patches (depending 
on the precision requirements and time issues in given context). 
Under Win32 GDI the point [/ (x1,_y1)] is not drawn.&]
[s4; [*C@3 x1, y1]-|line beginning (relative to current coordinate origin)&]
[s4; [*C@3 x2, y2]-|line end&]
[s4; [*C@3 width]-|line width or one of the [/ PEN`_] constants for dashed 
lines&]
[s4; [*C@3 color]-|line color. When [/ color `=`= Null], nothing is drawn. 
On palette`-based devices the nearest palette color is used (no 
dithering is made).&]
[s0; &]
[s0;3 &]
[s0;:`:`:Draw`:`:enum`{ BEGIN`, OFFSET`, CLIP`, CLIPOFF`, EXCLUDECLIP`, INTERSECTCLIP`, END`, DRAWRECT`, DRAWIMAGE`, DRAWMONOIMAGE`, DRAWDRAWING`, DRAWLINE`, DRAWELLIPSE`, DRAWTEXT`, DRAWARC`, DRAWPOLYPOLYLINE`}: [* e
num `{ PEN`_NULL, PEN`_SOLID, PEN`_DASH, PEN`_DOT, PEN`_DASHDOT, 
PEN`_DASHDOTDOT `}]&]
[s2; &]
[s4; [%-*C@3 PEN`_NULL]-|empty pen (nothing is drawn)&]
[s4; [%-*C@3 PEN`_SOLID]-|solid pen&]
[s4; [%-*C@3 PEN`_DASH]-|dashed pen `- `- `-&]
[s4; [%-*C@3 PEN`_DOT]-|dotted pen (dashes are shorter) . . .&]
[s4; [%-*C@3 PEN`_DASHDOT]-|dash `- dot `- dash `- dot pattern&]
[s4; [%-*C@3 PEN`_DASHDOTDOT]-|dash `- dot `- dot `- dash `- dot `- 
dot pattern&]
[s0; &]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 DrawLine]([^`:`:Point^ Point]_[@3 p1], [^`:`:Point^ Point]_[@3 p2],
 [@(0.0.255) int]_[@3 width]_`=_[@3 0], [^`:`:Color^ Color]_[@3 color]_`=_DefaultInk)&]
[s2; Draws a line from the point [/ p1] to [/ p2] with color [/ color]. 
[/ width] gives line width (positive) or dash pattern (negative). 
Under Win32 GDI the point [/ (x1,_y1)] is not drawn.&]
[s2; &]
[s4; [*C@3 p1]-|line beginning (relative to coordinate origin)&]
[s4; [*C@3 p2]-|line end&]
[s4; [*C@3 width]-|line width or dash pattern&]
[s4; [*C@3 color]-|line color&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 DrawEllipse]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 r], 
[^`:`:Color^ Color]_[@3 color]_`=_DefaultInk, [@(0.0.255) int]_[@3 pen]_`=_Null, 
[^`:`:Color^ Color]_[@3 pencolor]_`=_DefaultInk)&]
[s2; Draws the largest ellipse with both axes parallel to coordinate 
axes fully within rectangle [/ r], i.e. with center point at [/ r.CenterPoint()], 
semi major axis and semi minor axis equal to [/ r.Width() / 2] 
and [/ r.Height() / 2].&]
[s4; [*C@3 r]-|ellipse`'s bounding rectangle&]
[s4; [*C@3 color]-|color to fill the ellipse inside with ([/ Null] `= 
no filling)&]
[s4; [*C@3 pen]-|pen width / dash style to used for drawing the ellipse 
circumference&]
[s4; [*C@3 pencolor]-|pen color for drawing the ellipse circumference 
([/ Null] `= circumference is not drawn)&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 DrawEllipse]([@(0.0.255) int]_[@3 x], [@(0.0.255) int]_[@3 y], 
[@(0.0.255) int]_[@3 cx], [@(0.0.255) int]_[@3 cy], [^`:`:Color^ Color]_[@3 color]_`=_Default
Ink, [@(0.0.255) int]_[@3 pen]_`=_Null, [^`:`:Color^ Color]_[@3 pencolor]_`=_DefaultInk)&]
[s2; Draws the largest ellipse with both axes parallel to coordinate 
axes fully within rectangle [/ RectC(x, y, cx, cy)], i.e. with 
center point at [/ x_`+_cx_/_2] and [/ y_`+_cy_/_2], semi major axis 
and semi minor axis equal to [/ cx / 2] and [/ cy / 2].&]
[s2; &]
[s4; [*C@3 x]-|left side of ellipse`'s bounding rectangle&]
[s4; [*C@3 y]-|top side of ellipse`'s bounding rectangle&]
[s4; [*C@3 cx]-|rectangle width&]
[s4; [*C@3 cy]-|rectangle height&]
[s4; [*C@3 color]-|color to fill ellipse inside with ([/ Null] `= interior 
is not filled)&]
[s4; [*C@3 pen]-|pen width / dash style for drawing ellipse circumference&]
[s4; [*C@3 pencolor]-|pen color for drawing ellipse circumference ([/ Null] 
`= not drawn)&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 DrawArc]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 rc], 
[^`:`:Point^ Point]_[@3 start], [^`:`:Point^ Point]_[@3 end], [@(0.0.255) int]_[@3 width]_`=_
[@3 0], [^`:`:Color^ Color]_[@3 color]_`=_DefaultInk)&]
[s2; Draws elliptic arc corresponding to the largest ellipse fully 
within the rectangle [/ rc] and running counterclockwise from the 
direction corresponding to the line connecting the centre of 
the ellipse ([/ rc.CenterPoint()]) with the point [/ start] and ending 
at direction of the point [/ end] from the ellipse centre. When 
[/ start `=`= end], the full ellipse is drawn.&]
[s4; [*C@3 rc]-|ellipse`'s bounding rectangle&]
[s4; [*C@3 start]-|direction at which to start the arc&]
[s4; [*C@3 end]-|direction of arc end (from the ellipsec centre)&]
[s4; [*C@3 width]-|pen width or dash style&]
[s4; [*C@3 color]-|color to used for drawing. On palette`-based devices 
the nearest palette color is used (no dithering).&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 DrawPolyPolyline]([@(0.0.255) const]_[^`:`:Point^ Point]_`*[@3 ve
rtices], [@(0.0.255) int]_[@3 vertex`_count], [@(0.0.255) const]_[@(0.0.255) int]_`*[@3 cou
nts], [@(0.0.255) int]_[@3 count`_count], [@(0.0.255) int]_[@3 width]_`=_[@3 0], 
[^`:`:Color^ Color]_[@3 color]_`=_DefaultInk, [^`:`:Color^ Color]_[@3 doxor]_`=_Null)&]
[s2; Draws a series of polylines. Polyline vertices are kept in the 
array [/ vertices]. The parameter [/ vertext`_count] gives the total 
number of vertices of all polylines in the array. The array [/ counts] 
gives numbers of points defining the individual polylines and 
[/ count`_count] gives number of entries in this array (i.e. the 
number of connected polylines). The first polyline comprises 
vertices [/ vertices`[0`], vertices`[1`]] ... [/ vertices`[counts`[0`] 
`- 1`]], the second polyline [/ vertices`[counts`[0`]`], vertices`[counts`[0`] 
`+ 1`] ... vertices`[counts`[0`] `+ counts`[1`] `- 1`]], etc.&]
[s4; [*C@3 vertices]-|array of polyline vertices (relative to coordinate 
origin)&]
[s4; [*C@3 vertex`_count]-|total number of vertices of all polylines&]
[s4; [*C@3 counts]-|array of polyline vertex counts&]
[s4; [*C@3 count`_count]-|number of entries in the [/ counts] array, i.e. 
the number of polylines&]
[s4; [*C@3 width]-|pen width or dash style.&]
[s4; [*C@3 color]-|polyline color.&]
[s4; [*C@3 doxor]-|used to draw a xor`'ed polyline set. Useful for drag 
`& drop animations where it is needed to draw and undraw the 
rubber rectangle or line repeatedly without having to repaint 
the whole display image. When set to non`-[/ Null] value, it gives 
the `'background`' color on which polyline pixels will have color 
[/ color] after xoring.&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 DrawPolyPolyline]([@(0.0.255) const]_[^`:`:Vector^ Vector]<[^`:`:Point^ P
oint]>`&_[@3 vertices], [@(0.0.255) const]_[^`:`:Vector^ Vector]<[^int^ int]>`&_[@3 counts],
 [^int^ int]_[@3 width]_`=_[@3 0], [^`:`:Color^ Color]_[@3 color]_`=_DefaultInk, 
[^`:`:Color^ Color]_[@3 doxor]_`=_Null)&]
[s2; Draws a series of polylines. Polyline vertices are kept in the 
array [/ vertices]. The array [/ counts] gives numbers of points 
defining the individual polylines (i.e. the number of connected 
polylines is equal to [/ counts.GetCount()]). The first polyline 
comprises vertices [/ vertices`[0`], vertices`[1`]] ... [/ vertices`[counts`[0`] 
`- 1`]], the second polyline [/ vertices`[counts`[0`]`], vertices`[counts`[0`] 
`+ 1`] ... vertices`[counts`[0`] `+ counts`[1`] `- 1`]], etc.&]
[s2; &]
[s4; [*C@3 vertices]-|vertices of all polylines to draw&]
[s4; [*C@3 counts]-|vertex counts in individual polyline segments&]
[s4; [*C@3 width]-|pen width / dash style&]
[s4; [*C@3 color]-|polyline color&]
[s4; [*C@3 doxor]-|background value for xor`'ed drawing ([/ Null] `= draw 
normally)&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 DrawPolyline]([@(0.0.255) const]_[^`:`:Point^ Point]_`*[@3 vertic
es], [@(0.0.255) int]_[@3 count], [@(0.0.255) int]_[@3 width]_`=_[@3 0], 
[^`:`:Color^ Color]_[@3 color]_`=_DefaultInk, [^`:`:Color^ Color]_[@3 doxor]_`=_Null)&]
[s2; Draws a single polyline connecting all [/ count] [/ vertices].&]
[s4; [*C@3 vertices]-|Polyline vertices&]
[s4; [*C@3 count]-|number of vertices&]
[s4; [*C@3 width]-|pen width / dash style&]
[s4; [*C@3 color]-|polyline color&]
[s4; [*C@3 doxor]-|background value for xor`'ed drawing ([/ Null] `= draw 
normally)&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 DrawPolyline]([@(0.0.255) const]_[^`:`:Vector^ Vector]<[^`:`:Point^ P
oint]>`&_[@3 vertices], [@(0.0.255) int]_[@3 width]_`=_[@3 0], [^`:`:Color^ Color]_[@3 color]_
`=_DefaultInk, [^`:`:Color^ Color]_[@3 doxor]_`=_Null)&]
[s2; Draws a single polyline connecting all [/ vertices].&]
[s4; [*C@3 vertices]-|polyline vertices&]
[s4; [*C@3 width]-|pen width / dash style&]
[s4; [*C@3 color]-|polyline color&]
[s4; [*C@3 doxor]-|background value for xor`'ed drawing ([/ Null] `= draw 
normally)&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 DrawPolyPolyPolygon]([@(0.0.255) const]_[^`:`:Point^ Point]_`*[@3 v
ertices], [@(0.0.255) int]_[@3 vertex`_count], [@(0.0.255) const]_[@(0.0.255) int]_`*[@3 su
bpolygon`_counts], [@(0.0.255) int]_[@3 subpolygon`_count`_count], 
[@(0.0.255) const]_[@(0.0.255) int]_`*[@3 disjunct`_polygon`_counts], 
[@(0.0.255) int]_[@3 disjunct`_polygon`_count`_count], [^`:`:Color^ Color]_[@3 color]_`=_
DefaultInk, [@(0.0.255) int]_[@3 width]_`=_[@3 0], [^`:`:Color^ Color]_[@3 outline]_`=_Null
, [^`:`:Image^ Image]_[@3 image]_`=_Null, [^`:`:Color^ Color]_[@3 doxor]_`=_Null)&]
[s2; Draws a series of complex polygons (i.e. polygons which may 
contain holes). The [/ vertices] array holds all polygon defining 
vertices. The array is divided into sections corresponding to 
the whole complex polygons (parameters [/ disjunct`_polygon`_counts] 
and [/ disjunct`_polygon`_count`_count]) and these sections are 
further divided into the individual polygons defining one complex 
polygon (i.e. outer boundary and holes). Numbers of vertices 
in the individual polygons are held in the array [/ subpolygon`_counts] 
(total number of simple polygons `= [/ subpolygon`_count`_count]).&]
[s4; [*C@3 vertices]-|all polygon vertices&]
[s4; [*C@3 vertex`_count]-|number of polygon vertices&]
[s4; [*C@3 subpolygon`_counts]-|vertex counts in individual simple polygons&]
[s4; [*C@3 subpolygon`_count`_count]-|number of entries in [/ subpolygon`_counts]&]
[s4; [*C@3 disjunct`_polygon`_counts]-|vertex counts of the whole complex 
polygons&]
[s4; [*C@3 disjunct`_polygon`_count`_count]-|number of [/ disjunct`_polygon`_counts]&]
[s4; [*C@3 color]-|polygon fill color ([/ Null] `= no fill)&]
[s4; [*C@3 width]-|pen width / dash style to draw polygon boundary with&]
[s4; [*C@3 outline]-|pen color for drawing polygon boundary ([/ Null] 
`= no boundary)&]
[s4; [*C@3 image]-|pattern for filling polygon interior. Due to Win32 
GDI limitations [/ image] must be 8 pixels wide and high.&]
[s4; [*C@3 doxor]-|Background color for xor`'ed drawing.&]
[s0; &]
[s0; Drawing raster primitives&]
[s0; &]
[s5;K:`:`:Draw`:`:DrawImage`(int`,int`,int`,int`,const`:`:Image`&`,const`:`:Rect`&`):%- [@(0.0.255) v
oid]_[@0 DrawImage]([@(0.0.255) int]_[@3 x], [@(0.0.255) int]_[@3 y], [@(0.0.255) int]_[@3 cx],
 [@(0.0.255) int]_[@3 cy], [@(0.0.255) const]_[^`:`:Image^ Image]`&_[@3 img], 
[@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 src])&]
[s5;K:`:`:Draw`:`:DrawImage`(int`,int`,int`,int`,const`:`:Image`&`):%- [@(0.0.255) void
]_[@0 DrawImage]([@(0.0.255) int]_[@3 x], [@(0.0.255) int]_[@3 y], [@(0.0.255) int]_[@3 cx], 
[@(0.0.255) int]_[@3 cy], [@(0.0.255) const]_[^`:`:Image^ Image]`&_[@3 img])&]
[s5;K:`:`:Draw`:`:DrawImage`(int`,int`,int`,int`,const`:`:Image`&`,const`:`:Rect`&`,`:`:Color`):%- [@(0.0.255) v
oid]_[@0 DrawImage]([@(0.0.255) int]_[@3 x], [@(0.0.255) int]_[@3 y], [@(0.0.255) int]_[@3 cx],
 [@(0.0.255) int]_[@3 cy], [@(0.0.255) const]_[^`:`:Image^ Image]`&_[@3 img], 
[@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 src], [^`:`:Color^ Color]_[@3 color])&]
[s5;K:`:`:Draw`:`:DrawImage`(int`,int`,int`,int`,const`:`:Image`&`,`:`:Color`):%- [@(0.0.255) v
oid]_[@0 DrawImage]([@(0.0.255) int]_[@3 x], [@(0.0.255) int]_[@3 y], [@(0.0.255) int]_[@3 cx],
 [@(0.0.255) int]_[@3 cy], [@(0.0.255) const]_[^`:`:Image^ Image]`&_[@3 img], 
[^`:`:Color^ Color]_[@3 color])&]
[s5;K:`:`:Draw`:`:DrawImage`(const`:`:Rect`&`,const`:`:Image`&`,const`:`:Rect`&`):%- [@(0.0.255) v
oid]_[@0 DrawImage]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 r], [@(0.0.255) const]_[^`:`:Image^ I
mage]`&_[@3 img], [@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 src])&]
[s5;K:`:`:Draw`:`:DrawImage`(const`:`:Rect`&`,const`:`:Image`&`):%- [@(0.0.255) void]_[@0 D
rawImage]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 r], [@(0.0.255) const]_[^`:`:Image^ Im
age]`&_[@3 img])&]
[s5;K:`:`:Draw`:`:DrawImage`(const`:`:Rect`&`,const`:`:Image`&`,const`:`:Rect`&`,`:`:Color`):%- [@(0.0.255) v
oid]_[@0 DrawImage]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 r], [@(0.0.255) const]_[^`:`:Image^ I
mage]`&_[@3 img], [@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 src], [^`:`:Color^ Color]_[@3 co
lor])&]
[s5;K:`:`:Draw`:`:DrawImage`(const`:`:Rect`&`,const`:`:Image`&`,`:`:Color`):%- [@(0.0.255) v
oid]_[@0 DrawImage]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 r], [@(0.0.255) const]_[^`:`:Image^ I
mage]`&_[@3 img], [^`:`:Color^ Color]_[@3 color])&]
[s5;K:`:`:Draw`:`:DrawImage`(int`,int`,const`:`:Image`&`,const`:`:Rect`&`):%- [@(0.0.255) v
oid]_[@0 DrawImage]([@(0.0.255) int]_[@3 x], [@(0.0.255) int]_[@3 y], [@(0.0.255) const]_[^`:`:Image^ I
mage]`&_[@3 img], [@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 src])&]
[s5;K:`:`:Draw`:`:DrawImage`(int`,int`,const`:`:Image`&`):%- [@(0.0.255) void]_[@0 DrawIm
age]([@(0.0.255) int]_[@3 x], [@(0.0.255) int]_[@3 y], [@(0.0.255) const]_[^`:`:Image^ Image]`&
_[@3 img])&]
[s5;K:`:`:Draw`:`:DrawImage`(int`,int`,const`:`:Image`&`,const`:`:Rect`&`,`:`:Color`):%- [@(0.0.255) v
oid]_[@0 DrawImage]([@(0.0.255) int]_[@3 x], [@(0.0.255) int]_[@3 y], [@(0.0.255) const]_[^`:`:Image^ I
mage]`&_[@3 img], [@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 src], [^`:`:Color^ Color]_[@3 co
lor])&]
[s5;K:`:`:Draw`:`:DrawImage`(int`,int`,const`:`:Image`&`,`:`:Color`):%- [@(0.0.255) voi
d]_[@0 DrawImage]([@(0.0.255) int]_[@3 x], [@(0.0.255) int]_[@3 y], [@(0.0.255) const]_[^`:`:Image^ I
mage]`&_[@3 img], [^`:`:Color^ Color]_[@3 color])&]
[s2; Draws an Image at specified position. If the position specifies 
dimension ([%-*@3 cx][%-@(64) , ][%-*@3 cy] or is defined using  Rect 
[%-@3 r], Image is rescaled. If [%-*@3 color] is provided, only Image 
alpha channel is used and painted with the specified color. [%-*@3 src] 
can be used specify only a portion of the source Image to be 
painted.&]
[s0;:`:`:Draw`:`:DrawImage`(const`:`:Rect`&`,const`:`:Image`&`,const`:`:Rect`&`,int`):  
&]
[s0;3 &]
[s0;:`:`:Draw`:`:GetTextSize`(const`:`:wchar`*`,`:`:Font: Size_[* GetTextSize](const_wc
har_`*[*@3 text], Font_[*@3 font]_`=_StdFont(), int_[*@3 n]_`=_`-[@3 1])&]
[s2; Measures width and height of a Unicode text (as when painted 
using given font).&]
[s4; [*C@3 text]-|Unicode text to measure&]
[s4; [*C@3 font]-|font to use for the metrics measurements&]
[s4; [*C@3 n]-|number of letters in the array [/ text]. When [/ n < 0], 
[/ text] length is counted using [/ wcslen].&]
[s4; [*/ Return value]-|[/ cx `=] output text pixel width[/ , cy `= ]line 
height of given font&]
[s0;3 &]
[s0;:`:`:Draw`:`:DrawText`(int`,int`,int`,const`:`:wchar`*`,`:`:Font: void_[* DrawText](
int_[*@3 x], int_[*@3 y], int_[*@3 angle], const_wchar_`*[*@3 text], 
Font_[*@3 font]_`=_StdFont(), Color_[*@3 ink]_`=_SBlack, int_[*@3 n]_`=_`-[@3 1], 
const_int_`*[*@3 dx]_`=_NULL)&]
[s2; Draws text on the output device.&]
[s2; [* Note:] when working with rotated texts, always remember that 
[/ `[x, y`]] define the topleft corner of the text box. Box size 
is that returned by the function [/ GetTextSize]. In case of rotated 
texts, the text box is naturally not aligned with the coordinate 
axes. Also, some system fonts do not support rotation (bitmap 
fonts). Unfortunately there is currently no reliable way to detect 
if a font supports rotation. FontInfo`::IsScaleable should provide 
a good guess as to whether a given font supports rotation.&]
[s4; [*C@3 x]-|x coordinate of the topleft corner of the text box&]
[s4; [*C@3 y]-|y coordinate of the topleft corner of the text box&]
[s4; [*C@3 angle]-|angle for the text in tenths of degrees (full circle 
`= 3600). 0 `= to the right (normal text orientation), 900 `= 
upwards, 1800 `= head down left, 2700 downwards. &]
[s4; [*C@3 text]-|Unicode text to draw&]
[s4; [*C@3 font]-|font to use for drawing text&]
[s4; [*C@3 ink]-|text color; the text is always drawn as transparent. 
To set the background under the text to a given color, you must 
first measure the text size using [/ GetTextSize] and then call 
[/ DrawRect] to set the text box to a given color. When using rotated 
text ([/ angle !`= 0]) the situation is naturally much more complicated 
and a [/ DrawPolygon] would be needed to clear the rotated text 
box.&]
[s4; [*C@3 n]-|number of letters in the array [/ text]. When [/ n < 0], 
[/ text] length is counted using [/ wcslen].&]
[s4; [*C@3 dx]-|array of letter widths. This can be used to set explicit 
spacings for the individual letters in the text. When NULL, default 
letters widths are used. When not NULL, it must contain (at least) 
as many entries as are being painted from the given [/ text].&]
[s0;3 &]
[s0;:`:`:Draw`:`:DrawText`(int`,int`,const`:`:wchar`*`,`:`:Font: void_[* DrawText](int_
[*@3 x], int_[*@3 y], const_wchar_`*[*@3 text], Font_[*@3 font]_`=_StdFont(), 
Color_[*@3 ink]_`=_SBlack, int_[*@3 n]_`=_`-[@3 1], const_int_`*[*@3 dx]_`=_NULL)&]
[s2; Draws text on the output device. This is a simplified version 
of the above function for the most common case when [/ angle `=`= 
0] (i.e. the text is being painted in the ordinary direction 
from left to right).&]
[s4; [*C@3 x]-|x coordinate of the topleft corner of the text box&]
[s4; [*C@3 y]-|y coordinate of the topleft corner of the text box&]
[s4; [*C@3 text]-|Unicode text to draw&]
[s4; [*C@3 font]-|font to use for drawing text&]
[s4; [*C@3 ink]-|text color; the text is always drawn as transparent. 
To set the background under the text to a given color, you must 
first measure the text size using [/ GetTextSize] and then call 
[/ DrawRect] to set the text box to a given color.&]
[s4; [*C@3 n]-|number of letters in the array [/ text]. When [/ n < 0], 
[/ text] length is counted using [/ wcslen].&]
[s4; [*C@3 dx]-|array of letter widths. This can be used to set explicit 
spacings for the individual letters in the text. When NULL, default 
letters widths are used. When not NULL, it must contain (at least) 
as many entries as are being painted from the given [/ text].&]
[s0;3 &]
[s0;:`:`:Draw`:`:GetTextSize`(const`:`:WString`&`,`:`:Font: Size_[* GetTextSize](const_
WString`&_[*@3 text], Font_[*@3 font]_`=_StdFont())&]
[s2; Measures width and height of a Unicode text (as when painted 
using given font).&]
[s4; [*C@3 text]-|text string to measure&]
[s4; [*C@3 font]-|font to use for metrics measurements&]
[s4; [*/ Return value]-|[/ cx `= ]text box width, [/ cy `= ] text box height 
(font ascent `+ descent).&]
[s0;3 &]
[s0;:`:`:Draw`:`:DrawText`(int`,int`,const`:`:WString`&`,`:`:Font: void_[* DrawText](in
t_[*@3 x], int_[*@3 y], const_WString`&_[*@3 text], Font_[*@3 font]_`=_StdFont(), 
Color_[*@3 ink]_`=_SBlack, const_int_`*[*@3 dx]_`=_NULL)&]
[s2; Draws text on the output device (from left to right). This is 
a variation of one of the above function for the case when the 
input parameter is a WString. In such situation the number of 
letters is known ([/ text.GetLength()]) and doesn`'t (indeed shoudn`'t) 
be measured using [/ wcslen].&]
[s4; [*C@3 x]-|x coordinate of the topleft corner of the text box&]
[s4; [*C@3 y]-|y coordinate of the topleft corner of the text box&]
[s4; [*C@3 text]-|Unicode text to draw&]
[s4; [*C@3 font]-|font to use for drawing text&]
[s4; [*C@3 ink]-|text color; the text is always drawn as transparent.&]
[s4; [*C@3 dx]-|array of letter widths. This can be used to set explicit 
spacings for the individual letters in the text. When NULL, default 
letters widths are used. When not NULL, it must contain (at least) 
as many entries as are being painted from the given [/ text].&]
[s0;3 &]
[s0;:`:`:Draw`:`:DrawText`(int`,int`,int`,const`:`:WString`&`,`:`:Font: void_[* DrawTex
t](int_[*@3 x], int_[*@3 y], int_[*@3 angle], const_WString`&_[*@3 text], 
Font_[*@3 font]_`=_StdFont(), Color_[*@3 ink]_`=_SBlack, const_int_`*[*@3 dx]_`=_NULL)&]
[s2; Draws text on the output device. A variation of the above function 
allowing text rotation. See above notes concerning text rotation 
issues.&]
[s4; [*C@3 x]-|x coordinate of the topleft corner of the text box&]
[s4; [*C@3 y]-|y coordinate of the topleft corner of the text box&]
[s4; [*C@3 angle]-|angle for the text in tenths of degrees (full circle 
`= 3600). 0 `= to the right (normal text orientation), 900 `= 
upwards, 1800 `= head down left, 2700 downwards. &]
[s4; [*C@3 text]-|Unicode text to draw&]
[s4; [*C@3 font]-|font to use for drawing text&]
[s4; [*C@3 ink]-|text color; the text is always drawn as transparent.&]
[s4; [*C@3 dx]-|array of letter widths. This can be used to set explicit 
spacings for the individual letters in the text. When NULL, default 
letters widths are used. When not NULL, it must contain (at least) 
as many entries as are being painted from the given [/ text].&]
[s0;3 &]
[s0;:`:`:Draw`:`:GetTextSize`(const char`*`,`:`:byte`,`:`:Font: Size_[* GetTextSize](co
nst_char_`*[*@3 text], byte_[*@3 charset], Font_[*@3 font]_`=_StdFont(), 
int_[*@3 n]_`=_`-[@3 1])&]
[s2; Measures text box size for text in given character set.&]
[s4; [*C@3 text]-|text to measure&]
[s4; [*C@3 charset]-|text character set&]
[s4; [*C@3 font]-|font to use for the metrics measurements&]
[s4; [*C@3 n]-|number of letters in [/ text]. When [/ n < 0], [/ text] length 
is counted using [/ strlen] (or [/ utf8len], when [/ charset `=`= CHARSET`_UTF8]).&]
[s4; [*/ Return value]-|&]
[s0;3 &]
[s0;:`:`:Draw`:`:DrawText`(int`,int`,int`,const char`*`,`:`:byte`,`:`:Font: void_[* Dra
wText](int_[*@3 x], int_[*@3 y], int_[*@3 angle], const_char_`*[*@3 text], 
byte_[*@3 charset], Font_[*@3 font]_`=_StdFont(), Color_[*@3 ink]_`=_SBlack, 
int_[*@3 n]_`=_`-[@3 1], const_int_`*[*@3 dx]_`=_NULL)&]
[s2; Draw given text in a given character set to the ouput device. 
This variant allows text rotation.&]
[s4; [*C@3 x]-|x coordinate of the topleft corner of the text box&]
[s4; [*C@3 y]-|y coordinate of the topleft corner of the text box&]
[s4; [*C@3 angle]-|angle for the text in tenths of degrees (full circle 
`= 3600). 0 `= to the right (normal text orientation), 900 `= 
upwards, 1800 `= head down left, 2700 downwards. &]
[s4; [*C@3 text]-|text to draw&]
[s4; [*C@3 charset]-|output text character set (from the CHARSET`_xxx 
enumeration)&]
[s4; [*C@3 font]-|font to use for drawing text&]
[s4; [*C@3 ink]-|text color; the text is always drawn as transparent.&]
[s4; [*C@3 n]-|number of letters in [/ text]. When [/ n < 0], [/ text] length 
is counted using [/ strlen].&]
[s4; [*C@3 dx]-|array of letter widths. This can be used to set explicit 
spacings for the individual letters in the text. When NULL, default 
letters widths are used. When not NULL, it must contain (at least) 
as many entries as are being painted from the given [/ text].&]
[s0;3 &]
[s0;:`:`:Draw`:`:DrawText`(int`,int`,const char`*`,`:`:byte`,`:`:Font: void_[* DrawText
](int_[*@3 x], int_[*@3 y], const_char_`*[*@3 text], byte_[*@3 charset], 
Font_[*@3 font]_`=_StdFont(), Color_[*@3 ink]_`=_SBlack, int_[*@3 n]_`=_`-[@3 1], 
const_int_`*[*@3 dx]_`=_NULL)&]
[s2; Draws text in given character set to the output device (from 
left to right).&]
[s4; [*C@3 x]-|x coordinate of the topleft corner of the text box&]
[s4; [*C@3 y]-|y coordinate of the topleft corner of the text box&]
[s4; [*C@3 text]-|text to draw&]
[s4; [*C@3 charset]-|output text character set (from the CHARSET`_xxx 
enumeration)&]
[s4; [*C@3 font]-|font to use for drawing text&]
[s4; [*C@3 ink]-|text color; the text is always drawn as transparent.&]
[s4; [*C@3 n]-|number of letters in [/ text]. When [/ n < 0], [/ text] length 
is counted using [/ strlen] (or [/ utf8len], when [/ charset `=`= CHARSET`_UTF8]).&]
[s4; [*C@3 dx]-|array of letter widths. This can be used to set explicit 
spacings for the individual letters in the text. When NULL, default 
letters widths are used. When not NULL, it must contain (at least) 
as many entries as are being painted from the given [/ text].&]
[s0;3 &]
[s0;:`:`:Draw`:`:GetTextSize`(const char`*`,`:`:Font: Size_[* GetTextSize](const_char_`*
[*@3 text], Font_[*@3 font]_`=_StdFont(), int_[*@3 n]_`=_`-[@3 1])&]
[s2; Measures text box size for a text encoded in system`-default 
character set. &]
[s4; [*C@3 text]-|text to measure (in default character set, CHARSET`_DEFAULT)&]
[s4; [*C@3 font]-|font to use for the metrics measurements&]
[s4; [*C@3 n]-|number of letters in [/ text]. When [/ n < 0], [/ text] length 
is counted using [/ strlen] (or [/ utf8len], when the default charset 
is [/ CHARSET`_UTF8]).&]
[s4; [*/ Return value]-|&]
[s0;3 &]
[s0;:`:`:Draw`:`:DrawText`(int`,int`,int`,const char`*`,`:`:Font: void_[* DrawText](int
_[*@3 x], int_[*@3 y], int_[*@3 angle], const_char_`*[*@3 text], Font_[*@3 font]_`=_StdFont
(), Color_[*@3 ink]_`=_SBlack, int_[*@3 n]_`=_`-[@3 1], const_int_`*[*@3 dx]_`=_NULL)&]
[s2; Draws text encoded in system`-default character set on the output 
device. This variant allows text rotation.&]
[s4; [*C@3 x]-|x coordinate of the topleft corner of the text box&]
[s4; [*C@3 y]-|y coordinate of the topleft corner of the text box&]
[s4; [*C@3 angle]-|angle for the text in tenths of degrees (full circle 
`= 3600). 0 `= to the right (normal text orientation), 900 `= 
upwards, 1800 `= head down left, 2700 downwards. &]
[s4; [*C@3 text]-|text to draw (in default character set, CHARSET`_DEFAULT)&]
[s4; [*C@3 font]-|font to use for drawing text&]
[s4; [*C@3 ink]-|text color; the text is always drawn as transparent.&]
[s4; [*C@3 n]-|number of letters in [/ text]. When [/ n < 0], [/ text] length 
is counted using [/ strlen] (or [/ utf8len], when the default character 
set is [/ CHARSET`_UTF8]).&]
[s4; [*C@3 dx]-|array of letter widths. This can be used to set explicit 
spacings for the individual letters in the text. When NULL, default 
letters widths are used. When not NULL, it must contain (at least) 
as many entries as are being painted from the given [/ text].&]
[s0;3 &]
[s0;:`:`:Draw`:`:DrawText`(int`,int`,const char`*`,`:`:Font: void_[* DrawText](int_[*@3 x
], int_[*@3 y], const_char_`*[*@3 text], Font_[*@3 font]_`=_StdFont(), 
Color_[*@3 ink]_`=_SBlack, int_[*@3 n]_`=_`-[@3 1], const_int_`*[*@3 dx]_`=_NULL)&]
[s2; Draws text encoded in system`-default character set on the output 
device (from left to right).&]
[s4; [*C@3 x]-|x coordinate of the topleft corner of the text box&]
[s4; [*C@3 y]-|y coordinate of the topleft corner of the text box&]
[s4; [*C@3 text]-|text to draw (in default character set, CHARSET`_DEFAULT)&]
[s4; [*C@3 font]-|font to use for drawing text&]
[s4; [*C@3 ink]-|text color; the text is always drawn as transparent.&]
[s4; [*C@3 n]-|number of letters in [/ text]. When [/ n < 0], [/ text] length 
is counted using [/ strlen] (or [/ utf8len], when the default character 
set is [/ CHARSET`_UTF8]).&]
[s4; [*C@3 dx]-|array of letter widths. This can be used to set explicit 
spacings for the individual letters in the text. When NULL, default 
letters widths are used. When not NULL, it must contain (at least) 
as many entries as are being painted from the given [/ text].&]
[s0;3 &]
[s0;:`:`:Draw`:`:GetTextSize`(const`:`:String`&`,`:`:Font: Size_[* GetTextSize](const_S
tring`&_[*@3 text], Font_[*@3 font]_`=_StdFont())&]
[s2; Measures text size (default character set). This is a variant 
of the above function for the case when [/ text] i a [/ String] when 
the text length is known ([/ text.GetLength()]) and it needn`'t 
and shouldn`'t be measured using [/ strlen]. However, when the 
current system`-default character set it CHARSET`_UTF8, the text 
length must still be measured using [/ utf8len] because the number 
of UTF8 letters can differ from the number of bytes in the string.&]
[s4; [*C@3 text]-|text to measure (in default character set, CHARSET`_DEFAULT)&]
[s4; [*C@3 font]-|font to use for the metrics measurements&]
[s4; [*/ Return value]-|&]
[s0;3 &]
[s0;:`:`:Draw`:`:DrawText`(int`,int`,const`:`:String`&`,`:`:Font: void_[* DrawText](int
_[*@3 x], int_[*@3 y], const_String`&_[*@3 text], Font_[*@3 font]_`=_StdFont(), 
Color_[*@3 ink]_`=_SBlack, const_int_`*[*@3 dx]_`=_NULL)&]
[s2; Draws text encoded in system`-default character set on the output 
device (from left to right).&]
[s4; [*C@3 x]-|x coordinate of the topleft corner of the text box&]
[s4; [*C@3 y]-|y coordinate of the topleft corner of the text box&]
[s4; [*C@3 text]-|text to draw (in default character set, CHARSET`_DEFAULT)&]
[s4; [*C@3 font]-|font to use for drawing text&]
[s4; [*C@3 ink]-|text color; the text is always drawn as transparent.&]
[s4; [*C@3 dx]-|array of letter widths. This can be used to set explicit 
spacings for the individual letters in the text. When NULL, default 
letters widths are used. When not NULL, it must contain (at least) 
as many entries as are being painted from the given [/ text].&]
[s0;3 &]
[s0;:`:`:Draw`:`:DrawText`(int`,int`,int`,const`:`:String`&`,`:`:Font: void_[* DrawText
](int_[*@3 x], int_[*@3 y], int_[*@3 angle], const_String`&_[*@3 text], 
Font_[*@3 font]_`=_StdFont(), Color_[*@3 ink]_`=_SBlack, const_int_`*[*@3 dx]_`=_NULL)&]
[s2; Draws text encoded in system`-default character set on the output 
device. This variant supports text rotation. See above for notes 
concerning text rotation issues.&]
[s4; [*C@3 x]-|x coordinate of the topleft corner of the text box&]
[s4; [*C@3 y]-|y coordinate of the topleft corner of the text box&]
[s4; [*C@3 angle]-|angle for the text in tenths of degrees (full circle 
`= 3600). 0 `= to the right (normal text orientation), 900 `= 
upwards, 1800 `= head down left, 2700 downwards. &]
[s4; [*C@3 text]-|text to draw&]
[s4; [*C@3 font]-|font to use for drawing text&]
[s4; [*C@3 ink]-|text color; the text is always drawn as transparent.&]
[s4; [*C@3 dx]-|array of letter widths. This can be used to set explicit 
spacings for the individual letters in the text. When NULL, default 
letters widths are used. When not NULL, it must contain (at least) 
as many entries as are being painted from the given [/ text].&]
[s0;3 &]
[s5;K%- static [@(0.0.255) void]_[@0 SinCos]([@(0.0.255) int]_[@3 angle], 
[@(0.0.255) double]`&_[@3 sina], [@(0.0.255) double]`&_[@3 cosa])&]
[s2; A simple utility function which calculates the sine and cosine 
of given angle (in tenths of degrees). This function is used 
internally to calculate metrics of rotated text. &]
[s4; [*C@3 angle]-|angle in tenths of degrees. 0 `= right, 900 `= up, 
1800 `= left, 2700 `= down.&]
[s4; [*C@3 sina]-|sine of the angle, or [/ sin(angle `* 2 `* M`_PI / 3600)]&]
[s4; [*C@3 cosa]-|cosine of the angle, or [/ cos(angle `* 2 `* M`_PI / 
3600)]&]
[s0; &]
[s0; Accessing [/ Drawing]`-specific functions&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 DrawDrawing]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 r], 
[@(0.0.255) const]_[^`:`:Drawing^ Drawing]`&_[@3 iw])&]
[s2; Draws drawing scaled into given rectangle. The coordinate transform 
equations are&]
[s2; &]
[s2; x[, out]`=x[, dwg] `* r.Width() / iw.GetSize().cx `+ r.left&]
[s2; y[, out]`=y[, dwg] `* r.Height() / iw.GetSize().cy `+ r.top&]
[s2; &]
[s4; [*C@3 r]-|destination rectangle in logical device units&]
[s4; [*C@3 iw]-|drawing object to draw&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 DrawDrawing]([@(0.0.255) int]_[@3 x], [@(0.0.255) int]_[@3 y], 
[@(0.0.255) int]_[@3 cx], [@(0.0.255) int]_[@3 cy], [@(0.0.255) const]_[^`:`:Drawing^ Drawing
]`&_[@3 iw])&]
[s2; Draws drawing scaled into rectangle [* cx] `* [* cy] pixels starting 
at `[x, y`]. The equations used to scale the drawing are&]
[s2; &]
[s2; x[, out]`=x[, dwg] `* cx / iw.GetSize().cx `+ x&]
[s2; y[, out]`=y[, dwg] `* cy / iw.GetSize().cy `+ y&]
[s2; &]
[s4; [*C@3 x]-|left edge of output rectangle&]
[s4; [*C@3 y]-|top edge of output rectangle&]
[s4; [*C@3 cx]-|rectangle width&]
[s4; [*C@3 cy]-|rectangle height&]
[s4; [*C@3 iw]-|drawing to draw at the specified location&]
[s0;3 &]
[s5;K%- [^`:`:Stream^ Stream]`&_[@0 DrawingOp]([@(0.0.255) int]_[@3 code])&]
[s2; &]
[s4; [*C@3 code]-|&]
[s4; [*/ Return value]-|&]
[s0;3 &]
[s5;K%- [^`:`:Stream^ Stream]`&_[@0 PutRect]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 r])&]
[s2; &]
[s4; [*C@3 r]-|&]
[s4; [*/ Return value]-|&]
[s0; &]
[s0; Accessing unified virtual output interface&]
[s0;3 &]
[s5;K%- virtual [@(0.0.255) void]_[@0 BeginOp]()&]
[s2; &]
[s0;3 &]
[s5;K%- virtual [@(0.0.255) void]_[@0 EndOp]()&]
[s2; &]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 OffsetOp]([^`:`:Point^ Point]_[@3 p])&]
[s2; &]
[s4; [*C@3 p]-|&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 ClipOp]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 r])&]
[s2; &]
[s4; [*C@3 r]-|&]
[s4; [*/ Return value]-|&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 ClipoffOp]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 r])&]
[s2; &]
[s4; [*C@3 r]-|&]
[s4; [*/ Return value]-|&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 ExcludeClipOp]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 r])&]
[s2; &]
[s4; [*C@3 r]-|&]
[s4; [*/ Return value]-|&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 IntersectClipOp]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 r])&]
[s2; &]
[s4; [*C@3 r]-|&]
[s4; [*/ Return value]-|&]
[s0;3 &]
[s5;K%- virtual [^`:`:Rect^ Rect]_[@0 GetClipOp]()_[@(0.0.255) const]&]
[s2; &]
[s4; [*/ Return value]-|&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 DrawRectOp]([@(0.0.255) int]_[@3 x], [@(0.0.255) int]_[@3 y], 
[@(0.0.255) int]_[@3 cx], [@(0.0.255) int]_[@3 cy], [^`:`:Color^ Color]_[@3 color])&]
[s2; &]
[s4; [*C@3 x]-|&]
[s4; [*C@3 y]-|&]
[s4; [*C@3 cx]-|&]
[s4; [*C@3 cy]-|&]
[s4; [*C@3 color]-|&]
[s0;3 &]
[s0;:`:`:Draw`:`:DrawImageOp`(const`:`:Rect`&`,const`:`:Image`&`,const`:`:Rect`&`,int`): v
irtual void_[* DrawImageOp](const_Rect`&_[*@3 rect], const_Image`&_[*@3 img], 
const_Rect`&_[*@3 src], int_[*@3 fx])&]
[s2; &]
[s4; [*C@3 rect]-|&]
[s4; [*C@3 img]-|&]
[s4; [*C@3 src]-|&]
[s4; [*C@3 fx]-|&]
[s0;3 &]
[s0;:`:`:Draw`:`:DrawImageOp`(const`:`:Rect`&`,const`:`:Image`&`,const`:`:Rect`&`,`:`:Color`,`:`:Color`,`:`:Color`): v
irtual void_[* DrawImageOp](const_Rect`&_[*@3 rect], const_Image`&_[*@3 img], 
const_Rect`&_[*@3 src], Color_[*@3 fore], Color_[*@3 back], Color_[*@3 doxor])&]
[s2; &]
[s4; [*C@3 rect]-|&]
[s4; [*C@3 img]-|&]
[s4; [*C@3 src]-|&]
[s4; [*C@3 fore]-|&]
[s4; [*C@3 back]-|&]
[s4; [*C@3 doxor]-|&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 DrawLineOp]([@(0.0.255) int]_[@3 x1], [@(0.0.255) int]_[@3 y1], 
[@(0.0.255) int]_[@3 x2], [@(0.0.255) int]_[@3 y2], [@(0.0.255) int]_[@3 width], 
[^`:`:Color^ Color]_[@3 color])&]
[s2; &]
[s4; [*C@3 x1]-|&]
[s4; [*C@3 y1]-|&]
[s4; [*C@3 x2]-|&]
[s4; [*C@3 y2]-|&]
[s4; [*C@3 width]-|&]
[s4; [*C@3 color]-|&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 DrawPolyPolylineOp]([@(0.0.255) const]_[^`:`:Point^ Point]_`*[@3 v
ertices], [@(0.0.255) int]_[@3 vertex`_count], [@(0.0.255) const]_[@(0.0.255) int]_`*[@3 co
unts], [@(0.0.255) int]_[@3 count`_count], [@(0.0.255) int]_[@3 width], 
[^`:`:Color^ Color]_[@3 color], [^`:`:Color^ Color]_[@3 doxor])&]
[s2; &]
[s4; [*C@3 vertices]-|&]
[s4; [*C@3 vertex`_count]-|&]
[s4; [*C@3 counts]-|&]
[s4; [*C@3 count`_count]-|&]
[s4; [*C@3 width]-|&]
[s4; [*C@3 color]-|&]
[s4; [*C@3 doxor]-|&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 DrawEllipseOp]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 r], 
[^`:`:Color^ Color]_[@3 color], [@(0.0.255) int]_[@3 width], [^`:`:Color^ Color]_[@3 pencolor
])&]
[s2; &]
[s4; [*C@3 r]-|&]
[s4; [*C@3 color]-|&]
[s4; [*C@3 pen]-|&]
[s4; [*C@3 pencolor]-|&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 DrawArcOp]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 rc], 
[^`:`:Point^ Point]_[@3 start], [^`:`:Point^ Point]_[@3 end], [@(0.0.255) int]_[@3 width], 
[^`:`:Color^ Color]_[@3 color])&]
[s2; &]
[s4; [*C@3 rc]-|&]
[s4; [*C@3 start]-|&]
[s4; [*C@3 end]-|&]
[s4; [*C@3 width]-|&]
[s4; [*C@3 color]-|&]
[s0;3 &]
[s5;K%- virtual [@(0.0.255) void]_[@0 DrawTextOp]([@(0.0.255) int]_[@3 x], 
[@(0.0.255) int]_[@3 y], [@(0.0.255) int]_[@3 angle], [@(0.0.255) const]_[^`:`:wchar^ wchar]_
`*[@3 text], [^`:`:Font^ Font]_[@3 font], [^`:`:Color^ Color]_[@3 ink], 
[@(0.0.255) int]_[@3 n], [@(0.0.255) const]_[@(0.0.255) int]_`*[@3 dx])&]
[s2; &]
[s4; [*C@3 x]-|&]
[s4; [*C@3 y]-|&]
[s4; [*C@3 angle]-|&]
[s4; [*C@3 text]-|&]
[s4; [*C@3 font]-|&]
[s4; [*C@3 ink]-|text color&]
[s4; [*C@3 n]-|number of letters in [/ text]. When [/ n < 0], [/ text] length 
is counted using [/ wcslen].&]
[s4; [*C@3 dx]-|array of letter widths. This can be used to set explicit 
spacings for the individual letters in the text. When NULL, default 
letters widths are used. When not NULL, it must contain (at least) 
as many entries as are being painted from the given [/ text].&]
[s0;3 &]
[s5;K%- virtual [@(0.0.255) void]_[@0 DrawDrawingOp]([@(0.0.255) const]_[^`:`:Rect^ Rect]`&_[@3 t
arget], [@(0.0.255) const]_[^`:`:Drawing^ Drawing]`&_[@3 w])&]
[s2; &]
[s4; [*C@3 target]-|&]
[s4; [*C@3 w]-|&]
[s0; &]
[s0; Accessing the underlying physical output device interface&]
[s0;3 &]
[s5;K%- [^COLORREF^ COLORREF]_[@0 GetColor]([^`:`:Color^ Color]_[@3 c])_[@(0.0.255) const]&]
[s2; &]
[s4; [*C@3 color]-|&]
[s4; [*/ Return value]-|&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 SetColor]([^`:`:Color^ Color]_[@3 color])&]
[s2; &]
[s4; [*C@3 color]-|&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 SetDrawPen]([@(0.0.255) int]_[@3 width], [^`:`:Color^ Color]_[@3 co
lor])&]
[s2; &]
[s4; [*C@3 width]-|&]
[s4; [*C@3 color]-|&]
[s0;3 &]
[s5;K%- [^HDC^ HDC]_[@0 BeginGdi]()&]
[s2; &]
[s4; [*/ Return value]-|&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 EndGdi]()&]
[s2; &]
[s0;3 &]
[s5;K%- [^HDC^ HDC]_[@0 GetHandle]()&]
[s2; &]
[s4; [*/ Return value]-|&]
[s0;3 &]
[s5;K%- operator_HDC()_[@(0.0.255) const]&]
[s2; [* Win32`-specific:] retrieves the device context handle for the 
output device (in Win32, device context handles are used to paint 
into windows, images, printer and Windows metafile). When the 
device doesn`'t correspond to a Windows context handle (e.g. 
for DrawingDraw, PdfDraw and the like), the function returns 
NULL.&]
[s4; [*/ Return value]-|handle of device context (NULL `= not available 
or applicable)&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 Unselect]()&]
[s2; [* Win32`-specific:] restores all drawing objects originally selected 
in the Windows device context. When drawing using different line 
and filll styles, the Draw object internally modifies the state 
automaton of the device context to allocate the necessary brushes 
and pens. This functions unselects all objects created internally 
by Draw during painting and restores the objects originally selected 
into the context. This is sometimes necessary when you need to 
access and manipulate the device context manually using specific 
Windows API calls.&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 Attach]([^HDC^ HDC]_[@3 ahandle])&]
[s2; [* Win32`-specific:] attaches the Draw object to a given Windows 
device handle. The function stores the given handle and performs 
certain initializations (like determining the color model and 
other characteristics of the output device). This is normally 
used only internally by objects deriving from the Draw object 
to perform specific drawing tasks (see ImageDraw and PrintDraw).&]
[s4; [*C@3 ahandle]-|windows device context handle to connect to the 
Draw object&]
[s0;3 &]
[s5;K%- [^HDC^ HDC]_[@0 Detach]()&]
[s2; [* Win32`-specific:] detaches the Windows device context handle 
from the Draw object. The function unselects all device objects 
selected previously by the internal implementation of the drawing 
operations. After calling this function the device context handle 
is freed from the Draw and can be used to perform Win32`-specific 
drawing tasks.&]
[s4; [*/ Return value]-|The Windows device context being detached&]
[s0;3 &]
[s5;K%- [^`:`:Size^ Size]_[@0 GetSizeCaps]([@(0.0.255) int]_[@3 i], [@(0.0.255) int]_[@3 j])_[@(0.0.255) c
onst]&]
[s2; [* Win32`-specific:] returns a pair of Windows device context capabilities 
forming an `[x, y`] pair. It is quite common for device context 
characteristics to come in pairs, like HORZRES / VERTRES, PHYSICALWIDTH 
/ PHYSICALHEIGHT etc. In a few such cases it is handy to have 
a funcion which reads the given two capabilities (i and j) and 
returns the result in the form of a Size object.&]
[s4; [*C@3 i]-|1st capability (its value is returned in Size`::cx)&]
[s4; [*C@3 j]-|2nd capability (its value is returned in Size`::cy)&]
[s4; [*/ Return value]-|Size formed from the results of call to GetDeviceCaps 
for the HDC of the Draw object and the capabilities [* i] and [* j].&]
[s0;3 &]
[s5;K%- static [@(0.0.255) void]_[@0 Flush]()&]
[s2; &]
[s0;3 &]
[s0;:`:`:Draw`:`:MakeXLFD`(`:`:byte`,`:`:Font`,int`,int`): String_[* MakeXLFD](byte_[*@3 c
s], Font_[*@3 f], int_[*@3 height]_`=_Null, int_[*@3 angle]_`=_[@3 0])&]
[s2; &]
[s4; [*C@3 cs]-|&]
[s4; [*C@3 f]-|&]
[s4; [*C@3 height]-|&]
[s4; [*C@3 angle]-|&]
[s4; [*/ Return value]-|&]
[s0;3 &]
[s5;K%- static [^XftFont^ XftFont]_`*[@0 CreateXftFont]([^`:`:Font^ Font]_[@3 f], 
[@(0.0.255) int]_[@3 angle])&]
[s2; &]
[s4; [*C@3 f]-|&]
[s4; [*C@3 angle]-|&]
[s4; [*/ Return value]-|&]
[s0;3 &]
[s5;K%- [^XftDraw^ XftDraw]_`*[@0 GetXftDraw]()_[@(0.0.255) const]&]
[s2; &]
[s4; [*/ Return value]-|&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 SetForeground]([^`:`:Color^ Color]_[@3 color])&]
[s2; &]
[s4; [*C@3 color]-|&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 SetLineStyle]([@(0.0.255) int]_[@3 width])&]
[s2; &]
[s4; [*C@3 width]-|&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 SetFont]([^`:`:Font^ Font]_[@3 font], [@(0.0.255) int]_[@3 angle])&]
[s2; &]
[s4; [*C@3 font]-|&]
[s4; [*C@3 angle]-|&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 SetClip]()&]
[s2; &]
[s0;3 &]
[s5;K%- [^Drawable^ Drawable]_[@0 GetDrawable]()_[@(0.0.255) const]&]
[s2; &]
[s4; [*/ Return value]-|&]
[s0;3 &]
[s5;K%- [^GC^ GC]_[@0 GetGC]()_[@(0.0.255) const]&]
[s2; &]
[s4; [*/ Return value]-|&]
[s0;3 &]
[s5;K%- [@(0.0.255) const]_[^`:`:Vector^ Vector]<[^`:`:Rect^ Rect]>`&_[@0 GetClipList]()_[@(0.0.255) c
onst]&]
[s2; &]
[s4; [*/ Return value]-|&]
[s0;3 &]
[s5;K%- [^`:`:FontInfo^ FontInfo]_[@0 GetFontInfo]([^`:`:byte^ byte]_[@3 charset], 
[^`:`:Font^ Font]_[@3 font]_`=_StdFont())&]
[s2; &]
[s4; [*C@3 `_clip]-|&]
[s4; [*C@3 `_offset]-|&]
[s0; &]
[s0; Accessing device`-secific functions&]
[s0;3 &]
[s5;K%- virtual [@(0.0.255) void]_[@0 StartPage]()&]
[s2; &]
[s0;3 &]
[s5;K%- virtual [@(0.0.255) void]_[@0 EndPage]()&]
[s2; &]
[s0;3 &]
[s5;K%- static [@(0.0.255) void]_[@0 Register]([@(0.0.255) int]_[@3 code], 
[^`:`:Draw`:`:Drawer^ Drawer]_[@3 drawer])&]
[s2; &]
[s4; [*C@3 code]-|&]
[s4; [*C@3 drawer]-|&]
[s0;3 &]
[s3; [3 Important derived classes]&]
[s0;3 &]
[s0;:`:`:ScreenDraw`:`:class`:`:ScreenDraw: class_[* ScreenDraw] : public 
[* Draw]&]
[s0;3 &]
[s0; Used for determining screen characteristics like pixel `& physical 
resolution, supported color model, and for retrieving physical 
screen data. This is needed in situation when you must access 
the whole screen not depending on the logical window system (e.g. 
when writing an utility showing in its window a magnified part 
of the screen).&]
[s0; &]
[s0;3 &]
[s5;K%- [^`:`:Draw^ Draw]`&_[@0 ScreenInfo]()&]
[s0; &]
[s0; Used for determining screen characteristics like pixel `& physical 
resolution, supported color model. Instead of [* ScreenDraw], ScreenInfo 
cannot be used to read physical display data, only for retrieving 
device configuration information.&]
[s0; &]
[s0;3 &]
[s0;:`:`:ViewDraw`:`:class`:`:ViewDraw: class_[* ViewDraw] : public 
[* Draw]&]
[s0; &]
[s0; Used to paint into a control`'s view area. This is usually needed 
only in special situations (like for `"animated`" display in 
drag `& drop operations), because usually the controls are repainted 
automatically upon Windows request via the event loop (see [^topic`:`/`/CtrlCore`/src`/Ctrl`$en`-us`#`:`:Ctrl`:`:Paint`(Draw`&`)^ C
trl`::Paint]).&]
[s0;3 &]
[s0;:`:`:ViewDraw`:`:ViewDraw`(`:`:Ctrl`*`): [* ViewDraw](Ctrl `*[*@3 ctrl])&]
[s2; Initializes the ViewDraw object to paint into the window area 
of a given Ctrl. See [^topic`:`/`/CtrlCore`/src`/Ctrl`$en`-us^ CtrlCore] 
for greater detail on controls.&]
[s0; &]
[s0;3 &]
[s0;:`:`:ImageDraw`:`:class`:`:ImageDraw: class_[* ImageDraw] : public 
[* Draw]&]
[s0; &]
[s0; Used to paint into images. This is needed when you generate 
an image (to be later stored as a PNG, for example) using Windows 
GDI functions like DrawLine, DrawText etc. You create an image 
object, construct an ImageDraw using this object (and possibly 
a reference Draw to specify the image color format), then perform 
a series of GDI operations on the ImageDraw object. After you 
Close the ImageDraw object, you can further process the Image 
which now contains the object painted using the GDI output.&]
[s0; &]
[s0;3 &]
[s0;:`:`:ImageDraw`:`:ImageDraw`(`):%- [* ImageDraw]()&]
[s2; Constructs an empty ImageDraw. You can later Open the ImageDraw 
with a given Image.&]
[s0;3 &]
[s0;:`:`:ImageDraw`:`:ImageDraw`(`:`:Draw`&`,`:`:Image`&`):%- [* ImageDraw](Draw`&_[*@3 d
raw], Image`&_[*@3 image])&]
[s2; Constructs an ImageDraw and Opens it for painting into the given 
[* image].&]
[s4; [%-*C@3 draw]-|reference draw defining the image`'s color format.&]
[s4; [%-*C@3 image]-|image to write into&]
[s0;3 &]
[s0;:`:`:ImageDraw`:`:ImageDraw`(`:`:Image`&`):%- [* ImageDraw](Image`&_[*@3 image])&]
[s2; Constructs and ImageDraw and Opens it for painting into the 
given [* image]. The image is considered to be in the color format 
defined by [* ScreenDraw].&]
[s4; [%-*C@3 image]-|image to write into&]
[s0;3 &]
[s0;:`:`:ImageDraw`:`:Open`(`:`:Image`&`):%- void_[* Open](Image`&_[*@3 image])&]
[s2; Opens the ImageDraw for painting into given [* image ](assumed 
to have color format compatible with ScreenDraw). If an image 
was opened in the ImageDraw before, it is automatically closed.&]
[s4; [%-*C@3 image]-|image to write into&]
[s0;3 &]
[s0;:`:`:ImageDraw`:`:Open`(`:`:Draw`&`,`:`:Image`&`):%- void_[* Open](Draw`&_[*@3 draw],
 Image`&_[*@3 image])&]
[s2; Opens the ImageDraw for painting into given [* image]. The [* draw] 
parameter defines the [* image]`'s color model. This is needed 
because in Win32, standard GDI is not completely generic as concerns 
image color models. To process a bitmap, you must create a CompatibleDC 
suitable for processing the image, and this is not generally 
possible to determine and create solely using the information 
in the image. (E.g. when a printer has different color model 
than the screen, which is quite often the case, an image created 
using the PrintDraw as its compatible draw will not be processable 
by another ImageDraw based on ScreenDraw).&]
[s4; [%-*C@3 draw]-|draw compatible with image color model&]
[s4; [%-*C@3 image]-|image to write into&]
[s0;3 &]
[s0;:`:`:ImageDraw`:`:Close`(`):%- void_[* Close]()&]
[s2; Shuts down writing into the (previously Open`-ed) image. Between 
the Open (or the non`-empty contructor) and a Close the image 
itself must not be manipulated, otherwise the results may be 
inpredictable. You had best consider the image locked (although 
in reality, no physical lock is currently done) and leave it 
alone until the Close, after which you can process it further 
(encoder it using an ImageEncoder and save it to the disk, store 
it in a VectorMap`-based cache for web server throughput acceleration, 
assign it to the system cursor using [^topic`:`/`/CtrlCore`/src`/Ctrl`$en`-us`#`:`:Ctrl`:`:CursorImage`(Point`,dword`)^ C
ursorImage] etc.).&]
[s0; &]
[s0;3 &]
[s0;:`:`:ImageMaskDraw`:`:class`:`:ImageMaskDraw:%- class_[* ImageMaskDraw]&]
[s2; Used to paint into image masks. Images can be either unmasked 
(considered to have mask equal to opaque everywhere in the image 
area), or masked. Full alpha channel is currently not supported, 
but is planned (hopefully soon, written on June 29, 2005). Mask 
can be either `"off`" for the pixel (then the pixel is transparent 
and nothing is painted) or `"on`" (then the pixel is painted 
and the original pixel is overwritten). This applies to standard 
functions like the simpler form of DrawImage, other functions 
manipulate the pixel `& mask data otherwise.&]
[s0;%- [%%/ Derived from][%%  ]Draw&]
[s0;3 &]
[s0;:`:`:ImageMaskDraw`:`:ImageMaskDraw`(`):%- [* ImageMaskDraw]()&]
[s2; Constructs an empty ImageMaskDraw. You can later Open the ImageMaskDraw 
for processing an Image.&]
[s0;3 &]
[s0;:`:`:ImageMaskDraw`:`:ImageMaskDraw`(`:`:Image`&`):%- [* ImageMaskDraw](Image`&_[*@3 i
mage])&]
[s2; Creates an ImageMaskDraw and opens it for writing into an Image.&]
[s4; [%-*C@3 image]-|image to write to&]
[s0;3 &]
[s0;:`:`:ImageMaskDraw`:`:Open`(`:`:Image`&`):%- void_[* Open](Image`&_[*@3 image])&]
[s2; Opens the ImageMaskDraw to write into given Image. When the 
ImageMaskDraw was previously opened with another image, it is 
automatically closed. It is an error to open the same Image in 
two ImageMaskDraws at once. It is, however, legal to open an 
Image simultaneously in an ImageDraw together with the ImageMaskDraw. 
It is often handy to be able to paint the data and mask at once, 
because they often correlate.&]
[s4; [%-*C@3 image]-|image to write to&]
[s0;3 &]
[s0;:`:`:ImageMaskDraw`:`:Close`(`):%- void_[* Close]()&]
[s2; Finishes writing into the image mask. After this operation you 
can further process the newly modified image (paint it, encode 
it or anything else).&]
[s0;3 &]
[s0;:`:`:DrawingDraw`:`:class`:`:DrawingDraw: &]
[s0;%- class_[* DrawingDraw]&]
[s2; Used to create an internal linearized representation of the 
executed drawing operations, called a [* Drawing]. The Drawing 
can later be painted using DrawDrawing or serialized into a stream 
(to be later read back). Please consider the DrawingDraw an optimized 
internal short`-term image storage format (like when preparing 
the output for printer or for caches), not a completely `"official`" 
or stable format suitable e.g. for documents or distributable 
images. It tends to change from time to time. We plan to implement 
a specialized `"stable`" Drawing`-like vector format which will 
be suitable for long`-term data storage.&]
[s0;%- [%%/ Derived from][%%  ]Draw&]
[s0;3 &]
[s0;:`:`:DrawingDraw`:`:DrawingDraw`(`):%- [* DrawingDraw]()&]
[s2; Constructs an empty DrawingDraw. The DrawingDraw can be initialized 
later using [* Create].&]
[s0;3 &]
[s0;:`:`:DrawingDraw`:`:DrawingDraw`(int`,int`):%- [* DrawingDraw](int_[*@3 cx], 
int_[*@3 cy])&]
[s2; Creates a DrawingDraw and initializes it with given dimensions. 
Pixels are set as default Drawing units, although you can change 
the units to dots using SetPixels.&]
[s4; [%-*C@3 cx]-|drawing width&]
[s4; [%-*C@3 cy]-|drawing height&]
[s0;3 &]
[s0;:`:`:DrawingDraw`:`:DrawingDraw`(`:`:Size`):%- [* DrawingDraw](Size_[*@3 sz])&]
[s2; Creates a DrawingDraw with given size (with pixels as default 
units).&]
[s4; [%-*C@3 sz]-|desired drawing size&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 SetPixels]([@(0.0.255) bool]_[@3 b]_`=_true)&]
[s2; Switches to pixel units (b `= true) or to dot units (b `= false).&]
[s4; [%-*C@3 b]-|unit mode: true `= pixels, false `= dots&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 Create]([@(0.0.255) int]_[@3 cx], [@(0.0.255) int]_[@3 cy])&]
[s2; Initializes the DrawingDraw to record drawing operations into 
a Drawing of given size. After performing the requested set of 
operations, you can GetResult to retrieve the Drawing containing 
the recording of the performed operations. Default drawing units 
are pixels, use SetPixels(false) to switch them to dots.&]
[s4; [%-*C@3 cx]-|drawing width&]
[s4; [%-*C@3 cy]-|drawing height&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 Create]([^`:`:Size^ Size]_[@3 sz])&]
[s2; Initializes the DrawingDraw to create a Drawing of given size.&]
[s4; [%-*C@3 sz]-|drawing size&]
[s0;3 &]
[s0;:`:`:DrawingDraw`:`:GetResult`(`)const:%- Drawing_[* GetResult]()_const&]
[s2; Returns the Drawing containing the recorded operations. (Before 
you use GetResult, you must first use the constructor with parameters 
or call Create to initialize the Drawing and set its size).&]
[s4; [*/ Return value]-|a Drawing representing the recorded set of drawing 
operations. You can later replay this set of operations using 
[^topic`:`/`/Draw`/src`/Draw`$en`-us`#`:`:Draw`:`:DrawDrawing`(const Rect`&`,const Drawing`&`)^ D
rawDrawing] or Serialize it for storage.&]
[s0;3 &]
[s0;:`:`:DrawingDraw`:`:operator`:`:Drawing`(`)const:%- [* operator_Drawing]()_const&]
[s2; Returns the recorded Drawing (just like GetResult).&]
[s4; [*/ Return value]-|the recorded drawing operations&]
[s0; &]
[s0; &]
[s0; class_[* Report]&]
[s0; The Report can be used for generating documents for printing. 
Is is currently considered slightly obsolete as it is based on 
the old Document object instead on RichText. It is planned to 
be removed sometimes in the future, but is currently needed for 
not breaking our older projects.&]
[s0; &]
[s0; class_[* WinMetaFileDraw (Win32 only)]&]
[s0; Used to create Windows metafiles. &]
[s0;3 &]
[s0;:`:`:WinMetaFileDraw`:`:WinMetaFileDraw`(HDC`,int`,int`,const char`*`,const char`*`,const char`*`):%- [* W
inMetaFileDraw](HDC_[*@3 hdc], int_[*@3 cx], int_[*@3 cy], const_char_`*[*@3 app], 
const_char_`*[*@3 name], const_char_`*[*@3 file])&]
[s2; Constructs a WinMetaFileDraw to generate a metafile in color 
format compatible with given device.&]
[s4; [%-*C@3 hdc]-|reference device to use for initializing metafile 
color model&]
[s4; [%-*C@3 cx]-|metafile width&]
[s4; [%-*C@3 cy]-|metafile height&]
[s4; [%-*C@3 app]-|application name (stored in the metafile header)&]
[s4; [%-*C@3 name]-|metafile name (stored in the metafile header)&]
[s4; [%-*C@3 file]-|optional file name (when not given, the metafile 
is memory`-only)&]
[s0;3 &]
[s0;:`:`:WinMetaFileDraw`:`:WinMetaFileDraw`(int`,int`,const char`*`,const char`*`,const char`*`):%- [* W
inMetaFileDraw](int_[*@3 cx], int_[*@3 cy], const_char_`*[*@3 app], 
const_char_`*[*@3 name], const_char_`*[*@3 file])&]
[s2; Constructs a WinMetaFileDraw to generate a metafile in color 
format compatible with ScreenDraw.&]
[s4; [%-*C@3 cx]-|metafile width&]
[s4; [%-*C@3 cy]-|metafile height&]
[s4; [%-*C@3 app]-|application name&]
[s4; [%-*C@3 name]-|metafile name&]
[s4; [%-*C@3 file]-|optional file name (empty causes a memory`-only 
metafile to be created)&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 Create]([^HDC^ HDC]_[@3 hdc], [@(0.0.255) int]_[@3 cx], 
[@(0.0.255) int]_[@3 cy], [@(0.0.255) const]_[@(0.0.255) char]_`*[@3 app]_`=_NULL, 
[@(0.0.255) const]_[@(0.0.255) char]_`*[@3 name]_`=_NULL, [@(0.0.255) const]_[@(0.0.255) ch
ar]_`*[@3 file]_`=_NULL)&]
[s2; Creates a new metafile compatible with given reference device 
context.&]
[s4; [%-*C@3 hdc]-|reference device context to copy color format from&]
[s4; [%-*C@3 cx]-|metafile width&]
[s4; [%-*C@3 cy]-|metafile height&]
[s4; [%-*C@3 app]-|application name&]
[s4; [%-*C@3 name]-|metafile name&]
[s4; [%-*C@3 file]-|optional file name (when not given, is memory`-only)&]
[s4; [*/ Return value]-|[* true] on success, [* false] on failure&]
[s0;3 &]
[s5;K%- [@(0.0.255) bool]_[@0 Create]([@(0.0.255) int]_[@3 cx], [@(0.0.255) int]_[@3 cy], 
[@(0.0.255) const]_[@(0.0.255) char]_`*[@3 app]_`=_NULL, [@(0.0.255) const]_[@(0.0.255) cha
r]_`*[@3 name]_`=_NULL, [@(0.0.255) const]_[@(0.0.255) char]_`*[@3 file]_`=_NULL)&]
[s2; Creates a new metafile compatible with the screen.&]
[s4; [%-*C@3 cx]-|metafile width&]
[s4; [%-*C@3 cy]-|metafile height&]
[s4; [%-*C@3 app]-|application name&]
[s4; [%-*C@3 name]-|metafile name&]
[s4; [%-*C@3 file]-|optional file name&]
[s4; [*/ Return value]-|[* true] on success, [* false] on failure&]
[s0;3 &]
[s5;K%- [^`:`:WinMetaFile^ WinMetaFile]_[@0 Close]()&]
[s2; Finishes metafile creation and returns the created [* WinMetaFile] 
object.&]
[s4; [*/ Return value]-|the recorded metafile&]
[s0; &]
[s0;3 &]
[s0;:`:`:PrintDraw`:`:class`:`:PrintDraw:%- class_[* PrintDraw (Win32`-only)]&]
[s2; Used for generating printer output. This is currently Win32`-only, 
we hope to make a Linux version soon (volunteers needed). Currently 
we have also a Win32`-compatible PdfDraw which should be ported 
to Linux. Perhaps then the PrintDraw on Linux will be more or 
less derived from PdfDraw.&]
[s0;%- [%%/ Derived from][%%  ]Draw&]
[s0;3 &]
[s0;:`:`:PrintDraw`:`:PrintDraw`(HDC`,const char`*`):%- [* PrintDraw](HDC_[*@3 hdc], 
const_char_`*[*@3 jobname])&]
[s2; Creates a PrintDraw object. Prior to constructing a PrintDraw, 
you must create the printer HDC using PrintDlg or CreateDC.&]
[s4; [%-*C@3 hdc]-|printer DC&]
[s4; [%-*C@3 jobname]-|printer job name&]
[s0;3 &]
[s5;K%- virtual [@(0.0.255) void]_[@0 StartPage]()&]
[s2; Begins a new page.&]
[s0;3 &]
[s5;K%- virtual [@(0.0.255) void]_[@0 EndPage]()&]
[s2; Ends current page.&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 InitPrinter]()&]
[s2; Sends an initialization sequence to the printer.&]
[s0;3 &]
[s5;K%- [@(0.0.255) void]_[@0 Abort]()&]
[s2; Aborts current print job.&]
[s0; &]
[s0; struct_[* PageDraw]&]
[s0; The PageDraw is an abstract interface used to draw formatted 
text using the RichText objects. It is derived from Draw and 
captures drawing operations on the currently selected output 
page. After the painting is finished, you can access the generated 
pages. The user must derive the Page and Info methods and support 
their routines to manage the output pages.&]
[s0; &]
[s0;3 &]
[s0;:`:`:PageDraw`:`:struct`:`:PageDraw: struct_[* PdfDraw (Win32`-only)]&]
[s0; Used to create PDF files. Volunteers are needed to implement 
a Linux version (some font hackery will perhaps be needed, current 
version works only with TrueType fonts).&]
[s0; ]