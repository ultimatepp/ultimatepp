topic "FAQ";
[l288;i1120;a17;O9;~~~.1408;2 $$1,0#10431211400427159095818037425705:param]
[a83;*R6 $$2,5#31310162474203024125188417583966:caption]
[H4;b83;*4 $$3,5#07864147445237544204411237157677:title]
[i288;O9;C2 $$4,6#40027414424643823182269349404212:item]
[b42;a42;ph2 $$5,5#45413000475342174754091244180557:text]
[l288;b17;a17;2 $$6,6#27521748481378242620020725143825:desc]
[l321;C@5+75 $$7,7#20902679421464641399138805415013:code]
[b2503;2 $$8,0#65142375456100023862071332075487:separator]
[*@(0.0.255)2 $$9,0#83433469410354161042741608181528:base]
[C2 $$10,0#37138531426314131251341829483380:class]
[l288;a17;*1 $$11,11#70004532496200323422659154056402:requirement]
[i417;b42;a42;O9;~~~.416;2 $$12,12#10566046415157235020018451313112:tparam]
[b167;C2 $$13,13#92430459443460461911108080531343:item1]
[i288;a42;O9;C2 $$14,14#77422149456609303542238260500223:item2]
[*@2$(0.128.128)2 $$15,15#34511555403152284025741354420178:NewsDate]
[l321;*C$7;2 $$16,16#03451589433145915344929335295360:result]
[l321;b83;a83;*C$7;2 $$17,17#07531550463529505371228428965313:result`-line]
[l160;*C+117 $$18,5#88603949442205825958800053222425:package`-title]
[2 $$19,0#53580023442335529039900623488521:gap]
[C2 $$20,20#70211524482531209251820423858195:class`-nested]
[b50;2 $$21,21#03324558446220344731010354752573:Par]
[2 $$0,0#00000000000000000000000000000000:Default]
[{_} 
[s2; FAQ&]
[s0;R+93 &]
[s0; [R+93 1 ][R^topic`:`/`/Core`/SSH`/srcdoc`/FAQ`_en`-us`#q1^+93 Why 
not just use libssh2 directly?]&]
[s0; [R+93 2 ][R^topic`:`/`/Core`/SSH`/srcdoc`/FAQ`_en`-us`#q2^+93 Why 
is everything derived from ][C^topic`:`/`/Core`/SSH`/srcdoc`/FAQ`_en`-us`#q2^+93 Ss
h][R^topic`:`/`/Core`/SSH`/srcdoc`/FAQ`_en`-us`#q2^+93 ?]&]
[s0; [R+93 3 ][R^topic`:`/`/Core`/SSH`/srcdoc`/FAQ`_en`-us`#q3^+93 Why 
is there a global static mutex?]&]
[s0; [R+93 4 ][R^topic`:`/`/Core`/SSH`/srcdoc`/FAQ`_en`-us`#q4^+93 Why 
does ][C^topic`:`/`/Core`/SSH`/srcdoc`/FAQ`_en`-us`#q4^+93 Run()][R^topic`:`/`/Core`/SSH`/srcdoc`/FAQ`_en`-us`#q4^+93  
take a Gate?]&]
[s0; [R+93 5 ][R^topic`:`/`/Core`/SSH`/srcdoc`/FAQ`_en`-us`#q5^+93 Why 
exceptions internally but status externally?]&]
[s0; [R+93 6 ][R^topic`:`/`/Core`/SSH`/srcdoc`/FAQ`_en`-us`#q6^+93 Why 
RAII and pick semantics?]&]
[s0; [R+93 7 ][R^topic`:`/`/Core`/SSH`/srcdoc`/FAQ`_en`-us`#q7^+93 Why 
does SshShell handle X11 forwarding?]&]
[s0; [R+93 8 ][R^topic`:`/`/Core`/SSH`/srcdoc`/FAQ`_en`-us`#q8^+93 Is 
this blocking or non`-blocking?]&]
[s0; [R+93 9 ][R^topic`:`/`/Core`/SSH`/srcdoc`/FAQ`_en`-us`#q9^+93 Why 
detailed trace logging?]&]
[s0; [R+93 10 ][R^topic`:`/`/Core`/SSH`/srcdoc`/FAQ`_en`-us`#q10^+93 Why 
does the core enforce timeout?]&]
[s0;* &]
[s3;:q1: Q1: Why not just use libssh2 directly?&]
[s0; Because writing the same EAGAIN loop 73 times is character`-building, 
but not productive. &]
[s0; This wrapper centralizes: &]
[s0;l224;i150;O0; Timeout logic&]
[s0;l224;i150;O0; Abort logic&]
[s0;l224;i150;O0; Socket wait handling&]
[s0;l224;i150;O0; Error translation&]
[s0; So users can write SSH logic, not SSH archaeology. &]
[s0; &]
[s3;:q2: Q2: Why is everything derived from Ssh?&]
[s0; Because every SSH operation: &]
[s0;l224;i150;O0;~~~128; Has a lifecycle&]
[s0;l224;i150;O0;~~~128; Can fail&]
[s0;l224;i150;O0;~~~128; Can block&]
[s0;l224;i150;O0;~~~128; Can timeout&]
[s0;l224;i150;O0;~~~128; Can be aborted&]
[s0; Instead of duplicating that logic across classes, it lives in 
one place. &]
[s0; Think of Ssh as the constitutional law of the package. &]
[s0; &]
[s3;:q3: Q3: Why is there a global static mutex?&]
[s0; Because libssh2 is not magically thread`-safe in all scenarios. 
&]
[s0; We serialize sensitive sections intentionally. &]
[s0; This prevents: &]
[s0;l224;i150;O0;~~~192~160~192~192; Subtle race conditions&]
[s0;l224;i150;O0;~~~192~160~192~192; Heisenbugs&]
[s0;l224;i150;O0;~~~192~160~192~192; Late`-night debugging sessions 
involving caffeine and regret&]
[s0; &]
[s3;:q4: Q4: Why does Run() take a Gate?&]
[s0; To wrap arbitrary libssh2 calls inside the controlled execution 
loop. &]
[s0; It turns: &]
[s0; -|“Call function until it stops returning EAGAIN” &]
[s0; Into: &]
[s0; -|“Just do the thing.” &]
[s0; &]
[s3;:q5: Q5: Why exceptions internally but status externally?&]
[s0; Internally: &]
[s0;l224;i150;O0; Clean unwinding&]
[s0;l224;i150;O0; Less repetitive error checks&]
[s0;l224;i150;O0; Externally: &]
[s0;l224;i150;O0; Predictable status`-based API&]
[s0;l224;i150;O0; Friendly for GUI and console apps&]
[s0; It’s a diplomatic compromise. &]
[s0; &]
[s3;:q6: Q6: Why RAII and pick semantics?&]
[s0; Because this is U`+`+. &]
[s0; Manual memory management is a hobby. Deterministic cleanup is 
a feature. &]
[s0; &]
[s3;:q7: Q7: Why does SshShell handle X11 forwarding?&]
[s0; Because SSH channels are multiplexed over the same session. 
&]
[s0; Shell already manages interactive channel semantics.&]
[s0; X11 forwarding is just another channel mode. &]
[s0; Also, creating “SshX11ChannelOfDoom” felt excessive. &]
[s0; &]
[s3;:q8: Q8: Is this blocking or non`-blocking?&]
[s0; Yes. &]
[s0; Internally: non`-blocking libssh2&]
[s0; Externally: controlled blocking with timeout and event wait &]
[s0; You get determinism without spinning CPUs. &]
[s0; &]
[s3;:q9: Q9: Why detailed trace logging?&]
[s0; Because when SSH fails, it fails quietly, mysteriously, and 
often remotely. &]
[s0; Trace logging gives: &]
[s0;l224;i150;O0;~~~128; Object identity&]
[s0;l224;i150;O0;~~~128; Type&]
[s0;l224;i150;O0;~~~128; Directional block info&]
[s0;l224;i150;O0;~~~128; Debug`-level hex dumps&]
[s0; Without it, debugging SSH is mostly superstition. &]
[s0; &]
[s3;:q10: Q10: Why does the core enforce timeout?&]
[s0; Because infinite waits are [/ rarely ]a feature. &]
[s0; Unless you`'re waiting for a kernel compile over hotel Wi`-Fi 
or running [^topic`:`/`/Core`/SSH`/src`/Upp`_Ssh`_Channels`_en`-us`#Upp`:`:SshShell`:`:class^ S
shShell]&]
[s0; ]]