topic "ArrayCtrl";
[i448;a25;kKO9;2 $$1,0#37138531426314131252341829483380:class]
[l288;2 $$2,2#27521748481378242620020725143825:desc]
[0 $$3,0#96390100711032703541132217272105:end]
[H6;0 $$4,0#05600065144404261032431302351956:begin]
[i448;a25;kKO9;2 $$5,0#37138531426314131252341829483370:item]
[l288;a4;*@5;1 $$6,6#70004532496200323422659154056402:requirement]
[l288;i1121;b17;O9;~~~.1408;2 $$7,0#10431211400427159095818037425705:param]
[i448;b42;O9;2 $$8,8#61672508125594000341940100500538:tparam]
[b42;2 $$9,9#13035079074754324216151401829390:normal]
[2 $$0,0#00000000000000000000000000000000:Default]
[{_}%EN-US 
[ {{10000t/25b/25@3 [s0; [*@(229)4 ArrayCtrl]]}}&]
[s5;K &]
[s0; 
@@image:2362&1443
(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)
&]
[s0;*@3;3 &]
[s1;:ArrayCtrl`:`:class: [@(0.0.255)3 class][3 _][*3 ArrayCtrl][3 _:_][@(0.0.255)3 public][3 _][*@3;3 C
trl]&]
[s1; &]
[s0; [* 
@@image:1843&731
(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)
]&]
[s0;* &]
[s0; [* ArrayCtrl] implements basic grid functionality. It is typically 
used for display and editing of arrays of values or (heterogeneous) 
records. The records correspond to rows in the array, the individual 
fields within each record can be either bound to columns or to 
any generic [* Ctrl]`'s, thus supporting basic master`-detail functionality 
with practically no additional cost.&]
[s0; &]
[s0; The standard derived classes extend various aspects of the ArrayCtrl 
functionality. [* SqlArray] adds the nuts and bolts needed for 
editing SQL`-based tables, whereas [* PopupTable] couples the ArrayCtrl 
functionality with the drop`-down mechanism very similar to the 
one used in popup menus. This opens the door for implementing 
drop`-down controls like [* DropList] (aka [/ combo box]) or [* DropChoice] 
(usually used together with a control of the [* EditField ]or [* DataPusher] 
family to support coupling native data editing with drop`-down 
selection, widely used for history or commonly used predefined 
values. The [* ArrayPair] is, as its name implies, a pair of [* ArrayCtrl]`'s 
with arrow buttons between them allowing to visually select subsets 
of a certain set by moving its elements between the two lists.&]
[s0; &]
[s0; [*+117 The array data organization: indices and columns]&]
[s0; &]
[s0; There is a great deal of genericity supported by the ArrayCtrl 
with respect both to its source data and its visual presentation. 
Conceptually, the source array data is a matrix of [* Value]`'s. 
There is a series of methods for accessing this source data, 
the basic ones being [* Set] and [* Get]. The rows are addressed 
by integer indices (zero based), the columns can be addressed 
either by integer indices as well, or alternatively any source 
column can be assigned an [* Id] identifier and addressed by it. 
This is especially helpful in SQL`-based tables, where the table 
column names can be used for the [* Id]`'s. A pair of methods, 
[* GetPos] and [* GetId], can be used to translate these two column 
addressing modes. In the code terminology, the columns in the 
source data matrix are called [/ indices] whereas the visual (output) 
columns are called simply [/ columns].&]
[s0; &]
[s0; The visual ArrayCtrl structure can be entirely independent of 
the source data structure (although it`'s seldom helpful to make 
the mapping completely arbitrary). Basically, each column can 
have an arbitrary number of indices defining its source data. 
Of course, the most common case is one index per column. This 
is also simplest to address, because the column indices are equal 
to the source data indices. However, many other combinations 
are possible, each of which can be handy in certain situations:&]
[s0; &]
[s0;i150;O0; Index without a column: the most common of the `"special`" 
cases is used mainly for row id`'s or other internally important 
data without visual representation. The same behaviour can be 
obtained by making a column invisible.&]
[s0;i150;O0; Column without an index (a [/ rownum column]): this less 
common case can be used to display external data (not stored 
in the table). &]
[s0;i150;O0; Multiple columns sharing the same index: this can be 
used to display various aspects of a complex data object or to 
display the same source data in multiple ways (e.g., a temperature 
reading in Celsius and Fahrenheit degrees).&]
[s0;i150;O0; Column with multiple indices: can be used to display 
information gathered from multiple source data columns. This 
is used for instance in IconDes in TheIDE to display image identifiers 
together with their sizes in the list. This is the most complicated 
case because you have to implement a specific [* Display] for such 
a multi`-index column.&]
[s0; &]
[s0; [* Note:] in the current U`+`+ version, the implementation of index`-less 
columns (arrays with external data not stored in the source matrix) 
is rather awkward. It is planned to enhance this feature in the 
future by adding support for access to external data via a data 
accessor interface object. &]
[s0; &]
[s0; [*+117 ArrayCtrl GUI: selection, editing, and local menu]&]
[s0; &]
[s0; Array rows can be selected using the mouse or keyboard. ArrayCtrl`'s 
support both single`-selection (plain cursor) and multiselection 
model. Of course, row selection can be controlled via the programmatic 
array interface as well. The selection and cursor always spans 
entire rows, it is not possible (without substantial patchwork) 
to select only certain columns or individual cells.&]
[s0; &]
[s0; The ArrayCtrl rows can be inserted, edited and deleted either 
programmatically, or via common GUI elements (mouse and keyboard 
selection, local menu). It is possible to alter the standard 
ArrayCtrl local menu using the [* WhenBar] callback.&]
[s0; &]
[s0; [* Note:] it is worth noting that the standard editing keys ([* Insert] 
`= row insertion, [* Ctrl`+Enter] `= editing and [* Ctrl`+Delete] 
`= deletion) are not hardcoded in the ArrayCtrl`'s [* Key] method, 
they are mere hotkeys for the relevant local menu items. When 
you change the ArrayCtrl`'s local menu, the editing hotkeys change 
accordingly.&]
[s0; &]
[s0; A special but rather important case of array editing is [/ sorting]: 
there is no specific standard GUI for that. If you aren`'t content 
with programmatic sorting (e.g. after opening a dialog or after 
loading the array data), you have to implement some GUI for that 
as well. In certain cases, it is cool to use the [* HeaderCtrl] 
[* WhenAction] method to allow sorting the array by clicking on 
the header columns; alternatively you can add a sort function 
to the array local menu or possibly somewhere else (like a standalone 
button in the dialog).&]
[s0; &]
[s0; [* Insertion tricks: before, after, and the secrets of the AppendLine]&]
[s0; &]
[s0; In todays text editors, when you type a new letter, it is trivial 
to see where in the text will the new letter go. This is so because 
the caret is always positioned between a pair of successive letters 
and thus is well defines the insertion spot. Additionally, the 
caret can be placed in front of the first letter or after the 
last letter, which naturally allows typing some text at the very 
beginning or end.&]
[s0; &]
[s0; When inserting new rows into the array controls, things are 
a bit more tricky. This is so because, unlike in the text editor, 
the cursor is not placed [/ between] two successive rows, but [/ over] 
a certain row. This is of course necessary to make row editing 
possible (note that in the aforementioned text editor analogy, 
a single letter is an atomic object whereas in the array it is 
a potentially complex structure consisting of many columns and 
data items). However, when it comes to row insertion, it has 
two main troubles as its implication:&]
[s0; &]
[s0;i150;O9; [* 1.]-|It is necessary to decide somehow whether the new 
row will go [/ above] or [/ below] the cursor row.&]
[s0;i150;O9; [* 2.]-|In an array with [/ n] rows, there are [/ n`+1] possible 
locations for a new row (before the row #0, #1 ... #([/ n`-1]) 
and after the last row), but only [/ n] distinct cursor locations.&]
[s0; &]
[s0; Over the years, during the development of U`+`+, we experimented 
with multiple ways to overcome these logical problems. As a result 
of this, the ArrayCtrl supports a few methods allowing to fine`-tune 
the row insertion mechanism. It is also worth noting that there 
are cases, like in the case of SQL`-based tables, where the row 
ordering is arbitrary or implicit and the exact `'location`' 
of a new row doesn`'t make any sense. In such cases, it is possible 
to replace array [/ insertion] function with the [/ append] function 
emphasizing the fact that the visual row order is unimportant 
and that insertion means merely adding a new record to the record 
set.&]
[s0; &]
[s0; For arrays in which the order is important, there are two ways 
to solve the [/ n`+1] row positions dilemma:&]
[s0; &]
[s0;i150;O9; [* 1.]-|Replacing the Insert function with a pair of functions 
for inserting a new row [/ before] / [/ after] the current row.&]
[s0;i150;O9; [* 2.]-|Visually extending the array by adding a pseudo`-row 
with no real data at its end; this creates the [/ n`+1]`-th cursor 
position necessary to denote all the available row insertion 
locations.&]
[s0; &]
[s0; In the first case, it is also possible to select which of the 
insertion functions (before / after) takes precedence (which 
of the two actions should be bound to the standard [* Insert] hotkey). 
This corresponds to the [* BeforeAfterInserting] and [* AfterBeforeInserting] 
methods. The second case is called the [* AppendLine] and is activated 
by setting the property with the same name.&]
[s0; &]
[s0; To make all this even more interesting, a special mechanism 
called [* InsertAppend] is available to make array filling as easy 
as possible. When activated and the user appends a new row at 
the table end, after pressing [* Enter] (to commit the inserted 
row) another row is automatically added after it and opened for 
editing. This mechanism is turned on by default, but it can be 
disable by setting the [* NoInsertAppend] property to true.&]
[s3; &]
[s0; &]
[s0; &]
[ {{10000t/25b/25@3 [s0; [*@(229)4 Categorized method summary]]}}&]
[s9; The following table summarizes ArrayCtrl methods according to 
the aspect of functionality they support together with a very 
brief description. For more thorough documentation of the individual 
methods see below.&]
[s0; &]
[ {{2337:7663-1 [s0; [* Initialization and configuration]]
:: [s0;%- ]
:: [s0; Reset]
:: [s0; clears column `& index definition and restores all ArrayCtrl 
default properties]
:: [s0; IsEdit]
:: [s0; true `= array state automaton is currently in row editing mode]
:: [s0; IsInsert]
:: [s0; true `= array state automaton is currently in row insertion 
mode]
:: [s0; SetLineCy]
:: [s0; sets array row height (global or individual for a single row)]
:: [s0; GetLineCy]
:: [s0; returns logical array row height (value set by preceding SetLineCy)]
:: [s0; GetLineY]
:: [s0; returns [/ y] position of given row (relative to table beginning)]
:: [s0; `[No`]AppendLine]
:: [s0; `[do not`] display an additional pseudo`-row used for row insertion]
:: [s0; IsAppendLine]
:: [s0; returns actual value of the [* AppendLine] property]
:: [s0; ShowAppendLine]
:: [s0; scrolls the table view to display the appending line]
:: [s0; `[No`]Inserting]
:: [s0; `[do not`] allow inserting new rows]
:: [s0; IsInserting]
:: [s0; returns actual value of the [* Inserting] property]
:: [s0; BeforeAfterInserting]
:: [s0; allow inserting rows before / after current row (default `= 
before)]
:: [s0; AfterBeforeInserting]
:: [s0; allow inserting rows before / after current row (default `= 
after)]
:: [s0; NoInsertAppend]
:: [s0; do not autoinsert another row after committing last row insertion]
:: [s0; IsEditing]
:: [s0; true `= (at least one column of the) ArrayCtrl supports editing]
:: [s0; `[No`]Duplicating]
:: [s0; `[do not`] allow row duplication]
:: [s0; IsDuplicating]
:: [s0; returns actual value of the [* Duplicating] property]
:: [s0; Appending]
:: [s0; allow appending new row at the table end]
:: [s0; IsAppending]
:: [s0; returns actual state of the [* Appending] property]
:: [s0; AutoAppending]
:: [s0; allow appending new row at the table end, Enter appends another 
one]
:: [s0; IsAutoAppending]
:: [s0; returns actual state of [* AutoAppending] property]
:: [s0; `[No`]Removing]
:: [s0; `[do not`] allow table row removing]
:: [s0; IsRemoving]
:: [s0; returns actual state of the [* Removing] property]
:: [s0; `[No`]AskRemove]
:: [s0; `[do not`] prompt user to confirm row removal]
:: [s0; IsAskRemove]
:: [s0; returns actual state of the [* AskRemove] property]
:: [s0; Moving]
:: [s0; allow row swapping (moving a row before / after neighbouring 
row)]
:: [s0; IsMoving]
:: [s0; returns actual state of the [* Moving] property]
:: [s0; `[No`]Header]
:: [s0; `[do not`] display table header]
:: [s0; `[No`]Track]
:: [s0; `[do not`] animate tracking table column widths]
:: [s0; `[No`]VertGrid]
:: [s0; `[do not`] display column breaks]
:: [s0; `[No`]HorzGrid]
:: [s0; `[do not`] display row breaks]
:: [s0; `[No`]Grid]
:: [s0; `[do not`] display both grids (VertGrid `+ HorzGrid)]
:: [s0; GridColor]
:: [s0; set grid line color]
:: [s0; EvenRowColor]
:: [s0; background color for even rows]
:: [s0; OddRowColor]
:: [s0; background color for odd rows]
:: [s0; RowFormat]
:: [s0; formats menu items substituting given word for the term `'row`']
:: [s0; RowName]
:: [s0; sets the context`-relevant word to substitute for `'row`' in 
the local menu texts]
:: [s0; NoCursor]
:: [s0; do not highlight cursor row]
:: [s0; `[No`]MouseMoveCursor]
:: [s0; automatically move cursor as the mouse moves (used e.g. in PopupTable)]
:: [s0; `[No`]AutoHideSb]
:: [s0; `[do not`] display scroll bar only when necessary]
:: [s0; MultiSelect]
:: [s0; enable selecting multiple rows at the same time]
:: [s0; ColumnWidths]
:: [s0; sets logical column widths using a formatted string, e.g. `"1 
5 10 10 5 1`"]}}&]
[s0; &]
[ {{2337:7663-1 [s0; [* Array index `& column structure management]]
:: [s0;%- ]
:: [s0; IndexInfo]
:: [s0; returns the [* IdInfo] structure describing an index (see below)]
:: [s0; AddIndex]
:: [s0; adds a new index to the source data matrix]
:: [s0; GetIndexCount]
:: [s0; returns number of index columns (columns in the source data 
matrix)]
:: [s0; GetId]
:: [s0; returns identifier of a given index (given by its integral index)]
:: [s0; GetPos]
:: [s0; returns integral index of source matrix column ([/ index]) identified 
by an [* Id]]
:: [s0; SetId]
:: [s0; sets the [* Id] identifier for a given index (column of the source 
matrix)]
:: [s0; AddKey]
:: [s0; sets up the first index to act as primary key (often used for 
SQL tables)]
:: [s0; GetKeyId]
:: [s0; returns primary key identifier (equal to [* GetId(0)])]
:: [s0; AddColumn]
:: [s0; adds a column`-index pair to the table (one data column, one 
output column)]
:: [s0; AddColumnAt]
:: [s0; adds a column bound to a given index]
:: [s0; AddRowNumColumn]
:: [s0; adds a column without an index (used for external data)]
:: [s0; GetColumnCount]
:: [s0; returns number of (visual) columns in the table]
:: [s0; FindColumnWithPos]
:: [s0; locates table column according to given index number]
:: [s0; FindColumnWithId]
:: [s0; locates table column according to index identifier]
:: [s0; ColumnAt]
:: [s0; returns the [* ArrayCtrl`::Column] structure describing given column]
:: [s0; HeaderTab]
:: [s0; returns the [* HeaderCtrl`::Column] structure for the given column]
:: [s0; HeaderObject]
:: [s0; returns a reference to the [* HeaderCtrl] object for this table]
:: [s0; SerializeHeader]
:: [s0; serialize header layout information (column widths etc.)]
:: [s0; AddCtrl]
:: [s0; adds an outer control`-index pair to the table (one data column, 
one outer Ctrl)]
:: [s0; AddCtrlAt]
:: [s0; adds an outer control bound to a given index]
:: [s0; AddRowNumCtrl]
:: [s0; adds an outer control without an index `- used ([/ seldom])  for 
external data]
:: [s0; SetDisplay]
:: [s0; sets display for a given table column or cell]
:: [s0; GetDisplay]
:: [s0; returns column / cell display]
:: [s0; SetCtrl]
:: [s0; sets a [* Ctrl] object for custom editing of a given cell]
:: [s0; GetTotalCy]
:: [s0; returns total row height]
:: [s0; GetLineAt]
:: [s0; locate table row when given an [/ y] position (relative to table 
top)]
:: [s0; GetClickColumn]
:: [s0; returns column number of last clicked column (Null if clicked 
outside existing rows)]
:: [s0; GetClickRow]
:: [s0; returns row number of last clicked row (Null if clicked outside 
existing rows)]
:: [s0; GetClickPos]
:: [s0; returns Point(GetClickColumn(), GetClickRow())]}}&]
[s0; &]
[ {{2337:7663-1 [s0; [* Data setting `& retrieval]]
:: [s0;%- ]
:: [s0; SetCount]
:: [s0; sets number of rows in the array]
:: [s0; SetVirtualCount]
:: [s0; sets number of rows in the array with external data]
:: [s0; GetCount]
:: [s0; returns number of rows]
:: [s0; Clear]
:: [s0; clears array data, identical to [* SetCount(0)]]
:: [s0; Shrink]
:: [s0; shrinks source data matrix to the minimum necessary size]
:: [s0; Get]
:: [s0; returns given Value element of the source data matrix]
:: [s0; GetOriginal]
:: [s0; returns given element of source data matrix before editing]
:: [s0; Set]
:: [s0; sets given element of the source data matrix]
:: [s0; GetKey]
:: [s0; returns given primary key (column #0 in the data matrix)]
:: [s0; GetOriginalKey]
:: [s0; returns `'old`' value of primary key before editing]
:: [s0; GetColumn]
:: [s0; returns value of a given output column (according to its index 
mapping)]
:: [s0; GetConvertedColumn]
:: [s0; returns value of a given output column after applying its [* Convert]]
:: [s0; ReadRow]
:: [s0; returns a row of the source data matrix]
:: [s0; Add]
:: [s0; adds a new row at the end of table]
:: [s0; Insert]
:: [s0; inserts a new row into the table]
:: [s0; Remove]
:: [s0; removes a given table row]
:: [s0; SwapUp]
:: [s0; exchanges a table row with the preceding row]
:: [s0; SwapDown]
:: [s0; exchanges a table row with the next row]
:: [s0; Sort]
:: [s0; sorts table rows using a given predicate]
:: [s0; ClearCache]
:: [s0; clears data conversion cache]
:: [s0; InvalidateCache]
:: [s0; invalidates given table row in the conversion cache]}}&]
[s0; &]
[ {{2337:7663-1 [s0; [* Cursor `& selection management]]
:: [s0;%- ]
:: [s0; GetSelectCount]
:: [s0; returns number of currently selected rows]
:: [s0; IsSelection]
:: [s0; checks whether any rows are selected (identical to [* GetSelectCount() 
> 0])]
:: [s0; Select]
:: [s0; selects / unselects given row or a series of rows]
:: [s0; IsSelected]
:: [s0; checks whether given row is selected]
:: [s0; ClearSelection]
:: [s0; clears the current selection]
:: [s0; SetCursor]
:: [s0; moves array cursor to a new row]
:: [s0; KillCursor]
:: [s0; removes the cursor away from the table]
:: [s0; CancelCursor]
:: [s0; cancels editing of current row]
:: [s0; IsCursor]
:: [s0; checks whether cursor is in the table (identical to [* GetCursor() 
>`= 0])]
:: [s0; GetCursor]
:: [s0; returns current cursor row, `-1 when none]
:: [s0; GoBegin]
:: [s0; moves the cursor to the first table row]
:: [s0; GoEnd]
:: [s0; moves the cursor to the last table row]
:: [s0; GetCursorSc]
:: [s0; returns the location of the cursor row within the table view 
area]
:: [s0; ScCursor]
:: [s0; scrolls the table to move the cursor row to given location within 
the table view]
:: [s0; CenterCursor]
:: [s0; scrolls the table to move cursor into the middle of the current 
view]
:: [s0; ScrollInto]
:: [s0; scrolls the table by minimum amount necessary to make given 
row visible]
:: [s0; ScrollIntoCursor]
:: [s0; scrolls the table by minimum amount necessary to make cursor 
row visible]
:: [s0; GetScroll]
:: [s0; returns current table scrollbar location]
:: [s0; ScrollTo]
:: [s0; sets table scrollbar location]
:: [s0; Find]
:: [s0; locates table row containing a given element]
:: [s0; FindSetCursor]
:: [s0; moves the cursor to table row containing a given element]}}&]
[s0;3 &]
[s0; &]
[s0; &]
[ {{2337:7663-1 [s0; [* GUI elements]]
:: [s0;%- ]
:: [s0; StdBar]
:: [s0; the default array local menu]
:: [s0; IsModified]
:: [s0; checks modification state of given array cell]
:: [s0; StartEdit]
:: [s0; open current array row for editing]
:: [s0; GetEditColumn]
:: [s0; returns the column being currently edited]
:: [s0; DoEdit]
:: [s0; corresponds to the local menu `'Edit`' function]
:: [s0; DoInsert]
:: [s0; corresponds to the local menu `'Insert`' function]
:: [s0; DoInsertBefore]
:: [s0; corresponds to the local menu `'Insert before`' function]
:: [s0; DoInsertAfter]
:: [s0; corresponds to the local menu `'Insert after`' function]
:: [s0; DoAppend]
:: [s0; corresponds to the local menu `'Append`' function]
:: [s0; DoRemove]
:: [s0; corresponds to the local menu `'Remove`' function]
:: [s0; DoDuplicate]
:: [s0; corresponds to the local menu `'Duplicate`' function]
:: [s0; DoSelectAll]
:: [s0; selects the entire array]
:: [s0; AcceptEnter]
:: [s0; commits the currently edited row and possibly begins insertion 
of another row]}}&]
[s0; &]
[ {{2337:7663-1 [s0; [* Notification callbacks]]
:: [s0;%- ]
:: [s0; WhenLeftClick]
:: [s0; left mouse click within the array]
:: [s0; WhenLeftDouble]
:: [s0; left mouse doubleclick within the array]
:: [s0; WhenSel]
:: [s0; called when cursor or selection status of widget changes]
:: [s0; WhenCursor]
:: [s0; called whenever the cursor location changes [/ (deprecated, use 
WhenSel)]]
:: [s0; WhenKillCursor]
:: [s0; called when the cursor moves away from the table [/ (deprecated, 
use WhenSel)]]
:: [s0; WhenSelection]
:: [s0; called whenever current selection changes [/ (deprecated, use 
WhenSel)]]
:: [s0; WhenEnterRow]
:: [s0; called whenever the cursor moves to a new row [/ (deprecated, 
use WhenSel)]]
:: [s0; WhenUpdateRow]
:: [s0; called after updating a row]
:: [s0; WhenAcceptRow]
:: [s0; additional row validation callback]
:: [s0; WhenStartEdit]
:: [s0; called after initiating row editing]
:: [s0; WhenAcceptEdit]
:: [s0; called after accepting changes to a given row]
:: [s0; WhenArrayAction]
:: [s0; called whenever array source data changes (after insert / delete 
/ edit)]
:: [s0; WhenBar]
:: [s0; can be used to supply custom local menu for the array]
:: [s0; WhenCtrlsAction]
:: [s0; called by [* WhenAction] callbacks of internally created controls]}}&]
[s3; &]
[s0; &]
[s0; &]
[s0; &]
[ {{10000t/25b/25@3 [s0; [*@(229)4 Detailed method description]]}}&]
[s0; &]
[s0; [* Initialization and configuration]&]
[s3; &]
[s0; &]
[s5;:ArrayCtrl`:`:Reset`(`): [@(0.0.255) void]_[* Reset]()&]
[s2; Clears table rows and resets all array properties to their default 
values.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ShowAppendLine`(`): [@(0.0.255) void]_[* ShowAppendLine]()&]
[s2; Show an additional pseudo`-row at the table end. When clicked, 
a new row is appended to the array.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:AcceptRow`(`):%- [@(0.0.255) bool]_[* AcceptRow]()&]
[s2; When there are slave widgets (connected using AddCtrl), the 
visible content of ArrayCtrl line is normally updated when cursor 
moves to another line (and the move is prevented if any slave 
widget has invalid value). This method tries to check for invalid 
values and updates the row immediately. Returns true if there 
were no invalid values in slave widgets.&]
[s3;%- &]
[s4; &]
[s5;:ArrayCtrl`:`:IsEdit`(`)const: [@(0.0.255) bool]_[* IsEdit]()_[@(0.0.255) const]&]
[s2; Checks whether the array is currently being edited.&]
[s7; [*/ Return value]-|[* true] `= a row is currently open for editing, 
[* false] `= array is in normal browsing mode&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsInsert`(`)const: [@(0.0.255) bool]_[* IsInsert]()_[@(0.0.255) const]&]
[s2; Checks whether a new row is currently being inserted.&]
[s7; [*/ Return value]-|[* true] `= newly inserted row is currently being 
edited, [* false] when not&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SetLineCy`(int`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* SetLineCy]([@(0.0.255) i
nt]_[*@3 cy])&]
[s2; Sets the (default) array row height. For certain rows, this 
can be overriden by the two`-parameter version of this method.&]
[s7; [*C@3 cy]-|row height in pixels&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:SetEditLineCy`(`):%- [_^Upp`:`:ArrayCtrl^ ArrayCtrl][@(0.0.255) `&
]_[* SetEditLineCy]()&]
[s2; Sets the default array row height such that EditField based 
editors comfortably fit into the ArrayCtrl.&]
[s3;%- &]
[s4; &]
[s5;:ArrayCtrl`:`:SetLineCy`(int`,int`): [@(0.0.255) void]_[* SetLineCy]([@(0.0.255) int]_[*@3 i
], [@(0.0.255) int]_[*@3 cy])&]
[s2; Sets row height for a given row. This overrides the default 
value set by the one`-parameter version of this method.&]
[s7; [*C@3 i]-|row index (zero based)&]
[s7; [*C@3 cy]-|row height in pixels, [* Null] `= use default row height&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetLineCy`(`)const: [@(0.0.255) int]_[* GetLineCy]()_[@(0.0.255) const]&]
[s2; Returns default array row height.&]
[s7; [*/ Return value]-|row height in pixels&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetLineY`(int`)const: [@(0.0.255) int]_[* GetLineY]([@(0.0.255) int]_[*@3 i
])_[@(0.0.255) const]&]
[s2; Returns [/ y] position of given array row (the pixel distance 
between the top of first array row and [/ i]`-th row, i.e. sum 
of heights of all rows above this row).&]
[s7; [*C@3 i]-|row index (zero based)&]
[s7; [*/ Return value]-|Vertical position of row top in pixels (relative 
to array beginning)&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetLineCy`(int`)const: [@(0.0.255) int]_[* GetLineCy]([@(0.0.255) int]_[*@3 i
])_[@(0.0.255) const]&]
[s2; Returns the height of a given row (either the row`-specific 
row height, or, when Null, the default row height).&]
[s7; [*C@3 i]-|row index (zero based)&]
[s7; [*/ Return value]-|row height in pixels&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AppendLine`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* AppendLine
]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; The AppendLine property controls whether the array displays 
an additional `'append`' row after its last (real) row. &]
[s7; [*C@3 b]-|[* true] `= display appending row, [* false] `= hide it&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoAppendLine`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoAppendLine
]()&]
[s2; Hide the appending line (identical to [* AppendLine(false)]).&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsAppendLine`(`)const: [@(0.0.255) bool]_[* IsAppendLine]()_[@(0.0.255) c
onst]&]
[s2; Returns current state of the [* AppendLine] property.&]
[s7; [*/ Return value]-|[* true] `= display appending pseudo`-row at the 
end of the array&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Inserting`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* Inserting](
[@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Enable / disable inserting new rows in the array (no matter 
which insertion mechanism is selected).&]
[s7; [*C@3 b]-|[* true] `= enable insertion, [* false] `= disable it&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoInserting`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoInserting](
)&]
[s2; Disables row insertion (identical to [* Inserting(false)]).&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsInserting`(`)const: [@(0.0.255) bool]_[* IsInserting]()_[@(0.0.255) con
st]&]
[s2; Returns current state of the [* Inserting] property.&]
[s7; [*/ Return value]-|[* true] `= row insertion is enabled, [* false] 
when not&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Appending`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* Appending](
[@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Enable / disable adding new rows at the table end.&]
[s7; [*C@3 b]-|[* true] `= enable row appending, [* false] `= disable it&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsAppending`(`)const: [@(0.0.255) bool]_[* IsAppending]()_[@(0.0.255) con
st]&]
[s2; Returns current state of the [* Appending] property.&]
[s7; [*/ Return value]-|[* true] `= appending rows is enabled, [* false] 
when not.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AutoAppending`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* AutoApp
ending]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Same as [* Appending] but Enter pressed when editing a new row 
accepts it and adds another one at the table end.&]
[s7; [*C@3 b]-|[* true ]to enable the mode&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsAutoAppending`(`)const: [@(0.0.255) bool]_[* IsAutoAppending]()_[@(0.0.255) c
onst]&]
[s2; Returns current state of [* AutoAppending] property.&]
[s7; [*/ Return value]-|[* true] `= [* AutoAppending ]is active&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:BeforeAfterInserting`(int`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* B
eforeAfterInserting]([@(0.0.255) int]_[*@3 q]_`=_[@3 1])&]
[s2; Activate before / after row insertion mechanism ([* Insert] hotkey 
`= before).&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AfterBeforeInserting`(int`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* A
fterBeforeInserting]([@(0.0.255) int]_[*@3 q]_`=_[@3 2])&]
[s2; Activate before / after row insertion mechanism ([* Insert] hotkey 
`= after)&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Duplicating`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* Duplicati
ng]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Enable / disable row duplication. Note that this property only 
controls whether the `'Duplicate`' item should be present in 
the array local menu. Of course, nothing can prevent you from 
supporting duplication in some other way, or from calling the 
[* DoDuplicate] method as you see fit.&]
[s7; [*C@3 b]-|[* true] `= enable duplication, [* false] `= disable it&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoDuplicating`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoDuplicati
ng]()&]
[s2; Disable row duplication (identical to [* Duplicating(false)]).&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsDuplicating`(`)const: [@(0.0.255) bool]_[* IsDuplicating]()_[@(0.0.255) c
onst]&]
[s2; Returns the state of the [* Duplicating] property.&]
[s7; [*/ Return value]-|[* true] `= local menu offers row duplication, 
[* false] when not&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoInsertAppend`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoInse
rtAppend]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Enables / disables the auto`-append mechanism (see above section 
on inserting rows).&]
[s7; [*C@3 b]-|[* true] `= disable InsertAppend mechanism, [* false] `= 
enable it (the default)&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsEditing`(`)const: [@(0.0.255) bool]_[* IsEditing]()_[@(0.0.255) const]&]
[s2; Checks whether at least one array column supports editing (whether 
it is possible to [/ open] a row for editing).&]
[s7; [*/ Return value]-|[* true] `= row editing is possible, [* false] when 
not&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Removing`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* Removing]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Enable / disable deleting rows from the table.&]
[s7; [*C@3 b]-|[* true] `= enable deletion, [* false] `= disable it&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoRemoving`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoRemoving]()&]
[s2; Disable deleting table rows (identical to [* Removing(false)]).&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsRemoving`(`)const: [@(0.0.255) bool]_[* IsRemoving]()_[@(0.0.255) const
]&]
[s2; Returns current state of the [* Removing] property.&]
[s7; [*/ Return value]-|[* true] `= row deletion is enabled, [* false ]when 
not&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AskRemove`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* AskRemove](
[@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Sets whether the user must manually confirm array row deletion. 
When set to [* true], every time a row is to be deleted, a confirmation 
dialog pops up. When set to [* false], rows are deleted automatically 
without any further confirmation.&]
[s7; [*C@3 b]-|[* true] `= prompt user to confirm row deletion, [* false] 
`= delete rows instantly&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoAskRemove`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoAskRemove](
)&]
[s2; Disables user confirmation of row deletion (equivalent to [* AskRemove(false)]).&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsAskRemove`(`)const: [@(0.0.255) bool]_[* IsAskRemove]()_[@(0.0.255) con
st]&]
[s2; Returns current state of the [* AskRemove] property.&]
[s7; [*/ Return value]-|[* true] `= user confirmation is needed to delete 
rows, [* false] `= rows are deleted immediately&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Moving`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* Moving]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Enable / disable row swapping. When set to [* true], it is possible 
to move an array row up and down by swapping it with the previous 
/ next row. This can be used to reorder array rows in a visually 
straightforward manner.&]
[s7; [*C@3 b]-|[* true] `= offer row moving in the local menu, [* false] 
`= don`'t&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsMoving`(`)const: [@(0.0.255) bool]_[* IsMoving]()_[@(0.0.255) const]&]
[s2; Returns current state of the [* Moving] property.&]
[s7; [*/ Return value]-|[* true] `= local menu supports row swapping, 
[* false] `= it doesn`'t&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Header`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* Header]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Show / hide the [*^topic`:`/`/CtrlLib`/src`/HeaderCtrl`$en`-us^ HeaderCtrl] 
object for this table.&]
[s7; [*C@3 b]-|[* true] `= show table header, [* false] `= hide it&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoHeader`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoHeader]()&]
[s2; Hide table header (equivalent to [* Header(false)]).&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Track`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* Track]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Animate array column resizing. This is equivalent to setting 
the [*^topic`:`/`/CtrlLib`/src`/HeaderCtrl`$en`-us`#`:`:HeaderCtrl`:`:Track`(bool`)^ T
rack] property in the array HeaderCtrl.&]
[s7; [*C@3 b]-|[* true] `= repaint the array repeatedly while dragging 
column widths, [* false] `= regenerate everything only after drag 
`& drop is finished.&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoTrack`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoTrack]()&]
[s2; Do not animate array column resizing (equivalent to [* Track(false)]).&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:VertGrid`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* VertGrid]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Show / hide vertical array grid lines (separating array columns).&]
[s7; [*C@3 b]-|[* true] `= show vertical grid lines, [* false] `= hide them&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoVertGrid`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoVertGrid]()&]
[s2; Hide vertical grid lines (equivalent to [* VertGrid(false)]).&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:HorzGrid`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* HorzGrid]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Show / hide horizontal grid lines (separating array rows).&]
[s7; [*C@3 b]-|[* true] `= show horizontal grid lines, [* false] `= hide 
them&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoHorzGrid`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoHorzGrid]()&]
[s2; Hide horizontal grid lines (equivalent to [* HorzGrid(false)]).&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Grid`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* Grid]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Show / hide both horizontal and vertical grid lines (equivalent 
to [* HorzGrid(b).VertGrid(b)]).&]
[s7; [*C@3 b]-|[* true] `= show grid line matrix, [* false] `= hide all 
grid lines&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoGrid`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoGrid]()&]
[s2; Hide horizontal and vertical grid lines (equivalent to [* Grid(false)]).&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GridColor`(Color`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* GridColor](
[_^Color^ Color]_[*@3 c])&]
[s2; Sets the color for grid lines.&]
[s7; [*C@3 c]-|new grid line color&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:EvenRowColor`(Color`,Color`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* E
venRowColor]([_^Color^ Color]_[*@3 paper]_`=_Blend(SColorMark, SColorPaper, 
[@3 220]), [_^Color^ Color]_[*@3 ink]_`=_SColorText)&]
[s2; Sets the paper and ink (background and foreground) color for 
even array rows. In certain cases setting a different background 
color for odd and even rows helps to simplify visual orientation 
in the arrays (especially when the array has many columns).&]
[s2; [* Note:] the even / odd row terminology refers to the natural 
array row numbering, so first array row is [/ odd] and the second 
is [/ even]. This is in contrast to the zero`-baesd integral row 
indexing, where the first array row has index 0.&]
[s7; [*C@3 paper]-|background color to use for second, fourth, sixth 
etc. array row&]
[s7; [*C@3 ink]-|foreground color for even rows&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:OddRowColor`(Color`,Color`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* O
ddRowColor]([_^Color^ Color]_[*@3 paper]_`=_SColorInfo, [_^Color^ Color]_[*@3 ink]_`=_SCo
lorText)&]
[s2; Sets the paper and ink (background and foreground) color for 
odd array rows.&]
[s7; [*C@3 paper]-|background color to use for first, third, fifth etc. 
array row&]
[s7; [*C@3 ink]-|foreground color for odd rows&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoCursor`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoCursor]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Turns on / off highlighting cursor row.&]
[s7; [*C@3 b]-|[* true] `= do not highlight cursor row, [* false] `= default 
behaviour (cursor row is shown in inverse colors)&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:MouseMoveCursor`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* Mouse
MoveCursor]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Enables / disables automatical cursor row switching as the mouse 
cursor moves over the array rows.&]
[s7; [*C@3 b]-|[* true] `= automatically switch cursor row, [* false] `= 
only upon clicks and keyboard navigation&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoMouseMoveCursor`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoMouse
MoveCursor]()&]
[s2; Disable automatical cursor row switching (equivalent to [* MouseMoveCursor(false)])
.&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AutoHideSb`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* AutoHideSb
]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; When set to [* true], the vertical scrollbar at the right array 
edge is displayed only when the total row height exceeds the 
array view height. When set to [* false], the scrollbar is shown 
all the time.&]
[s7; [*C@3 b]-|[* true] `= show / hide the scrollbar as necessary, [* false] 
`= display it unconditionally&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoAutoHideSb`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoAutoHideSb
]()&]
[s2; Display vertical scrollbar all the time (equivalent to [* AutoHideSb(false)]).&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:HideSb`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* HideSb]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Hides vertical scrollbar (even if it would be needed).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AutoHideHorzSb`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* AutoHi
deHorzSb]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Makes horizontal scroll bar (active if HeaderCtrl is in absolute 
mode only) to autohide. Default is on.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoAutoHideHorzSb`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoAutoHi
deHorzSb]()&]
[s2; Same as AutoHideHorzSb(false).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:HideHorzSb`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* HideHorzSb
]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Unconditionally hides horizontal scrollbar (active if HeaderCtrl 
is in absolute mode only).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:MultiSelect`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* MultiSele
ct]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Enable / disable multiple row selection. &]
[s7; [*C@3 b]-|[* true] `= allow selecting multiple rows at the same time, 
[* false] `= only one row at a time&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsMultiSelect`(`)const: [@(0.0.255) bool]_[* IsMultiSelect]()_[@(0.0.255) c
onst]&]
[s2; Returns true if ArrayCtrl is in multiselect mode.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoBackground`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoBackgr
ound]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Sets the widget into transparent mode `- background is not painted 
and Transparent is activated `- a result, anything painted behind 
the widget is visible, allowing client code to provide any background 
it needs.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:PopUpEx`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* PopUpEx]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Activates showing small popup windows with cell content when 
mouse is over and cell is to big to fit current dimensions. Default 
is activated.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoPopUpEx`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoPopUpEx]()&]
[s2; Same as PopUpEx(false).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoFocusSetCursor`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoFocusS
etCursor]()&]
[s2; Normally, when ArrayCtrl gets a focus and no cursor is set (and 
cursor is allowed and there is at least one line), ArrayCtrl 
a sets the cursor to the first line. This modifier deactivates 
this feature.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:MovingHeader`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* MovingHe
ader]([@(0.0.255) bool]_[*@3 b])&]
[s2; Activates dragging columns in header. Default is active.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoMovingHeader`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoMovingHe
ader]()&]
[s2; Same as MovingHeader(false).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ColumnSortFindKey`(bool`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* Col
umnSortFindKey]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; Before ColumnSort orders the ArrayCtrl, the key of current row 
(with cursor) is stored and after sorting, it is restored.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AllSorting`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* AllSorting]()&]
[s2; If set, Sorting() is invoked for all columns (added either before 
or after this modifier is called).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ColumnSortSecondary`(const ArrayCtrl`:`:Order`&`): [_^ArrayCtrl^ Arra
yCtrl][@(0.0.255) `&]_[* ColumnSortSecondary]([@(0.0.255) const]_[_^ArrayCtrl`:`:Order^ O
rder][@(0.0.255) `&]_[*@3 order])&]
[s2; Sets secondary sorting predicate for column sorts (see ColumnSort, 
Sorting) `- if two cells are equal when performing sort by column, 
they are ordered by this predicate.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoColumnSortSecondary`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoC
olumnSortSecondary]()&]
[s2; Removes secondary sorting predicate..&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:SortingFrom`(int`):%- [_^Upp`:`:ArrayCtrl^ ArrayCtrl][@(0.0.255) `&
]_[* SortingFrom]([@(0.0.255) int]_[*@3 from])&]
[s2; When ArrayCtrl is sorted (without specifying the range of lines), 
specifies the first column sorted. This allows for easy header 
or summation line.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ColumnWidths`(const char`*`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* C
olumnWidths]([@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 s])&]
[s2; Initializes column widths based on a text string containing 
blank`-separated decimal numbers, e.g. `"1 4 6 4 1`".&]
[s7; [*C@3 s]-|control string defining column widths&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetColumnWidths`(`): [_^String^ String]_[* GetColumnWidths]()&]
[s2; Returns current column widths in format compatible with ColumnWidths.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:CursorOverride`(const Image`&`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&
]_[* CursorOverride]([@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 arrow])&]
[s2; Overrides mouse cursor to [*@3 arrow]. Setting Null ends override.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:NoCursorOverride`(`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* NoCursor
Override]()&]
[s2; Same as CursorOverride(Null).&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:SpanWideCells`(bool`):%- [_^Upp`:`:ArrayCtrl^ ArrayCtrl][@(0.0.255) `&
]_[* SpanWideCells]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2; In this mode, if cell content (as defined by Display`::GetStdSize) 
is wider than cell width and next cell is Null (empty), the cell 
width is extended to span over the next cell (just like in common 
spreadsheet applications). ArrayCtrl header must no be in Moving 
mode for correct operation. Returns `*this.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:RowFormat`(const char`*`): [_^String^ String]_[* RowFormat]([@(0.0.255) c
onst]_[@(0.0.255) char]_`*[*@3 s])&]
[s2; Formats a text by substituting [* %s] with the array`-specific 
term for `'row`' (as set by the [* RowName] property). This is 
used for array local menu items. Returns `*this.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:RowName`(const char`*`): [_^ArrayCtrl^ ArrayCtrl][@(0.0.255) `&]_[* RowNa
me]([@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 s])&]
[s2; Sets the array`-specific term for `'row`'. This can be used 
to customize the local menu terminology according to the logical 
content of the array. For instance, when you have an array with 
the list of employees, you can call [* RowName(`"employee`")] and 
the menu items will then read [/ `'Insert new employee`', `'Delete 
employee`'] etc.&]
[s7; [*C@3 s]-|the term to substitute for `'array row`' in menu items&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s0;* &]
[s0; [* Column structure programming]&]
[s3; &]
[s0; &]
[s5;:ArrayCtrl`:`:IndexInfo`(int`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&]_[* Index
Info]([@(0.0.255) int]_[*@3 ii])&]
[s2; Returns a reference to the [* IdInfo] structure describing a given 
array index (column in the source data matrix).&]
[s7; [*C@3 ii]-|zero`-based ordinal number of the array index&]
[s7; [*/ Return value]-|IdInfo reference for the given index&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IndexInfo`(const Id`&`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&]_
[* IndexInfo]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id])&]
[s2; Returns a reference to the [* IdInfo] structure describing a given 
array index.&]
[s7; [*C@3 id]-|the [* Id] index identifier&]
[s7; [*/ Return value]-|IdInfo reference for the given index&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddIndex`(const Id`&`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&]_
[* AddIndex]([@(0.0.255) const] [_^Id^ Id]`&_[*@3 id])&]
[s2; Adds a new index to the array and assign it a given [* Id] identifier.&]
[s7; [*C@3 id]-|new index identifier&]
[s7; [*/ Return value]-|A reference to the [* IdInfo ]structure describing 
the newly added index. The reference can be used to set additional 
index properties.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddIndex`(`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&]_[* AddIndex](
)&]
[s2; Adds a new index (without an identifier) to the array.&]
[s7; [*/ Return value]-|A reference to the [* IdInfo] structure describing 
the newly added index.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetIndexCount`(`)const: [@(0.0.255) int]_[* GetIndexCount]()_[@(0.0.255) c
onst]&]
[s2; Returns number of indices in the array.&]
[s7; [*/ Return value]-|index count&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetId`(int`)const: [_^Id^ Id]_[* GetId]([@(0.0.255) int]_[*@3 ii])_[@(0.0.255) c
onst]&]
[s2; Returns the identifier of a given index (addresses by its zero`-based 
ordinal number).&]
[s7; [*C@3 ii]-|zero`-based ordinal number of the queried index&]
[s7; [*/ Return value]-|index identifier or [* Null] if the index has 
no identifier&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetPos`(const Id`&`)const: [@(0.0.255) int]_[* GetPos]([@(0.0.255) const 
][_^Id^ Id]`&_[*@3 id])_[@(0.0.255) const]&]
[s2; Returns the zero`-based positional number of the array index 
with a given identifier.&]
[s7; [*C@3 id]-|array index identifier&]
[s7; [*/ Return value]-|zero`-based index number, `-1 when not found&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SetId`(int`,const Id`&`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&
]_[* SetId]([@(0.0.255) int]_[*@3 ii], [@(0.0.255) const ][_^Id^ Id]`&_[*@3 id])&]
[s2; Sets the identifier for a given array index. This can be used 
to set or modify the identifier for a previously added index.&]
[s7; [*C@3 ii]-|zero`-based ordinal number of the index to set the identifier 
for&]
[s7; [*C@3 id]-|new index identifier ([* Null] when none)&]
[s7; [*/ Return value]-|A reference to the [* IdInfo] descriptive structure 
for the [/ ii]`-th index. The reference can be used to set additional 
properties of the altered index.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddKey`(const Id`&`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&]_[* A
ddKey]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id])&]
[s2; Adds a [/ primary key] index to the table. The [/ primary key] is 
just another name for the first index (index with ordinal number 
0). This is just a handy convention often used for SQL`-based 
tables. [* AddKey] must be called only once after array initialization 
or [* Reset] and before calling any other functions adding indices 
(like [* AddIndex], [* AddColumn] or [* AddCtrl]). When [* GetIndexCount() 
> 0 ]before the call to this function, this method fails with 
an [* ASSERT].&]
[s7; [*C@3 id]-|primary key identifier&]
[s7; [*/ Return value]-|A reference to the descriptive [* IdInfo] structure 
for the primary key index.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddKey`(`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&]_[* AddKey]()&]
[s2; Adds a primary key index without an identifier to the table. 
This is equivalent to [* AddKey(Null)].&]
[s7; [*/ Return value]-|A reference to the [* IdInfo] structure describing 
the primary key index.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetKeyId`(`)const: [_^Id^ Id]_[* GetKeyId]()_[@(0.0.255) const]&]
[s2; Returns primary key identifier for this table. This is equivalent 
to calling [* GetId(0)].&]
[s7; [*/ Return value]-|primary key index identifier&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddColumn`(const char`*`,int`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&
]_[* AddColumn]([@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 text]_`=_NULL, 
[@(0.0.255) int]_[*@3 w]_`=_[@3 0])&]
[s2; Add a new column`-index pair to the table. The function adds 
a (source) index and an (output) column and sets the index as 
the data source for the column. This is the most common method 
for adding columns to the array.&]
[s7; [*C@3 text]-|column name (displayed in the array header)&]
[s7; [*C@3 w]-|logical relative column width&]
[s7; [*/ Return value]-|A reference to the [* Column] structure describing 
the newly added column. This can be used to set additional properties 
for the newly added column and the corresponding header tab.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddColumn`(const Id`&`,const char`*`,int`): [_^ArrayCtrl`:`:Column^ C
olumn][@(0.0.255) `&]_[* AddColumn]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id], 
[@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 text], [@(0.0.255) int]_[*@3 w]_`=_[@3 0])&]
[s2; Adds a new column`-index pair to the table. This is equivalent 
to the above two`-parameter version but, in addition, the method 
sets the [* Id] identifier for the newly created index.&]
[s7; [*C@3 id]-|new index identifier&]
[s7; [*C@3 text]-|column name (displayed in the header)&]
[s7; [*C@3 w]-|logical relative column width&]
[s7; [*/ Return value]-|A reference to the [* Column] structure describing 
the newly added array column.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddColumnAt`(int`,const char`*`,int`): [_^ArrayCtrl`:`:Column^ Column
][@(0.0.255) `&]_[* AddColumnAt]([@(0.0.255) int]_[*@3 ii], [@(0.0.255) const]_[@(0.0.255) ch
ar]_`*[*@3 text], [@(0.0.255) int]_[*@3 w]_`=_[@3 0])&]
[s2; Adds a new column to the table and binds it to a given source 
data index.&]
[s7; [*C@3 ii]-|zero`-based ordinal number of the index to use as source 
for this column&]
[s7; [*C@3 text]-|column name (displayed in the header)&]
[s7; [*C@3 w]-|logical relative column width&]
[s7; [*/ Return value]-|A reference to the [* Column] structure describing 
the newly added array column.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddColumnAt`(const Id`&`,const char`*`,int`): [_^ArrayCtrl`:`:Column^ C
olumn][@(0.0.255) `&]_[* AddColumnAt]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id], 
[@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 text], [@(0.0.255) int]_[*@3 w]_`=_[@3 0])&]
[s2; Adds a new column to the table and binds it to a given source 
data index.&]
[s7; [*C@3 id]-|identifier of the index to use as source for the newly 
added column&]
[s7; [*C@3 text]-|column name (displayed in the header)&]
[s7; [*C@3 w]-|logical relative column width&]
[s7; [*/ Return value]-|A reference to the [* Column] structure describing 
the newly added array column.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddRowNumColumn`(const char`*`,int`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&
]_[* AddRowNumColumn]([@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 text], 
[@(0.0.255) int]_[*@3 w]_`=_[@3 0])&]
[s2; Adds a new column to the table. The newly added column has no 
source index, it is assumed to have an external data source. 
Instead of the source data [* Value] object, the current zero`-based 
row number is passed to the column`'s [* Convert] / [* Display]. 
This allows the host application to decode somehow the external 
data based on the row number. In the current U`+`+ version, the 
[/ RowNum columns] cannot be edited (using the standard array inline 
editing mechanism).&]
[s7; [*C@3 text]-|column name (displayed in the header)&]
[s7; [*C@3 w]-|logical relative column width&]
[s7; [*/ Return value]-|A reference to the [* Column] structure describing 
the newly added array column.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddCtrl`(Ctrl`&`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&]_[* AddC
trl]([_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 ctrl])&]
[s2; Adds a new index`-control pair to the table; the index keeps 
the source data and the external control is used to edit it. 
The ArrayCtrl handles data transfer between the source data matrix 
and the external control. The method returns a reference the 
[* IdInfo] descriptive structure for the newly added index.&]
[s2; [* Note:] it is good to keep in mind that there are a few differences 
between the ordinary array cell editors and the freestanding 
edit controls. In contrast with the cell editors, which appear 
only when the row is opened for editing, the freestanding controls 
are present all the time. For instance, the ArrayCtrl automatically 
disables the controls when the cursor moves away from the table 
(using [* KillCursor]) and re`-enables them after it comes back. 
This is important e.g. if you want to implement an additional 
logic enabling some of the controls only depending on the circumstances; 
in such case, you have to use one of the notification callbacks 
(like  [* WhenEnterRow]) to force your additional behaviour on 
the controls.&]
[s7; [*C@3 ctrl]-|control to attach to the given index&]
[s7; [*/ Return value]-|a reference to the IdInfo structure describing 
the newly added index&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddCtrl`(const Id`&`,Ctrl`&`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&
]_[* AddCtrl]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id], [_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 ctrl
])&]
[s2; Adds a new index`-control pair to the table. This is identical 
to the above version with the only difference that the newly 
added index is assigned an [* Id] identifier at the same time.&]
[s7; [*C@3 id]-|the identifier to assign to the newly created index&]
[s7; [*C@3 ctrl]-|freestanding control used to edit the given index&]
[s7; [*/ Return value]-|a reference to the IdInfo structure describing 
the newly added index&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddIdCtrl`(Ctrl`&`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&]_[* Ad
dIdCtrl]([_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 ctrl])&]
[s2; Same as AddCtrl(ctrl.GetLayoutId(), ctrl). Helpful when adding 
dialog widgets whose id is the same as widget`'s variable id.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddCtrlAt`(int`,Ctrl`&`): [@(0.0.255) void]_[* AddCtrlAt]([@(0.0.255) int
]_[*@3 ii], [_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 ctrl])&]
[s2; Adds a new control to the table and binds it to the index with 
given ordinal number. You can use this method to create the binding 
between the control and an arbitrary source index.&]
[s7; [*C@3 ii]-|zero`-based ordinal number of the index to bind to this 
control&]
[s7; [*C@3 ctrl]-|freestanding control used to edit the [/ ii]`-th data 
index&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddCtrlAt`(const Id`&`,Ctrl`&`): [@(0.0.255) void]_[* AddCtrlAt]([@(0.0.255) c
onst ][_^Id^ Id]`&_[*@3 id], [_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 ctrl])&]
[s2; Adds a new control to the table and binds it to the index with 
given identifier.&]
[s7; [*C@3 id]-|identifier of the index to bind to this control&]
[s7; [*C@3 ctrl]-|freestanding control used to edit the index with identifier 
[/ id]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddRowNumCtrl`(Ctrl`&`): [@(0.0.255) void]_[* AddRowNumCtrl]([_^Ctrl^ Ctr
l][@(0.0.255) `&]_[*@3 ctrl])&]
[s2; Adds a new freestanding control to the table. The control is 
not bound to any source data index. During cursor movement in 
the array, array uses the control`'s [* SetData] method to set 
it to the current row number. The control must be ready for that 
and it can use the row number value to decode some externally 
located data for display. In the current U`+`+ version, such 
controls cannot be used for editing (there is currently no clean 
way to store the edited data back to its external storage).&]
[s7; [*C@3 ctrl]-|[/ RowNum]`-based freestanding editor control&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetColumnCount`(`)const: [@(0.0.255) int]_[* GetColumnCount]()_[@(0.0.255) c
onst]&]
[s2; Returns the current number of (output) columns in the array.&]
[s7; [*/ Return value]-|number of columns&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:FindColumnWithPos`(int`)const: [@(0.0.255) int]_[* FindColumnWithPos]([@(0.0.255) i
nt]_[*@3 pos])_[@(0.0.255) const]&]
[s2; Returns the zero`-based index of a first column based on its 
source data index or `-1 if not found. Note that there could 
be multiple columns linked with single source `- in that case 
the function returns the index of first one found. Use FindColumnsWithPos 
if you need them all.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:FindColumnWithId`(const Id`&`)const: [@(0.0.255) int]_[* FindColumnWith
Id]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id])_[@(0.0.255) const]&]
[s2; Returns the zero`-based index of a first column based on its 
source data Id or `-1 if not found. Note that there could be 
multiple columns linked with single source `- in that case the 
function returns the index of first one found. Use FindColumnsWithId 
if you need them all.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:FindColumnsWithPos`(int`)const:%- [_^Upp`:`:Vector^ Vector]<[@(0.0.255) i
nt]>_[* FindColumnsWithPos]([@(0.0.255) int]_[*@3 pos])_[@(0.0.255) const]&]
[s2; Returns the zero`-based indices of all columns based on its 
source data index or `-1 if not found.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:FindColumnsWithId`(const Upp`:`:Id`&`)const:%- [_^Upp`:`:Vector^ V
ector]<[@(0.0.255) int]>_[* FindColumnsWithId]([@(0.0.255) const]_[_^Upp`:`:Id^ Id][@(0.0.255) `&
]_[*@3 id])_[@(0.0.255) const]&]
[s2; Returns the zero`-based indices of all columns based on its 
source data [%-*@3 id] or `-1 if not found.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ColumnAt`(int`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&]_[* Column
At]([@(0.0.255) int]_[*@3 i])&]
[s2; Returns the [* Column] structure describing a given column.&]
[s7; [*C@3 i]-|zero`-based column index&]
[s7; [*/ Return value]-|a reference to the [* Column] structure describing 
the given column&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ColumnAt`(const Id`&`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&]_
[* ColumnAt]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id])&]
[s2; Returns the [* Column] structure describing a given column.&]
[s7; [*C@3 i]-|zero`-based column index&]
[s7; [*/ Return value]-|a constant reference to the [* Column] structure 
describing the given column&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ColumnAt`(int`)const: [@(0.0.255) const]_[_^ArrayCtrl`:`:Column^ Column
][@(0.0.255) `&]_[* ColumnAt]([@(0.0.255) int]_[*@3 i])_[@(0.0.255) const]&]
[s2; Returns the [* Column] structure describing a column with given 
source index. This is merely the const version of the above method; 
it can be used to query properties for the column.&]
[s7; [*C@3 id]-|identifier of the index used as source for the column&]
[s7; [*/ Return value]-|a reference to the [* Column] structure describing 
the given column&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ColumnAt`(const Id`&`)const: [@(0.0.255) const]_[_^ArrayCtrl`:`:Column^ C
olumn][@(0.0.255) `&]_[* ColumnAt]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id])_[@(0.0.255) cons
t]&]
[s2; Returns a constant reference to the [* Column] structure describing 
a column with given source index. This is the constant version 
of the above method; it can be used to query properties for the 
column.&]
[s7; [*C@3 id]-|identifier of the index used as source for the column&]
[s7; [*/ Return value]-|a constant reference to the [* Column] structure 
describing the given column&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:HeaderTab`(int`): [_^HeaderCtrl`:`:Column^ HeaderCtrl`::Column][@(0.0.255) `&
]_[* HeaderTab]([@(0.0.255) int]_[*@3 i])&]
[s2; Returns the [*^topic`:`/`/CtrlLib`/src`/HeaderCtrl`$en`-us`#`:`:HeaderCtrl`:`:Column`:`:Min`(int`)^ H
eaderCtrl`::Column] descriptive structure for the given column. 
The correspondence between the array columns and the header tabs 
is 1:1, so that the indices of both are always the same ([* array.GetColumnCount() 
`=`= array.HeaderObject().GetCount()] holds all the time).&]
[s7; [*C@3 i]-|zero`-based column index&]
[s7; [*/ Return value]-|a reference to the [* HeaderCtrl`::Column] structure. 
This can be used to set additional properties of the header column 
(e.g. column width constraints, font and icon for the column 
title etc.)&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:HeaderTab`(int`)const: [@(0.0.255) const]_[_^HeaderCtrl`:`:Column^ Head
erCtrl`::Column][@(0.0.255) `&]_[* HeaderTab]([@(0.0.255) int]_[*@3 i])_[@(0.0.255) const]&]
[s2; Returns a constant reference to the [* HeaderCtrl`::Column] structure 
for the given column.&]
[s7; [*C@3 i]-|zero`-based column index&]
[s7; [*/ Return value]-|a reference to the [* HeaderCtrl`::Column] structure. 
This can be used to set additional properties of the header column 
(e.g. column width constraints, font and icon for the column 
title etc.)&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:HeaderTab`(const Id`&`): [_^HeaderCtrl`:`:Column^ HeaderCtrl`::Column][@(0.0.255) `&
]_[* HeaderTab]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id])&]
[s2; Returns the [* HeaderCtrl`::Column] descriptive structure for the 
column bound to a given source index.&]
[s7; [*C@3 id]-|identifier of the index used as source for the column&]
[s7; [*/ Return value]-|a reference to the [* HeaderCtrl`::Column] structure&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:HeaderTab`(const Id`&`)const: [@(0.0.255) const]_[_^HeaderCtrl`:`:Column^ H
eaderCtrl`::Column][@(0.0.255) `&]_[* HeaderTab]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id])_[@(0.0.255) c
onst]&]
[s2; Returns a constant reference to the [* HeaderCtrl`::Column] descriptive 
structure for the column bound to a given source index.&]
[s7; [*C@3 id]-|identifier of the index used as source for the column&]
[s7; [*/ Return value]-|a constant reference to the [* HeaderCtrl`::Column] 
structure&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:HeaderObject`(`)const: [@(0.0.255) const]_[_^HeaderCtrl^ HeaderCtrl][@(0.0.255) `&
]_[* HeaderObject]()_[@(0.0.255) const]&]
[s2; Returns a non`-constant reference to the [* HeaderCtrl] object 
for this table. The reference can be further used to alter properties 
of the table header (tab visibility, header visual mode and so 
on).&]
[s7; [*/ Return value]-|A non`-constant reference to the table HeaderCtrl 
object.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:HeaderObject`(`): [_^HeaderCtrl^ HeaderCtrl][@(0.0.255) `&]_[* HeaderObje
ct]()&]
[s2; This is just the constant version of the above method; when 
called on a constant [* ArrayCtrl] reference, it returns a constant 
reference to its underlying HeaderCtrl object which can be then 
used to query additional header information.&]
[s7; [*/ Return value]-|A constant reference to the table HeaderCtrl 
object.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SerializeHeader`(Stream`&`): [@(0.0.255) void]_[* SerializeHeader]([_^Stream^ S
tream][@(0.0.255) `&]_[*@3 s])&]
[s2; Serializes all information pertaining to the array header (mainly 
the user`-set column widths). This is equivalent to calling [* HeaderObject().Seria
lize(s)]. The main purpose of this function is to allow storing 
header configuration to be restored upon opening the dialog or 
the application for the next time. This function is now deprecated 
in favor of SerializeSettings.&]
[s7; [*C@3 s]-|the [*^topic`:`/`/Core`/src`/Stream`$en`-us^ Stream] object 
to serialize the header to/from&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SerializeSettings`(Stream`&`): [@(0.0.255) void]_[* SerializeSettings](
[_^Stream^ Stream][@(0.0.255) `&]_[*@3 s])&]
[s2; Serializes all information pertaining to the array header (mainly 
the user`-set column widths) and the setting of sort column. 
The main purpose of this function is to allow storing configuration 
to be restored upon opening the dialog or the application for 
the next time.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SetDisplay`(int`,int`,const Display`&`): [@(0.0.255) void]_[* SetDispla
y]([@(0.0.255) int]_[*@3 i], [@(0.0.255) int]_[*@3 col], [@(0.0.255) const]_[_^Display^ Displ
ay][@(0.0.255) `&]_[*@3 d])&]
[s2; Sets the [* Display] object for a given array cell.&]
[s2;* &]
[s2; [* Note:] the ownership to the Display object is not transferred 
by this call. The ArrayCtrl stores a mere pointer to it and it 
is the responsibility of the programmer to keep the Display object 
alive as long as necessary (until the array is shut down or the 
cell display changed via another call to SetDisplay). In fact, 
most Display`-based objects don`'t support data copying at all. 
In any case, copying Displays is not a very good practice and 
is very prone to slicing (as most actual Displays are actually 
derived classes with additional data members).&]
[s2; &]
[s2; In many cases it would be relatively safe to assume that the 
Display is not used unless the array is actually painted (e.g., 
when the control is not bound to a parent or when its view has 
zero size), but it is not a very wise practice and it can fail 
in very weird ways under special circumstances (like making screenshots 
or graphical exports from the array control).&]
[s2; &]
[s7; [*C@3 i]-|zero`-based row index&]
[s7; [*C@3 j]-|zero`-based column index&]
[s7; [*C@3 d]-|display to use&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:SetRowDisplay`(int`,const Upp`:`:Display`&`):%- [@(0.0.255) vo
id]_[* SetRowDisplay]([@(0.0.255) int]_[*@3 i], [@(0.0.255) const]_[_^Upp`:`:Display^ Displ
ay][@(0.0.255) `&]_[*@3 d])&]
[s2; Sets Display [%-*@3 d] for each cell of line [%-*@3 i].&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:SetColumnDisplay`(int`,const Upp`:`:Display`&`):%- [@(0.0.255) v
oid]_[* SetColumnDisplay]([@(0.0.255) int]_[*@3 j], [@(0.0.255) const]_[_^Upp`:`:Display^ D
isplay][@(0.0.255) `&]_[*@3 d])&]
[s2; Sets Display [%-*@3 d] for each cell of column j.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetDisplay`(int`,int`): [@(0.0.255) const]_[_^Display^ Display][@(0.0.255) `&
]_[* GetDisplay]([@(0.0.255) int]_[*@3 row], [@(0.0.255) int]_[*@3 col])&]
[s2; Returns a reference to the Display object for the given array 
cell.&]
[s7; [*C@3 row]-|zero`-based row index&]
[s7; [*C@3 col]-|zero`-based column index&]
[s7; [*/ Return value]-|a reference to the Display object.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetDisplay`(int`): [@(0.0.255) const]_[_^Display^ Display][@(0.0.255) `&]_
[* GetDisplay]([@(0.0.255) int]_[*@3 col])&]
[s2; Returns a reference to the Display object for the given array 
column.&]
[s7; [*C@3 col]-|zero`-based column index&]
[s7; [*/ Return value]-|constant reference to the column Display&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SetCtrl`(int`,int`,Ctrl`&`,bool`): [@(0.0.255) void]_[* SetCtrl]([@(0.0.255) i
nt]_[*@3 i], [@(0.0.255) int]_[*@3 col], [_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 ctrl], 
[@(0.0.255) bool]_[*@3 value]_`=_[@(0.0.255) true])&]
[s2; Sets an external control to use as the editor for a single array 
cell. Naturally, the same Ctrl object cannot be used as the editor 
for multiple array cells. If the position of Ctrl is equivalent 
to `'SetRect(0, 0, 0, 0)`', which is the default value, Ctrl 
is resized to fit the ArrayCtrl cell accurately, spanning the 
whole width and using STDSIZE for height, otherwise the position 
represents the position within the cell. If [*@3 value] is true, 
then the Ctrl represents the value of the cell, otherwise it 
is independent of it.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetCtrl`(int`,int`): [_^Ctrl^ Ctrl]_`*[* GetCtrl]([@(0.0.255) int]_[*@3 i],
 [@(0.0.255) int]_[*@3 col])&]
[s2; Returns a pointer to a ctrl at row [*@3 i] and column [*@3 col ]if 
there is any, NULL otherwise.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:CreateCtrl`(int`,int`,bool`): [@(0.0.255) template]_<[@(0.0.255) class]_
[*@4 T]>_[*@4 T][@(0.0.255) `&]_[* CreateCtrl]([@(0.0.255) int]_[*@3 i], 
[@(0.0.255) int]_[*@3 col], [@(0.0.255) bool]_[*@3 value]_`=_[@(0.0.255) true])&]
[s2; Creates an control (owned by ArrayCtrl) for a single array cell. 
If [*@3 value] is true, then the Ctrl represents the value of the 
cell, otherwise it is independent of it. If the position of Ctrl 
is equivalent to `'SetRect(0, 0, 0, 0)`', which is the default 
value, Ctrl is resized to fit the ArrayCtrl cell accurately, 
spanning the whole width and using STDSIZE for height, otherwise 
the position represents the position within the cell. &]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetTotalCy`(`)const: [@(0.0.255) int]_[* GetTotalCy]()_[@(0.0.255) const]&]
[s2; Returns total height of the array (sum of the individual line 
heights for all array rows)&]
[s7; [*/ Return value]-|array height in pixels&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetLineAt`(int`)const: [@(0.0.255) int]_[* GetLineAt]([@(0.0.255) int]_[*@3 y
])_[@(0.0.255) const]&]
[s2; Locates the array row according to given [/ y] coordinate (such 
array row [/ r] for which [* GetLineY(r) <`= y `&`& GetLineY(r) `+ 
GetLineCy(r) > y]).&]
[s7; [*C@3 y]-|vertical pixel coordinate to locate&]
[s7; [*/ Return value]-|zero`-based row number or `-1 when not found&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:SetLineColor`(int`,Upp`:`:Color`):%- [@(0.0.255) void]_[* SetLin
eColor]([@(0.0.255) int]_[*@3 i], [_^Upp`:`:Color^ Color]_[*@3 c])&]
[s2; Sets the background color of line [%-*@3 i] to [%-*@3 c].&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:GetCellRect`(int`,int`)const:%- [_^Upp`:`:Rect^ Rect]_[* GetCell
Rect]([@(0.0.255) int]_[*@3 i], [@(0.0.255) int]_[*@3 col])_[@(0.0.255) const]&]
[s2; Returns rectangle of cell at [%-*@3 i],[%-*@3  col] in view coordinates. 
Cell left and right margins are included in rectangle.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:GetCellRectM`(int`,int`)const:%- [_^Upp`:`:Rect^ Rect]_[* GetCel
lRectM]([@(0.0.255) int]_[*@3 i], [@(0.0.255) int]_[*@3 col])_[@(0.0.255) const]&]
[s2; Returns rectangle of cell at [%-*@3 i],[%-*@3  col] in view coordinates. 
Cell left and right margins are not included in rectangle.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:GetScreenCellRect`(int`,int`)const:%- [_^Upp`:`:Rect^ Rect]_[* G
etScreenCellRect]([@(0.0.255) int]_[*@3 i], [@(0.0.255) int]_[*@3 col])_[@(0.0.255) const]&]
[s2; Returns rectangle of cell at [%-*@3 i],[%-*@3  col] in screen coordinates. 
Cell left and right margins are included in rectangle.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:GetScreenCellRectM`(int`,int`)const:%- [_^Upp`:`:Rect^ Rect]_[* G
etScreenCellRectM]([@(0.0.255) int]_[*@3 i], [@(0.0.255) int]_[*@3 col])_[@(0.0.255) const]&]
[s2; Returns rectangle of cell at [%-*@3 i],[%-*@3  col] in screen coordinates. 
Cell left and right margins are not included in rectangle.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetClickColumn`(`)const: [@(0.0.255) int]_[* GetClickColumn]()_[@(0.0.255) c
onst]&]
[s2; Returns column index of the last clicked column in the array. 
If the click happens past the last row of array, returns Null.&]
[s7; [*/ Return value]-|zero`-based index of the relevant column&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetClickRow`(`)const: [@(0.0.255) int]_[* GetClickRow]()_[@(0.0.255) cons
t]&]
[s2; Returns column index of the last clicked row in the array. If 
the click happens past the last row of array, returns Null.&]
[s7; [*/ Return value]-|zero`-based index of the relevant column&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetClickPos`(`)const: [_^Point^ Point]_[* GetClickPos]()_[@(0.0.255) cons
t]&]
[s7; [*/ Return value]-|[* Point(GetClickColumn(), GetClickRow())].&]
[s3; &]
[s0;* &]
[s0; [* Data setting and retrieval]&]
[s3; &]
[s0; &]
[s5;:ArrayCtrl`:`:SetCount`(int`): [@(0.0.255) void]_[* SetCount]([@(0.0.255) int]_[*@3 c])&]
[s2; Sets the number of rows in the array. This extends or trims 
the source matrix as necessary. When using the Ctrl`-based individual 
cell editors, as a side`-effect of this call some controls can 
be constructed or destroyed.&]
[s7; [*C@3 c]-|new row count&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SetVirtualCount`(int`): [@(0.0.255) void]_[* SetVirtualCount]([@(0.0.255) i
nt]_[*@3 c])&]
[s2; Sets the number of rows in an array with external data. This 
makes sense only when all the [/ Column`'s] and [/ Ctrl`'s] of the 
array are [/ rownum]`-based. The function doesn`'t physically allocate 
any source data matrix space, it just makes the array `'think`' 
it has [/ c] rows (this is of course necessary for the Paint routine, 
for cursor / selection management and so on).&]
[s2; [* Note:] in the current implementation, selection flags for the 
individual rows are kept in the row objects. Therefore it is 
not very wise to use multiselection for arrays with external 
data, because as soon as the last row is selected, all row storage 
structures are allocated as a side effect to keep the selection 
flags.&]
[s7; [*C@3 c]-|new `'virtual`' number of rows&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetCount`(`)const: [@(0.0.255) int]_[* GetCount]()_[@(0.0.255) const]&]
[s2; Returns the number of rows in the array. In fact, this returns 
the maximum of the number of `'real`' source matrix rows (as 
set by the SetCount / Add / Insert methods) and the `'virtual`' 
row count (as se by SetVirtualCount). By checking the implementation 
of this method, you can easily find that, simply,&]
[s2; &]
[s2; [C int ArrayCtrl`::GetCount() const `{]&]
[s2; [C -|-|return max(virtualcount, array.GetCount());]&]
[s2; [C `}]&]
[s2; &]
[s7; [*/ Return value]-|Number of rows in the array.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Clear`(`): [@(0.0.255) void]_[* Clear]()&]
[s2; Clears the array source data matrix and sets the virtual row 
count to 0.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Shrink`(`): [@(0.0.255) void]_[* Shrink]()&]
[s2; Shrinks the source data array, i.e. reallocates the data to 
the minimum required memory space.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Get`(int`,int`)const: [_^Value^ Value]_[* Get]([@(0.0.255) int]_[*@3 i], 
[@(0.0.255) int]_[*@3 ii])_[@(0.0.255) const]&]
[s2; Returns the value at a given location in the source data matrix.&]
[s7; [*C@3 i]-|zero`-based row number&]
[s7; [*C@3 ii]-|zero`-based index ordinal number&]
[s7; [*/ Return value]-|value at the given location in the source data 
matrix&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Get`(int`,const Id`&`)const: [_^Value^ Value]_[* Get]([@(0.0.255) int]_[*@3 i
], [@(0.0.255) const ][_^Id^ Id]`&_[*@3 id])_[@(0.0.255) const]&]
[s2; Returns the value at a given location in the source data matrix. 
In this version, the source indices are addressed by their identifiers.&]
[s7; [*C@3 i]-|zero`-based row number&]
[s7; [*C@3 id]-|source index identifier&]
[s7; [*/ Return value]-|value at the given location in the source data 
matrix&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Get`(int`)const: [_^Value^ Value]_[* Get]([@(0.0.255) int]_[*@3 ii])_[@(0.0.255) c
onst]&]
[s2; Returns the value of a given source index at the currently active 
cursor row. This is equivalent to [* Get(GetCursor(), ii)]. When 
the row is currently being edited, the function returns the `'new`' 
value (the current value of the respective editor control, i.e. 
potentially edited).&]
[s2; [* Note:] when the cursor row is not set (when [* !IsCursor()]), 
the function fails with an [* ASSERT].&]
[s7; [*C@3 ii]-|zero`-based index ordinal number&]
[s7; [*/ Return value]-|value at a given location in the cursor row&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Get`(const Id`&`)const: [_^Value^ Value]_[* Get]([@(0.0.255) const 
][_^Id^ Id]`&_[*@3 id])_[@(0.0.255) const]&]
[s2; Returns the value of a given source index at the currently active 
cursor row. This is equivalent to [* Get(GetCursor(), id)].&]
[s7; [*C@3 id]-|source index identifier&]
[s7; [*/ Return value]-|value at the given location in the cursor row&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetOriginal`(int`)const: [_^Value^ Value]_[* GetOriginal]([@(0.0.255) int
]_[*@3 ii])_[@(0.0.255) const]&]
[s2; Returns the `'original`' value of a given source index at the 
currently active cursor row. When the row is open for editing, 
this function returns the `'old`' value before any editing took 
place.&]
[s7; [*C@3 ii]-|zero`-based index ordinal number&]
[s7; [*/ Return value]-|value at the given location in the cursor row&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetOriginal`(const Id`&`)const: [_^Value^ Value]_[* GetOriginal]([@(0.0.255) c
onst ][_^Id^ Id]`&_[*@3 id])_[@(0.0.255) const]&]
[s2; Returns the `'original`' value (i.e., without any editing changed 
applied) of a given source index at the currently active cursor 
row.&]
[s7; [*C@3 id]-|source index identifier&]
[s7; [*/ Return value]-|value at the given location in the cursor row&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetKey`(`)const: [_^Value^ Value]_[* GetKey]()_[@(0.0.255) const]&]
[s2; Returns the value of the current row`'s primary key. This is 
equivalent to [* Get(0)].&]
[s7; [*/ Return value]-|value at the index #0 in the cursor row&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetOriginalKey`(`)const: [_^Value^ Value]_[* GetOriginalKey]()_[@(0.0.255) c
onst]&]
[s2; Returns the original value of the current row`'s primary key. 
During editing, the function returns the value at the time of 
opening the row for editing, i.e. without any editing changes 
applied. This is equivalent to [* GetOriginal(0)].&]
[s7; [*/ Return value]-|value at the index #0 in the cursor row&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Set`(int`,int`,const Value`&`): [@(0.0.255) void]_[* Set]([@(0.0.255) int
]_[*@3 i], [@(0.0.255) int]_[*@3 ii], [@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v
])&]
[s2; Sets the value at a given location in the source data matrix.&]
[s7; [*C@3 i]-|zero`-based row number&]
[s7; [*C@3 ii]-|zero`-based index ordinal number&]
[s7; [*C@3 v]-|value to set to the given cell&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Set`(int`,const Id`&`,const Value`&`): [@(0.0.255) void]_[* Set]([@(0.0.255) i
nt]_[*@3 i], [@(0.0.255) const ][_^Id^ Id]`&_[*@3 id], [@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&
]_[*@3 v])&]
[s2; Sets the value at a given location in the source data matrix. 
&]
[s7; [*C@3 i]-|zero`-based row number&]
[s7; [*C@3 id]-|source index identifier&]
[s7; [*C@3 v]-|value to set to the given cell&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Set`(int`,const Value`&`): [@(0.0.255) void]_[* Set]([@(0.0.255) int]_[*@3 i
i], [@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v])&]
[s2; Modifies the value at a given location in the cursor row. When 
the row is open for editing, the function immediately changes 
the value in the appropriate editor control.&]
[s7; [*C@3 ii]-|zero`-based index ordinal number&]
[s7; [*C@3 v]-|value to set&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Set`(const Id`&`,const Value`&`): [@(0.0.255) void]_[* Set]([@(0.0.255) c
onst ][_^Id^ Id]`&_[*@3 id], [@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v])&]
[s2; Modifies the value at a given location in the cursor row. This 
overloaded version uses the [* Id] identifier to address the relevant 
index.&]
[s7; [*C@3 id]-|index identifier&]
[s7; [*C@3 v]-|value to set&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetColumn`(int`,int`)const: [_^Value^ Value]_[* GetColumn]([@(0.0.255) in
t]_[*@3 row], [@(0.0.255) int]_[*@3 col])_[@(0.0.255) const]&]
[s2; Returns the value of a given column. This depends on the column`-index 
mapping established when adding columns to the table. When the 
column is a [/ rownum] type (it is bound to no source indices), 
the function just returns the [/ row] parameter. For columns with 
a single source index, the function returns the value of the 
mapped source index. For columns with multiple source indices, 
the function returns a [* ValueArray ]containing the values of 
its source indices.&]
[s7; [*C@3 row]-|zero`-based row index&]
[s7; [*C@3 col]-|zero`-based column index&]
[s7; [*/ Return value]-|value of the given column&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetConvertedColumn`(int`,int`): [_^Value^ Value]_[* GetConvertedColumn](
[@(0.0.255) int]_[*@3 row], [@(0.0.255) int]_[*@3 col])&]
[s2; Returns the value of a given column after application of its 
[* Convert]. For performance reasons, the values obtained by calls 
to the [* Convert`::Format] methods are cached internally within 
the ArrayCtrl object. You can manipulate the conversion cache 
using the methods [*^topic`:`/`/CtrlLib`/src`/ArrayCtrl`$en`-us`#`:`:ArrayCtrl`:`:ClearCache`(`)^ C
learCache] and[*  ][*^topic`:`/`/CtrlLib`/src`/ArrayCtrl`$en`-us`#`:`:ArrayCtrl`:`:InvalidateCache`(int`)^ I
nvalidateCache].&]
[s7; [*C@3 row]-|zero`-based row index&]
[s7; [*C@3 col]-|zero`-based column index&]
[s7; [*/ Return value]-|the converted cell value&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ReadRow`(int`)const: [_^Vector^ Vector]<[_^Value^ Value]>_[* ReadRow]([@(0.0.255) i
nt]_[*@3 i])_[@(0.0.255) const]&]
[s2; Returns a [* Vector] containing the values of all source indices 
in the given row. Invariantly, the [* GetCount()] of the returned 
array is equal to the [* GetIndexCount()] of the source ArrayCtrl.&]
[s7; [*C@3 i]-|zero`-based row index&]
[s7; [*/ Return value]-|an array of all source values in the given row&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Set`(int`,const Vector`<Value`>`&`): [@(0.0.255) void]_[* Set]([@(0.0.255) i
nt]_[*@3 i], [@(0.0.255) const]_[_^Vector^ Vector]<[_^Value^ Value]>`&_[*@3 v])&]
[s5;:Upp`:`:ArrayCtrl`:`:Set`(int`,Upp`:`:Vector`<Upp`:`:Value`>`&`&`):%- [@(0.0.255) v
oid]_[* Set]([@(0.0.255) int]_[*@3 i], [_^Upp`:`:Vector^ Vector]<[_^Upp`:`:Value^ Value]>`&
`&_[*@3 v])&]
[s2; Modifies a given row by setting all source index values to values 
passed in the parameter [/ v].&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SetArray`(int`,const ValueArray`&`): [@(0.0.255) void]_[* SetArray]([@(0.0.255) i
nt]_[*@3 i], [@(0.0.255) const]_[_^ValueArray^ ValueArray][@(0.0.255) `&]_[*@3 va])&]
[s2; Sets the row [*@3 i] to [*@3 va].&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Add`(`): [@(0.0.255) void]_[* Add]()&]
[s2; Adds an empty row to the source data matrix.&]
[s2; [* Note:] the [* InsertValue] property of the [* IdInfo] structure 
defines a method to generate / retrieve default values for newly 
inserted rows. However, these values are only used during the 
GUI`-based [* DoInsert] method and do not apply to the [* Add] method. 
If you need to set the newly added source matrix row to some 
non`-null defaults, you have to modify the relevant cells manually.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Add`(const Vector`<Value`>`&`): [@(0.0.255) void]_[* Add]([@(0.0.255) con
st]_[_^Vector^ Vector]<[_^Value^ Value]>`&_[*@3 v])&]
[s5;:Upp`:`:ArrayCtrl`:`:Add`(Upp`:`:Vector`<Upp`:`:Value`>`&`&`):%- [@(0.0.255) void]_
[* Add]([_^Upp`:`:Vector^ Vector]<[_^Upp`:`:Value^ Value]>`&`&_[*@3 v])&]
[s2; Adds a new row at the end of the source data matrix. The [*^topic`:`/`/Core`/src`/Vector`$en`-us^ V
ector] parameter contains the values to be used to initialize 
the new row of the matrix.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddArray`(const ValueArray`&`): [@(0.0.255) void]_[* AddArray]([@(0.0.255) c
onst]_[_^ValueArray^ ValueArray][@(0.0.255) `&]_[*@3 va])&]
[s2; Adds a new row at the end of source with value [*@3 va].&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetArray`(int`)const: [_^ValueArray^ ValueArray]_[* GetArray]([@(0.0.255) i
nt]_[*@3 i])_[@(0.0.255) const]&]
[s2; Returns a row as ValueArray.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Set`(int`,const VectorMap`<String`,Value`>`&`): [@(0.0.255) void]_[* Se
t]([@(0.0.255) int]_[*@3 i], [@(0.0.255) const]_[_^VectorMap^ VectorMap]<[_^String^ String],
 [_^Value^ Value]>`&_[*@3 m])&]
[s2; Sets the row based on map. Keys are matched to row Ids, keys 
that are not found are ignored, those found are assigned correspoding 
map values.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Add`(const VectorMap`<String`,Value`>`&`): [@(0.0.255) void]_[* Add]([@(0.0.255) c
onst]_[_^VectorMap^ VectorMap]<[_^String^ String], [_^Value^ Value]>`&_[*@3 m])&]
[s2; Adds the row based on map. Keys are matched to row Ids, keys 
that are not found are ignored, those found are assigned correspoding 
map values.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SetMap`(int`,const ValueMap`&`): [@(0.0.255) void]_[* SetMap]([@(0.0.255) i
nt]_[*@3 i], [@(0.0.255) const]_[_^ValueMap^ ValueMap][@(0.0.255) `&]_[*@3 m])&]
[s2; Sets the row based on map. Keys are matched to row Ids, keys 
that are not found are ignored, those found are assigned correspoding 
map values.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AddMap`(const ValueMap`&`): [@(0.0.255) void]_[* AddMap]([@(0.0.255) cons
t]_[_^ValueMap^ ValueMap][@(0.0.255) `&]_[*@3 m])&]
[s2; Adds the row based on map. Keys are matched to row Ids, keys 
that are not found are ignored, those found are assigned correspoding 
map values.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetMap`(int`)const: [_^ValueMap^ ValueMap]_[* GetMap]([@(0.0.255) int]_[*@3 i
])_[@(0.0.255) const]&]
[s2; Returns row as map of row Ids to row values. Only non`-empty 
row Ids are added.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Add`(const Value`&`[`,const Value`&`]`.`.`.`): [@(0.0.255) void]_[* Add
]([@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_`[, [@(0.0.255) const]_[_^Value^ Value
][@(0.0.255) `&]_`]...)&]
[s2; Adds a new row at the bottom of the source data matrix. This 
is in fact a series of functions (generated automatically using 
the [* Expand] macro) which takes an arbitrary number of arguments. 
Its arguments are used to initialize the source indices in the 
newly added row.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Add`(const Nuller`&`): [@(0.0.255) void]_[* Add]([@(0.0.255) const]_[_^Nuller^ N
uller][@(0.0.255) `&]_[*@3 null])&]
[s2; This is helper method required for correct overloading resolution 
of Add(Null).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Insert`(int`): [@(0.0.255) void]_[* Insert]([@(0.0.255) int]_[*@3 i])&]
[s2; Inserts a new row into the source array. All indices are initialized 
to [* Null] values. The [* InsertValue] property doesn`'t apply; 
if you need to set the newly created row to some non`-trivial 
values, you have to do so manually.&]
[s7; [*C@3 i]-|zero`-based position of the newly created row&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Insert`(int`,const Vector`<Value`>`&`): [@(0.0.255) void]_[* Insert]([@(0.0.255) i
nt]_[*@3 i], [@(0.0.255) const]_[_^Vector^ Vector]<[_^Value^ Value]>`&_[*@3 v])&]
[s2; Inserts a new row into the array at a given position. The second 
parameter, [/ v], is used to initialize the source indices of the 
newly created row.&]
[s7; [*C@3 i]-|zero`-based row index&]
[s7; [*C@3 v]-|a vector of values used to initialize the source indices 
of the given row&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Remove`(int`): [@(0.0.255) void]_[* Remove]([@(0.0.255) int]_[*@3 i])&]
[s2; Removes the given source data row.&]
[s2; [* Note:] the [* AskRemove] property of the [* ArrayCtrl] object tells 
whether a confirmation dialog should pop up every time the user 
wants to remove a row. However, this method applies only to the 
GUI`-based row removal; the [* Remove] method always removes the 
requested row unconditionally without popping up any confirmation 
dialog.&]
[s7; [*C@3 i]-|zero`-based index of the row to remove&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SwapUp`(`): [@(0.0.255) void]_[* SwapUp]()&]
[s2; Exchanges the cursor row with the preceding row, effectively 
moving it up.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SwapDown`(`): [@(0.0.255) void]_[* SwapDown]()&]
[s2; Exchanges the cursor row with following row, effectively moving 
it down.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:ReArrange`(const Upp`:`:Vector`<int`>`&`):%- [@(0.0.255) void]_
[* ReArrange]([@(0.0.255) const]_[_^Upp`:`:Vector^ Vector]<[@(0.0.255) int]>`&_[*@3 order])
&]
[s2; Rearranges lines of array by [%-*@3 order] of former line indices. 
The count of items in [%-*@3 order] must be the same as GetCount 
of ArrayCtrl and it must contain all indices from zero to GetCount() 
`- 1. [%-*@3 order] establishes a new order expressed in former 
indices of lines.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Sort`(Gate2`<int`,int`>`): [@(0.0.255) void]_[* Sort]([_^Gate2^ Gate2]<[@(0.0.255) i
nt], [@(0.0.255) int]>_[*@3 order])&]
[s5;:ArrayCtrl`:`:Sort`(int`,int`,Gate2`<int`,int`>`): [@(0.0.255) void]_[* Sort]([@(0.0.255) i
nt]_[*@3 from], [@(0.0.255) int]_[*@3 count], [_^Gate2^ Gate2]<[@(0.0.255) int], 
[@(0.0.255) int]>_[*@3 order])&]
[s2; Sorts the array rows according to a given ordering predicate. 
The [*@3 order] object defines the ordering predicate; two parameters 
are indicies of ArrayCtrl lines; it should returns true if they 
are in required ordering.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Sort`(const ArrayCtrl`:`:Order`&`): [@(0.0.255) void]_[* Sort]([@(0.0.255) c
onst]_[_^ArrayCtrl`:`:Order^ ArrayCtrl`::Order][@(0.0.255) `&]_[*@3 order])&]
[s2; Sorts the array rows according to a given ordering predicate. 
The [* ArrayCtrl`::Order] object defines the ordering predicate; 
its [* operator ()] should return [* true] whenever its first parameter 
(a vector containing the values of all source indices in a row) 
is less than its second parameter.&]
[s7; &]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Sort`(int`,int`,const ArrayCtrl`:`:Order`&`): [@(0.0.255) void]_[* Sort
]([@(0.0.255) int]_[*@3 from], [@(0.0.255) int]_[*@3 count], [@(0.0.255) const]_[_^ArrayCtrl`:`:Order^ A
rrayCtrl`::Order][@(0.0.255) `&]_[*@3 order])&]
[s2; Sorts a portion of the array using a given ordering predicate.&]
[s7; [*C@3 from]-|zero`-based index of the first row to sort&]
[s7; [*C@3 count]-|number of rows to be sorted&]
[s7; [*C@3 order]-|the ordering predicate object. The object should 
be derived from [* ArrayCtrl`::Order] and should override the [* operator 
()] method. This method should return [* true ]whenever its first 
parameter (a vector containing all source index values for a 
certain row) is less than its second parameter.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Sort`(int`(`*`)`(const Vector`<Value`>`&v1`,const Vector`<Value`>`&v2`)`): [@(0.0.255) v
oid]_[* Sort]([@(0.0.255) int]_(`*[*@3 compare])([@(0.0.255) const]_Vector<Value>`&_v1, 
[@(0.0.255) const]_Vector<Value>`&_v2))&]
[s2; Sorts the array rows according to the order defined by the specified 
ordering predicate [/ compare]. This is supposed to be a global 
function returning [* true] whenever its first parameter ([/ v1], 
an array consisting of all source indices within a row) is less 
than the second parameter [/ v2] (according to the desired ordering).&]
[s7; [*C@3 compare]-|the ordering predicate; _the function is supposed 
to return [* true] whenever its first parameter ([/ v1]) is less 
than the second parameter ([/ v2]) according to the desired ordering.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Sort`(int`,int`(`*`)`(const Value`&v1`,const Value`&v2`)`): [@(0.0.255) v
oid]_[* Sort]([@(0.0.255) int]_[*@3 ii], [@(0.0.255) int]_(`*[*@3 compare])([@(0.0.255) const
]_Value[@(0.0.255) `&]_v1, [@(0.0.255) const]_Value[@(0.0.255) `&]_v2)_`=_StdValueCompa
re)&]
[s2; Sorts the array rows according to the given ordering predicate 
for the source index with a given ordinal number. When not explicitly 
specified, the [* StdValueCompare] function is used as the default 
comparison predicate.&]
[s7; [*C@3 ii]-|zero`-based ordinal number of the source index used 
for sorting&]
[s7; [*C@3 compare]-|the sorting predicate function: the function is 
supposed to return [* true] whenever its first parameter ([/ v1]) 
is less than the second parameter ([/ v2]) according to the desired 
ordering.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Sort`(const Id`&`,int`(`*`)`(const Value`&v1`,const Value`&v2`)`): [@(0.0.255) v
oid]_[* Sort]([@(0.0.255) const ][_^Id^ Id]`&_[*@3 id], [@(0.0.255) int]_(`*[*@3 compare])([@(0.0.255) c
onst]_Value[@(0.0.255) `&]_v1, [@(0.0.255) const]_Value[@(0.0.255) `&]_v2)_`=_StdValueC
ompare)&]
[s2; Sorts the array rows according to the given ordering predicate 
for the source index with a given identifier. When not explicitly 
specified, the [* StdValueCompare] function is used as the default 
comparison predicate.&]
[s7; [*C@3 id]-|identifier of the source index used for sorting&]
[s7; [*C@3 compare]-|the sorting predicate function: the function is 
supposed to return [* true] whenever its first parameter ([/ v1]) 
is less than the second parameter ([/ v2]) according to the desired 
ordering .&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Sort`(`): [@(0.0.255) void]_[* Sort]()&]
[s2; Sorts the array according to the default ordering predicate 
for the first source index. This is equivalent to calling [* Sort(0)].&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ColumnSort`(int`,Gate2`<int`,int`>`): [@(0.0.255) void]_[* ColumnSort](
[@(0.0.255) int]_[*@3 column], [_^Gate2^ Gate2]<[@(0.0.255) int], [@(0.0.255) int]>_[*@3 orde
r])&]
[s2; Sorts by the column using ordering based on line indicies. This 
is almost the same as the plain Sort, except that it respects 
ColumnSortSecondary and ColumnSortFindKey flags.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ColumnSort`(int`,const ValueOrder`&`): [@(0.0.255) void]_[* ColumnSort](
[@(0.0.255) int]_[*@3 column], [@(0.0.255) const]_[_^ValueOrder^ ValueOrder][@(0.0.255) `&]_
[*@3 order])&]
[s2; Sorts by the column. Note that this is different from Sort, 
because the final converted value of column is used (which can 
even be combination of more indexes).&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:ColumnSort`(int`,int`(`*`)`(const Valua`&a`,const Upp`:`:Value`&b`)`):%- [@(0.0.255) v
oid]_[* ColumnSort]([@(0.0.255) int]_[*@3 column], [@(0.0.255) int]_(`*[*@3 compare])([@(0.0.255) c
onst]_Valua[@(0.0.255) `&]_a, [@(0.0.255) const]_Value[@(0.0.255) `&]_b))&]
[s2; Sorts by the column. Note that this is different from Sort, 
because the final converted value of column is used (which can 
even be combination of more indexes).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SetSortColumn`(int`,bool`): [@(0.0.255) void]_[* SetSortColumn]([@(0.0.255) i
nt]_[*@3 ii], [@(0.0.255) bool]_[*@3 descending]_`=_[@(0.0.255) false])&]
[s2; Sets the `"sorting`" column and calls DoColumnSort. This setting 
is used by DoColumnSort.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ToggleSortColumn`(int`): [@(0.0.255) void]_[* ToggleSortColumn]([@(0.0.255) i
nt]_[*@3 ii])&]
[s2; Similar to SetSortColumn, but if the column is already set, 
descending flag is inverted; otherwise descending flag is set 
to false (indicating ascending sort).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:DoColumnSort`(`): [@(0.0.255) void]_[* DoColumnSort]()&]
[s2; Sorts the array by sorting column and indicates it by setting 
an image in the header.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetSortColumn`(`)const: [@(0.0.255) int]_[* GetSortColumn]()_[@(0.0.255) c
onst]&]
[s2; Returns the column that is sorting the ArrayCtrl (user clicked 
on it and it has up or down arrow displayed).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsSortDescending`(`)const: [@(0.0.255) bool]_[* IsSortDescending]()_[@(0.0.255) c
onst]&]
[s2; Returns true if current column`-sort is descending.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ClearCache`(`): [@(0.0.255) void]_[* ClearCache]()&]
[s2; Invalidates the whole [/ convert cache]. The convert cache keeps 
the results of the [* Convert`::Format] method applied to individual 
array data cells for performance reasons. Whenever you call the 
[* ClearCache] method, all cache entries are marked as obsolete 
and the [* Convert]`'s [* Format] method will be called as soon as 
the converted value of a table cell is required (usually during 
the next [* Paint]).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:InvalidateCache`(int`): [@(0.0.255) void]_[* InvalidateCache]([@(0.0.255) i
nt]_[*@3 i])&]
[s2; Invalidates a given row in the [/ convert cache]. For performance 
reasons, the results of the [* Convert`::Format] method applied 
to the individual data cells are kept in a cache. This function 
marks a given row of the cache as obsolete; this means the next 
time the converted values are to be used (usually within the 
[* Paint] routine or when setting up the row editor controls), 
the [* Convert] objects are used again to generate the actualized 
output values.&]
[s7; [*C@3 i]-|zero`-based row index&]
[s3; &]
[s0; &]
[s0; [* Cursor and selection management]&]
[s3; &]
[s0; &]
[s5;:ArrayCtrl`:`:ScrollUp`(`): [@(0.0.255) void]_[* ScrollUp]()&]
[s5;:ArrayCtrl`:`:ScrollDown`(`): [@(0.0.255) void]_[* ScrollDown]()&]
[s5;:ArrayCtrl`:`:ScrollPageUp`(`): [@(0.0.255) void]_[* ScrollPageUp]()&]
[s5;:ArrayCtrl`:`:ScrollPageDown`(`): [@(0.0.255) void]_[* ScrollPageDown]()&]
[s5;:ArrayCtrl`:`:ScrollEnd`(`): [@(0.0.255) void]_[* ScrollEnd]()&]
[s5;:ArrayCtrl`:`:ScrollBegin`(`): [@(0.0.255) void]_[* ScrollBegin]()&]
[s2; Scrolls the content of ArrayCtrl.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetSelectCount`(`)const: [@(0.0.255) int]_[* GetSelectCount]()_[@(0.0.255) c
onst]&]
[s2; Returns the number of selected row within the table.&]
[s7; [*/ Return value]-|number of selected records (in the range [/ `[0 
.. GetCount()`]])&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsSelection`(`)const: [@(0.0.255) bool]_[* IsSelection]()_[@(0.0.255) con
st]&]
[s2; Checks whether any rows are selected. Equivalent to [* GetSelectCount() 
> 0].&]
[s7; [*/ Return value]-|[* true] `= there is at least one selected row, 
[* false] `= there is none.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Select`(int`,bool`): [@(0.0.255) void]_[* Select]([@(0.0.255) int]_[*@3 i],
 [@(0.0.255) bool]_[*@3 sel]_`=_[@(0.0.255) true])&]
[s2; Selects / unselects a given row.&]
[s7; [*C@3 i]-|zero`-based row index&]
[s7; [*C@3 sel]-|[* true] `= add row to the current selection, [* false] 
`= remove row from selection&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Select`(int`,int`,bool`): [@(0.0.255) void]_[* Select]([@(0.0.255) int]_[*@3 i
], [@(0.0.255) int]_[*@3 count], [@(0.0.255) bool]_[*@3 sel]_`=_[@(0.0.255) true])&]
[s2; Selects / unselects a given row range.&]
[s7; [*C@3 i]-|zero`-based index of the first row to select / unselect&]
[s7; [*C@3 count]-|number of rows to select / unselect&]
[s7; [*C@3 sel]-|[* true] `= select the rows, [* false] `= unselect the 
rows&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsSelected`(int`)const: [@(0.0.255) bool]_[* IsSelected]([@(0.0.255) int]_
[*@3 i])_[@(0.0.255) const]&]
[s7; Checks whether a given row is selected.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsSel`(int`)const: [@(0.0.255) bool]_[* IsSel]([@(0.0.255) int]_[*@3 i])_[@(0.0.255) c
onst]&]
[s2; If there is selection in the widget, returns true if [*@3 i] is 
selected, otherwise returns true if cursor is at [*@3 i].&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:GetSelKeys`(`)const:%- [_^Upp`:`:Vector^ Vector]<[@(0.0.255) int
]>_[* GetSelKeys]()_[@(0.0.255) const]&]
[s2; Returns keys (elements with index 0) of all selected lines (ordered 
by line order).&]
[s3;%- &]
[s4; &]
[s5;:Upp`:`:ArrayCtrl`:`:EnableLine`(int`,bool`): [@(0.0.255) void]_[* EnableLine]([@(0.0.255) i
nt]_[*@3 i], [@(0.0.255) bool]_[*@3 e])&]
[s2; Enables line to be selected by cursor. Lines are enabled by 
default.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:ArrayCtrl`:`:DisableLine`(int`): [@(0.0.255) void]_[* DisableLine]([@(0.0.255) i
nt]_[*@3 i])&]
[s2; Same as EnableLine(false).&]
[s3; &]
[s4; &]
[s5;:Upp`:`:ArrayCtrl`:`:IsLineEnabled`(int`)const: [@(0.0.255) bool]_[* IsLineEnabled]([@(0.0.255) i
nt]_[*@3 i])_[@(0.0.255) const]&]
[s2; Returns true if line is enabled. Not that in addition to EnableLine 
method, callback WhenLineEnabled affects the status too.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:ArrayCtrl`:`:IsLineDisabled`(int`)const: [@(0.0.255) bool]_[* IsLineDisabled](
[@(0.0.255) int]_[*@3 i])_[@(0.0.255) const]&]
[s2; Same as !IsLineEnabled([*@3 i]).&]
[s3; &]
[s4; &]
[s5;:Upp`:`:ArrayCtrl`:`:ShowLine`(int`,bool`): [@(0.0.255) void]_[* ShowLine]([@(0.0.255) i
nt]_[*@3 i], [@(0.0.255) bool]_[*@3 visible])&]
[s2; Sets the visibility of line. Hidden lines are omitted from the 
list.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:ArrayCtrl`:`:HideLine`(int`): [@(0.0.255) void]_[* HideLine]([@(0.0.255) int]_[*@3 i
])&]
[s2; Same as ShowLine([*@3 i], false).&]
[s3; &]
[s4; &]
[s5;:Upp`:`:ArrayCtrl`:`:IsLineVisible`(int`)const: [@(0.0.255) bool]_[* IsLineVisible]([@(0.0.255) i
nt]_[*@3 i])_[@(0.0.255) const]&]
[s2; Returns true if line is visible. Not that in addition to EnableLine 
method, callback WhenLineVisible affects the visibility too.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ClearSelection`(`): [@(0.0.255) void]_[* ClearSelection]()&]
[s2; Clears the current selection (unselects all selected rows).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsCursor`(`)const: [@(0.0.255) bool]_[* IsCursor]()_[@(0.0.255) const]&]
[s2; Checks whether the cursor is within the table. This is equivalent 
to [* GetCursor()_>`=_0].&]
[s7; [*/ Return value]-|&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SetCursor`(int`): [@(0.0.255) bool]_[* SetCursor]([@(0.0.255) int]_[*@3 i])
&]
[s2; Sets the current cursor row. When an array row is open for editing, 
the function first commits the edited row, then moved the cursor 
to the new row. When the edited row cannot be commited, the function 
returns [* false] and doesn`'t change the cursor location.&]
[s7; [*C@3 i]-|zero`-based row index&]
[s7; [*/ Return value]-|[* true] `= cursor has been moved, [* false ]when 
not (when committing the previously edited row failed)&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:KillCursor`(`): [@(0.0.255) bool]_[* KillCursor]()&]
[s2; Moves the cursor away from the array. When an array row is open 
for editing, the function first commits the edited row, then 
moved the cursor away from the array. When the edited row cannot 
be commited, the function returns [* false] and doesn`'t change 
the cursor location.&]
[s7; [*/ Return value]-|[* true] `= cursor has been moved away from the 
array, [* false] when not (when committing the previously edited 
row failed)&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:CancelCursor`(`): [@(0.0.255) void]_[* CancelCursor]()&]
[s2; Cancels editing of the row being currently edited. All changes 
made in the individual column editors are rejected.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetCursor`(`)const: [@(0.0.255) int]_[* GetCursor]()_[@(0.0.255) const]&]
[s2; Returns the current cursor row, `-1 when none.&]
[s7; [*/ Return value]-|zero`-based cursor row index, `-1 `= cursor 
is not in the array&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GoBegin`(`): [@(0.0.255) void]_[* GoBegin]()&]
[s2; Moves the cursor to the first row in the array (equivalent to 
[* SetCursor(0)]).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GoEnd`(`): [@(0.0.255) void]_[* GoEnd]()&]
[s2; Moves the cursor to the last array row (equivalent to [* SetCursor(GetCount() 
`- 1)]).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetCursorSc`(`)const: [@(0.0.255) int]_[* GetCursorSc]()_[@(0.0.255) cons
t]&]
[s2; Returns the visual vertical position of the cursor row relative 
to the current view. This method, in combination with [* ScCursor], 
can be used to reposition the cursor row while maintaining the 
same visual position of the row within the array view.&]
[s7; [*/ Return value]-|an integer describing the vertical position 
of the cursor row relative to the array view&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ScCursor`(int`): [@(0.0.255) void]_[* ScCursor]([@(0.0.255) int]_[*@3 a])&]
[s2; Modifies the scrollbar position so that the current cursor row 
appears at a given vertical position relative to the array view. 
By doing the following sequence of operations: [* GetCursorSc], 
then reposition the cursor row, then [* ScCursor], you can achieve 
cursor relocation while maintaining its visual location within 
the array view.&]
[s7; [*C@3 a]-|an integer describing the vertical position of the cursor 
row (typically a number returned by a previous call to [* GetCursorSc])&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:CenterCursor`(`): [@(0.0.255) void]_[* CenterCursor]()&]
[s2; Modifies the scrollbar position so that the current cursor row 
appears in the middle of the array view.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ScrollInto`(int`): [@(0.0.255) void]_[* ScrollInto]([@(0.0.255) int]_[*@3 l
ine])&]
[s2; Moves the scrollbar by the least possible amount in order to 
make the given array row visible. When the given array row is 
already visible, the function does nothing.&]
[s7; [*C@3 line]-|zero`-based row index of the array row to make visible&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ScrollIntoCursor`(`): [@(0.0.255) void]_[* ScrollIntoCursor]()&]
[s2; Moves the scrollbar by the least possible amount in order to 
make the cursor row visible. This is equivalent to [* ScrollInto(GetCursor())].&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetCursor`(`)const: [@(0.0.255) int]_[* GetCursor]()_[@(0.0.255) const]&]
[s2; Returns the current vertical scrollbar position.&]
[s7; [*/ Return value]-|Pixel position of the vertical scrollbar. Position 
0 is at the very top (the top row of the array is fully visible).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:ScrollTo`(int`): [@(0.0.255) void]_[* ScrollTo]([@(0.0.255) int]_[*@3 sc])&]
[s2; Moves the vertical array scrollbar to a given position.&]
[s7; [*C@3 sc]-|Pixel position of the scrollbar. The visible portion 
of the array can be obtained conceptually by taking the stack 
of array rows with its top aligned at the top of the view and 
moving it [/ sc] pixels upwards.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Find`(const Value`&`,int`,int`)const: [@(0.0.255) int]_[* Find]([@(0.0.255) c
onst]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v], [@(0.0.255) int]_[*@3 ii]_`=_[@3 0], 
[@(0.0.255) int]_[*@3 from]_`=_[@3 0])_[@(0.0.255) const]&]
[s2; [*C@3 v]-|value to look for in the given source index&]
[s7; [*C@3 ii]-|zero`-based ordinal number of the source index to search&]
[s7; [*C@3 from]-|zero`-based row index to start the search from&]
[s7; [*/ Return value]-|zero`-based number of the matched row, `-1 when 
none&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Find`(const Value`&`,const Id`&`,int`)const: [@(0.0.255) int]_[* Find](
[@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v], [@(0.0.255) const 
][_^Id^ Id]`&_[*@3 id], [@(0.0.255) int]_[*@3 from]_`=_[@3 0])_[@(0.0.255) const]&]
[s2; Locates the row (using linear search beginning at the row [/ from]) 
in which the source index value identified by [/ id] equals [/ val]. 
If such a row is found, the function returns its zero`-based 
index. When not matched, the function returns `-1.&]
[s7; [*C@3 v]-|value to look for in the given source index&]
[s7; [*C@3 id]-|source index identifier&]
[s7; [*C@3 from]-|zero`-based row index to start the search from&]
[s7; [*/ Return value]-|zero`-based number of the matched row, `-1 when 
none&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:FindSetCursor`(const Value`&`,int`,int`): [@(0.0.255) bool]_[* FindSetC
ursor]([@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 val], 
[@(0.0.255) int]_[*@3 ii]_`=_[@3 0], [@(0.0.255) int]_[*@3 from]_`=_[@3 0])&]
[s2; Locates the row (using linear search beginning at the row [/ from]) 
in which the source index value identified by its ordinal number 
[/ ii] equals [/ val]. If such a row is found, the [* SetCursor] is 
called automatically to move the cursor to such a row.&]
[s7; [*C@3 val]-|value to look for in the given source index&]
[s7; [*C@3 ii]-|zero`-based ordinal number of the source index to search&]
[s7; [*C@3 from]-|zero`-based row index to start the search from&]
[s7; [*/ Return value]-|zero`-based number of the matched row, `-1 when 
none&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:FindSetCursor`(const Value`&`,const Id`&`,int`): [@(0.0.255) bool]_[* F
indSetCursor]([@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 val], 
[@(0.0.255) const ][_^Id^ Id]`&_[*@3 id], [@(0.0.255) int]_[*@3 from]_`=_[@3 0])&]
[s2; Locates the row (using linear search beginning at the row [/ from]) 
in which the source index value identified by [/ id] equals [/ val]. 
If such a row is found, the [* SetCursor] is called automatically 
to move the cursor to such a row.&]
[s7; [*C@3 val]-|value to look for in the given source index&]
[s7; [*C@3 id]-|source index identifier&]
[s7; [*C@3 from]-|zero`-based row index to start the search from&]
[s7; [*/ Return value]-|[* true] `= the desired row was found (and the 
cursor set), [* false] when not&]
[s3; &]
[s0;* &]
[s0; [* User interface elements]&]
[s3; &]
[s0; &]
[s5;:ArrayCtrl`:`:StdBar`(Bar`&`): [@(0.0.255) void]_[* StdBar]([_^Bar^ Bar][@(0.0.255) `&]_[*@3 m
enu])&]
[s2; The default array local menu. The default local menu consists 
of the standard editing actions (inserting / appending / duplicating 
a row, editing a row, removing a row, moving a row, select all 
rows) filtered by the array properties enabling / disabling the 
various GUI elements (item insertion / deletion etc.). &]
[s7; [*C@3 menu]-|the [* Bar] object representing the menu being generated&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsModified`(int`)const: [@(0.0.255) bool]_[* IsModified]([@(0.0.255) int]_
[*@3 ii])_[@(0.0.255) const]&]
[s2; Checks a source index in the currently edited row for changes.&]
[s7; [*C@3 ii]-|zero`-based row index&]
[s7; [*/ Return value]-|[* true] `= the index has been modified, [* false] 
`= the index is in its original state&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IsModified`(const Id`&`)const: [@(0.0.255) bool]_[* IsModified]([@(0.0.255) c
onst ][_^Id^ Id]`&_[*@3 id])_[@(0.0.255) const]&]
[s2; Checks a source index in the currently edited array row for 
changes.&]
[s7; [*C@3 id]-|source index identifier&]
[s7; [*/ Return value]-|[* true] `= the source index has been modified, 
[* false ]when not&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:StartEdit`(int`): [@(0.0.255) bool]_[* StartEdit]([@(0.0.255) int]_[*@3 d]_
`=_[@3 0])&]
[s2; Opens the current cursor row for editing and sets focus to the 
[/ d]`-th column.&]
[s7; [*C@3 d]-|zero`-based column index&]
[s7; [*/ Return value]-|[* true] `= editing successfully initiated, [* false] 
when not (when the array is in [* ReadOnly] mode or it has no editable 
columns)&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:GetEditColumn`(`)const: [@(0.0.255) int]_[* GetEditColumn]()_[@(0.0.255) c
onst]&]
[s2; Returns the column being currently edited.&]
[s7; [*/ Return value]-|zero`-based index of the column being edited, 
`-1 `= none&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:DoEdit`(`): [@(0.0.255) void]_[* DoEdit]()&]
[s2; Opens the current cursor row for editing.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:DoInsert`(int`): [@(0.0.255) void]_[* DoInsert]([@(0.0.255) int]_[*@3 curso
r])&]
[s2; Begins the GUI insertion of a new row at a given location.&]
[s7; [*C@3 cursor]-|zero`-based location of the new row&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:DoInsertBefore`(`): [@(0.0.255) void]_[* DoInsertBefore]()&]
[s2; Begins the GUI insertion of a new row above the current row.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:DoInsertAfter`(`): [@(0.0.255) void]_[* DoInsertAfter]()&]
[s2; Begins the GUI insertion of a new row below the current row.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:DoAppend`(`): [@(0.0.255) void]_[* DoAppend]()&]
[s2; Begins the GUI insertion of a new row at the end of the array.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:DoRemove`(`): [@(0.0.255) virtual] [@(0.0.255) bool]_[* DoRemove]()&]
[s2; Performs the GUI`-based removal of the current cursor row. When 
the [* AskRemove] property is set to [* true] and the user cancels 
the confirmation dialog, the function returns [* false] and the 
current row is not removed.&]
[s7; [*/ Return value]-|[* true] `= row has been removed successfully, 
[* false] `=  user has canceled the row removal&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:DoDuplicate`(`): [@(0.0.255) void]_[* DoDuplicate]()&]
[s2; Duplicates the current row and opens it for editing.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:DoSelectAll`(`): [@(0.0.255) void]_[* DoSelectAll]()&]
[s2; Marks all array row as selected.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AcceptEnter`(`): [@(0.0.255) bool]_[* AcceptEnter]()&]
[s2; Performs all necessary GUI actions equivalent to when the user 
presses the [* Enter] key. The row being currently edited is committed 
and, in the case it was a newly appended line and the [* NoInsertAppend] 
property is not set, an additional row is added to the array 
and opened for editing.&]
[s7; [*/ Return value]-|[* true] `= the current row has been successfully 
committed, [* false] when not&]
[s3; &]
[s0; &]
[s0; &]
[s0; [* Content export]&]
[s0;* &]
[s3; &]
[s5;:ArrayCtrl`:`:AsText`(String`(`*`)`(const Value`&`)`,bool`,const char`*`,const char`*`,const char`*`,const char`*`)const: [_^String^ S
tring]_[* AsText]([_^String^ String]_(`*[*@3 format])([@(0.0.255) const]_Value[@(0.0.255) `&
]), [@(0.0.255) bool]_[*@3 sel]_`=_[@(0.0.255) false], [@(0.0.255) const]_[@(0.0.255) char]_
`*[*@3 tab]_`=_`"`\t`", [@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 row]_`=_`"`\r`\n`", 
[@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 hdrtab]_`=_`"`\t`", [@(0.0.255) const]_[@(0.0.255) c
har]_`*[*@3 hdrrow]_`=_`"`\r`\n`")_[@(0.0.255) const]&]
[s2; Generic function for conversion of ArrayCtrl content to text. 
The content visible on screen is exported (means, it exports 
columns defined using AddColumn, not indicies). Cells are converted 
to output format using [*@3 format] function. If [*@3 sel] is true, 
only rows with IsSel true are exported. [*@3 tab] represents a 
separator text between cells in a row, [*@3 row] separator of rows. 
[*@3 hdrtab] is separator of header cells (those are texts of ArrayCtrl 
header) `- if NULL, no header is exported. [*@3 hdrrow].is separator 
of header and data rows.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:SetClipboard`(bool`,bool`)const: [@(0.0.255) void]_[* SetClipboard]([@(0.0.255) b
ool]_[*@3 sel]_`=_[@(0.0.255) false], [@(0.0.255) bool]_[*@3 hdr]_`=_[@(0.0.255) true])_[@(0.0.255) c
onst]&]
[s2; Puts ArrayCtrl content to clipboard in text format, `"`\t`" 
and `"`\r`\n`" as separators. If [*@3 sel] is true, only rows with 
IsSel true are exported, [*@3 hdr] controls whether header is exported.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AsQtf`(bool`,bool`): [_^String^ String]_[* AsQtf]([@(0.0.255) bool]_[*@3 se
l]_`=_[@(0.0.255) false], [@(0.0.255) bool]_[*@3 hdr]_`=_[@(0.0.255) true])&]
[s2; Returns ArrayCtrl content in QTF format. If [*@3 sel] is true, 
only rows with IsSel true are exported, [*@3 hdr] controls whether 
header is exported.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:AsCsv`(bool`,int`,bool`): [_^String^ String]_[* AsCsv]([@(0.0.255) bool]_
[*@3 sel]_`=_[@(0.0.255) false], [@(0.0.255) int]_[*@3 sep]_`=_`';`', 
[@(0.0.255) bool]_[*@3 hdr]_`=_[@(0.0.255) true])&]
[s2; Returns ArrayCtrl content in csv format, using [*@3 sep] as separator. 
If [*@3 sel] is true, only rows with IsSel true are exported, [*@3 hdr] 
controls whether header is exported.&]
[s0; &]
[s0; &]
[s0; [* Notification callbacks]&]
[s3; &]
[s3; &]
[s5;:ArrayCtrl`:`:WhenSel: [_^Callback^ Callback]_[* WhenSel]&]
[s2; Called whenever cursor or selection changes. This probably the 
most common ArrayCtrl callback. We recommend to start with this 
one first and use others only if necessary.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenLeftClick: [_^Callback^ Callback]_[* WhenLeftClick]&]
[s2; This callback is called whenever the user clicks an array cell.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenLeftDouble: [_^Callback^ Callback]_[* WhenLeftDouble]&]
[s2; This callback is called whenever the user doubleclicks an array 
cell.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenMouseMove: [_^Callback1^ Callback1]<[_^Point^ Point]>_[* WhenMouseMov
e]&]
[s2; Called when mouse moves over the ArrayCtrl or moves out of ArrayCtrl. 
The Point`::y is the line number, Point`::x column index. If mouse 
moves out of ArrayCtrl, parameter is Null.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenEnterKey: [_^Callback^ Callback]_[* WhenEnterKey]&]
[s2; Called when user presses Enter key while focus is in ArrayCtrl, 
some line of ArrayCtrl has cursor and Enter key is not `'eaten`' 
by another action like accepting the input. When this Callback 
is not empty, Enter key is never passed to parent.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenBar: [_^Callback1^ Callback1]<Bar[@(0.0.255) `&]>_[* WhenBar]&]
[s2; This callback is called whenever the local array menu has to 
be regenerated. By setting this callback to a different function 
/ method you can supply a custom local menu for the array. The 
[* Bar`&] argument is a reference to the menu to be generated.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenEnterRow: [_^Callback^ Callback]_[* WhenEnterRow]&]
[s0; [* -|][*/ Deprecated]&]
[s2; This callback is called every time the cursor location changes 
to a different row of the array.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenAcceptRow: [_^Gate^ Gate]_[* WhenAcceptRow]&]
[s2; This gate is called every time an array row (open for editing) 
needs to be validated. When the gate returns [* false], the validation 
process is assumed to have failed, when it returns [* true], it 
is assumed to have succeeded. You can use this callback to add 
your own validation algorithms relevant to the array context 
within your application.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenUpdateRow: [_^Callback^ Callback]_[* WhenUpdateRow]&]
[s2; This callback is called whenever an array row has been updated. 
You can use this callback e.g. to project the changes to a database 
or generally to an external data source.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenKillCursor: [_^Callback^ Callback]_[* WhenKillCursor]&]
[s0; [* -|][*/ Deprecated]&]
[s2; This callback is called whenever the cursor is moved away from 
the table.&]
[s2; [* Note:] internally, when moving the cursor (e.g. by calling the 
[* SetCursor ]method), after committing the previous row the cursor 
is removed from the table using [* KillCursor] and placed to the 
new location afterwards. Therefore every time the cursor is moved, 
the [* WhenKillCursor] callback is called as a by`-product.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenCursor: [_^Callback^ Callback]_[* WhenCursor]&]
[s0; [* -|][*/ Deprecated]&]
[s2; This callback is called every time the cursor row number changes 
(either when the cursor is removed from the table, or when it 
has been moved to a different row).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenArrayAction: [_^Callback^ Callback]_[* WhenArrayAction]&]
[s2; This callback is called every time the source array data changes 
(typically after accepting changes to a certain row or after 
deleting a row).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenStartEdit: [_^Callback^ Callback]_[* WhenStartEdit]&]
[s2; This callback is called whenever the array row editing process 
is initiated. It can be used e.g. to set up some additional properties 
of the column editor objects, to fill in drop`-down lists pertaining 
to certain column editors etc.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenAcceptEdit: [_^Callback^ Callback]_[* WhenAcceptEdit]&]
[s2; This callback is called whenever the currently edited line has 
been committed.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenSelection: [_^Callback^ Callback]_[* WhenSelection]&]
[s0; [* -|][*/ Deprecated]&]
[s2; This callback is called whenever the current array selection 
changes. This includes changes to the cursor location as the 
cursor is automatically considered part of the selection.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenCtrlsAction: [_^Callback^ Callback]_[* WhenCtrlsAction]&]
[s2; This callback is called whenever some of the editor controls 
constructed automatically via the column editing [/ factory] calls 
its [* WhenAction] method. It can be used to watch out for changes 
in the cell editors and react to specific situations accordingly.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenScroll: [_^Callback^ Callback]_[* WhenScroll]&]
[s2; Called when scrolling of ArrayCtrl content happened.&]
[s3; &]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenHeaderLayout: [_^Callback^ Callback]_[* WhenHeaderLayout]&]
[s2; Called when header changes.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:WhenColumnSorted:%- [_^Upp`:`:Event^ Event]<>_[* WhenColumnSorte
d]&]
[s2; Invoked at the end of DoColumnSort. This allows to react to 
user sorting ArrayCtrl by clicking on column header marked as 
Sorting.&]
[s3;%- &]
[s4; &]
[s5;:ArrayCtrl`:`:WhenLineEnabled: [_^Callback2^ Callback2]<[@(0.0.255) int], 
[@(0.0.255) bool`&]>_[* WhenLineEnabled]&]
[s2; Provides additional means to enable/disable lines in addition 
to `"EnableLine`" interface. This is especially useful when using 
SetVirtualCount. First parameter is the line number, second is 
reference to enable status.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:ArrayCtrl`:`:WhenLineVisible: [_^Upp`:`:Callback2^ Callback2]<[@(0.0.255) int
], [@(0.0.255) bool`&]>_[* WhenLineVisible]&]
[s2; Provides additional means to show/hide lines in addition to 
`"ShowLine`" interface. This is especially useful when using 
SetVirtualCount. First parameter is the line number, second is 
reference to visibility status.&]
[s3; &]
[s0; &]
[ {{10000t/25b/25@3 [s0; [*@(229)4 ArrayCtrl`::IdInfo]]}}&]
[s3; &]
[s1;:ArrayCtrl`:`:IdInfo`:`:struct: [@(0.0.255)3 struct][3 _][*3 IdInfo]&]
[s9; The [* IdInfo] structure contains properties of all source array 
indices. It can be used to set additional properties pertaining 
to source array data.&]
[s3; &]
[s0; &]
[ {{10000F(128)G(128)@1 [s0; [* Public Member List]]}}&]
[s3; &]
[s5;:ArrayCtrl`:`:IdInfo`:`:InsertValue`(const Value`&`): [_^ArrayCtrl`:`:IdInfo^ IdInf
o][@(0.0.255) `&]_[* InsertValue]([@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v])
&]
[s2; The method sets up the default source index value for newly 
created rows. This is used only when the row insertion is GUI`-based 
(like using the [* DoInsert] method for instance). When a row is 
added to the array programmatically (e.g. using [* Add] or [* Insert]), 
these default values are not used.&]
[s7; [*C@3 v]-|default source index value&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IdInfo`:`:InsertValue`(ValueGen`&`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&
]_[* InsertValue]([_^ValueGen^ ValueGen][@(0.0.255) `&]_[*@3 g])&]
[s2; The method sets up a factory for generating default index values 
for newly created rows. This is used only when the row insertion 
is GUI`-based (like using the [* DoInsert] method for instance). 
When a row is added to the array programmatically (e.g. using 
[* Add] or [* Insert]), the [* InserValue] property is not consulted.&]
[s7; [*C@3 g]-|a reference to the value generation factory. The ownership 
to the factory is not passed by this call; the caller must insure 
the existence of the factory object throughout the array duration.&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IdInfo`:`:Accel`(int`(`*`)`(int`)`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&
]_[* Accel]([@(0.0.255) int]_(`*[*@3 filter])([@(0.0.255) int]))&]
[s2; This method sets up the source index accelerator function. The 
accelerator is used to quickly locate rows using the keyboard 
key presses.&]
[s7; [*C@3 filter]-|a [* CharFilter ]function for keypress filtering&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IdInfo`:`:Accel`(`): [_^ArrayCtrl`:`:IdInfo^ IdInfo][@(0.0.255) `&]_[* Ac
cel]()&]
[s2; This method sets up keyboard acceleration for the given source 
index. The `'trivial`' [/ CharConvert] is used for character translation.&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:IdInfo`:`:GetInsertValue`(`): [_^Value^ Value]_[* GetInsertValue]()&]
[s2; Uses the [* InsertValue] property to generate a new source index 
value (either using a fixed default value or the value creation 
factory).&]
[s7; [*/ Return value]-|the generated value to be used as the default 
for the newly inserted row.&]
[s3; &]
[s0; &]
[s0; &]
[s0; &]
[ {{10000t/25b/25@3 [s0; [*@(229)4 ArrayCtrl`::Column]]}}&]
[s3; &]
[s1;:ArrayCtrl`:`:Column`:`:class: [@(0.0.255)3 class][3 _][*3 Column][3 _:_][@(0.0.255)3 privat
e][3 _][*@3;3 FormatConvert]&]
[s2; &]
[s0; [/ Derived from] FormatConvert&]
[s0;3 &]
[s0; The [* ArrayCtrl`::Column] structure describes an output array 
column. Its methods can be used to set or query its properties, 
some of which are also settable via ArrayCtrl methods.&]
[s3; &]
[s0; &]
[ {{10000F(128)G(128)@1 [s0; [* Public Member List]]}}&]
[s3; &]
[s5;:ArrayCtrl`:`:Column`:`:Add`(int`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&]_[* A
dd]([@(0.0.255) int]_[*@3 `_pos])&]
[s2; Adds another source data index to the list of source indices 
used as the data for the given output column.&]
[s7; [*C@3 `_pos]-|zero`-based ordinal number of the source index&]
[s7; [*/ Return value]-|[* `*this].&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:Add`(const Id`&`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&
]_[* Add](const [_^Id^ Id]`&_[*@3 id])&]
[s2; Adds another source data index to the list of source indices 
used as the data for the given output column.&]
[s7; [*C@3 id]-|the [* Id] identifier of the source index&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:AddIndex`(const Id`&`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&
]_[* AddIndex]([@(0.0.255) const]_[_^Id^ Id][@(0.0.255) `&]_[*@3 id])&]
[s2; Adds another source index to the array and adds it to the list 
of source indices bound to this output column. The newly created 
index is assigned the given identifier.&]
[s7; [*C@3 id]-|the identifier for the newly created index&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:AddIndex`(`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&]_
[* AddIndex]()&]
[s2; Adds another source index to the array and adds it to the list 
of source indices bound to this output column.&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:SetConvert`(const Convert`&`): [_^ArrayCtrl`:`:Column^ Colu
mn][@(0.0.255) `&]_[* SetConvert]([@(0.0.255) const]_[_^Convert^ Convert][@(0.0.255) `&]_[*@3 c
])&]
[s2; Sets the [* Convert] object for the given column. This object 
is used to convert the source values (obtained from the source 
data matrix) to the values displayable and/or editable by the 
respective column display / editor object.&]
[s2; [* Note:] the ownership of the [* Convert] object is not transferred 
by this function. The array merely stores a pointer to the Convert 
object. It is up to the host application to keep the Convert 
object alive as long as necessary (until the ArrayCtrl object 
is destroyed or all references to the Convert object obliterated 
by new calls to the [* SetConvert] method). In any case, most Convert`-based 
object do not support copying at all; moreover, as the Convert`-based 
objects are mostly derived from the basic class, their copying 
is normally prone to slicing.&]
[s7; [*C@3 c]-|a constant reference to the Convert object to use for 
the given column&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:Column`:`:ConvertBy`(Upp`:`:Function`<Upp`:`:Value`(const Upp`:`:Value`&`)`>`):%- [_^Upp`:`:ArrayCtrl`:`:Column^ A
rrayCtrl`::Column][@(0.0.255) `&]_[* ConvertBy]([_^Upp`:`:Function^ Function]<Value([@(0.0.255) c
onst]_Value[@(0.0.255) `&])>_[*@3 cv])&]
[s2; Similar to SetConvert, but using [%-*@3 cv] instead of class for 
conversion.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:SetFormat`(const char`*`): [@(0.0.255) virtual] 
[_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&]_[* SetFormat]([@(0.0.255) const]_[@(0.0.255) c
har]_`*[*@3 fmt])&]
[s2; Sets the format string to use for the default value formatting. 
When no Convert object is set for the column, the source value 
is normally passed to the [* NFormat] function where the [/ fmt] 
argument defines the desired formatting pattern.&]
[s7; [*C@3 fmt]-|a [* NFormat]`-compatible formatting pattern&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:SetDisplay`(const Display`&`): [_^ArrayCtrl`:`:Column^ Colu
mn][@(0.0.255) `&]_[* SetDisplay]([@(0.0.255) const]_[_^Display^ Display][@(0.0.255) `&]_[*@3 d
])&]
[s2; Sets the default Display to use for this column. The column 
Display can be overridden for certain array cells by calls to 
the [*^topic`:`/`/CtrlLib`/src`/ArrayCtrl`$en`-us`#`:`:ArrayCtrl`:`:SetDisplay`(int`,int`,const Display`&`)^ A
rrayCtrl`::SetDisplay] method.&]
[s2; [* Note:] the ownership to the Display object is not transferred 
by this function. The array merely stores a pointer to the Display; 
it is up to the host application to keep the Display object alive 
as long as necessary.&]
[s7; [*C@3 d]-|a reference to the Display object&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:Edit`(Ctrl`&`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&
]_[* Edit]([_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 e])&]
[s2; Sets up the Ctrl`-based object to use for inline array column 
editing.&]
[s7; [*C@3 e]-|a reference to the editor control object&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:Ctrls`(void`(`*`)`(One`<Ctrl`>`&`)`): [_^ArrayCtrl`:`:Column^ C
olumn][@(0.0.255) `&]_[* Ctrls]([@(0.0.255) void]_(`*[*@3 factory])(One<Ctrl>`&))&]
[s2; The methods sets up a factory which the ArrayCtrl uses as necessary 
to create new Ctrl`'s for editing a given column. The argument 
of this function is a function pointer, which, upon execution, 
should allocate (normally using the One`::Create method) the desired 
editor object and set it to its argument. If the position of 
Ctrl is equivalent to `'SetRect(0, 0, 0, 0)`', which is the default 
value, Ctrl is resized to fit the ArrayCtrl cell accurately, 
spanning the whole width and using STDSIZE for height, otherwise 
the position represents the position within the cell.&]
[s7; [*C@3 factory]-|a global function used for editor control creation&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:Ctrls`(`): [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 T]>_[_^ArrayCtrl`:`:Column^ C
olumn][@(0.0.255) `&]_[* Ctrls]()&]
[s2; This member template sets up a default factory for creating 
editor controls of a given type. Every time the ArrayCtrl needs 
to create a new editor control, an object of the type [* T] is 
created automatically (using the [* new] operator). If the position 
of Ctrl is equivalent to `'SetRect(0, 0, 0, 0)`', which is the 
default value, Ctrl is resized to fit the ArrayCtrl cell accurately, 
spanning the whole width and using STDSIZE for height, otherwise 
the position represents the position within the cell.&]
[s7; [*C@4 T]-|the desired object editor type &]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:Column`:`:WithLined`(Upp`:`:Event`<int`,Upp`:`:One`<Upp`:`:Ctrl`>`&`>`):%- [_^Upp`:`:ArrayCtrl`:`:Column^ A
rrayCtrl`::Column][@(0.0.255) `&]_[* WithLined]([_^Upp`:`:Event^ Event]<[@(0.0.255) int], 
[_^Upp`:`:One^ One]<[_^Upp`:`:Ctrl^ Ctrl]>`&>_[*@3 factory])&]
[s2; This method sets up a factory which the ArrayCtrl uses to create 
new Ctrl`'s for editing a given column. The argument, a global 
function, is supposed to create a new editor control in the second 
argument (usually using the One`::Create method). The first argument 
of Event is the line index. If the position of Ctrl is equivalent 
to `'SetRect(0, 0, 0, 0)`', which is the default value, Ctrl 
is resized to fit the ArrayCtrl cell accurately, spanning the 
whole width and using STDSIZE for height, otherwise the position 
represents the position within the cell.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:Column`:`:With`(Upp`:`:Event`<Upp`:`:One`<Upp`:`:Ctrl`>`&`>`):%- [_^Upp`:`:ArrayCtrl`:`:Column^ A
rrayCtrl`::Column][@(0.0.255) `&]_[* With]([_^Upp`:`:Event^ Event]<[_^Upp`:`:One^ One]<[_^Upp`:`:Ctrl^ C
trl]>`&>_[*@3 factory])&]
[s2; This method sets up a factory which the ArrayCtrl uses to create 
new Ctrl`'s for editing a given column. The argument, a global 
function, is supposed to create a new editor control in the argument 
(usually using the One`::Create method). If the position of Ctrl 
is equivalent to `'SetRect(0, 0, 0, 0)`', which is the default 
value, Ctrl is resized to fit the ArrayCtrl cell accurately, 
spanning the whole width and using STDSIZE for height, otherwise 
the position represents the position within the cell.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:InsertValue`(const Value`&`): [_^ArrayCtrl`:`:Column^ Colum
n][@(0.0.255) `&]_[* InsertValue]([@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v])
&]
[s2; Instructs the ArrayCtrl object to initialize this column in 
newly created rows to the given value [/ v]. (This applies only 
to GUI`-based row insertion using methods like [* DoInsert] etc., 
the low`-level, programmer`-controlled row insertion methods 
like [* Add] or [* Insert] always initialize the source data matrix 
with [* Null]`'s).&]
[s7; [*C@3 v]-|the value to use as the default for newly inserted rows&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:InsertValue`(ValueGen`&`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&
]_[* InsertValue]([_^ValueGen^ ValueGen][@(0.0.255) `&]_[*@3 g])&]
[s2; Programs the ArrayCtrl object to use the given [* ValueGen] factory 
for default value generation for newly created rows. This can 
be used e.g. to generate unique UUID`'s or primary keys using 
an Oracle SEQUENCE object for a primary key column.&]
[s7; [*C@3 g]-|a reference to the ValueGen object used for default value 
generation&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:NoClickEdit`(`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&
]_[* NoClickEdit]()&]
[s2; Disables entering the editing mode when clicking the respective 
column.&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:Cache`(`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&]_[* Ca
che]()&]
[s2; Enables using the cache to store the converted values of this 
column. By default, converted value caching is turned off to 
make cell value conversion entirely dynamic; however, very often 
it is advisable to enable using the cache, especially when the 
conversion is relatively slow (for instance, when the conversion 
queries a database connection to convert the value).&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:Accel`(int`(`*`)`(int`)`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&
]_[* Accel]([@(0.0.255) int]_(`*[*@3 filter])([@(0.0.255) int]))&]
[s2; Sets up the accelerator for the given column. A given filtering 
function is used to convert keystrokes before acceleration.&]
[s7; [*C@3 filter]-|a [* CharConvert]`-style function to use for keystroke 
conversion&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:Accel`(`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&]_[* Ac
cel]()&]
[s2; Sets up the accelerator for the given column. No keystroke conversion 
is performed.&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:Margin`(int`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&]_
[* Margin]([@(0.0.255) int]_[*@3 m])&]
[s2; Sets up the margin width for the given column. This is equivalent 
to calling the [*^topic`:`/`/CtrlLib`/src`/HeaderCtrl`$en`-us`#`:`:HeaderCtrl`:`:Column`:`:SetMargin`(int`)^ S
etMargin] method of the underlying [* HeaderTab].&]
[s7; [*C@3 m]-|&]
[s7; [*/ Return value]-|[* `*this]&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:Sorting`(const ValueOrder`&`): [_^ArrayCtrl`:`:Column^ Colu
mn][@(0.0.255) `&]_[* Sorting]([@(0.0.255) const]_[_^ValueOrder^ ValueOrder][@(0.0.255) `&]_
[*@3 o])&]
[s5;:ArrayCtrl`:`:Column`:`:Sorting`(`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&]_[* S
orting]()&]
[s2; Activates sorting of ArrayCtrl column by clicking on its header 
tab. Parameterless version uses default Value ordering using 
StdValueCompare.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:Column`:`:SortingLined`(Upp`:`:Gate`<int`,int`>`):%- [_^Upp`:`:ArrayCtrl`:`:Column^ A
rrayCtrl`::Column][@(0.0.255) `&]_[* SortingLined]([_^Upp`:`:Gate^ Gate]<[@(0.0.255) int],
 [@(0.0.255) int]>_[*@3 aorder])&]
[s2; Activates sorting of ArrayCtrl column by clicking on its header 
tab. This variant uses a Gate2 predicate that is supposed to 
compare two lines (it has indicies as parameters). Note that 
this variant ignores ascending/descending order, it has to be 
implemented in predicate, using ArrayCtrl`::IsSortDescending to 
determine the order.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:Column`:`:SortingBy`(Upp`:`:Function`<int`(const Upp`:`:Value`&a`,const Upp`:`:Value`&b`)`>`):%- [_^Upp`:`:ArrayCtrl`:`:Column^ A
rrayCtrl`::Column][@(0.0.255) `&]_[* SortingBy]([_^Upp`:`:Function^ Function]<[@(0.0.255) i
nt]_([@(0.0.255) const]_Value[@(0.0.255) `&]_a, [@(0.0.255) const]_Value[@(0.0.255) `&]_b
)>_[*@3 c])&]
[s2; Activates sorting of ArrayCtrl column by clicking on its header 
tab, using [%-*@3 c] to compare values of column. [%-*@3 c] should 
return `-1, 0, 1 for <, `=, >.&]
[s3; &]
[s4;%- &]
[s5;:Upp`:`:ArrayCtrl`:`:Column`:`:SortDefault`(bool`):%- [_^Upp`:`:ArrayCtrl`:`:Column^ A
rrayCtrl`::Column][@(0.0.255) `&]_[* SortDefault]([@(0.0.255) bool]_[*@3 desc] 
`= [@(0.0.255) false])&]
[s2;%- [%% Sets this column to be initial sorting column (calls SetSortColumn 
of ArrayCtrl). If none of Sorting/SortingBy/SortingLines methods 
was called on this column yet, calls default Sorting for the 
column too. If ][*@3 desc] is true, sorting is in descending order.&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:HeaderTab`(`): [_^HeaderCtrl`:`:Column^ HeaderCtrl`::Column][@(0.0.255) `&
]_[* HeaderTab]()&]
[s5;:ArrayCtrl`:`:Column`:`:HeaderTab`(`)const: [@(0.0.255) const]_[_^HeaderCtrl`:`:Column^ H
eaderCtrl`::Column][@(0.0.255) `&]_[* HeaderTab]()_[@(0.0.255) const]&]
[s2; Returns the [* HeaderCtrl`::Column] object describing the given 
column. This object can be used to set up additional column properties 
(like column width constraints or the [*^topic`:`/`/CtrlLib`/src`/HeaderCtrl`$en`-us`#`:`:HeaderCtrl`:`:Column`:`:Callback WhenAction^ W
henAction] callback).&]
[s3; &]
[s4; &]
[s5;:ArrayCtrl`:`:Column`:`:Tip`(const char`*`): [_^ArrayCtrl`:`:Column^ Column][@(0.0.255) `&
]_[* Tip]([@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 tip])&]
[s2; Assigns a [*@3 tip] to header tab column.&]
[s3; &]
[s0; &]
[ {{10000t/25b/25@3 [s0; [*@(229)4 ArrayCtrl`::Order]]}}&]
[s3; &]
[s1;:ArrayCtrl`:`:Order`:`:struct: [@(0.0.255)3 struct][3 _][*3 Order]&]
[s9; The [* Order] object is used for array row sorting. The overloaded 
[* operator ()] acts as the sorting predicate, which is consulted 
within the sorting method to determine which of a given pair 
of row is `'less`' according to the desired sorting.&]
[s3; &]
[s0; &]
[ {{10000F(128)G(128)@1 [s0; [* Public Member List]]}}&]
[s3; &]
[s5;:ArrayCtrl`:`:Order`:`:operator`(`)`(const Vector`<Value`>`&`,const Vector`<Value`>`&`)const: [@(0.0.255) v
irtual] [@(0.0.255) bool]_[* operator()]([@(0.0.255) const]_[_^Vector^ Vector]<[_^Value^ Va
lue]>`&_[*@3 row1], [@(0.0.255) const]_[_^Vector^ Vector]<[_^Value^ Value]>`&_[*@3 row2])_[@(0.0.255) c
onst]_`=_[@3 0]&]
[s2; The sorting predicate. This method should return [* true] when 
its first argument ([/ row1]) is less than the second argument 
([/ row2]) according to the desired ordering.&]
[s7; [*C@3 row1]-|an array of source data index values for the first 
of the rows to compare&]
[s7; [*C@3 row2]-|an array of source data index values for the other 
row to compare&]
[s7; [*/ Return value]-|[* true] `= row1 < row2, [* false] `= row1 >`= row2&]
[s3; &]
[s0; ]]