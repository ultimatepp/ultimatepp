topic "TreeCtrl";
[i448;a25;kKO9;2 $$1,0#37138531426314131252341829483380:class]
[l288;2 $$2,0#27521748481378242620020725143825:desc]
[0 $$3,0#96390100711032703541132217272105:end]
[H6;0 $$4,0#05600065144404261032431302351956:begin]
[i448;a25;kKO9;2 $$5,0#37138531426314131252341829483370:item]
[l288;a4;*@5;1 $$6,6#70004532496200323422659154056402:requirement]
[l288;i1121;b17;O9;~~~.1408;2 $$7,0#10431211400427159095818037425705:param]
[i448;b42;O9;2 $$8,8#61672508125594000341940100500538:tparam]
[b42;2 $$9,9#13035079074754324216151401829390:normal]
[2 $$0,0#00000000000000000000000000000000:Default]
[{_} 
[ {{10000@3 [s0; [*@(229)4 TreeCtrl]]}}&]
[s3;%% &]
[s1;:TreeCtrl`:`:class: [@(0.0.255)3 class][3 _][*3 TreeCtrl][3 _:_][@(0.0.255)3 public][3 _][*@3;3 C
trl]&]
[s2;%% &]
[s2;%% 
@@image:1212&1156
(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)
&]
[s0;%% &]
[s9;%% TreeCtrl hierarchy management is based on integer id numbers. 
Each node in tree (item) has associated integer id unique for 
the tree. Child nodes of item are organized as an array. TreeCtrl 
provides operation to insert child nodes at specified array position 
and to query child and parent nodes. Root item has fixed id 0.&]
[s3;%% &]
[s0;%% &]
[ {{10000F(128)G(128)@1 [s0;%% [* Public Member List]]}}&]
[s3; &]
[s5;:TreeCtrl`:`:WhenOpen: [_^Callback1^ Callback1][@(0.0.255) <int>]_[* WhenOpen]&]
[s2;%% Tree item was opened, parameter is the item id.  &]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:WhenClose: [_^Callback1^ Callback1][@(0.0.255) <int>]_[* WhenClose]&]
[s2;%% Tree item was closed, parameter is the item id.  &]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:WhenLeftClick: [_^Callback^ Callback]_[* WhenLeftClick]&]
[s2;%% Tree item was clicked. Cursor identifies clicked item. You 
can get the click position within the item using GetItemClickPos 
method.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:WhenLeftDouble: [_^Callback^ Callback]_[* WhenLeftDouble]&]
[s2;%% Tree item was double`-clicked. Cursor identifies clicked item. 
You can get the click position within the item using GetItemClickPos 
method.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:WhenBar: [_^Callback1^ Callback1][@(0.0.255) <]Bar[@(0.0.255) `&>]_[* WhenBa
r]&]
[s2;%% Use to supply context menu.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:WhenSel: [_^Callback^ Callback]_[* WhenSel]&]
[s2;%% Cursor or selection has changed (including KillCursor).&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:WhenDrag: [_^Callback^ Callback]_[* WhenDrag]&]
[s2;%% Triggered when user attempts dragging an item.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:WhenDropItem: [_^Callback2^ Callback2][@(0.0.255) <int], 
[_^PasteClip^ PasteClip][@(0.0.255) `&>]_[* WhenDropItem]&]
[s2;%% This callback manages drag`&drop into TreeCtrl items. The 
first parameter is an id of item. See [^PasteClip^ PasteClip] for 
more details.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:WhenDropInsert: [_^Callback3^ Callback3][@(0.0.255) <int], 
[@(0.0.255) int], [_^PasteClip^ PasteClip][@(0.0.255) `&>]_[* WhenDropInsert]&]
[s2;%% This callback manages drag`&drop into insert positions between 
TreeCtrl items. The first parameter is an id of parent item, 
the second parameter is insert index within parent`'s child list. 
See [^PasteClip^ PasteClip] for more details.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:WhenDrop: [_^Callback1^ Callback1][@(0.0.255) <]PasteClip[@(0.0.255) `&>]_
[* WhenDrop]&]
[s2;%% This callback manages drag`&drop when WhenDropItem and WhenDropInsert 
do not apply `- drop into empty area. See [^PasteClip^ PasteClip] 
for more details.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:TreeCtrl`:`:WhenStartEdit: [_^Upp`:`:Event^ Event]<[@(0.0.255) int]>_[* WhenSta
rtEdit]&]
[s2;%% Called before TreeCtrl starts editing the node. The first 
parameter is the cursor of edited element.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:TreeCtrl`:`:WhenEdited: [_^Upp`:`:Event^ Event]<[@(0.0.255) int][%% ,][@(0.0.255)  
const]_Value[@(0.0.255) `&]>_[* WhenEdited]&]
[s2;%% When defined TreeCtrl will start editing the node value when 
clicked on already select one (after a while) in a way similar 
to e.g. FileSel file renaming. When the value is accepted, WhenEdit 
is called with a new value. Value is not changed in TreeCtrl, 
if that is desired, it is a responsibility of code that is assigned 
to the WhenEdited. Default editor is EditString and can be changed 
with Editor modifier method. The first parameter is the cursor 
of edited element.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:WhenCursor: [_^Callback^ Callback]_[* WhenCursor]&]
[s2;%% Cursor has changed (including KillCursor). Deprecated.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:WhenSelection: [_^Callback^ Callback]_[* WhenSelection]&]
[s2;%% Selection has changed. Deprecated.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SetRoot`(const TreeCtrl`:`:Node`&`): [@(0.0.255) void]_[* SetRoot]([@(0.0.255) c
onst]_[_^TreeCtrl`:`:Node^ TreeCtrl`::Node][@(0.0.255) `&]_[*@3 n])&]
[s2;%% Sets the content of root item to [%-*@3 n]. Full deep copy of 
[%-*@3 n] is performed.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SetRoot`(const Image`&`,Value`): [@(0.0.255) void]_[* SetRoot]([@(0.0.255) c
onst]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], [_^Value^ Value]_[*@3 v])&]
[s2;%% Sets image, key and value of root item. [%-*@3 v] is used both 
for key and value.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SetRoot`(const Image`&`,Value`,Value`): [@(0.0.255) void]_[* SetRoot]([@(0.0.255) c
onst]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], [_^Value^ Value]_[*@3 key], 
[_^Value^ Value]_[*@3 text])&]
[s2;%% Sets the image, key and value of root item.&]
[s3;%% &]
[s4; &]
[s5;:TreeCtrl`:`:SetRoot`(const Image`&`,Ctrl`&`,int`,int`): [@(0.0.255) void]_[* SetRoot
]([@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], [_^Ctrl^ Ctrl][@(0.0.255) `&]_
[*@3 ctrl], [@(0.0.255) int]_[*@3 cx]_`=_[@3 0], [@(0.0.255) int]_[*@3 cy]_`=_[@3 0])&]
[s2;%% Sets widget to be at root item. Only reference to [%-*@3 ctrl] 
is stored `-> widget object lifetime must exceed TreeCtrl`'s 
lifetime. Dimensions of widget should be [%-*@3 cx], [%-*@3 cy]. 
If either [%-*@3 cx] or [%-*@3 cy] are zero, GetMinSize dimension 
is used.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Insert`(int`,int`,const TreeCtrl`:`:Node`&`): [@(0.0.255) int]_[* Insert
]([@(0.0.255) int]_[*@3 parentid], [@(0.0.255) int]_[*@3 i], [@(0.0.255) const]_[_^TreeCtrl`:`:Node^ T
reeCtrl`::Node][@(0.0.255) `&]_[*@3 n])&]
[s5;:TreeCtrl`:`:Insert`(int`,int`): [@(0.0.255) int]_[* Insert]([@(0.0.255) int]_[*@3 parent
id], [@(0.0.255) int]_[*@3 i])&]
[s5;:TreeCtrl`:`:Insert`(int`,int`,const Image`&`,Value`,bool`): [@(0.0.255) int]_[* Inse
rt]([@(0.0.255) int]_[*@3 parentid], [@(0.0.255) int]_[*@3 i], [@(0.0.255) const]_[_^Image^ I
mage][@(0.0.255) `&]_[*@3 img], [_^Value^ Value]_[*@3 value], [@(0.0.255) bool]_[*@3 withopen
]_`=_[@(0.0.255) false])&]
[s5;:TreeCtrl`:`:Insert`(int`,int`,const Image`&`,Value`,Value`,bool`): [@(0.0.255) int
]_[* Insert]([@(0.0.255) int]_[*@3 parentid], [@(0.0.255) int]_[*@3 i], 
[@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], [_^Value^ Value]_[*@3 key], 
[_^Value^ Value]_[*@3 value], [@(0.0.255) bool]_[*@3 withopen]_`=_[@(0.0.255) false])&]
[s5;:TreeCtrl`:`:Insert`(int`,int`,const Image`&`,Ctrl`&`,int`,int`,bool`): [@(0.0.255) i
nt]_[* Insert]([@(0.0.255) int]_[*@3 parentid], [@(0.0.255) int]_[*@3 i], 
[@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], [_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 c
], [@(0.0.255) int]_[*@3 cx]_`=_[@3 0], [@(0.0.255) int]_[*@3 cy]_`=_[@3 0], 
[@(0.0.255) bool]_[*@3 wo]_`=_[@(0.0.255) false])&]
[s5;:TreeCtrl`:`:Insert`(int`,int`,const Image`&`,Value`,const String`&`,bool`): [@(0.0.255) i
nt]_[* Insert]([@(0.0.255) int]_[*@3 parentid], [@(0.0.255) int]_[*@3 i], 
[@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], [_^Value^ Value]_[*@3 key], 
[@(0.0.255) const]_[_^String^ String][@(0.0.255) `&]_[*@3 value], [@(0.0.255) bool]_[*@3 with
open]_`=_[@(0.0.255) false])&]
[s5;:TreeCtrl`:`:Insert`(int`,int`,const Image`&`,Value`,const char`*`,bool`): [@(0.0.255) i
nt]_[* Insert]([@(0.0.255) int]_[*@3 parentid], [@(0.0.255) int]_[*@3 i], 
[@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], [_^Value^ Value]_[*@3 key], 
[@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 value], [@(0.0.255) bool]_[*@3 withopen]_`=_[@(0.0.255) f
alse])&]
[s2; Inserts child item to parent specified by id. Distinct variants 
set various attributes to TreeCtrl`::Node of insterted item. Returns 
id of new item. Note: Last two overloads are  to avoid overloading 
ambiguity.&]
[s3;%% &]
[s4; &]
[s5;:TreeCtrl`:`:Add`(int`,const TreeCtrl`:`:Node`&`): [@(0.0.255) int]_[* Add]([@(0.0.255) i
nt]_[*@3 parentid], [@(0.0.255) const]_[_^TreeCtrl`:`:Node^ TreeCtrl`::Node][@(0.0.255) `&
]_[*@3 n])&]
[s5;:TreeCtrl`:`:Add`(int`): [@(0.0.255) int]_[* Add]([@(0.0.255) int]_[*@3 parentid])&]
[s5;:TreeCtrl`:`:Add`(int`,const Image`&`,Value`,bool`): [@(0.0.255) int]_[* Add]([@(0.0.255) i
nt]_[*@3 parentid], [@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], 
[_^Value^ Value]_[*@3 value], [@(0.0.255) bool]_[*@3 withopen]_`=_[@(0.0.255) false])&]
[s5;:TreeCtrl`:`:Add`(int`,const Image`&`,Value`,Value`,bool`): [@(0.0.255) int]_[* Add](
[@(0.0.255) int]_[*@3 parentid], [@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img],
 [_^Value^ Value]_[*@3 key], [_^Value^ Value]_[*@3 value], [@(0.0.255) bool]_[*@3 withopen]_`=
_[@(0.0.255) false])&]
[s5;:TreeCtrl`:`:Add`(int`,const Image`&`,Ctrl`&`,int`,int`,bool`): [@(0.0.255) int]_[* A
dd]([@(0.0.255) int]_[*@3 parentid], [@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 i
mg], [_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 ctrl], [@(0.0.255) int]_[*@3 cx]_`=_[@3 0], 
[@(0.0.255) int]_[*@3 cy]_`=_[@3 0], [@(0.0.255) bool]_[*@3 withopen]_`=_[@(0.0.255) false])&]
[s5;:TreeCtrl`:`:Add`(int`,const Image`&`,Value`,const String`&`,bool`): [@(0.0.255) in
t]_[* Add]([@(0.0.255) int]_[*@3 parentid], [@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&
]_[*@3 img], [_^Value^ Value]_[*@3 key], [@(0.0.255) const]_[_^String^ String][@(0.0.255) `&]_
[*@3 value], [@(0.0.255) bool]_[*@3 withopen]_`=_[@(0.0.255) false])&]
[s5;:TreeCtrl`:`:Add`(int`,const Image`&`,Value`,const char`*`,bool`): [@(0.0.255) int]_
[* Add]([@(0.0.255) int]_[*@3 parentid], [@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 i
mg], [_^Value^ Value]_[*@3 key], [@(0.0.255) const]_[@(0.0.255) char]_`*[*@3 value], 
[@(0.0.255) bool]_[*@3 withopen]_`=_[@(0.0.255) false])&]
[s2; Inserts child item at the end of list of parent`'s child items. 
Parent is specified by id. Distinct variants set various attributes 
to TreeCtrl`::Node of insterted item. Returns id of new item. 
Note: Last two overloads are  to avoid overloading ambiguity.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Remove`(int`): [@(0.0.255) void]_[* Remove]([@(0.0.255) int]_[*@3 id])&]
[s2;%% Removes item with [%-*@3 id] from the tree.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:RemoveChildren`(int`): [@(0.0.255) void]_[* RemoveChildren]([@(0.0.255) in
t]_[*@3 id])&]
[s2;%% Removes all child items from parent item with [%-*@3 id].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Swap`(int`,int`): [@(0.0.255) void]_[* Swap]([@(0.0.255) int]_[*@3 id1], 
[@(0.0.255) int]_[*@3 id2])&]
[s2;%% Swaps two tree items.&]
[s3;%% &]
[s4; &]
[s5;:TreeCtrl`:`:SwapChildren`(int`,int`,int`): [@(0.0.255) void]_[* SwapChildren]([@(0.0.255) i
nt]_[*@3 parentid], [@(0.0.255) int]_[*@3 i1], [@(0.0.255) int]_[*@3 i2])&]
[s2;%% Swaps [%-*@3 parentid] children with indices [%-*@3 i1] and [%-*@3 i2].&]
[s3;%% &]
[s4; &]
[s5;:TreeCtrl`:`:GetChildCount`(int`)const: [@(0.0.255) int]_[* GetChildCount]([@(0.0.255) i
nt]_[*@3 id])_[@(0.0.255) const]&]
[s2;%% Returns the number of child items of parent item with [%-*@3 id].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetChild`(int`,int`)const: [@(0.0.255) int]_[* GetChild]([@(0.0.255) int]_
[*@3 id], [@(0.0.255) int]_[*@3 i])_[@(0.0.255) const]&]
[s2;%% Returns the identifier of child at index  [%-*@3 i] of parent 
item with [%-*@3 id].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetChildIndex`(int`,int`)const: [@(0.0.255) int]_[* GetChildIndex]([@(0.0.255) i
nt]_[*@3 parentid], [@(0.0.255) int]_[*@3 childid])_[@(0.0.255) const]&]
[s2;%% Returns an index of child item of [%-*@3 parentid] with id [%-*@3 childid].&]
[s3;%% &]
[s4; &]
[s5;:TreeCtrl`:`:GetParent`(int`)const: [@(0.0.255) int]_[* GetParent]([@(0.0.255) int]_[*@3 i
d])_[@(0.0.255) const]&]
[s2;%% Returns the parent identifier of child with [%-*@3 id].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Get`(int`)const: [_^Value^ Value]_[* Get]([@(0.0.255) int]_[*@3 id])_[@(0.0.255) c
onst]&]
[s3;^Value^ &]
[s4;^Value^ &]
[s5;:TreeCtrl`:`:GetValue`(int`)const: [_^Value^ Value]_[* GetValue]([@(0.0.255) int]_[*@3 id
])_[@(0.0.255) const]&]
[s2;%% Returns the value of item with [%-*@3 id].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:operator`[`]`(int`)const: [_^Value^ Value]_[* operator`[`]]([@(0.0.255) in
t]_[*@3 id])_[@(0.0.255) const]&]
[s2;%% Returns the key of item with [%-*@3 id].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Set`(int`,Value`): [@(0.0.255) void]_[* Set]([@(0.0.255) int]_[*@3 id], 
[_^Value^ Value]_[*@3 v])&]
[s2;%% Sets the value [/ and] key of item with [%-*@3 id].&]
[s3;%% &]
[s4; &]
[s5;:TreeCtrl`:`:Set`(int`,Value`,Value`): [@(0.0.255) void]_[* Set]([@(0.0.255) int]_[*@3 id
], [_^Value^ Value]_[*@3 key], [_^Value^ Value]_[*@3 value])&]
[s2;%% Sets the value and key of item with [%-*@3 id].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SetValue`(const Value`&`): [@(0.0.255) void]_[* SetValue]([@(0.0.255) cons
t]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v])&]
[s2;%% Sets the value of item with cursor, key is unchanged.&]
[s3;%% &]
[s4; &]
[s5;:TreeCtrl`:`:SetDisplay`(int`,const Display`&`): [@(0.0.255) void]_[* SetDisplay]([@(0.0.255) i
nt]_[*@3 id], [@(0.0.255) const]_[_^Display^ Display][@(0.0.255) `&]_[*@3 display])&]
[s2;%% Sets the display of [%-*@3 id] item.&]
[s3;%% &]
[s4; &]
[s5;:TreeCtrl`:`:RefreshItem`(int`): [@(0.0.255) void]_[* RefreshItem]([@(0.0.255) int]_[*@3 i
d])&]
[s2;%% Forces the repainting of item (e.g. when its appearance changes 
in a way that cannot be detected by TreeCtrl widget).&]
[s3;%% &]
[s4; &]
[s5;:TreeCtrl`:`:GetLineCount`(`): [@(0.0.255) int]_[* GetLineCount]()&]
[s2;%% Gets the current number of lines `- visible items `- in TreeCtrl.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetItemAtLine`(int`): [@(0.0.255) int]_[* GetItemAtLine]([@(0.0.255) int]_
[*@3 i])&]
[s2;%% Gets the id of item at line i.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetLineAtItem`(int`): [@(0.0.255) int]_[* GetLineAtItem]([@(0.0.255) int]_
[*@3 id])&]
[s2;%% Gets the line of item with [%-*@3 id]. If item is not visible, 
returns negative value.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetNode`(int`)const: [_^TreeCtrl`:`:Node^ Node]_[* GetNode]([@(0.0.255) in
t]_[*@3 id])_[@(0.0.255) const]&]
[s2;%% Returns attributes of item with [%-*@3 id].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SetNode`(int`,const TreeCtrl`:`:Node`&`): [@(0.0.255) void]_[* SetNode](
[@(0.0.255) int]_[*@3 id], [@(0.0.255) const]_[_^TreeCtrl`:`:Node^ TreeCtrl`::Node][@(0.0.255) `&
]_[*@3 n])&]
[s2;%% Sets attributes.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:TreeCtrl`:`:IsValid`(int`)const: [@(0.0.255) bool]_[* IsValid]([@(0.0.255) int]_
[*@3 id])_[@(0.0.255) const]&]
[s2;%% Returns true if [%-*@3 id] represents a valid node id.&]
[s3;%% &]
[s4; &]
[s5;:TreeCtrl`:`:IsOpen`(int`)const: [@(0.0.255) bool]_[* IsOpen]([@(0.0.255) int]_[*@3 id])_
[@(0.0.255) const]&]
[s2;%% Tests whether item is opened.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Open`(int`,bool`): [@(0.0.255) void]_[* Open]([@(0.0.255) int]_[*@3 id], 
[@(0.0.255) bool]_[*@3 open]_`=_[@(0.0.255) true])&]
[s2;%% Opens or closes (if [%-*@3 open] is false) item with id `- makes 
all child items visible.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Close`(int`): [@(0.0.255) void]_[* Close]([@(0.0.255) int]_[*@3 id])&]
[s2;%% Same as Open(id, false).&]
[s3; &]
[s4; &]
[s5;:Upp`:`:TreeCtrl`:`:GetOpenIds`(`)const: [_^Upp`:`:Vector^ Vector]<[@(0.0.255) int]>_
[* GetOpenIds]()_[@(0.0.255) const]&]
[s2;%% Returns all open node ids.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:TreeCtrl`:`:OpenIds`(const Upp`:`:Vector`<int`>`&`): [@(0.0.255) void]_[* Ope
nIds]([@(0.0.255) const]_[_^Upp`:`:Vector^ Vector]<[@(0.0.255) int]>`&_[*@3 ids])&]
[s2;%% Opens all valid [%-*@3 ids].&]
[s3;%% &]
[s4; &]
[s5;:TreeCtrl`:`:OpenDeep`(int`,bool`): [@(0.0.255) void]_[* OpenDeep]([@(0.0.255) int]_[*@3 i
d], [@(0.0.255) bool]_[*@3 open]_`=_[@(0.0.255) true])&]
[s2;%% Opens/closes item with [%-*@3 id] and all of its child items.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:CloseDeep`(int`): [@(0.0.255) void]_[* CloseDeep]([@(0.0.255) int]_[*@3 id])
&]
[s2;%% Same as OpenDeep([%-*@3 id], false).&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:MakeVisible`(int`): [@(0.0.255) void]_[* MakeVisible]([@(0.0.255) int]_[*@3 i
d])&]
[s2;%% Opens all parent items of item with [%-*@3 id] to make it visible.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SetCursorLine`(int`): [@(0.0.255) void]_[* SetCursorLine]([@(0.0.255) int]_
[*@3 i])&]
[s2;%% Sets cursor in the tree to be at visible item line [%-*@3 i].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetCursorLine`(`)const: [@(0.0.255) int]_[* GetCursorLine]()_[@(0.0.255) c
onst]&]
[s2;%% Returns visible item line.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:KillCursor`(`): [@(0.0.255) void]_[* KillCursor]()&]
[s2;%% Removes cursor from tree.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SetCursor`(int`): [@(0.0.255) void]_[* SetCursor]([@(0.0.255) int]_[*@3 id])
&]
[s2;%% Sets cursor to item with [%-*@3 id]. If item is not visible, 
MakeVisible(id) is called first.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetCursor`(`)const: [@(0.0.255) int]_[* GetCursor]()_[@(0.0.255) const]&]
[s2;%% Returns id of item that currently has cursor or negative value 
if there is none.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:IsCursor`(`)const: [@(0.0.255) bool]_[* IsCursor]()_[@(0.0.255) const]&]
[s2;%% Returns true if there is cursor in the tree.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetItemClickPos`(`)const: [_^Point^ Point]_[* GetItemClickPos]()_[@(0.0.255) c
onst]&]
[s2;%% Returns current mouse position within item Display rectangle 
when clicked.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetScroll`(`)const: [_^Point^ Point]_[* GetScroll]()_[@(0.0.255) const]&]
[s2;%% Returns the scroll position of tree.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:ScrollTo`(Point`): [@(0.0.255) void]_[* ScrollTo]([_^Point^ Point]_[*@3 sc])
&]
[s2;%% Scrolls tree back to value previously returned by GetScroll.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Get`(`)const: [_^Value^ Value]_[* Get]()_[@(0.0.255) const]&]
[s2;%% Returns key of item with cursor or Null if there is none.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetValue`(`)const: [_^Value^ Value]_[* GetValue]()_[@(0.0.255) const]&]
[s2;%% Returns value of item with cursor or Null if there is none.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Find`(Value`): [@(0.0.255) int]_[* Find]([_^Value^ Value]_[*@3 key])&]
[s2;%% Returns id of item with [%-*@3 key] or negative value if not 
found.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:FindSetCursor`(Value`): [@(0.0.255) bool]_[* FindSetCursor]([_^Value^ Valu
e]_[*@3 key])&]
[s2;%% Places cursor to first item with [%-*@3 key], returns true if 
found.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Sort`(int`,const ValueOrder`&`,bool`): [@(0.0.255) void]_[* Sort]([@(0.0.255) i
nt]_[*@3 id], [@(0.0.255) const]_[_^ValueOrder^ ValueOrder][@(0.0.255) `&]_[*@3 order], 
[@(0.0.255) bool]_[*@3 byvalue]_`=_[@(0.0.255) false])&]
[s2;%% Sorts child items of item with [%-*@3 id] using [%-*@3 order] 
sorting predicate. If [%-*@3 byvalue] is false, items are sorted 
by keys, if true, by values.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SortDeep`(int`,const ValueOrder`&`,bool`): [@(0.0.255) void]_[* SortDeep
]([@(0.0.255) int]_[*@3 id], [@(0.0.255) const]_[_^ValueOrder^ ValueOrder][@(0.0.255) `&]_[*@3 o
rder], [@(0.0.255) bool]_[*@3 byvalue]_`=_[@(0.0.255) false])&]
[s2;%% Sorts child items of item with [%-*@3 id] using [%-*@3 order] 
sorting predicate. If [%-*@3 byvalue] is false, items are sorted 
by keys, if true, by values. After sorting, it recursively calls 
SortDeep for all child items.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Sort`(int`,int`(`*`)`(const Value`&v1`,const Value`&v2`)`,bool`): [@(0.0.255) v
oid]_[* Sort]([@(0.0.255) int]_[*@3 id], [@(0.0.255) int]_(`*[*@3 compare])([@(0.0.255) const
]_Value[@(0.0.255) `&]_v1, [@(0.0.255) const]_Value[@(0.0.255) `&]_v2)_`=_StdValueCompa
re, [@(0.0.255) bool]_[*@3 byvalue]_`=_[@(0.0.255) false])&]
[s2;%% Sort with simplified predicate [%-*@3 compare].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SortDeep`(int`,int`(`*`)`(const Value`&v1`,const Value`&v2`)`,bool`): [@(0.0.255) v
oid]_[* SortDeep]([@(0.0.255) int]_[*@3 id], [@(0.0.255) int]_(`*[*@3 compare])([@(0.0.255) c
onst]_Value[@(0.0.255) `&]_v1, [@(0.0.255) const]_Value[@(0.0.255) `&]_v2)_`=_StdValueC
ompare, [@(0.0.255) bool]_[*@3 byvalue]_`=_[@(0.0.255) false])&]
[s2;%% SortDeep with simplified predicate [%-*@3 compare].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SortByValue`(int`,const ValueOrder`&`): [@(0.0.255) void]_[* SortByValue
]([@(0.0.255) int]_[*@3 id], [@(0.0.255) const]_[_^ValueOrder^ ValueOrder][@(0.0.255) `&]_[*@3 o
rder])&]
[s5;:TreeCtrl`:`:SortDeepByValue`(int`,const ValueOrder`&`): [@(0.0.255) void]_[* SortDee
pByValue]([@(0.0.255) int]_[*@3 id], [@(0.0.255) const]_[_^ValueOrder^ ValueOrder][@(0.0.255) `&
]_[*@3 order])&]
[s5;:TreeCtrl`:`:SortByValue`(int`,int`(`*`)`(const Value`&v1`,const Value`&v2`)`): [@(0.0.255) v
oid]_[* SortByValue]([@(0.0.255) int]_[*@3 id], [@(0.0.255) int]_(`*[*@3 compare])([@(0.0.255) c
onst]_Value[@(0.0.255) `&]_v1, [@(0.0.255) const]_Value[@(0.0.255) `&]_v2)_`=_StdValueC
ompare)&]
[s5;:TreeCtrl`:`:SortDeepByValue`(int`,int`(`*`)`(const Value`&v1`,const Value`&v2`)`): [@(0.0.255) v
oid]_[* SortDeepByValue]([@(0.0.255) int]_[*@3 id], [@(0.0.255) int]_(`*[*@3 compare])([@(0.0.255) c
onst]_Value[@(0.0.255) `&]_v1, [@(0.0.255) const]_Value[@(0.0.255) `&]_v2)_`=_StdValueC
ompare)&]
[s2;%% Convenience variants call their basic counterparts with byvalue 
equal to true.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Sort`(int`,const ValuePairOrder`&`): [@(0.0.255) void]_[* Sort]([@(0.0.255) i
nt]_[*@3 id], [@(0.0.255) const]_[_^ValuePairOrder^ ValuePairOrder][@(0.0.255) `&]_[*@3 ord
er])&]
[s5;:TreeCtrl`:`:Sort`(int`,int`(`*`)`(const Value`&k1`,const Value`&v1`,const Value`&k2`,const Value`&v2`)`): [@(0.0.255) v
oid]_[* Sort]([@(0.0.255) int]_[*@3 id], [@(0.0.255) int]_(`*[*@3 compare])([@(0.0.255) const
]_Value[@(0.0.255) `&]_k1, [@(0.0.255) const]_Value[@(0.0.255) `&]_v1, 
[@(0.0.255) const]_Value[@(0.0.255) `&]_k2, [@(0.0.255) const]_Value[@(0.0.255) `&]_v2))&]
[s2;%% Sorts the children list of parent [%-*@3 id]. Note that if [%-*@3 id] 
is 0, the whole tree is sorted. The grandchildren are left intact.&]
[s3;%% &]
[s4; &]
[s5;:TreeCtrl`:`:SortDeep`(int`,const ValuePairOrder`&`): [@(0.0.255) void]_[* SortDeep](
[@(0.0.255) int]_[*@3 id], [@(0.0.255) const]_[_^ValuePairOrder^ ValuePairOrder][@(0.0.255) `&
]_[*@3 order])&]
[s5;:TreeCtrl`:`:SortDeep`(int`,int`(`*`)`(const Value`&k1`,const Value`&v1`,const Value`&k2`,const Value`&v2`)`): [@(0.0.255) v
oid]_[* SortDeep]([@(0.0.255) int]_[*@3 id], [@(0.0.255) int]_(`*[*@3 compare])([@(0.0.255) c
onst]_Value[@(0.0.255) `&]_k1, [@(0.0.255) const]_Value[@(0.0.255) `&]_v1, 
[@(0.0.255) const]_Value[@(0.0.255) `&]_k2, [@(0.0.255) const]_Value[@(0.0.255) `&]_v2))&]
[s2;%% Sorts the subtree of parent [%-*@3 id]. Note that if [%-*@3 id] 
is 0, the whole tree is sorted. The grandchildren are sorted 
as well.&]
[s3;%% &]
[s4; &]
[s5;:TreeCtrl`:`:Clear`(`): [@(0.0.255) void]_[* Clear]()&]
[s2;%% Removes all items from the tree.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:ClearSelection`(`): [@(0.0.255) void]_[* ClearSelection]()&]
[s2;%% Clears any selection.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SelectOne`(int`,bool`): [@(0.0.255) void]_[* SelectOne]([@(0.0.255) int]_[*@3 i
d], [@(0.0.255) bool]_[*@3 sel])&]
[s2;%% Selects/unselects single item with id.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:IsSelected`(int`)const: [@(0.0.255) bool]_[* IsSelected]([@(0.0.255) int]_
[*@3 id])_[@(0.0.255) const]&]
[s2;%% Returns true if item with [%-*@3 id] is selected.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:IsSel`(int`)const: [@(0.0.255) bool]_[* IsSel]([@(0.0.255) int]_[*@3 id])_[@(0.0.255) c
onst]&]
[s2;%% Returns true if item with [%-*@3 id] is selected [*/ or has cursor][/ .]&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:GetSelectCount`(`)const: [@(0.0.255) int]_[* GetSelectCount]()_[@(0.0.255) c
onst]&]
[s2;%% The number of selected items.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:IsSelDeep`(int`)const: [@(0.0.255) bool]_[* IsSelDeep]([@(0.0.255) int]_[*@3 i
d])_[@(0.0.255) const]&]
[s2;%% True, if IsSel is true for the item or if IsSelDeep is true 
for its parent (if any item in parenthood chain is selected).&]
[s3;%% &]
[s4; &]
[s5;:TreeCtrl`:`:GetSel`(`)const: [_^Vector^ Vector][@(0.0.255) <int>]_[* GetSel]()_[@(0.0.255) c
onst]&]
[s2;%% Returns ids of all items with IsSel is true (note that it 
includes cursor item if there is no selection).&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Remove`(const Vector`<int`>`&`): [@(0.0.255) void]_[* Remove]([@(0.0.255) c
onst]_[_^Vector^ Vector][@(0.0.255) <int>`&]_[*@3 id])&]
[s2;%% Removes a set of items, [%-*@3 id ]is a list of item ids to 
remove.&]
[s3;%% &]
[s4; &]
[s5;:TreeCtrl`:`:RemoveSelection`(`): [@(0.0.255) void]_[* RemoveSelection]()&]
[s2;%% Same as Remove(GetSel()) `- removes all selected items.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:TreeCtrl`:`:OkEdit`(`): [@(0.0.255) void]_[* OkEdit]()&]
[s2;%% If in`-place editor is active (see WhenEdited, WhenStartEdit 
and Editor), accepts the new value and ends the mode.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:TreeCtrl`:`:EndEdit`(`): [@(0.0.255) void]_[* EndEdit]()&]
[s2;%% If in`-place editor is active (see WhenEdited, WhenStartEdit 
and Editor), ends the mode without accepting the value.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Dump`(`): [@(0.0.255) void]_[* Dump]()&]
[s2;%% Diagnostic dump of tree content to standard log. Exists in 
debug mode only.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:NoCursor`(bool`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* NoCursor]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2;%% Tree does not allow cursor.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:NoRoot`(bool`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* NoRoot]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2;%% Root item is not shown.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:LevelCx`(int`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* LevelCx]([@(0.0.255) i
nt]_[*@3 cx])&]
[s2;%% Indentation per single hierarchy level. Default value is 16 
pixels.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:MultiSelect`(bool`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* MultiSelect](
[@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2;%% Allows selection of items.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:NoBackground`(bool`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* NoBackgroun
d]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2;%% White background of tree is not painted.&]
[s0;%% &]
[s4; &]
[s5;:TreeCtrl`:`:PopUpEx`(bool`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* PopUpEx]([@(0.0.255) b
ool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2;%% In case that the display size of node value is greater than 
currently available area, attempts to show the complete value 
when cursor hovers over the node.&]
[s3;%% &]
[s4; &]
[s5;:TreeCtrl`:`:NoPopUpEx`(`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* NoPopUpEx]()&]
[s2;%% Same as PopUpEx(false).&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:MouseMoveCursor`(bool`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* MouseMov
eCursor]([@(0.0.255) bool]_[*@3 m]_`=_[@(0.0.255) true])&]
[s2;%% Mouse cursor moves tree cursor without clicking, just by moving 
the mouse over the tree.&]
[s3;%% &]
[s4; &]
[s5;:TreeCtrl`:`:Accel`(bool`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* Accel]([@(0.0.255) b
ool]_[*@3 a]_`=_[@(0.0.255) true])&]
[s2;%% Activates simple keyboard accelerator. Node values are converted 
using StdFormat to text and then the first letter is used to 
find the appropriate item.&]
[s3;%% &]
[s4; &]
[s5;:TreeCtrl`:`:SetDisplay`(const Display`&`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* Se
tDisplay]([@(0.0.255) const]_[_^Display^ Display][@(0.0.255) `&]_[*@3 d])&]
[s2;%% Sets the universal Display used for all node values. This 
can be overridden for particular node by assigning node specific 
Display.&]
[s3;%% &]
[s4; &]
[s5;:TreeCtrl`:`:HighlightCtrl`(bool`): [_^TreeCtrl^ TreeCtrl][@(0.0.255) `&]_[* HighlightC
trl]([@(0.0.255) bool]_[*@3 a]_`=_[@(0.0.255) true])&]
[s2;%% Paints the background area of embedded widgets with the same 
color as that used to paint regular values `- respects selection, 
cursor position etc.&]
[s3;%% &]
[s4; &]
[s5;:Upp`:`:TreeCtrl`:`:RenderMultiRoot`(bool`): [_^Upp`:`:TreeCtrl^ TreeCtrl][@(0.0.255) `&
]_[* RenderMultiRoot]([@(0.0.255) bool]_[*@3 a]_`=_[@(0.0.255) true])&]
[s2;%% When active, no lines are drawn connecting zero level nodes 
(so it looks like there are multiple roots).&]
[s3;%% &]
[s4; &]
[s5;:Upp`:`:TreeCtrl`:`:EmptyNodeIcon`(const Upp`:`:Image`&`): [_^Upp`:`:TreeCtrl^ Tree
Ctrl][@(0.0.255) `&]_[* EmptyNodeIcon]([@(0.0.255) const]_[_^Upp`:`:Image^ Image][@(0.0.255) `&
]_[*@3 a])&]
[s2;%% When RenderMultiRoot is active and there the node is zero 
level and has not elements, [%-*@3 a] is drawn on the left side 
to indicate it is empty.&]
[s3;%% &]
[s4; &]
[s5;:Upp`:`:TreeCtrl`:`:Editor`(Upp`:`:Ctrl`&`): [_^Upp`:`:TreeCtrl^ TreeCtrl][@(0.0.255) `&
]_[* Editor]([_^Upp`:`:Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 e])&]
[s2;%% Assigns alternative editor for WhenEdited functionality.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:SetScrollBarStyle`(const ScrollBar`:`:Style`&`): [_^TreeCtrl^ TreeCtrl
][@(0.0.255) `&]_[* SetScrollBarStyle]([@(0.0.255) const]_[_^ScrollBar`:`:Style^ ScrollBa
r`::Style][@(0.0.255) `&]_[*@3 s])&]
[s2;%% Assigns a chameleon visual style of scrollbar of TreeCtrl.&]
[s3;%% &]
[s4; &]
[s5;:Upp`:`:TreeCtrl`:`:ScrollIntoX`(bool`): TreeCtrl[@(0.0.255) `&] 
[* ScrollIntoX]([@(0.0.255) bool] [*@3 b])&]
[s2;%% If active, ScrollIntoLine and ScrolIntoCursor functions also 
move horizontal scrollbar to make item visible (e.g. if it is 
very deep in the tree).&]
[s3;%% &]
[s0;%% &]
[s0; &]
[s0; &]
[ {{10000@3 [s0; [*@(229)4 TreeCtrl`::Node]]}}&]
[s3; &]
[s1;:TreeCtrl`:`:Node`:`:class: [@(0.0.255)3 class][3 _][*3 Node]&]
[s9;%% This class represents the content and appearance of single 
TreeCtrl node`-item.&]
[s3; &]
[s0; &]
[ {{10000F(128)G(128)@1 [s0;%% [* Constructor Detail]]}}&]
[s3; &]
[s5;:TreeCtrl`:`:Node`:`:Node`(`): [* Node]()&]
[s2;%% Default constructor.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:Node`(const Image`&`,const Value`&`): [* Node]([@(0.0.255) const
]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], [@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&
]_[*@3 v])&]
[s2;%% Assigns icon, key and value.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:Node`(const Image`&`,const Value`&`,const Value`&`): [* Node](
[@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], [@(0.0.255) const]_[_^Value^ Va
lue][@(0.0.255) `&]_[*@3 v], [@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 t])&]
[s2;%% Assigns icon, key and value.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:Node`(const Value`&`): [* Node]([@(0.0.255) const]_[_^Value^ Value
][@(0.0.255) `&]_[*@3 v])&]
[s2;%% Assigns key and value.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:Node`(const Value`&`,const Value`&`): [* Node]([@(0.0.255) const
]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v], [@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_
[*@3 t])&]
[s2;%% Assigns key and value.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:Node`(Ctrl`&`): [* Node]([_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 ctrl])&]
[s2;%% Assigns widget.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:Node`(const Image`&`,Ctrl`&`,int`,int`): [* Node]([@(0.0.255) co
nst]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img], [_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 ctrl], 
[@(0.0.255) int]_[*@3 cx]_`=_[@3 0], [@(0.0.255) int]_[*@3 cy]_`=_[@3 0])&]
[s2;%% Assigns icon, widget and its dimensions.&]
[s3;%% &]
[s0;%% &]
[ {{10000F(128)G(128)@1 [s0;%% [* Public Member List]]}}&]
[s3; &]
[s5;:TreeCtrl`:`:Node`:`:image: [_^Image^ Image]_[* image]&]
[s2;%% Node icon.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:margin: [@(0.0.255) int]_[* margin]&]
[s2;%% Space between icon and value of the item, or item`'s widget. 
Defaults to 2.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:key: [_^Value^ Value]_[* key]&]
[s2;%% Item key. This is not displayed.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:value: [_^Value^ Value]_[* value]&]
[s2;%% Item value.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:display: [@(0.0.255) const]_[_^Display^ Display]_`*[* display]&]
[s2;%% Display used to render value. Defaults to NULL, which means 
StdDisplay is to be used.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:size: [_^Size^ Size]_[* size]&]
[s2;%% Size of value area. Defaults to Null `- in that case, value 
area size is determined by display`->GetStdSize(value) or ctrl`->GetMinSize() 
if widget for item is used.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:ctrl: [_^Ptr^ Ptr][@(0.0.255) <][_^Ctrl^ Ctrl][@(0.0.255) >]_[* ctrl]&]
[s2;%% Widget associated with item.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:canopen: [@(0.0.255) bool]_[* canopen]&]
[s2;%% Item can be opened.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:canselect: [@(0.0.255) bool]_[* canselect]&]
[s2;%% Item can be selected.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:SetImage`(const Image`&`): [_^TreeCtrl`:`:Node^ Node][@(0.0.255) `&
]_[* SetImage]([@(0.0.255) const]_[_^Image^ Image][@(0.0.255) `&]_[*@3 img])&]
[s2;%% Sets image.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:Set`(const Value`&`): [_^TreeCtrl`:`:Node^ Node][@(0.0.255) `&]_
[* Set]([@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v])&]
[s2;%% Sets both key and value to [%-*@3 v].&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:Set`(const Value`&`,const Value`&`): [_^TreeCtrl`:`:Node^ Node
][@(0.0.255) `&]_[* Set]([@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 v], 
[@(0.0.255) const]_[_^Value^ Value][@(0.0.255) `&]_[*@3 t])&]
[s2;%% Sets key and value.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:SetDisplay`(const Display`&`): [_^TreeCtrl`:`:Node^ Node][@(0.0.255) `&
]_[* SetDisplay]([@(0.0.255) const]_[_^Display^ Display][@(0.0.255) `&]_[*@3 d])&]
[s2;%% Sets display.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:SetSize`(Size`): [_^TreeCtrl`:`:Node^ Node][@(0.0.255) `&]_[* SetS
ize]([_^Size^ Size]_[*@3 sz])&]
[s2;%% Sets size.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:SetCtrl`(Ctrl`&`): [_^TreeCtrl`:`:Node^ Node][@(0.0.255) `&]_[* Se
tCtrl]([_^Ctrl^ Ctrl][@(0.0.255) `&]_[*@3 `_ctrl])&]
[s2;%% Sets widget.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:CanOpen`(bool`): [_^TreeCtrl`:`:Node^ Node][@(0.0.255) `&]_[* CanO
pen]([@(0.0.255) bool]_[*@3 b]_`=_[@(0.0.255) true])&]
[s2;%% Sets canopen flag.&]
[s3; &]
[s4; &]
[s5;:TreeCtrl`:`:Node`:`:CanSelect`(bool`): [_^TreeCtrl`:`:Node^ Node][@(0.0.255) `&]_[* Ca
nSelect]([@(0.0.255) bool]_[*@3 b])&]
[s2;%% Sets canselect flag.&]
[s3; &]
[s0; ]]