/// @file include-private/xed3-phash-vv1.h

// This file was automatically generated.
// Do not edit this file.

#if !defined(INCLUDE_PRIVATE_XED3_PHASH_VV1_H)
# define INCLUDE_PRIVATE_XED3_PHASH_VV1_H
/*BEGIN_LEGAL

Copyright (c) 2018 Intel Corporation

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  
END_LEGAL */
#include "xed-internal-header.h"
#include "xed3-operand-lu.h"
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x10_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x11_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x12_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x13_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x14_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x15_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x16_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x17_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x28_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x29_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x2a_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x2b_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x2c_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x2d_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x2e_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x2f_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x41_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x42_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x44_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x45_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x46_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x47_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x4a_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x4b_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x50_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x51_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x52_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x53_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x54_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x55_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x56_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x57_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x58_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x59_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x5a_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x5b_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x5c_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x5d_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x5e_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x5f_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x60_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x61_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x62_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x63_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x64_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x65_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x66_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x67_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x68_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x69_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x6a_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x6b_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x6c_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x6d_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x6e_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x6f_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x70_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x71_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x72_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x73_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x74_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x75_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x76_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x77_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x7c_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x7d_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x7e_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x7f_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x90_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x91_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x92_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x93_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x98_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x99_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xae_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xc2_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xc4_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xc5_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xc6_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xd0_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xd1_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xd2_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xd3_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xd4_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xd5_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xd6_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xd7_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xd8_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xd9_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xda_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xdb_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xdc_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xdd_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xde_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xdf_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xe0_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xe1_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xe2_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xe3_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xe4_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xe5_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xe6_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xe7_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xe8_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xe9_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xea_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xeb_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xec_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xed_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xee_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xef_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xf0_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xf1_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xf2_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xf3_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xf4_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xf5_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xf6_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xf7_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xf8_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xf9_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xfa_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xfb_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xfc_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xfd_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0xfe_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x0_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x1_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x2_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x3_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x4_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x5_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x6_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x7_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x8_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x9_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xa_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xb_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xc_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xd_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xe_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xf_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x13_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x16_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x17_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x18_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x19_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x1a_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x1c_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x1d_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x1e_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x20_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x21_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x22_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x23_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x24_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x25_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x28_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x29_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x2a_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x2b_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x2c_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x2d_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x2e_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x2f_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x30_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x31_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x32_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x33_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x34_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x35_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x36_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x37_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x38_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x39_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x3a_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x3b_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x3c_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x3d_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x3e_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x3f_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x40_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x41_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x45_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x46_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x47_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x58_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x59_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x5a_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x78_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x79_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x8c_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x8e_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x90_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x91_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x92_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x93_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x96_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x97_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x98_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x99_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x9a_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x9b_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x9c_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x9d_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x9e_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x9f_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xa6_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xa7_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xa8_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xa9_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xaa_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xab_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xac_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xad_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xae_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xaf_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xb6_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xb7_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xb8_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xb9_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xba_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xbb_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xbc_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xbd_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xbe_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xbf_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xcf_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xdb_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xdc_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xdd_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xde_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xdf_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xf2_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xf3_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xf5_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xf6_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xf7_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x0_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x1_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x2_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x4_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x5_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x6_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x8_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x9_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0xa_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0xb_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0xc_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0xd_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0xe_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0xf_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x14_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x15_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x16_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x17_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x18_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x19_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x1d_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x20_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x21_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x22_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x30_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x31_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x32_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x33_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x38_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x39_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x40_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x41_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x42_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x44_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x46_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x48_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x49_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x4a_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x4b_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x4c_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x5c_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x5d_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x5e_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x5f_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x60_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x61_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x62_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x63_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x68_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x69_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x6a_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x6b_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x6c_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x6d_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x6e_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x6f_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x78_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x79_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x7a_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x7b_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x7c_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x7d_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x7e_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x7f_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0xce_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0xcf_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0xdf_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0xf0_vv1(const xed_decoded_inst_t* d);

static xed_uint32_t xed3_phash_find_map0x0F_opcode0x10_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[96] = {
/*h(125)=0 VV1 0x10  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {125, 2215},
/*h(93)=1 VV1 0x10  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {93, 2215},
/*h(61)=2 VV1 0x10  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {61, 2215},
/*h(29)=3 VV1 0x10  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {29, 2215},
/*empty slot1 */ {0,0},
/*h(118)=5 VV1 0x10  VF2 V0F MOD[mm] MOD!=3  NOVSR REG[rrr] RM[nnn] MODRM()*/ {118, 2204},
/*h(86)=6 VV1 0x10  VF2 V0F MOD[mm] MOD!=3  NOVSR REG[rrr] RM[nnn] MODRM()*/ {86, 2204},
/*h(54)=7 VV1 0x10  VF2 V0F MOD[mm] MOD!=3  NOVSR REG[rrr] RM[nnn] MODRM()*/ {54, 2204},
/*h(22)=8 VV1 0x10  VF2 V0F MOD[mm] MOD!=3  NOVSR REG[rrr] RM[nnn] MODRM()*/ {22, 2204},
/*h(115)=9 VV1 0x10  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {115, 2205},
/*h(83)=10 VV1 0x10  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {83, 2205},
/*h(51)=11 VV1 0x10  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {51, 2205},
/*h(19)=12 VV1 0x10  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {19, 2205},
/*h(126)=13 VV1 0x10  VF3 V0F MOD[mm] MOD!=3  NOVSR REG[rrr] RM[nnn] MODRM()*/ {126, 2214},
/*h(94)=14 VV1 0x10  VF3 V0F MOD[mm] MOD!=3  NOVSR REG[rrr] RM[nnn] MODRM()*/ {94, 2214},
/*h(62)=15 VV1 0x10  VF3 V0F MOD[mm] MOD!=3  NOVSR REG[rrr] RM[nnn] MODRM()*/ {62, 2214},
/*h(30)=16 VV1 0x10  VF3 V0F MOD[mm] MOD!=3  NOVSR REG[rrr] RM[nnn] MODRM()*/ {30, 2214},
/*empty slot1 */ {0,0},
/*h(119)=18 VV1 0x10  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {119, 2205},
/*h(87)=19 VV1 0x10  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {87, 2205},
/*h(55)=20 VV1 0x10  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {55, 2205},
/*h(23)=21 VV1 0x10  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 2205},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(127)=26 VV1 0x10  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {127, 2215},
/*h(95)=27 VV1 0x10  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {95, 2215},
/*h(63)=28 VV1 0x10  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {63, 2215},
/*h(31)=29 VV1 0x10  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {31, 2215},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(117)=35 VV1 0x10  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {117, 2205},
/*h(85)=36 VV1 0x10  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {85, 2205},
/*h(53)=37 VV1 0x10  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {53, 2205},
/*h(21)=38 VV1 0x10  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 2205},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(46)=42 VV1 0x10  V66 VL256 V0F NOVSR  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 2944},
/*h(14)=43 VV1 0x10  V66 VL128 V0F NOVSR  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2940},
/*h(121)=44 VV1 0x10  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {121, 2215},
/*h(89)=45 VV1 0x10  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {89, 2215},
/*h(57)=46 VV1 0x10  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {57, 2215},
/*h(25)=47 VV1 0x10  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {25, 2215},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(47)=55 VV1 0x10  V66 VL256 V0F NOVSR  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 2945},
/*h(15)=56 VV1 0x10  V66 VL128 V0F NOVSR  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 2941},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(123)=70 VV1 0x10  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {123, 2215},
/*h(91)=71 VV1 0x10  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {91, 2215},
/*h(59)=72 VV1 0x10  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {59, 2215},
/*h(27)=73 VV1 0x10  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {27, 2215},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(38)=77 VV1 0x10  VNP VL256 V0F NOVSR  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {38, 2926},
/*h(6)=78 VV1 0x10  VNP VL128 V0F NOVSR  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 2922},
/*h(113)=79 VV1 0x10  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {113, 2205},
/*h(81)=80 VV1 0x10  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {81, 2205},
/*h(49)=81 VV1 0x10  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {49, 2205},
/*h(17)=82 VV1 0x10  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {17, 2205},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(39)=90 VV1 0x10  VNP VL256 V0F NOVSR  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {39, 2927},
/*h(7)=91 VV1 0x10  VNP VL128 V0F NOVSR  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 2923},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = ((13*key % 139) % 96);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x11_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[96] = {
/*h(125)=0 VV1 0x11  VF3 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {125, 2217},
/*h(93)=1 VV1 0x11  VF3 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {93, 2217},
/*h(61)=2 VV1 0x11  VF3 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {61, 2217},
/*h(29)=3 VV1 0x11  VF3 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {29, 2217},
/*empty slot1 */ {0,0},
/*h(118)=5 VV1 0x11  VF2 V0F MOD[mm] MOD!=3 NOVSR REG[rrr] RM[nnn] MODRM()*/ {118, 2206},
/*h(86)=6 VV1 0x11  VF2 V0F MOD[mm] MOD!=3 NOVSR REG[rrr] RM[nnn] MODRM()*/ {86, 2206},
/*h(54)=7 VV1 0x11  VF2 V0F MOD[mm] MOD!=3 NOVSR REG[rrr] RM[nnn] MODRM()*/ {54, 2206},
/*h(22)=8 VV1 0x11  VF2 V0F MOD[mm] MOD!=3 NOVSR REG[rrr] RM[nnn] MODRM()*/ {22, 2206},
/*h(115)=9 VV1 0x11  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {115, 2207},
/*h(83)=10 VV1 0x11  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {83, 2207},
/*h(51)=11 VV1 0x11  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {51, 2207},
/*h(19)=12 VV1 0x11  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {19, 2207},
/*h(126)=13 VV1 0x11  VF3 V0F  MOD[mm] MOD!=3 NOVSR  REG[rrr] RM[nnn] MODRM()*/ {126, 2216},
/*h(94)=14 VV1 0x11  VF3 V0F  MOD[mm] MOD!=3 NOVSR  REG[rrr] RM[nnn] MODRM()*/ {94, 2216},
/*h(62)=15 VV1 0x11  VF3 V0F  MOD[mm] MOD!=3 NOVSR  REG[rrr] RM[nnn] MODRM()*/ {62, 2216},
/*h(30)=16 VV1 0x11  VF3 V0F  MOD[mm] MOD!=3 NOVSR  REG[rrr] RM[nnn] MODRM()*/ {30, 2216},
/*empty slot1 */ {0,0},
/*h(119)=18 VV1 0x11  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {119, 2207},
/*h(87)=19 VV1 0x11  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {87, 2207},
/*h(55)=20 VV1 0x11  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {55, 2207},
/*h(23)=21 VV1 0x11  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 2207},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(127)=26 VV1 0x11  VF3 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {127, 2217},
/*h(95)=27 VV1 0x11  VF3 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {95, 2217},
/*h(63)=28 VV1 0x11  VF3 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {63, 2217},
/*h(31)=29 VV1 0x11  VF3 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {31, 2217},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(117)=35 VV1 0x11  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {117, 2207},
/*h(85)=36 VV1 0x11  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {85, 2207},
/*h(53)=37 VV1 0x11  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {53, 2207},
/*h(21)=38 VV1 0x11  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 2207},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(46)=42 VV1 0x11  V66 VL256 V0F NOVSR  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 2946},
/*h(14)=43 VV1 0x11  V66 VL128 V0F NOVSR  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2942},
/*h(121)=44 VV1 0x11  VF3 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {121, 2217},
/*h(89)=45 VV1 0x11  VF3 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {89, 2217},
/*h(57)=46 VV1 0x11  VF3 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {57, 2217},
/*h(25)=47 VV1 0x11  VF3 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {25, 2217},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(47)=55 VV1 0x11  V66 VL256 V0F NOVSR  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 2947},
/*h(15)=56 VV1 0x11  V66 VL128 V0F NOVSR  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 2943},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(123)=70 VV1 0x11  VF3 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {123, 2217},
/*h(91)=71 VV1 0x11  VF3 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {91, 2217},
/*h(59)=72 VV1 0x11  VF3 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {59, 2217},
/*h(27)=73 VV1 0x11  VF3 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {27, 2217},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(38)=77 VV1 0x11  VNP VL256 V0F NOVSR  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {38, 2928},
/*h(6)=78 VV1 0x11  VNP VL128 V0F NOVSR  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 2924},
/*h(113)=79 VV1 0x11  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {113, 2207},
/*h(81)=80 VV1 0x11  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {81, 2207},
/*h(49)=81 VV1 0x11  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {49, 2207},
/*h(17)=82 VV1 0x11  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {17, 2207},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(39)=90 VV1 0x11  VNP VL256 V0F NOVSR  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {39, 2929},
/*h(7)=91 VV1 0x11  VNP VL128 V0F NOVSR  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 2925},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = ((13*key % 139) % 96);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x12_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[34] = {
/*h(0)=0 VV1 0x12  VL128 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {0, 2733},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(5)=3 VV1 0x12  VL128 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 3514},
/*empty slot1 */ {0,0},
/*h(31)=5 VV1 0x12  VL128 VF3 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {31, 2574},
/*h(10)=6 VV1 0x12  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2724},
/*h(23)=7 VV1 0x12  VL128 VF2 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 2385},
/*h(2)=8 VV1 0x12  VL128 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2733},
/*empty slot1 */ {0,0},
/*h(62)=10 VV1 0x12  VL256 VF3 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {62, 2575},
/*h(7)=11 VV1 0x12  VL128 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3514},
/*h(54)=12 VV1 0x12  VL256 VF2 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {54, 2386},
/*empty slot1 */ {0,0},
/*h(12)=14 VV1 0x12  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {12, 2724},
/*empty slot1 */ {0,0},
/*h(4)=16 VV1 0x12  VL128 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2733},
/*empty slot1 */ {0,0},
/*h(30)=18 VV1 0x12  VL128 VF3 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {30, 2573},
/*empty slot1 */ {0,0},
/*h(22)=20 VV1 0x12  VL128 VF2 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 2384},
/*h(1)=21 VV1 0x12  VL128 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {1, 3514},
/*h(14)=22 VV1 0x12  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2724},
/*empty slot1 */ {0,0},
/*h(6)=24 VV1 0x12  VL128 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 2733},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(3)=29 VV1 0x12  VL128 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3514},
/*empty slot1 */ {0,0},
/*h(63)=31 VV1 0x12  VL256 VF3 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {63, 2576},
/*h(8)=32 VV1 0x12  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {8, 2724},
/*h(55)=33 VV1 0x12  VL256 VF2 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {55, 2387}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 34ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x13_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[3] = {
/*empty slot1 */ {0,0},
/*h(14)=1 VV1 0x13  VL128 V66 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2725},
/*h(6)=2 VV1 0x13  VL128 VNP V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 2734}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 3ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x14_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[10] = {
/*h(0)=0 VV1 0x14  VL128 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {0, 3583},
/*h(10)=1 VV1 0x14  VL256 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3601},
/*h(2)=2 VV1 0x14  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3599},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(9)=5 VV1 0x14  VL256 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {9, 3586},
/*h(1)=6 VV1 0x14  VL128 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {1, 3584},
/*h(11)=7 VV1 0x14  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3602},
/*h(3)=8 VV1 0x14  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3600},
/*h(8)=9 VV1 0x14  VL256 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {8, 3585}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 10ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x15_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[10] = {
/*h(0)=0 VV1 0x15  VL128 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {0, 2852},
/*h(10)=1 VV1 0x15  VL256 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2510},
/*h(2)=2 VV1 0x15  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2508},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(9)=5 VV1 0x15  VL256 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {9, 2855},
/*h(1)=6 VV1 0x15  VL128 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {1, 2853},
/*h(11)=7 VV1 0x15  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2511},
/*h(3)=8 VV1 0x15  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2509},
/*h(8)=9 VV1 0x15  VL256 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {8, 2854}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 10ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x16_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[32] = {
/*h(0)=0 VV1 0x16  VL128 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {0, 3103},
/*h(3)=1 VV1 0x16  VL128 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2732},
/*h(30)=2 VV1 0x16  VL128 VF3 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {30, 2303},
/*h(7)=3 VV1 0x16  VL128 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 2732},
/*h(10)=4 VV1 0x16  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3080},
/*empty slot1 */ {0,0},
/*h(14)=6 VV1 0x16  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 3080},
/*h(4)=7 VV1 0x16  VL128 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 3103},
/*h(31)=8 VV1 0x16  VL128 VF3 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {31, 2304},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(1)=11 VV1 0x16  VL128 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {1, 2732},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(8)=14 VV1 0x16  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {8, 3080},
/*empty slot1 */ {0,0},
/*h(62)=16 VV1 0x16  VL256 VF3 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {62, 2305},
/*empty slot1 */ {0,0},
/*h(5)=18 VV1 0x16  VL128 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 2732},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(12)=21 VV1 0x16  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {12, 3080},
/*h(2)=22 VV1 0x16  VL128 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3103},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(63)=27 VV1 0x16  VL256 VF3 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {63, 2306},
/*empty slot1 */ {0,0},
/*h(6)=29 VV1 0x16  VL128 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3103},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = ((11*key % 37) % 32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x17_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[3] = {
/*empty slot1 */ {0,0},
/*h(14)=1 VV1 0x17  VL128 V66 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 3081},
/*h(6)=2 VV1 0x17  VL128 VNP V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3104}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 3ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x28_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[13] = {
/*h(47)=0 VV1 0x28  VL256 V66 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 3297},
/*h(39)=1 VV1 0x28  VL256 VNP V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {39, 3331},
/*empty slot1 */ {0,0},
/*h(15)=3 VV1 0x28  VL128 V66 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 3293},
/*h(7)=4 VV1 0x28  VL128 VNP V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3327},
/*h(46)=5 VV1 0x28  VL256 V66 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 3296},
/*h(38)=6 VV1 0x28  VL256 VNP V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {38, 3330},
/*empty slot1 */ {0,0},
/*h(14)=8 VV1 0x28  VL128 V66 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 3292},
/*h(6)=9 VV1 0x28  VL128 VNP V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3326},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 13ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x29_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[13] = {
/*h(47)=0 VV1 0x29  VL256 V66 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 3299},
/*h(39)=1 VV1 0x29  VL256 VNP V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {39, 3333},
/*empty slot1 */ {0,0},
/*h(15)=3 VV1 0x29  VL128 V66 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 3295},
/*h(7)=4 VV1 0x29  VL128 VNP V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3329},
/*h(46)=5 VV1 0x29  VL256 V66 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 3298},
/*h(38)=6 VV1 0x29  VL256 VNP V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {38, 3332},
/*empty slot1 */ {0,0},
/*h(14)=8 VV1 0x29  VL128 V66 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 3294},
/*h(6)=9 VV1 0x29  VL128 VNP V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3328},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 13ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x2a_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[34] = {
/*h(34)=0 VV1 0x2A  VF2 V0F not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {34, 3470},
/*empty slot1 */ {0,0},
/*h(60)=2 VV1 0x2A   VF3 V0F mode64 rexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {60, 3457},
/*empty slot1 */ {0,0},
/*h(52)=4 VV1 0x2A   VF3 V0F mode64 norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {52, 3455},
/*empty slot1 */ {0,0},
/*h(44)=6 VV1 0x2A  VF2 V0F mode64 rexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {44, 3474},
/*h(57)=7 VV1 0x2A   VF3 V0F not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {57, 3454},
/*h(36)=8 VV1 0x2A  VF2 V0F mode64 norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {36, 3472},
/*h(49)=9 VV1 0x2A   VF3 V0F not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {49, 3454},
/*empty slot1 */ {0,0},
/*h(41)=11 VV1 0x2A  VF2 V0F not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {41, 3471},
/*empty slot1 */ {0,0},
/*h(33)=13 VV1 0x2A  VF2 V0F not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {33, 3471},
/*empty slot1 */ {0,0},
/*h(59)=15 VV1 0x2A   VF3 V0F not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {59, 3454},
/*empty slot1 */ {0,0},
/*h(51)=17 VV1 0x2A   VF3 V0F not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {51, 3454},
/*empty slot1 */ {0,0},
/*h(43)=19 VV1 0x2A  VF2 V0F not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {43, 3471},
/*h(56)=20 VV1 0x2A   VF3 V0F not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {56, 3453},
/*h(35)=21 VV1 0x2A  VF2 V0F not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {35, 3471},
/*h(48)=22 VV1 0x2A   VF3 V0F not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {48, 3453},
/*h(61)=23 VV1 0x2A   VF3 V0F mode64 rexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {61, 3458},
/*h(40)=24 VV1 0x2A  VF2 V0F not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {40, 3470},
/*h(53)=25 VV1 0x2A   VF3 V0F mode64 norexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {53, 3456},
/*h(32)=26 VV1 0x2A  VF2 V0F not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {32, 3470},
/*h(45)=27 VV1 0x2A  VF2 V0F mode64 rexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {45, 3475},
/*h(58)=28 VV1 0x2A   VF3 V0F not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {58, 3453},
/*h(37)=29 VV1 0x2A  VF2 V0F mode64 norexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {37, 3473},
/*h(50)=30 VV1 0x2A   VF3 V0F not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {50, 3453},
/*empty slot1 */ {0,0},
/*h(42)=32 VV1 0x2A  VF2 V0F not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {42, 3470},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_MODE_REXW_VEX_PREFIX(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 34ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x2b_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(14)=0 VV1 0x2B  V66 V0F VL128 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 3574},
/*h(38)=1 VV1 0x2B  VNP V0F VL256 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {38, 3593},
/*h(46)=2 VV1 0x2B  V66 V0F VL256 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 3575},
/*h(6)=3 VV1 0x2B  VNP V0F VL128 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3592}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = ((4*key % 7) % 4);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x2c_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[24] = {
/*h(178)=0 VV1 0x2C   VF2 V0F  NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {178, 3707},
/*h(189)=1 VV1 0x2C   VF2 V0F  NOVSR mode64 rexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {189, 3712},
/*h(243)=2 VV1 0x2C   VF3 V0F  NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {243, 2746},
/*h(248)=3 VV1 0x2C   VF3 V0F  NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {248, 2745},
/*h(179)=4 VV1 0x2C   VF2 V0F  NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {179, 3708},
/*h(184)=5 VV1 0x2C   VF2 V0F  NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {184, 3707},
/*h(244)=6 VV1 0x2C   VF3 V0F  NOVSR mode64 norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {244, 2747},
/*h(249)=7 VV1 0x2C   VF3 V0F  NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {249, 2746},
/*h(180)=8 VV1 0x2C   VF2 V0F  NOVSR mode64 norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {180, 3709},
/*h(185)=9 VV1 0x2C   VF2 V0F  NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {185, 3708},
/*h(245)=10 VV1 0x2C   VF3 V0F  NOVSR mode64 norexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {245, 2748},
/*h(250)=11 VV1 0x2C   VF3 V0F  NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {250, 2745},
/*h(181)=12 VV1 0x2C   VF2 V0F  NOVSR mode64 norexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {181, 3710},
/*h(186)=13 VV1 0x2C   VF2 V0F  NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {186, 3707},
/*h(240)=14 VV1 0x2C   VF3 V0F  NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {240, 2745},
/*h(251)=15 VV1 0x2C   VF3 V0F  NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {251, 2746},
/*h(176)=16 VV1 0x2C   VF2 V0F  NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {176, 3707},
/*h(187)=17 VV1 0x2C   VF2 V0F  NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {187, 3708},
/*h(241)=18 VV1 0x2C   VF3 V0F  NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {241, 2746},
/*h(252)=19 VV1 0x2C   VF3 V0F  NOVSR mode64 rexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {252, 2749},
/*h(177)=20 VV1 0x2C   VF2 V0F  NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {177, 3708},
/*h(188)=21 VV1 0x2C   VF2 V0F  NOVSR mode64 rexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {188, 3711},
/*h(242)=22 VV1 0x2C   VF3 V0F  NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {242, 2745},
/*h(253)=23 VV1 0x2C   VF3 V0F  NOVSR mode64 rexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {253, 2750}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_MODE_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX(d);
hidx = ((4*key % 43) % 24);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x2d_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[24] = {
/*h(178)=0 VV1 0x2D   VF2 V0F  NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {178, 3476},
/*h(189)=1 VV1 0x2D   VF2 V0F  NOVSR mode64 rexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {189, 3481},
/*h(243)=2 VV1 0x2D   VF3 V0F  NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {243, 3026},
/*h(248)=3 VV1 0x2D   VF3 V0F  NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {248, 3025},
/*h(179)=4 VV1 0x2D   VF2 V0F  NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {179, 3477},
/*h(184)=5 VV1 0x2D   VF2 V0F  NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {184, 3476},
/*h(244)=6 VV1 0x2D   VF3 V0F  NOVSR mode64 norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {244, 3027},
/*h(249)=7 VV1 0x2D   VF3 V0F  NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {249, 3026},
/*h(180)=8 VV1 0x2D   VF2 V0F  NOVSR mode64 norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {180, 3478},
/*h(185)=9 VV1 0x2D   VF2 V0F  NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {185, 3477},
/*h(245)=10 VV1 0x2D   VF3 V0F  NOVSR mode64 norexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {245, 3028},
/*h(250)=11 VV1 0x2D   VF3 V0F  NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {250, 3025},
/*h(181)=12 VV1 0x2D   VF2 V0F  NOVSR mode64 norexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {181, 3479},
/*h(186)=13 VV1 0x2D   VF2 V0F  NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {186, 3476},
/*h(240)=14 VV1 0x2D   VF3 V0F  NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {240, 3025},
/*h(251)=15 VV1 0x2D   VF3 V0F  NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {251, 3026},
/*h(176)=16 VV1 0x2D   VF2 V0F  NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {176, 3476},
/*h(187)=17 VV1 0x2D   VF2 V0F  NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {187, 3477},
/*h(241)=18 VV1 0x2D   VF3 V0F  NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {241, 3026},
/*h(252)=19 VV1 0x2D   VF3 V0F  NOVSR mode64 rexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {252, 3029},
/*h(177)=20 VV1 0x2D   VF2 V0F  NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {177, 3477},
/*h(188)=21 VV1 0x2D   VF2 V0F  NOVSR mode64 rexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {188, 3480},
/*h(242)=22 VV1 0x2D   VF3 V0F  NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {242, 3025},
/*h(253)=23 VV1 0x2D   VF3 V0F  NOVSR mode64 rexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {253, 3030}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_MODE_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX(d);
hidx = ((4*key % 43) % 24);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x2e_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(15)=0 VV1 0x2E V66 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 3231},
/*h(7)=1 VV1 0x2E VNP V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3217},
/*h(14)=2 VV1 0x2E V66 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 3230},
/*h(6)=3 VV1 0x2E VNP V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3216}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX(d);
hidx = ((3*key % 5) % 4);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x2f_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(15)=0 VV1 0x2F   V66 V0F  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 2519},
/*h(7)=1 VV1 0x2F   VNP V0F  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 2532},
/*h(14)=2 VV1 0x2F   V66 V0F  NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2518},
/*h(6)=3 VV1 0x2F   VNP V0F  NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 2531}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX(d);
hidx = ((3*key % 5) % 4);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x41_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*empty slot1 */ {0,0},
/*h(23)=1 VV1 0x41 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W1*/ {23, 3461},
/*h(17)=2 VV1 0x41 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W0*/ {17, 2838},
/*h(19)=3 VV1 0x41 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W1*/ {19, 2846},
/*h(21)=4 VV1 0x41 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W0*/ {21, 2830}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x42_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*empty slot1 */ {0,0},
/*h(23)=1 VV1 0x42 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W1*/ {23, 2831},
/*h(17)=2 VV1 0x42 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W0*/ {17, 2845},
/*h(19)=3 VV1 0x42 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W1*/ {19, 2840},
/*h(21)=4 VV1 0x42 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W0*/ {21, 2823}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x44_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[8] = {
/*h(13)=0 VV1 0x44 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR*/ {13, 2953},
/*h(31)=1 VV1 0x44 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W1  NOVSR*/ {31, 2959},
/*h(15)=2 VV1 0x44 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W1  NOVSR*/ {15, 2952},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(29)=7 VV1 0x44 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR*/ {29, 2958}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-3));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x45_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*empty slot1 */ {0,0},
/*h(23)=1 VV1 0x45 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W1*/ {23, 2648},
/*h(17)=2 VV1 0x45 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W0*/ {17, 3690},
/*h(19)=3 VV1 0x45 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W1*/ {19, 2673},
/*h(21)=4 VV1 0x45 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W0*/ {21, 3621}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x46_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*empty slot1 */ {0,0},
/*h(23)=1 VV1 0x46 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W1*/ {23, 2302},
/*h(17)=2 VV1 0x46 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W0*/ {17, 2288},
/*h(19)=3 VV1 0x46 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W1*/ {19, 2285},
/*h(21)=4 VV1 0x46 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W0*/ {21, 2299}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x47_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*empty slot1 */ {0,0},
/*h(23)=1 VV1 0x47 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W1*/ {23, 3634},
/*h(17)=2 VV1 0x47 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W0*/ {17, 3553},
/*h(19)=3 VV1 0x47 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W1*/ {19, 2383},
/*h(21)=4 VV1 0x47 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W0*/ {21, 3362}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x4a_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*empty slot1 */ {0,0},
/*h(23)=1 VV1 0x4A V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W1*/ {23, 2839},
/*h(17)=2 VV1 0x4A VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W0*/ {17, 2824},
/*h(19)=3 VV1 0x4A VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W1*/ {19, 2829},
/*h(21)=4 VV1 0x4A V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W0*/ {21, 2847}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x4b_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(17)=2 VV1 0x4B VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W0*/ {17, 2978},
/*h(19)=3 VV1 0x4B VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W1*/ {19, 2406},
/*h(21)=4 VV1 0x4B V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=1  W0*/ {21, 3075}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x50_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(7)=0 VV1 0x50  VL128 VNP V0F  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 2208},
/*h(39)=1 VV1 0x50  VL256 VNP V0F  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {39, 2209},
/*h(15)=2 VV1 0x50  VL128 V66 V0F  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 2202},
/*h(47)=3 VV1 0x50  VL256 V66 V0F  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 2203}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = ((9*key % 7) % 4);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x51_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[144] = {
/*h(89)=0 VV1 0x51  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {89, 2507},
/*empty slot1 */ {0,0},
/*h(123)=2 VV1 0x51  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {123, 2507},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(47)=6 VV1 0x51  VL256 V66 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 2670},
/*empty slot1 */ {0,0},
/*h(81)=8 VV1 0x51  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {81, 2499},
/*h(26)=9 VV1 0x51  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {26, 2506},
/*h(115)=10 VV1 0x51  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {115, 2499},
/*h(60)=11 VV1 0x51  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {60, 2506},
/*empty slot1 */ {0,0},
/*h(94)=13 VV1 0x51  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {94, 2506},
/*h(39)=14 VV1 0x51  VL256 VNP NOVSR V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {39, 2658},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(18)=17 VV1 0x51  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {18, 2498},
/*empty slot1 */ {0,0},
/*h(52)=19 VV1 0x51  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {52, 2498},
/*empty slot1 */ {0,0},
/*h(86)=21 VV1 0x51  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {86, 2498},
/*h(31)=22 VV1 0x51  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {31, 2507},
/*h(120)=23 VV1 0x51  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {120, 2506},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(23)=30 VV1 0x51  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 2499},
/*h(112)=31 VV1 0x51  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {112, 2498},
/*h(57)=32 VV1 0x51  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {57, 2507},
/*empty slot1 */ {0,0},
/*h(91)=34 VV1 0x51  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {91, 2507},
/*empty slot1 */ {0,0},
/*h(125)=36 VV1 0x51  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {125, 2507},
/*empty slot1 */ {0,0},
/*h(15)=38 VV1 0x51  VL128 V66 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 2668},
/*empty slot1 */ {0,0},
/*h(49)=40 VV1 0x51  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {49, 2499},
/*empty slot1 */ {0,0},
/*h(83)=42 VV1 0x51  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {83, 2499},
/*h(28)=43 VV1 0x51  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {28, 2506},
/*h(117)=44 VV1 0x51  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {117, 2499},
/*h(62)=45 VV1 0x51  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {62, 2506},
/*h(7)=46 VV1 0x51  VL128 VNP NOVSR V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 2656},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(20)=51 VV1 0x51  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 2498},
/*empty slot1 */ {0,0},
/*h(54)=53 VV1 0x51  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {54, 2498},
/*empty slot1 */ {0,0},
/*h(88)=55 VV1 0x51  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {88, 2506},
/*empty slot1 */ {0,0},
/*h(122)=57 VV1 0x51  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {122, 2506},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(46)=61 VV1 0x51  VL256 V66 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 2669},
/*empty slot1 */ {0,0},
/*h(80)=63 VV1 0x51  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {80, 2498},
/*h(25)=64 VV1 0x51  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {25, 2507},
/*h(114)=65 VV1 0x51  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {114, 2498},
/*h(59)=66 VV1 0x51  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {59, 2507},
/*empty slot1 */ {0,0},
/*h(93)=68 VV1 0x51  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {93, 2507},
/*h(38)=69 VV1 0x51  VL256 VNP NOVSR V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {38, 2657},
/*h(127)=70 VV1 0x51  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {127, 2507},
/*empty slot1 */ {0,0},
/*h(17)=72 VV1 0x51  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {17, 2499},
/*empty slot1 */ {0,0},
/*h(51)=74 VV1 0x51  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {51, 2499},
/*empty slot1 */ {0,0},
/*h(85)=76 VV1 0x51  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {85, 2499},
/*h(30)=77 VV1 0x51  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {30, 2506},
/*h(119)=78 VV1 0x51  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {119, 2499},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(22)=85 VV1 0x51  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 2498},
/*empty slot1 */ {0,0},
/*h(56)=87 VV1 0x51  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {56, 2506},
/*empty slot1 */ {0,0},
/*h(90)=89 VV1 0x51  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {90, 2506},
/*empty slot1 */ {0,0},
/*h(124)=91 VV1 0x51  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {124, 2506},
/*empty slot1 */ {0,0},
/*h(14)=93 VV1 0x51  VL128 V66 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2667},
/*empty slot1 */ {0,0},
/*h(48)=95 VV1 0x51  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {48, 2498},
/*empty slot1 */ {0,0},
/*h(82)=97 VV1 0x51  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {82, 2498},
/*h(27)=98 VV1 0x51  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {27, 2507},
/*h(116)=99 VV1 0x51  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {116, 2498},
/*h(61)=100 VV1 0x51  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {61, 2507},
/*h(6)=101 VV1 0x51  VL128 VNP NOVSR V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 2655},
/*h(95)=102 VV1 0x51  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {95, 2507},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(19)=106 VV1 0x51  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {19, 2499},
/*empty slot1 */ {0,0},
/*h(53)=108 VV1 0x51  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {53, 2499},
/*empty slot1 */ {0,0},
/*h(87)=110 VV1 0x51  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {87, 2499},
/*empty slot1 */ {0,0},
/*h(121)=112 VV1 0x51  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {121, 2507},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(24)=119 VV1 0x51  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {24, 2506},
/*h(113)=120 VV1 0x51  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {113, 2499},
/*h(58)=121 VV1 0x51  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {58, 2506},
/*empty slot1 */ {0,0},
/*h(92)=123 VV1 0x51  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {92, 2506},
/*empty slot1 */ {0,0},
/*h(126)=125 VV1 0x51  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {126, 2506},
/*empty slot1 */ {0,0},
/*h(16)=127 VV1 0x51  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {16, 2498},
/*empty slot1 */ {0,0},
/*h(50)=129 VV1 0x51  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {50, 2498},
/*empty slot1 */ {0,0},
/*h(84)=131 VV1 0x51  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {84, 2498},
/*h(29)=132 VV1 0x51  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {29, 2507},
/*h(118)=133 VV1 0x51  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {118, 2498},
/*h(63)=134 VV1 0x51  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {63, 2507},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(21)=140 VV1 0x51  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 2499},
/*empty slot1 */ {0,0},
/*h(55)=142 VV1 0x51  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {55, 2499},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 144ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x52_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[72] = {
/*h(24)=0 VV1 0x52  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {24, 2545},
/*h(122)=1 VV1 0x52  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {122, 2545},
/*h(25)=2 VV1 0x52  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {25, 2546},
/*empty slot1 */ {0,0},
/*h(123)=4 VV1 0x52  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {123, 2546},
/*h(26)=5 VV1 0x52  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {26, 2545},
/*empty slot1 */ {0,0},
/*h(124)=7 VV1 0x52  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {124, 2545},
/*h(27)=8 VV1 0x52  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {27, 2546},
/*empty slot1 */ {0,0},
/*h(125)=10 VV1 0x52  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {125, 2546},
/*h(28)=11 VV1 0x52  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {28, 2545},
/*empty slot1 */ {0,0},
/*h(126)=13 VV1 0x52  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {126, 2545},
/*h(29)=14 VV1 0x52  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {29, 2546},
/*empty slot1 */ {0,0},
/*h(127)=16 VV1 0x52  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {127, 2546},
/*h(30)=17 VV1 0x52  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {30, 2545},
/*h(6)=18 VV1 0x52  VNP VL128 NOVSR V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3158},
/*empty slot1 */ {0,0},
/*h(31)=20 VV1 0x52  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {31, 2546},
/*h(7)=21 VV1 0x52  VNP VL128 NOVSR V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3159},
/*h(56)=22 VV1 0x52  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {56, 2545},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(57)=25 VV1 0x52  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {57, 2546},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(58)=28 VV1 0x52  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {58, 2545},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(59)=31 VV1 0x52  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {59, 2546},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(60)=34 VV1 0x52  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {60, 2545},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(61)=37 VV1 0x52  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {61, 2546},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(62)=40 VV1 0x52  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {62, 2545},
/*h(38)=41 VV1 0x52  VNP VL256 NOVSR V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {38, 3160},
/*empty slot1 */ {0,0},
/*h(63)=43 VV1 0x52  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {63, 2546},
/*h(39)=44 VV1 0x52  VNP VL256 NOVSR V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {39, 3161},
/*h(88)=45 VV1 0x52  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {88, 2545},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(89)=48 VV1 0x52  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {89, 2546},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(90)=51 VV1 0x52  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {90, 2545},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(91)=54 VV1 0x52  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {91, 2546},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(92)=57 VV1 0x52  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {92, 2545},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(93)=60 VV1 0x52  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {93, 2546},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(94)=63 VV1 0x52  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {94, 2545},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(95)=66 VV1 0x52  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {95, 2546},
/*empty slot1 */ {0,0},
/*h(120)=68 VV1 0x52  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {120, 2545},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(121)=71 VV1 0x52  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {121, 2546}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = ((3*key % 73) % 72);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x53_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[72] = {
/*h(24)=0 VV1 0x53  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {24, 2230},
/*h(122)=1 VV1 0x53  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {122, 2230},
/*h(25)=2 VV1 0x53  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {25, 2231},
/*empty slot1 */ {0,0},
/*h(123)=4 VV1 0x53  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {123, 2231},
/*h(26)=5 VV1 0x53  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {26, 2230},
/*empty slot1 */ {0,0},
/*h(124)=7 VV1 0x53  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {124, 2230},
/*h(27)=8 VV1 0x53  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {27, 2231},
/*empty slot1 */ {0,0},
/*h(125)=10 VV1 0x53  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {125, 2231},
/*h(28)=11 VV1 0x53  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {28, 2230},
/*empty slot1 */ {0,0},
/*h(126)=13 VV1 0x53  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {126, 2230},
/*h(29)=14 VV1 0x53  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {29, 2231},
/*empty slot1 */ {0,0},
/*h(127)=16 VV1 0x53  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {127, 2231},
/*h(30)=17 VV1 0x53  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {30, 2230},
/*h(6)=18 VV1 0x53  VNP VL128 NOVSR V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3466},
/*empty slot1 */ {0,0},
/*h(31)=20 VV1 0x53  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {31, 2231},
/*h(7)=21 VV1 0x53  VNP VL128 NOVSR V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3467},
/*h(56)=22 VV1 0x53  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {56, 2230},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(57)=25 VV1 0x53  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {57, 2231},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(58)=28 VV1 0x53  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {58, 2230},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(59)=31 VV1 0x53  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {59, 2231},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(60)=34 VV1 0x53  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {60, 2230},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(61)=37 VV1 0x53  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {61, 2231},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(62)=40 VV1 0x53  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {62, 2230},
/*h(38)=41 VV1 0x53  VNP VL256 NOVSR V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {38, 3468},
/*empty slot1 */ {0,0},
/*h(63)=43 VV1 0x53  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {63, 2231},
/*h(39)=44 VV1 0x53  VNP VL256 NOVSR V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {39, 3469},
/*h(88)=45 VV1 0x53  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {88, 2230},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(89)=48 VV1 0x53  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {89, 2231},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(90)=51 VV1 0x53  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {90, 2230},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(91)=54 VV1 0x53  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {91, 2231},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(92)=57 VV1 0x53  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {92, 2230},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(93)=60 VV1 0x53  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {93, 2231},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(94)=63 VV1 0x53  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {94, 2230},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(95)=66 VV1 0x53  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {95, 2231},
/*empty slot1 */ {0,0},
/*h(120)=68 VV1 0x53  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {120, 2230},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(121)=71 VV1 0x53  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {121, 2231}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = ((3*key % 73) % 72);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x54_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[10] = {
/*h(0)=0 VV1 0x54  VL128 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {0, 2402},
/*h(10)=1 VV1 0x54  VL256 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2381},
/*h(2)=2 VV1 0x54  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2379},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(9)=5 VV1 0x54  VL256 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {9, 2405},
/*h(1)=6 VV1 0x54  VL128 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {1, 2403},
/*h(11)=7 VV1 0x54  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2382},
/*h(3)=8 VV1 0x54  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2380},
/*h(8)=9 VV1 0x54  VL256 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {8, 2404}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 10ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x55_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[10] = {
/*h(0)=0 VV1 0x55  VL128 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {0, 3106},
/*h(10)=1 VV1 0x55  VL256 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3124},
/*h(2)=2 VV1 0x55  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3122},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(9)=5 VV1 0x55  VL256 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {9, 3109},
/*h(1)=6 VV1 0x55  VL128 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {1, 3107},
/*h(11)=7 VV1 0x55  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3125},
/*h(3)=8 VV1 0x55  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3123},
/*h(8)=9 VV1 0x55  VL256 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {8, 3108}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 10ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x56_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[10] = {
/*h(0)=0 VV1 0x56  VNP V0F VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {0, 3559},
/*h(10)=1 VV1 0x56  VL256 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3551},
/*h(2)=2 VV1 0x56  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3549},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(9)=5 VV1 0x56  VNP V0F VL256 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {9, 3562},
/*h(1)=6 VV1 0x56  VNP V0F VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {1, 3560},
/*h(11)=7 VV1 0x56  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3552},
/*h(3)=8 VV1 0x56  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3550},
/*h(8)=9 VV1 0x56  VNP V0F VL256 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {8, 3561}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 10ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x57_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[10] = {
/*h(0)=0 VV1 0x57  VNP V0F VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {0, 2910},
/*h(10)=1 VV1 0x57  V66 V0F VL256 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2891},
/*h(2)=2 VV1 0x57  V66 V0F VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2889},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(9)=5 VV1 0x57  VNP V0F VL256 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {9, 2913},
/*h(1)=6 VV1 0x57  VNP V0F VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {1, 2911},
/*h(11)=7 VV1 0x57  V66 V0F VL256 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2892},
/*h(3)=8 VV1 0x57  V66 V0F VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2890},
/*h(8)=9 VV1 0x57  VNP V0F VL256 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {8, 2912}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 10ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x58_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[34] = {
/*h(0)=0 VV1 0x58  VNP VL128 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {0, 3204},
/*h(13)=1 VV1 0x58  VF2  V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {13, 3732},
/*empty slot1 */ {0,0},
/*h(5)=3 VV1 0x58  VF2  V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 3732},
/*empty slot1 */ {0,0},
/*h(31)=5 VV1 0x58  VF3  V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {31, 3748},
/*h(10)=6 VV1 0x58  V66 VL256 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3190},
/*h(23)=7 VV1 0x58  VF3  V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 3748},
/*h(2)=8 VV1 0x58  V66 VL128 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3188},
/*h(15)=9 VV1 0x58  VF3  V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 3748},
/*h(28)=10 VV1 0x58  VF2  V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {28, 3731},
/*h(7)=11 VV1 0x58  VF3  V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3748},
/*h(20)=12 VV1 0x58  VF2  V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 3731},
/*empty slot1 */ {0,0},
/*h(12)=14 VV1 0x58  VF2  V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {12, 3731},
/*empty slot1 */ {0,0},
/*h(4)=16 VV1 0x58  VF2  V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 3731},
/*empty slot1 */ {0,0},
/*h(30)=18 VV1 0x58  VF3  V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {30, 3747},
/*h(9)=19 VV1 0x58  VNP VL256 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {9, 3207},
/*h(22)=20 VV1 0x58  VF3  V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 3747},
/*h(1)=21 VV1 0x58  VNP VL128 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {1, 3205},
/*h(14)=22 VV1 0x58  VF3  V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 3747},
/*empty slot1 */ {0,0},
/*h(6)=24 VV1 0x58  VF3  V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3747},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(11)=27 VV1 0x58  V66 VL256 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3191},
/*empty slot1 */ {0,0},
/*h(3)=29 VV1 0x58  V66 VL128 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3189},
/*empty slot1 */ {0,0},
/*h(29)=31 VV1 0x58  VF2  V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {29, 3732},
/*h(8)=32 VV1 0x58  VNP VL256 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {8, 3206},
/*h(21)=33 VV1 0x58  VF2  V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 3732}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 34ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x59_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[34] = {
/*h(0)=0 VV1 0x59  VL128 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {0, 2409},
/*h(13)=1 VV1 0x59  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {13, 2408},
/*empty slot1 */ {0,0},
/*h(5)=3 VV1 0x59  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 2408},
/*empty slot1 */ {0,0},
/*h(31)=5 VV1 0x59  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {31, 2378},
/*h(10)=6 VV1 0x59  VL256 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2759},
/*h(23)=7 VV1 0x59  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 2378},
/*h(2)=8 VV1 0x59  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2757},
/*h(15)=9 VV1 0x59  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 2378},
/*h(28)=10 VV1 0x59  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {28, 2407},
/*h(7)=11 VV1 0x59  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 2378},
/*h(20)=12 VV1 0x59  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 2407},
/*empty slot1 */ {0,0},
/*h(12)=14 VV1 0x59  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {12, 2407},
/*empty slot1 */ {0,0},
/*h(4)=16 VV1 0x59  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2407},
/*empty slot1 */ {0,0},
/*h(30)=18 VV1 0x59  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {30, 2377},
/*h(9)=19 VV1 0x59  VL256 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {9, 2412},
/*h(22)=20 VV1 0x59  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 2377},
/*h(1)=21 VV1 0x59  VL128 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {1, 2410},
/*h(14)=22 VV1 0x59  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2377},
/*empty slot1 */ {0,0},
/*h(6)=24 VV1 0x59  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 2377},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(11)=27 VV1 0x59  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2760},
/*empty slot1 */ {0,0},
/*h(3)=29 VV1 0x59  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2758},
/*empty slot1 */ {0,0},
/*h(29)=31 VV1 0x59  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {29, 2408},
/*h(8)=32 VV1 0x59  VL256 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {8, 2411},
/*h(21)=33 VV1 0x59  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 2408}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 34ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x5a_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[144] = {
/*h(89)=0 VV1 0x5A  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {89, 2513},
/*empty slot1 */ {0,0},
/*h(123)=2 VV1 0x5A  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {123, 2513},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(47)=6 VV1 0x5A  V66 VL256 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 3720},
/*empty slot1 */ {0,0},
/*h(81)=8 VV1 0x5A  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {81, 3460},
/*h(26)=9 VV1 0x5A  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {26, 2512},
/*h(115)=10 VV1 0x5A  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {115, 3460},
/*h(60)=11 VV1 0x5A  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {60, 2512},
/*empty slot1 */ {0,0},
/*h(94)=13 VV1 0x5A  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {94, 2512},
/*h(39)=14 VV1 0x5A  VNP VL256 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {39, 3756},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(18)=17 VV1 0x5A  VF2 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {18, 3459},
/*empty slot1 */ {0,0},
/*h(52)=19 VV1 0x5A  VF2 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {52, 3459},
/*empty slot1 */ {0,0},
/*h(86)=21 VV1 0x5A  VF2 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {86, 3459},
/*h(31)=22 VV1 0x5A  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {31, 2513},
/*h(120)=23 VV1 0x5A  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {120, 2512},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(23)=30 VV1 0x5A  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 3460},
/*h(112)=31 VV1 0x5A  VF2 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {112, 3459},
/*h(57)=32 VV1 0x5A  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {57, 2513},
/*empty slot1 */ {0,0},
/*h(91)=34 VV1 0x5A  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {91, 2513},
/*empty slot1 */ {0,0},
/*h(125)=36 VV1 0x5A  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {125, 2513},
/*empty slot1 */ {0,0},
/*h(15)=38 VV1 0x5A  V66 VL128 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 3718},
/*empty slot1 */ {0,0},
/*h(49)=40 VV1 0x5A  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {49, 3460},
/*empty slot1 */ {0,0},
/*h(83)=42 VV1 0x5A  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {83, 3460},
/*h(28)=43 VV1 0x5A  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {28, 2512},
/*h(117)=44 VV1 0x5A  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {117, 3460},
/*h(62)=45 VV1 0x5A  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {62, 2512},
/*h(7)=46 VV1 0x5A  VNP VL128 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3754},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(20)=51 VV1 0x5A  VF2 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 3459},
/*empty slot1 */ {0,0},
/*h(54)=53 VV1 0x5A  VF2 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {54, 3459},
/*empty slot1 */ {0,0},
/*h(88)=55 VV1 0x5A  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {88, 2512},
/*empty slot1 */ {0,0},
/*h(122)=57 VV1 0x5A  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {122, 2512},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(46)=61 VV1 0x5A  V66 VL256 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 3719},
/*empty slot1 */ {0,0},
/*h(80)=63 VV1 0x5A  VF2 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {80, 3459},
/*h(25)=64 VV1 0x5A  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {25, 2513},
/*h(114)=65 VV1 0x5A  VF2 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {114, 3459},
/*h(59)=66 VV1 0x5A  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {59, 2513},
/*empty slot1 */ {0,0},
/*h(93)=68 VV1 0x5A  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {93, 2513},
/*h(38)=69 VV1 0x5A  VNP VL256 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {38, 3755},
/*h(127)=70 VV1 0x5A  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {127, 2513},
/*empty slot1 */ {0,0},
/*h(17)=72 VV1 0x5A  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {17, 3460},
/*empty slot1 */ {0,0},
/*h(51)=74 VV1 0x5A  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {51, 3460},
/*empty slot1 */ {0,0},
/*h(85)=76 VV1 0x5A  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {85, 3460},
/*h(30)=77 VV1 0x5A  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {30, 2512},
/*h(119)=78 VV1 0x5A  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {119, 3460},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(22)=85 VV1 0x5A  VF2 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 3459},
/*empty slot1 */ {0,0},
/*h(56)=87 VV1 0x5A  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {56, 2512},
/*empty slot1 */ {0,0},
/*h(90)=89 VV1 0x5A  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {90, 2512},
/*empty slot1 */ {0,0},
/*h(124)=91 VV1 0x5A  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {124, 2512},
/*empty slot1 */ {0,0},
/*h(14)=93 VV1 0x5A  V66 VL128 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 3717},
/*empty slot1 */ {0,0},
/*h(48)=95 VV1 0x5A  VF2 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {48, 3459},
/*empty slot1 */ {0,0},
/*h(82)=97 VV1 0x5A  VF2 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {82, 3459},
/*h(27)=98 VV1 0x5A  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {27, 2513},
/*h(116)=99 VV1 0x5A  VF2 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {116, 3459},
/*h(61)=100 VV1 0x5A  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {61, 2513},
/*h(6)=101 VV1 0x5A  VNP VL128 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3753},
/*h(95)=102 VV1 0x5A  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {95, 2513},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(19)=106 VV1 0x5A  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {19, 3460},
/*empty slot1 */ {0,0},
/*h(53)=108 VV1 0x5A  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {53, 3460},
/*empty slot1 */ {0,0},
/*h(87)=110 VV1 0x5A  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {87, 3460},
/*empty slot1 */ {0,0},
/*h(121)=112 VV1 0x5A  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {121, 2513},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(24)=119 VV1 0x5A  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {24, 2512},
/*h(113)=120 VV1 0x5A  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {113, 3460},
/*h(58)=121 VV1 0x5A  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {58, 2512},
/*empty slot1 */ {0,0},
/*h(92)=123 VV1 0x5A  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {92, 2512},
/*empty slot1 */ {0,0},
/*h(126)=125 VV1 0x5A  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {126, 2512},
/*empty slot1 */ {0,0},
/*h(16)=127 VV1 0x5A  VF2 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {16, 3459},
/*empty slot1 */ {0,0},
/*h(50)=129 VV1 0x5A  VF2 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {50, 3459},
/*empty slot1 */ {0,0},
/*h(84)=131 VV1 0x5A  VF2 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {84, 3459},
/*h(29)=132 VV1 0x5A  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {29, 2513},
/*h(118)=133 VV1 0x5A  VF2 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {118, 3459},
/*h(63)=134 VV1 0x5A  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {63, 2513},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(21)=140 VV1 0x5A  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 3460},
/*empty slot1 */ {0,0},
/*h(55)=142 VV1 0x5A  VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {55, 3460},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 144ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x5b_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[22] = {
/*empty slot1 */ {0,0},
/*h(47)=1 VV1 0x5B  VL256 V66 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 2662},
/*h(39)=2 VV1 0x5B  VL256 VNP V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {39, 3353},
/*h(31)=3 VV1 0x5B  VL128 VF3 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {31, 2955},
/*empty slot1 */ {0,0},
/*h(15)=5 VV1 0x5B  VL128 V66 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 2660},
/*h(62)=6 VV1 0x5B  VL256 VF3 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {62, 2956},
/*h(7)=7 VV1 0x5B  VL128 VNP V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3351},
/*empty slot1 */ {0,0},
/*h(46)=9 VV1 0x5B  VL256 V66 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 2661},
/*h(38)=10 VV1 0x5B  VL256 VNP V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {38, 3352},
/*h(30)=11 VV1 0x5B  VL128 VF3 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {30, 2954},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(14)=14 VV1 0x5B  VL128 V66 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2659},
/*h(6)=15 VV1 0x5B  VL128 VNP V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3350},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(63)=20 VV1 0x5B  VL256 VF3 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {63, 2957},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 22ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x5c_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[34] = {
/*h(0)=0 VV1 0x5C  VL128 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {0, 3037},
/*h(13)=1 VV1 0x5C  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {13, 2654},
/*empty slot1 */ {0,0},
/*h(5)=3 VV1 0x5C  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 2654},
/*empty slot1 */ {0,0},
/*h(31)=5 VV1 0x5C  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {31, 2672},
/*h(10)=6 VV1 0x5C  V66 V0F VL256 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3023},
/*h(23)=7 VV1 0x5C  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 2672},
/*h(2)=8 VV1 0x5C  V66 V0F VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3021},
/*h(15)=9 VV1 0x5C  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 2672},
/*h(28)=10 VV1 0x5C  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {28, 2653},
/*h(7)=11 VV1 0x5C  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 2672},
/*h(20)=12 VV1 0x5C  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 2653},
/*empty slot1 */ {0,0},
/*h(12)=14 VV1 0x5C  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {12, 2653},
/*empty slot1 */ {0,0},
/*h(4)=16 VV1 0x5C  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2653},
/*empty slot1 */ {0,0},
/*h(30)=18 VV1 0x5C  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {30, 2671},
/*h(9)=19 VV1 0x5C  VL256 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {9, 3040},
/*h(22)=20 VV1 0x5C  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 2671},
/*h(1)=21 VV1 0x5C  VL128 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {1, 3038},
/*h(14)=22 VV1 0x5C  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2671},
/*empty slot1 */ {0,0},
/*h(6)=24 VV1 0x5C  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 2671},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(11)=27 VV1 0x5C  V66 V0F VL256 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3024},
/*empty slot1 */ {0,0},
/*h(3)=29 VV1 0x5C  V66 V0F VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3022},
/*empty slot1 */ {0,0},
/*h(29)=31 VV1 0x5C  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {29, 2654},
/*h(8)=32 VV1 0x5C  VL256 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {8, 3039},
/*h(21)=33 VV1 0x5C  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 2654}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 34ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x5d_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[34] = {
/*h(0)=0 VV1 0x5D  VNP V0F VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {0, 3367},
/*h(13)=1 VV1 0x5D  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {13, 3046},
/*empty slot1 */ {0,0},
/*h(5)=3 VV1 0x5D  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 3046},
/*empty slot1 */ {0,0},
/*h(31)=5 VV1 0x5D  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {31, 3032},
/*h(10)=6 VV1 0x5D  V66 V0F VL256 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3348},
/*h(23)=7 VV1 0x5D  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 3032},
/*h(2)=8 VV1 0x5D  V66 V0F VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3346},
/*h(15)=9 VV1 0x5D  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 3032},
/*h(28)=10 VV1 0x5D  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {28, 3045},
/*h(7)=11 VV1 0x5D  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3032},
/*h(20)=12 VV1 0x5D  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 3045},
/*empty slot1 */ {0,0},
/*h(12)=14 VV1 0x5D  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {12, 3045},
/*empty slot1 */ {0,0},
/*h(4)=16 VV1 0x5D  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 3045},
/*empty slot1 */ {0,0},
/*h(30)=18 VV1 0x5D  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {30, 3031},
/*h(9)=19 VV1 0x5D  VNP V0F VL256 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {9, 3370},
/*h(22)=20 VV1 0x5D  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 3031},
/*h(1)=21 VV1 0x5D  VNP V0F VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {1, 3368},
/*h(14)=22 VV1 0x5D  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 3031},
/*empty slot1 */ {0,0},
/*h(6)=24 VV1 0x5D  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3031},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(11)=27 VV1 0x5D  V66 V0F VL256 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3349},
/*empty slot1 */ {0,0},
/*h(3)=29 VV1 0x5D  V66 V0F VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3347},
/*empty slot1 */ {0,0},
/*h(29)=31 VV1 0x5D  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {29, 3046},
/*h(8)=32 VV1 0x5D  VNP V0F VL256 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {8, 3369},
/*h(21)=33 VV1 0x5D  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 3046}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 34ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x5e_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[34] = {
/*h(0)=0 VV1 0x5E  VNP V0F VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {0, 2589},
/*h(13)=1 VV1 0x5E  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {13, 2977},
/*empty slot1 */ {0,0},
/*h(5)=3 VV1 0x5E  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 2977},
/*empty slot1 */ {0,0},
/*h(31)=5 VV1 0x5E  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {31, 2965},
/*h(10)=6 VV1 0x5E  V66 V0F VL256 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2579},
/*h(23)=7 VV1 0x5E  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 2965},
/*h(2)=8 VV1 0x5E  V66 V0F VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2577},
/*h(15)=9 VV1 0x5E  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 2965},
/*h(28)=10 VV1 0x5E  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {28, 2976},
/*h(7)=11 VV1 0x5E  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 2965},
/*h(20)=12 VV1 0x5E  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 2976},
/*empty slot1 */ {0,0},
/*h(12)=14 VV1 0x5E  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {12, 2976},
/*empty slot1 */ {0,0},
/*h(4)=16 VV1 0x5E  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2976},
/*empty slot1 */ {0,0},
/*h(30)=18 VV1 0x5E  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {30, 2964},
/*h(9)=19 VV1 0x5E  VNP V0F VL256 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {9, 2592},
/*h(22)=20 VV1 0x5E  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 2964},
/*h(1)=21 VV1 0x5E  VNP V0F VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {1, 2590},
/*h(14)=22 VV1 0x5E  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2964},
/*empty slot1 */ {0,0},
/*h(6)=24 VV1 0x5E  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 2964},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(11)=27 VV1 0x5E  V66 V0F VL256 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2580},
/*empty slot1 */ {0,0},
/*h(3)=29 VV1 0x5E  V66 V0F VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2578},
/*empty slot1 */ {0,0},
/*h(29)=31 VV1 0x5E  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {29, 2977},
/*h(8)=32 VV1 0x5E  VNP V0F VL256 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {8, 2591},
/*h(21)=33 VV1 0x5E  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 2977}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 34ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x5f_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[34] = {
/*h(0)=0 VV1 0x5F  VNP V0F VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {0, 2809},
/*h(13)=1 VV1 0x5F  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {13, 2454},
/*empty slot1 */ {0,0},
/*h(5)=3 VV1 0x5F  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 2454},
/*empty slot1 */ {0,0},
/*h(31)=5 VV1 0x5F  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {31, 2436},
/*h(10)=6 VV1 0x5F  V66 V0F VL256 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2801},
/*h(23)=7 VV1 0x5F  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 2436},
/*h(2)=8 VV1 0x5F  V66 V0F VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2799},
/*h(15)=9 VV1 0x5F  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 2436},
/*h(28)=10 VV1 0x5F  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {28, 2453},
/*h(7)=11 VV1 0x5F  VF3 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 2436},
/*h(20)=12 VV1 0x5F  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 2453},
/*empty slot1 */ {0,0},
/*h(12)=14 VV1 0x5F  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {12, 2453},
/*empty slot1 */ {0,0},
/*h(4)=16 VV1 0x5F  VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2453},
/*empty slot1 */ {0,0},
/*h(30)=18 VV1 0x5F  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {30, 2435},
/*h(9)=19 VV1 0x5F  VNP V0F VL256 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {9, 2812},
/*h(22)=20 VV1 0x5F  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 2435},
/*h(1)=21 VV1 0x5F  VNP V0F VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {1, 2810},
/*h(14)=22 VV1 0x5F  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2435},
/*empty slot1 */ {0,0},
/*h(6)=24 VV1 0x5F  VF3 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 2435},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(11)=27 VV1 0x5F  V66 V0F VL256 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2802},
/*empty slot1 */ {0,0},
/*h(3)=29 VV1 0x5F  V66 V0F VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2800},
/*empty slot1 */ {0,0},
/*h(29)=31 VV1 0x5F  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {29, 2454},
/*h(8)=32 VV1 0x5F  VNP V0F VL256 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {8, 2811},
/*h(21)=33 VV1 0x5F  VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 2454}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 34ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x60_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x60  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2283},
/*h(2)=1 VV1 0x60  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2281},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x60  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2284},
/*h(3)=4 VV1 0x60  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2282}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x61_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x61  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2863},
/*h(2)=1 VV1 0x61  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2861},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x61  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2864},
/*h(3)=4 VV1 0x61  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2862}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x62_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x62  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3360},
/*h(2)=1 VV1 0x62  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3358},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x62  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3361},
/*h(3)=4 VV1 0x62  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3359}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x63_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x63  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3745},
/*h(2)=1 VV1 0x63  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3743},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x63  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3746},
/*h(3)=4 VV1 0x63  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3744}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x64_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x64  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3078},
/*h(2)=1 VV1 0x64  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3076},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x64  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3079},
/*h(3)=4 VV1 0x64  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3077}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x65_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x65  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3666},
/*h(2)=1 VV1 0x65  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3664},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x65  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3667},
/*h(3)=4 VV1 0x65  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3665}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x66_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x66  V66 V0F VL256  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3646},
/*h(2)=1 VV1 0x66  V66 V0F VL128  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3644},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x66  V66 V0F VL256 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3647},
/*h(3)=4 VV1 0x66  V66 V0F VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3645}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x67_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x67  V66 V0F VL256  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2805},
/*h(2)=1 VV1 0x67  V66 V0F VL128  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2803},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x67  V66 V0F VL256 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2806},
/*h(3)=4 VV1 0x67  V66 V0F VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2804}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x68_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x68  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3624},
/*h(2)=1 VV1 0x68  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3622},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x68  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3625},
/*h(3)=4 VV1 0x68  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3623}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x69_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x69  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3695},
/*h(2)=1 VV1 0x69  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3693},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x69  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3696},
/*h(3)=4 VV1 0x69  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3694}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x6a_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x6A  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2737},
/*h(2)=1 VV1 0x6A  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2735},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x6A  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2738},
/*h(3)=4 VV1 0x6A  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2736}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x6b_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x6B  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2482},
/*h(2)=1 VV1 0x6B  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2480},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x6B  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2483},
/*h(3)=4 VV1 0x6B  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2481}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x6c_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x6C  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3302},
/*h(2)=1 VV1 0x6C  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3300},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x6C  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3303},
/*h(3)=4 VV1 0x6C  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3301}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x6d_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x6D  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2815},
/*h(2)=1 VV1 0x6D  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2813},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x6D  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2816},
/*h(3)=4 VV1 0x6D  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2814}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x6e_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[17] = {
/*h(123)=0 VV1 0x6E  VL128 V66 V0F not64  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {123, 2243},
/*h(115)=1 VV1 0x6E  VL128 V66 V0F not64  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {115, 2243},
/*h(120)=2 VV1 0x6E  VL128 V66 V0F not64 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {120, 2242},
/*h(112)=3 VV1 0x6E  VL128 V66 V0F not64 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {112, 2242},
/*h(125)=4 VV1 0x6E  VL128 V66 V0F mode64 rexw_prefix NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {125, 2235},
/*h(117)=5 VV1 0x6E  VL128 V66 V0F mode64 norexw_prefix NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {117, 2247},
/*h(122)=6 VV1 0x6E  VL128 V66 V0F not64 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {122, 2242},
/*h(114)=7 VV1 0x6E  VL128 V66 V0F not64 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {114, 2242},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(124)=10 VV1 0x6E  VL128 V66 V0F mode64 rexw_prefix NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {124, 2234},
/*h(116)=11 VV1 0x6E  VL128 V66 V0F mode64 norexw_prefix NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {116, 2246},
/*empty slot1 */ {0,0},
/*h(121)=13 VV1 0x6E  VL128 V66 V0F not64  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {121, 2243},
/*h(113)=14 VV1 0x6E  VL128 V66 V0F not64  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {113, 2243},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_MODE_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 17ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x6f_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[10] = {
/*h(47)=0 VV1 0x6F  VL256 V66 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 2570},
/*h(31)=1 VV1 0x6F  VL128 VF3 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {31, 2582},
/*h(15)=2 VV1 0x6F  VL128 V66 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 2566},
/*h(62)=3 VV1 0x6F  VL256 VF3 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {62, 2583},
/*h(46)=4 VV1 0x6F  VL256 V66 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 2569},
/*h(30)=5 VV1 0x6F  VL128 VF3 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {30, 2581},
/*h(14)=6 VV1 0x6F  VL128 V66 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2565},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(63)=9 VV1 0x6F  VL256 VF3 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {63, 2584}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 10ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x70_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[17] = {
/*h(47)=0 VV1 0x70   VL256 V66 V0F NOVSR  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {47, 2554},
/*empty slot1 */ {0,0},
/*h(31)=2 VV1 0x70  VL128 VF3 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {31, 2426},
/*h(23)=3 VV1 0x70  VL128 VF2 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {23, 2598},
/*h(15)=4 VV1 0x70  VL128 V66 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {15, 2552},
/*h(62)=5 VV1 0x70   VL256 VF3 V0F NOVSR   MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {62, 2427},
/*h(54)=6 VV1 0x70   VL256 VF2 V0F NOVSR   MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {54, 2599},
/*h(46)=7 VV1 0x70   VL256 V66 V0F NOVSR   MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {46, 2553},
/*empty slot1 */ {0,0},
/*h(30)=9 VV1 0x70  VL128 VF3 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {30, 2425},
/*h(22)=10 VV1 0x70  VL128 VF2 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {22, 2597},
/*h(14)=11 VV1 0x70  VL128 V66 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {14, 2551},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(63)=15 VV1 0x70   VL256 VF3 V0F NOVSR  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {63, 2428},
/*h(55)=16 VV1 0x70   VL256 VF2 V0F NOVSR  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {55, 2600}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 17ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x71_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[6] = {
/*h(21)=0 VV1 0x71  VL128 V66 V0F MOD[0b11] MOD=3 REG[0b010] RM[nnn] UIMM8()*/ {21, 3278},
/*h(85)=1 VV1 0x71   VL256  V66 V0F MOD[0b11] MOD=3 REG[0b010] RM[nnn] UIMM8()*/ {85, 3281},
/*h(29)=2 VV1 0x71  VL128 V66 V0F MOD[0b11] MOD=3 REG[0b110] RM[nnn] UIMM8()*/ {29, 2630},
/*h(93)=3 VV1 0x71   VL256  V66 V0F MOD[0b11] MOD=3 REG[0b110] RM[nnn] UIMM8()*/ {93, 2633},
/*h(25)=4 VV1 0x71  VL128 V66 V0F MOD[0b11] MOD=3 REG[0b100] RM[nnn] UIMM8()*/ {25, 2557},
/*h(89)=5 VV1 0x71   VL256  V66 V0F MOD[0b11] MOD=3 REG[0b100] RM[nnn] UIMM8()*/ {89, 2560}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REG_VEX_PREFIX_VL(d);
hidx = ((5*key % 11) % 6);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x72_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[6] = {
/*h(21)=0 VV1 0x72  VL128 V66 V0F MOD[0b11] MOD=3 REG[0b010] RM[nnn] UIMM8()*/ {21, 3312},
/*h(85)=1 VV1 0x72   VL256  V66 V0F MOD[0b11] MOD=3 REG[0b010] RM[nnn] UIMM8()*/ {85, 3315},
/*h(29)=2 VV1 0x72  VL128 V66 V0F MOD[0b11] MOD=3 REG[0b110] RM[nnn] UIMM8()*/ {29, 2606},
/*h(93)=3 VV1 0x72   VL256  V66 V0F MOD[0b11] MOD=3 REG[0b110] RM[nnn] UIMM8()*/ {93, 2609},
/*h(25)=4 VV1 0x72  VL128 V66 V0F MOD[0b11] MOD=3 REG[0b100] RM[nnn] UIMM8()*/ {25, 2541},
/*h(89)=5 VV1 0x72   VL256  V66 V0F MOD[0b11] MOD=3 REG[0b100] RM[nnn] UIMM8()*/ {89, 2544}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REG_VEX_PREFIX_VL(d);
hidx = ((5*key % 11) % 6);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x73_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[14] = {
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(31)=2 VV1 0x73  VL128 V66 V0F MOD[0b11] MOD=3 REG[0b111] RM[nnn] UIMM8()*/ {31, 2232},
/*h(23)=3 VV1 0x73  VL128 V66 V0F MOD[0b11] MOD=3 REG[0b011] RM[nnn] UIMM8()*/ {23, 2413},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(93)=6 VV1 0x73   VL256  V66 V0F MOD[0b11] MOD=3 REG[0b110] RM[nnn] UIMM8()*/ {93, 2619},
/*h(85)=7 VV1 0x73   VL256  V66 V0F MOD[0b11] MOD=3 REG[0b010] RM[nnn] UIMM8()*/ {85, 3287},
/*empty slot1 */ {0,0},
/*h(95)=9 VV1 0x73  VL256 V66 V0F   MOD[0b11] MOD=3 REG[0b111] RM[nnn] UIMM8()*/ {95, 2233},
/*h(87)=10 VV1 0x73  VL256 V66 V0F   MOD[0b11] MOD=3 REG[0b011] RM[nnn] UIMM8()*/ {87, 2414},
/*empty slot1 */ {0,0},
/*h(29)=12 VV1 0x73  VL128 V66 V0F MOD[0b11] MOD=3 REG[0b110] RM[nnn] UIMM8()*/ {29, 2616},
/*h(21)=13 VV1 0x73  VL128 V66 V0F MOD[0b11] MOD=3 REG[0b010] RM[nnn] UIMM8()*/ {21, 3284}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REG_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 14ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x74_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x74  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2351},
/*h(2)=1 VV1 0x74  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2349},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x74  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2352},
/*h(3)=4 VV1 0x74  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2350}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x75_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x75  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2335},
/*h(2)=1 VV1 0x75  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2333},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x75  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2336},
/*h(3)=4 VV1 0x75  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2334}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x76_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x76  V66 V0F VL256  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2347},
/*h(2)=1 VV1 0x76  V66 V0F VL128  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2345},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x76  V66 V0F VL256 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2348},
/*h(3)=4 VV1 0x76  V66 V0F VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2346}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x77_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(19)=2 VV1 0x77 VNP  V0F VL256  NOVSR*/ {19, 2524},
/*h(3)=3 VV1 0x77 VNP  V0F VL128 NOVSR*/ {3, 3105}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-2));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x7c_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[13] = {
/*h(13)=0 VV1 0x7C  VL256 VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {13, 2939},
/*h(5)=1 VV1 0x7C  VL128 VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 2937},
/*h(10)=2 VV1 0x7C  VL256 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2275},
/*h(2)=3 VV1 0x7C  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2273},
/*empty slot1 */ {0,0},
/*h(12)=5 VV1 0x7C  VL256 VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {12, 2938},
/*h(4)=6 VV1 0x7C  VL128 VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2936},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(11)=10 VV1 0x7C  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2276},
/*h(3)=11 VV1 0x7C  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2274},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 13ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x7d_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[13] = {
/*h(13)=0 VV1 0x7D  VL256 VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {13, 2933},
/*h(5)=1 VV1 0x7D  VL128 VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 2931},
/*h(10)=2 VV1 0x7D  VL256 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2920},
/*h(2)=3 VV1 0x7D  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2918},
/*empty slot1 */ {0,0},
/*h(12)=5 VV1 0x7D  VL256 VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {12, 2932},
/*h(4)=6 VV1 0x7D  VL128 VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2930},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(11)=10 VV1 0x7D  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2921},
/*h(3)=11 VV1 0x7D  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2919},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 13ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x7e_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[34] = {
/*h(123)=0 VV1 0x7E  VL128 V66 V0F not64  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {123, 2245},
/*empty slot1 */ {0,0},
/*h(115)=2 VV1 0x7E  VL128 V66 V0F not64  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {115, 2245},
/*empty slot1 */ {0,0},
/*h(251)=4 VV1 0x7E  VL128 VF3 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {251, 2239},
/*h(120)=5 VV1 0x7E  VL128 V66 V0F not64  NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {120, 2244},
/*h(243)=6 VV1 0x7E  VL128 VF3 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {243, 2239},
/*h(112)=7 VV1 0x7E  VL128 V66 V0F not64  NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {112, 2244},
/*h(125)=8 VV1 0x7E  VL128 V66 V0F mode64 rexw_prefix NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {125, 2237},
/*h(248)=9 VV1 0x7E  VL128 VF3 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {248, 2238},
/*h(117)=10 VV1 0x7E  VL128 V66 V0F mode64 norexw_prefix NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {117, 2249},
/*h(240)=11 VV1 0x7E  VL128 VF3 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {240, 2238},
/*h(253)=12 VV1 0x7E  VL128 VF3 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {253, 2239},
/*h(122)=13 VV1 0x7E  VL128 V66 V0F not64  NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {122, 2244},
/*h(245)=14 VV1 0x7E  VL128 VF3 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {245, 2239},
/*h(114)=15 VV1 0x7E  VL128 V66 V0F not64  NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {114, 2244},
/*empty slot1 */ {0,0},
/*h(250)=17 VV1 0x7E  VL128 VF3 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {250, 2238},
/*empty slot1 */ {0,0},
/*h(242)=19 VV1 0x7E  VL128 VF3 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {242, 2238},
/*empty slot1 */ {0,0},
/*h(124)=21 VV1 0x7E  VL128 V66 V0F mode64 rexw_prefix NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {124, 2236},
/*empty slot1 */ {0,0},
/*h(116)=23 VV1 0x7E  VL128 V66 V0F mode64 norexw_prefix NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {116, 2248},
/*empty slot1 */ {0,0},
/*h(252)=25 VV1 0x7E  VL128 VF3 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {252, 2238},
/*h(121)=26 VV1 0x7E  VL128 V66 V0F not64  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {121, 2245},
/*h(244)=27 VV1 0x7E  VL128 VF3 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {244, 2238},
/*h(113)=28 VV1 0x7E  VL128 V66 V0F not64  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {113, 2245},
/*empty slot1 */ {0,0},
/*h(249)=30 VV1 0x7E  VL128 VF3 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {249, 2239},
/*empty slot1 */ {0,0},
/*h(241)=32 VV1 0x7E  VL128 VF3 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {241, 2239},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_MODE_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 34ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x7f_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[10] = {
/*h(47)=0 VV1 0x7F  VL256 V66 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 2572},
/*h(31)=1 VV1 0x7F  VL128 VF3 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {31, 2586},
/*h(15)=2 VV1 0x7F  VL128 V66 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 2568},
/*h(62)=3 VV1 0x7F  VL256 VF3 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {62, 2587},
/*h(46)=4 VV1 0x7F  VL256 V66 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 2571},
/*h(30)=5 VV1 0x7F  VL128 VF3 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {30, 2585},
/*h(14)=6 VV1 0x7F  VL128 V66 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2567},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(63)=9 VV1 0x7F  VL256 VF3 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {63, 2588}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 10ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x90_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[10] = {
/*h(13)=0 VV1 0x90 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR*/ {13, 2704},
/*h(31)=1 VV1 0x90 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W1  NOVSR*/ {31, 2684},
/*h(15)=2 VV1 0x90 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W1  NOVSR*/ {15, 2691},
/*h(28)=3 VV1 0x90 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM()  VL=0  W0  NOVSR*/ {28, 2251},
/*h(12)=4 VV1 0x90 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM()  VL=0  W0  NOVSR*/ {12, 2705},
/*h(30)=5 VV1 0x90 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM()  VL=0  W1  NOVSR*/ {30, 2685},
/*h(14)=6 VV1 0x90 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM()  VL=0  W1  NOVSR*/ {14, 2692},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(29)=9 VV1 0x90 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR*/ {29, 2250}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 10ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x91_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[8] = {
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(28)=2 VV1 0x91 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM()  VL=0  W0  NOVSR*/ {28, 2252},
/*h(12)=3 VV1 0x91 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM()  VL=0  W0  NOVSR*/ {12, 2706},
/*h(30)=4 VV1 0x91 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM()  VL=0  W1  NOVSR*/ {30, 2686},
/*h(14)=5 VV1 0x91 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM()  VL=0  W1  NOVSR*/ {14, 2693},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-3));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x92_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[21] = {
/*empty slot1 */ {0,0},
/*h(115)=1 VV1 0x92 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR*/ {115, 2253},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(49)=5 VV1 0x92 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR*/ {49, 2707},
/*h(117)=6 VV1 0x92 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR*/ {117, 2253},
/*h(185)=7 VV1 0x92 VF2 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  not64 NOVSR*/ {185, 2688},
/*h(177)=8 VV1 0x92 VF2 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  not64 NOVSR*/ {177, 2688},
/*empty slot1 */ {0,0},
/*h(51)=10 VV1 0x92 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR*/ {51, 2707},
/*empty slot1 */ {0,0},
/*h(187)=12 VV1 0x92 VF2 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  not64 NOVSR*/ {187, 2688},
/*h(179)=13 VV1 0x92 VF2 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  not64 NOVSR*/ {179, 2688},
/*empty slot1 */ {0,0},
/*h(53)=15 VV1 0x92 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR*/ {53, 2707},
/*h(189)=16 VV1 0x92 VF2 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W1  mode64  NOVSR*/ {189, 2694},
/*h(113)=17 VV1 0x92 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR*/ {113, 2253},
/*h(181)=18 VV1 0x92 VF2 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0 mode64  NOVSR*/ {181, 2687},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_MODE_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 21ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x93_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[21] = {
/*empty slot1 */ {0,0},
/*h(115)=1 VV1 0x93 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR*/ {115, 2254},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(49)=5 VV1 0x93 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR*/ {49, 2708},
/*h(117)=6 VV1 0x93 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR*/ {117, 2254},
/*h(185)=7 VV1 0x93 VF2 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  not64  NOVSR*/ {185, 2690},
/*h(177)=8 VV1 0x93 VF2 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  not64  NOVSR*/ {177, 2690},
/*empty slot1 */ {0,0},
/*h(51)=10 VV1 0x93 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR*/ {51, 2708},
/*empty slot1 */ {0,0},
/*h(187)=12 VV1 0x93 VF2 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  not64  NOVSR*/ {187, 2690},
/*h(179)=13 VV1 0x93 VF2 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  not64  NOVSR*/ {179, 2690},
/*empty slot1 */ {0,0},
/*h(53)=15 VV1 0x93 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR*/ {53, 2708},
/*h(189)=16 VV1 0x93 VF2 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W1  mode64  NOVSR*/ {189, 2695},
/*h(113)=17 VV1 0x93 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR*/ {113, 2254},
/*h(181)=18 VV1 0x93 VF2 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  mode64 NOVSR*/ {181, 2689},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_MODE_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 21ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x98_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[8] = {
/*h(13)=0 VV1 0x98 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR*/ {13, 2797},
/*h(31)=1 VV1 0x98 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W1  NOVSR*/ {31, 2807},
/*h(15)=2 VV1 0x98 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W1  NOVSR*/ {15, 2798},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(29)=7 VV1 0x98 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR*/ {29, 2808}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-3));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0x99_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[8] = {
/*h(13)=0 VV1 0x99 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR*/ {13, 2860},
/*h(31)=1 VV1 0x99 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W1  NOVSR*/ {31, 3554},
/*h(15)=2 VV1 0x99 VNP V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W1  NOVSR*/ {15, 2903},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(29)=7 VV1 0x99 V66 V0F MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR*/ {29, 3082}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-3));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xae_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[3] = {
/*h(52)=0 VV1 0xAE VL128 VNP V0F NOVSR MOD[mm] MOD!=3 REG[0b010] RM[nnn] MODRM()*/ {52, 2601},
/*h(54)=1 VV1 0xAE VL128 VNP V0F NOVSR MOD[mm] MOD!=3 REG[0b011] RM[nnn] MODRM()*/ {54, 2459},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REG_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 3ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xc2_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[34] = {
/*h(0)=0 VV1 0xC2  VNP VL128 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {0, 2995},
/*h(13)=1 VV1 0xC2   VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {13, 2613},
/*empty slot1 */ {0,0},
/*h(5)=3 VV1 0xC2   VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {5, 2613},
/*empty slot1 */ {0,0},
/*h(31)=5 VV1 0xC2   VF3 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {31, 2596},
/*h(10)=6 VV1 0xC2  V66 VL256 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {10, 3011},
/*h(23)=7 VV1 0xC2   VF3 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {23, 2596},
/*h(2)=8 VV1 0xC2  V66 VL128 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2, 3009},
/*h(15)=9 VV1 0xC2   VF3 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {15, 2596},
/*h(28)=10 VV1 0xC2   VF2 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {28, 2612},
/*h(7)=11 VV1 0xC2   VF3 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {7, 2596},
/*h(20)=12 VV1 0xC2   VF2 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {20, 2612},
/*empty slot1 */ {0,0},
/*h(12)=14 VV1 0xC2   VF2 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {12, 2612},
/*empty slot1 */ {0,0},
/*h(4)=16 VV1 0xC2   VF2 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {4, 2612},
/*empty slot1 */ {0,0},
/*h(30)=18 VV1 0xC2   VF3 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {30, 2595},
/*h(9)=19 VV1 0xC2  VNP VL256 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {9, 2998},
/*h(22)=20 VV1 0xC2   VF3 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {22, 2595},
/*h(1)=21 VV1 0xC2  VNP VL128 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {1, 2996},
/*h(14)=22 VV1 0xC2   VF3 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {14, 2595},
/*empty slot1 */ {0,0},
/*h(6)=24 VV1 0xC2   VF3 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {6, 2595},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(11)=27 VV1 0xC2  V66 VL256 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {11, 3012},
/*empty slot1 */ {0,0},
/*h(3)=29 VV1 0xC2  V66 VL128 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {3, 3010},
/*empty slot1 */ {0,0},
/*h(29)=31 VV1 0xC2   VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {29, 2613},
/*h(8)=32 VV1 0xC2  VNP VL256 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {8, 2997},
/*h(21)=33 VV1 0xC2   VF2 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {21, 2613}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 34ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xc4_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(2)=0 VV1 0xC4  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {3268},
/*h(3)=1 VV1 0xC4  VL128 V66 V0F  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {3269}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = key - 2;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xc5_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[1] = {
/*h(15)=0 VV1 0xC5  VL128 V66 V0F  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {3177}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 15;
if(hidx == 0) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xc6_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[10] = {
/*h(0)=0 VV1 0xC6  VL128 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {0, 2674},
/*h(10)=1 VV1 0xC6  VL256 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {10, 2651},
/*h(2)=2 VV1 0xC6  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2, 2649},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(9)=5 VV1 0xC6  VL256 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {9, 2677},
/*h(1)=6 VV1 0xC6  VL128 VNP V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {1, 2675},
/*h(11)=7 VV1 0xC6  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {11, 2652},
/*h(3)=8 VV1 0xC6  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {3, 2650},
/*h(8)=9 VV1 0xC6  VL256 VNP V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {8, 2676}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 10ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xd0_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[13] = {
/*h(13)=0 VV1 0xD0  VL256 VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {13, 3002},
/*h(5)=1 VV1 0xD0  VL128 VF2 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 3000},
/*h(10)=2 VV1 0xD0  VL256 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2492},
/*h(2)=3 VV1 0xD0  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2490},
/*empty slot1 */ {0,0},
/*h(12)=5 VV1 0xD0  VL256 VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {12, 3001},
/*h(4)=6 VV1 0xD0  VL128 VF2 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2999},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(11)=10 VV1 0xD0  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2493},
/*h(3)=11 VV1 0xD0  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2491},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 13ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xd1_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xD1  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3279},
/*h(2)=1 VV1 0xD1  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3276},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xD1  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3280},
/*h(3)=4 VV1 0xD1  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3277}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xd2_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xD2  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3313},
/*h(2)=1 VV1 0xD2  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3310},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xD2  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3314},
/*h(3)=4 VV1 0xD2  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3311}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xd3_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xD3  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3285},
/*h(2)=1 VV1 0xD3  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3282},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xD3  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3286},
/*h(3)=4 VV1 0xD3  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3283}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xd4_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xD4  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3112},
/*h(2)=1 VV1 0xD4  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3110},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xD4  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3113},
/*h(3)=4 VV1 0xD4  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3111}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xd5_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xD5  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3228},
/*h(2)=1 VV1 0xD5  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3226},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xD5  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3229},
/*h(3)=4 VV1 0xD5  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3227}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xd6_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(14)=0 VV1 0xD6  VL128 V66 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2240},
/*h(15)=1 VV1 0xD6  VL128 V66 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2241}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 14;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xd7_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(47)=0 VV1 0xD7  VL256 V66 V0F  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 2611},
/*h(15)=1 VV1 0xD7  VL128 V66 V0F  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 2610},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-2));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xd8_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xD8  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3053},
/*h(2)=1 VV1 0xD8  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3051},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xD8  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3054},
/*h(3)=4 VV1 0xD8  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3052}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xd9_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xD9  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3073},
/*h(2)=1 VV1 0xD9  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3071},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xD9  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3074},
/*h(3)=4 VV1 0xD9  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3072}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xda_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xDA  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3589},
/*h(2)=1 VV1 0xDA  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3587},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xDA  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3590},
/*h(3)=4 VV1 0xDA  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3588}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xdb_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xDB  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2638},
/*h(2)=1 VV1 0xDB  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2636},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xDB   VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2639},
/*h(3)=4 VV1 0xDB  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2637}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xdc_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xDC  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2867},
/*h(2)=1 VV1 0xDC  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2865},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xDC  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2868},
/*h(3)=4 VV1 0xDC  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2866}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xdd_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xDD  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2858},
/*h(2)=1 VV1 0xDD  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2856},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xDD  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2859},
/*h(3)=4 VV1 0xDD  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2857}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xde_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xDE  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2488},
/*h(2)=1 VV1 0xDE  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2486},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xDE  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2489},
/*h(3)=4 VV1 0xDE  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2487}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xdf_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xDF  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2646},
/*h(2)=1 VV1 0xDF  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2644},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xDF   VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2647},
/*h(3)=4 VV1 0xDF  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2645}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xe0_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xE0  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2359},
/*h(2)=1 VV1 0xE0  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2357},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xE0  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2360},
/*h(3)=4 VV1 0xE0  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2358}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xe1_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xE1  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2558},
/*h(2)=1 VV1 0xE1  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2555},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xE1  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2559},
/*h(3)=4 VV1 0xE1  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2556}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xe2_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xE2  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2542},
/*h(2)=1 VV1 0xE2  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2539},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xE2  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2543},
/*h(3)=4 VV1 0xE2  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2540}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xe3_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xE3  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2343},
/*h(2)=1 VV1 0xE3  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2341},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xE3  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2344},
/*h(3)=4 VV1 0xE3  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2342}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xe4_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xE4  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2212},
/*h(2)=1 VV1 0xE4  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2210},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xE4  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2213},
/*h(3)=4 VV1 0xE4  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2211}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xe5_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xE5  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2887},
/*h(2)=1 VV1 0xE5  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2885},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xE5  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2888},
/*h(3)=4 VV1 0xE5  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2886}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xe6_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[17] = {
/*h(47)=0 VV1 0xE6  VL256 V66 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 3638},
/*empty slot1 */ {0,0},
/*h(31)=2 VV1 0xE6  VL128 VF3 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {31, 3364},
/*h(23)=3 VV1 0xE6  VL128 VF2 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 2740},
/*h(15)=4 VV1 0xE6  VL128 V66 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 3636},
/*h(62)=5 VV1 0xE6  VL256 VF3 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {62, 3365},
/*h(54)=6 VV1 0xE6  VL256 VF2 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {54, 2741},
/*h(46)=7 VV1 0xE6  VL256 V66 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 3637},
/*empty slot1 */ {0,0},
/*h(30)=9 VV1 0xE6  VL128 VF3 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {30, 3363},
/*h(22)=10 VV1 0xE6  VL128 VF2 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 2739},
/*h(14)=11 VV1 0xE6  VL128 V66 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 3635},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(63)=15 VV1 0xE6  VL256 VF3 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {63, 3366},
/*h(55)=16 VV1 0xE6  VL256 VF2 V0F NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {55, 2742}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 17ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xe7_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(46)=0 VV1 0xE7  V66 V0F VL256 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 2984},
/*h(14)=1 VV1 0xE7  V66 V0F VL128 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2983}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-1));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xe8_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xE8  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3434},
/*h(2)=1 VV1 0xE8  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3432},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xE8  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3435},
/*h(3)=4 VV1 0xE8  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3433}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xe9_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xE9  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3447},
/*h(2)=1 VV1 0xE9  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3445},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xE9  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3448},
/*h(3)=4 VV1 0xE9  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3446}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xea_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xEA  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2470},
/*h(2)=1 VV1 0xEA  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2468},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xEA  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2471},
/*h(3)=4 VV1 0xEA  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2469}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xeb_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xEB  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3202},
/*h(2)=1 VV1 0xEB  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3200},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xEB   VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3203},
/*h(3)=4 VV1 0xEB  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3201}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xec_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xEC  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2795},
/*h(2)=1 VV1 0xEC  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2793},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xEC  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2796},
/*h(3)=4 VV1 0xEC  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2794}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xed_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xED  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2777},
/*h(2)=1 VV1 0xED  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2775},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xED  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2778},
/*h(3)=4 VV1 0xED  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2776}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xee_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xEE  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2390},
/*h(2)=1 VV1 0xEE  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2388},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xEE  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2391},
/*h(3)=4 VV1 0xEE  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2389}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xef_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xEF  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2496},
/*h(2)=1 VV1 0xEF  VL128 V66 V0F MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2494},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xEF   VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2497},
/*h(3)=4 VV1 0xEF  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2495}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xf0_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(54)=0 VV1 0xF0  VL256 VF2 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {54, 2683},
/*h(22)=1 VV1 0xF0  VL128 VF2 V0F NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 2682}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-1));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xf1_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xF1  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2631},
/*h(2)=1 VV1 0xF1  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2628},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xF1  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2632},
/*h(3)=4 VV1 0xF1  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2629}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xf2_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xF2  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2607},
/*h(2)=1 VV1 0xF2  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2604},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xF2  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2608},
/*h(3)=4 VV1 0xF2  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2605}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xf3_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xF3  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2617},
/*h(2)=1 VV1 0xF3  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2614},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xF3  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2618},
/*h(3)=4 VV1 0xF3  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2615}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xf4_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xF4  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2228},
/*h(2)=1 VV1 0xF4  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2226},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xF4  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2229},
/*h(3)=4 VV1 0xF4  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2227}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xf5_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xF5  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3651},
/*h(2)=1 VV1 0xF5  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3649},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xF5  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3652},
/*h(3)=4 VV1 0xF5  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3650}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xf6_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xF6  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3418},
/*h(2)=1 VV1 0xF6  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3416},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xF6  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3419},
/*h(3)=4 VV1 0xF6  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3417}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xf7_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[1] = {
/*h(15)=0 VV1 0xF7 V0F V66 VL128  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3573}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 15;
if(hidx == 0) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xf8_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xF8  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3381},
/*h(2)=1 VV1 0xF8  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3379},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xF8  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3382},
/*h(3)=4 VV1 0xF8  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3380}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xf9_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xF9  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3406},
/*h(2)=1 VV1 0xF9  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3404},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xF9  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3407},
/*h(3)=4 VV1 0xF9  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3405}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xfa_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xFA  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3385},
/*h(2)=1 VV1 0xFA  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3383},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xFA  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3386},
/*h(3)=4 VV1 0xFA  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3384}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xfb_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xFB  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3402},
/*h(2)=1 VV1 0xFB  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3400},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xFB  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3403},
/*h(3)=4 VV1 0xFB  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3401}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xfc_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xFC  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3120},
/*h(2)=1 VV1 0xFC  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3118},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xFC  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3121},
/*h(3)=4 VV1 0xFC  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3119}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xfd_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xFD  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3116},
/*h(2)=1 VV1 0xFD  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3114},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xFD  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3117},
/*h(3)=4 VV1 0xFD  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3115}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F_opcode0xfe_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xFE  VL256 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3128},
/*h(2)=1 VV1 0xFE  VL128 V66 V0F  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3126},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xFE  VL256 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3129},
/*h(3)=4 VV1 0xFE  VL128 V66 V0F MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3127}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x0_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x00  VL256 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2563},
/*h(2)=1 VV1 0x00  VL128 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2561},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x00  VL256 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2564},
/*h(3)=4 VV1 0x00  VL128 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2562}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x1_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x01  VL256 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2642},
/*h(2)=1 VV1 0x01  VL128 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2640},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x01  VL256 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2643},
/*h(3)=4 VV1 0x01  VL128 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2641}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x2_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x02  VL256 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2665},
/*h(2)=1 VV1 0x02  VL128 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2663},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x02  VL256 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2666},
/*h(3)=4 VV1 0x02  VL128 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2664}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x3_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x03  VL256 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3043},
/*h(2)=1 VV1 0x03  VL128 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3041},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x03  VL256 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3044},
/*h(3)=4 VV1 0x03  VL128 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3042}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x4_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x04  VL256 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2908},
/*h(2)=1 VV1 0x04  VL128 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2906},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x04  VL256 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2909},
/*h(3)=4 VV1 0x04  VL128 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2907}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x5_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x05  VL256 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3171},
/*h(2)=1 VV1 0x05  VL128 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3169},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x05  VL256 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3172},
/*h(3)=4 VV1 0x05  VL128 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3170}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x6_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x06  VL256 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3180},
/*h(2)=1 VV1 0x06  VL128 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3178},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x06  VL256 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3181},
/*h(3)=4 VV1 0x06  VL128 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3179}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x7_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x07  VL256 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3705},
/*h(2)=1 VV1 0x07  VL128 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3703},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x07  VL256 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3706},
/*h(3)=4 VV1 0x07  VL128 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3704}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x8_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x08  VL256 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2836},
/*h(2)=1 VV1 0x08  VL128 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2834},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x08  VL256 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2837},
/*h(3)=4 VV1 0x08  VL128 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2835}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x9_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x09  VL256 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2819},
/*h(2)=1 VV1 0x09  VL128 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2817},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x09  VL256 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2820},
/*h(3)=4 VV1 0x09  VL128 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2818}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xa_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x0A  VL256 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2871},
/*h(2)=1 VV1 0x0A  VL128 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2869},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x0A  VL256 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2872},
/*h(3)=4 VV1 0x0A  VL128 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2870}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xb_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x0B  VL256 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2257},
/*h(2)=1 VV1 0x0B  VL128 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2255},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x0B  VL256 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2258},
/*h(3)=4 VV1 0x0B  VL128 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2256}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xc_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(5)=0 VV1 0x0C  VL128 V66 V0F38 norexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 2310},
/*h(20)=1 VV1 0x0C  VL256 V66 V0F38  norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 2311},
/*h(4)=2 VV1 0x0C VL128 V66 V0F38 norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2309},
/*empty slot1 */ {0,0},
/*h(21)=4 VV1 0x0C  VL256 V66 V0F38  norexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 2312}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xd_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(5)=0 VV1 0x0D  VL128 V66 V0F38 norexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 3317},
/*h(20)=1 VV1 0x0D  VL256 V66 V0F38 norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 3318},
/*h(4)=2 VV1 0x0D VL128 V66 V0F38 norexw_prefix  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 3316},
/*empty slot1 */ {0,0},
/*h(21)=4 VV1 0x0D  VL256 V66 V0F38 norexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 3319}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xe_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[8] = {
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(28)=2 VV1 0x0E VL128 V66 V0F38 norexw_prefix  NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {28, 2979},
/*h(93)=3 VV1 0x0E VL256 V66 V0F38 norexw_prefix NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {93, 2982},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(92)=6 VV1 0x0E VL256 V66 V0F38  norexw_prefix NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {92, 2981},
/*h(29)=7 VV1 0x0E  VL128 V66 V0F38 norexw_prefix NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {29, 2980}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-3));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xf_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[8] = {
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(28)=2 VV1 0x0F  VL128 V66 V0F38 norexw_prefix NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {28, 2960},
/*h(93)=3 VV1 0x0F VL256 V66 V0F38 norexw_prefix NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {93, 2963},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(92)=6 VV1 0x0F VL256 V66 V0F38  norexw_prefix NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {92, 2962},
/*h(29)=7 VV1 0x0F VL128 V66 V0F38 norexw_prefix NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {29, 2961}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-3));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x13_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[8] = {
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(28)=2 VV1 0x13 VL128 V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()  W0*/ {28, 2295},
/*h(93)=3 VV1 0x13 VL256 V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]  W0*/ {93, 2298},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(92)=6 VV1 0x13 VL256 V66 V0F38 NOVSR  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() W0*/ {92, 2297},
/*h(29)=7 VV1 0x13 VL128 V66 V0F38 NOVSR  MOD[0b11] MOD=3 REG[rrr] RM[nnn] W0*/ {29, 2296}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-3));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x16_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(20)=0 VV1 0x16  VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {3581},
/*h(21)=1 VV1 0x16  VL256 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3582}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 20;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x17_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(47)=0 VV1 0x17  VL256 V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 2475},
/*h(15)=1 VV1 0x17  VL128 V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 2473},
/*h(46)=2 VV1 0x17  VL256 V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 2474},
/*h(14)=3 VV1 0x17  VL128 V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2472},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x18_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[8] = {
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(28)=2 VV1 0x18  norexw_prefix VL128 V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {28, 3342},
/*h(93)=3 VV1 0x18  VL256 V66 V0F38 W0 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {93, 3345},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(92)=6 VV1 0x18  norexw_prefix VL256 V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {92, 3343},
/*h(29)=7 VV1 0x18  VL128 V66 V0F38 W0 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {29, 3344}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-3));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x19_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(92)=0 VV1 0x19  norexw_prefix VL256 V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {3340},
/*h(93)=1 VV1 0x19  VL256 V66 V0F38 W0 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3341}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 92;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x1a_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[1] = {
/*h(92)=0 VV1 0x1A norexw_prefix VL256 V66 V0F38 NOVSR  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {3399}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 92;
if(hidx == 0) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x1c_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(47)=0 VV1 0x1C   VL256 V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 3133},
/*h(15)=1 VV1 0x1C  V66 V0F38 VL128 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 3131},
/*h(46)=2 VV1 0x1C   VL256 V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 3132},
/*h(14)=3 VV1 0x1C   V66 V0F38 VL128 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 3130},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x1d_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(47)=0 VV1 0x1D   VL256 V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 3036},
/*h(15)=1 VV1 0x1D  V66 V0F38 VL128 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 3034},
/*h(46)=2 VV1 0x1D   VL256 V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 3035},
/*h(14)=3 VV1 0x1D   V66 V0F38 VL128 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 3033},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x1e_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(47)=0 VV1 0x1E   VL256 V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 3673},
/*h(15)=1 VV1 0x1E  V66 V0F38 VL128 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 3671},
/*h(46)=2 VV1 0x1E   VL256 V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 3672},
/*h(14)=3 VV1 0x1E   V66 V0F38 VL128 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 3670},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x20_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(47)=0 VV1 0x20   VL256  V66 V0F38 NOVSR  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 3250},
/*h(15)=1 VV1 0x20  VL128 V66 V0F38 NOVSR  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 3248},
/*h(46)=2 VV1 0x20   VL256  V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 3251},
/*h(14)=3 VV1 0x20  VL128 V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 3249},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x21_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(47)=0 VV1 0x21   VL256  V66 V0F38 NOVSR  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 2549},
/*h(15)=1 VV1 0x21  VL128 V66 V0F38 NOVSR  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 2547},
/*h(46)=2 VV1 0x21   VL256  V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 2550},
/*h(14)=3 VV1 0x21  VL128 V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2548},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x22_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(47)=0 VV1 0x22   VL256  V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 2502},
/*h(15)=1 VV1 0x22  VL128 V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 2500},
/*h(46)=2 VV1 0x22   VL256  V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 2503},
/*h(14)=3 VV1 0x22  VL128 V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2501},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x23_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(47)=0 VV1 0x23   VL256  V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 3504},
/*h(15)=1 VV1 0x23  VL128 V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 3502},
/*h(46)=2 VV1 0x23   VL256  V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 3505},
/*h(14)=3 VV1 0x23  VL128 V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 3503},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x24_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(47)=0 VV1 0x24   VL256  V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 3521},
/*h(15)=1 VV1 0x24  VL128 V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 3519},
/*h(46)=2 VV1 0x24   VL256  V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 3522},
/*h(14)=3 VV1 0x24  VL128 V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 3520},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x25_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(47)=0 VV1 0x25   VL256  V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 2363},
/*h(15)=1 VV1 0x25  VL128 V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 2361},
/*h(46)=2 VV1 0x25   VL256  V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 2364},
/*h(14)=3 VV1 0x25  VL128 V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2362},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x28_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x28  VL256 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2711},
/*h(2)=1 VV1 0x28  VL128 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2709},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x28  VL256 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2712},
/*h(3)=4 VV1 0x28  VL128 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2710}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x29_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x29  VL256 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2339},
/*h(2)=1 VV1 0x29  VL128 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2337},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x29  VL256 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2340},
/*h(3)=4 VV1 0x29  VL128 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2338}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x2a_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(46)=0 VV1 0x2A  V66 V0F38 VL256 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 2420},
/*h(14)=1 VV1 0x2A  V66 V0F38 VL128 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2419}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-1));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x2b_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x2B  V66 V0F38 VL256  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3256},
/*h(2)=1 VV1 0x2B  V66 V0F38 VL128  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3254},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x2B  V66 V0F38 VL256 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3257},
/*h(3)=4 VV1 0x2B  V66 V0F38 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3255}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x2c_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(20)=0 VV1 0x2C V66 VL256 V0F38    norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 2790},
/*h(4)=1 VV1 0x2C V66 VL128 V0F38 norexw_prefix  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2789}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = ((4*key % 3) % 2);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x2d_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(20)=0 VV1 0x2D  V66 VL256 V0F38 norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 2780},
/*h(4)=1 VV1 0x2D  V66 VL128 V0F38  norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2779}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = ((4*key % 3) % 2);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x2e_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(20)=0 VV1 0x2E V66 V0F38 VL256 norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 2792},
/*h(4)=1 VV1 0x2E V66 V0F38 VL128  norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2791}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = ((4*key % 3) % 2);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x2f_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(20)=0 VV1 0x2F   V66 V0F38 VL256 norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 2782},
/*h(4)=1 VV1 0x2F   V66 V0F38 VL128 norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2781}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = ((4*key % 3) % 2);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x30_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(47)=0 VV1 0x30   VL256  V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 2769},
/*h(15)=1 VV1 0x30  VL128 V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 2767},
/*h(46)=2 VV1 0x30   VL256  V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 2770},
/*h(14)=3 VV1 0x30  VL128 V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2768},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x31_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(47)=0 VV1 0x31   VL256  V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 2765},
/*h(15)=1 VV1 0x31  VL128 V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 2763},
/*h(46)=2 VV1 0x31   VL256  V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 2766},
/*h(14)=3 VV1 0x31  VL128 V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2764},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x32_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(47)=0 VV1 0x32   V66  V0F38 VL256 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 2773},
/*h(15)=1 VV1 0x32  V66 V0F38 VL128 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 2771},
/*h(46)=2 VV1 0x32   V66  V0F38 VL256 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 2774},
/*h(14)=3 VV1 0x32  V66 V0F38 VL128 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2772},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x33_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(47)=0 VV1 0x33   V66  V0F38 VL256 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 3680},
/*h(15)=1 VV1 0x33  V66 V0F38 VL128 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 3678},
/*h(46)=2 VV1 0x33   V66  V0F38 VL256 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 3681},
/*h(14)=3 VV1 0x33  V66 V0F38 VL128 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 3679},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x34_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(47)=0 VV1 0x34   VL256  V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 2319},
/*h(15)=1 VV1 0x34  VL128 V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 2317},
/*h(46)=2 VV1 0x34   VL256  V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 2320},
/*h(14)=3 VV1 0x34  VL128 V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 2318},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x35_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(47)=0 VV1 0x35   VL256  V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {47, 3451},
/*h(15)=1 VV1 0x35  VL128 V66 V0F38 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {15, 3449},
/*h(46)=2 VV1 0x35   VL256  V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {46, 3452},
/*h(14)=3 VV1 0x35  VL128 V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {14, 3450},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x36_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(20)=0 VV1 0x36  VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2286},
/*h(21)=1 VV1 0x36  VL256 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2287}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 20;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x37_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x37  V66 V0F38 VL256  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3657},
/*h(2)=1 VV1 0x37  V66 V0F38 VL128  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3655},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x37  V66 V0F38 VL256 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3658},
/*h(3)=4 VV1 0x37  V66 V0F38 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3656}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x38_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x38  VL256 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2462},
/*h(2)=1 VV1 0x38  VL128 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2460},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x38  VL256 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2463},
/*h(3)=4 VV1 0x38  VL128 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2461}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x39_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x39  VL256 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2457},
/*h(2)=1 VV1 0x39  VL128 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2455},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x39  VL256 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2458},
/*h(3)=4 VV1 0x39  VL128 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2456}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x3a_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x3A  V66 V0F38 VL256  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3579},
/*h(2)=1 VV1 0x3A  V66 V0F38 VL128  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3577},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x3A  V66 V0F38 VL256 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3580},
/*h(3)=4 VV1 0x3A  V66 V0F38 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3578}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x3b_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x3B  V66 V0F38 VL256  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3596},
/*h(2)=1 VV1 0x3B  V66 V0F38 VL128  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3594},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x3B  V66 V0F38 VL256 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3597},
/*h(3)=4 VV1 0x3B  V66 V0F38 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3595}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x3c_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x3C  VL256 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2375},
/*h(2)=1 VV1 0x3C  VL128 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2373},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x3C  VL256 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2376},
/*h(3)=4 VV1 0x3C  VL128 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2374}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x3d_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x3D  VL256 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2367},
/*h(2)=1 VV1 0x3D  VL128 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2365},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x3D  VL256 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2368},
/*h(3)=4 VV1 0x3D  VL128 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2366}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x3e_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x3E  VL256 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3274},
/*h(2)=1 VV1 0x3E  VL128 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3272},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x3E  VL256 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3275},
/*h(3)=4 VV1 0x3E  VL128 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3273}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x3f_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x3F  VL256 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3260},
/*h(2)=1 VV1 0x3F  VL128 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3258},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x3F  VL256 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3261},
/*h(3)=4 VV1 0x3F  VL128 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3259}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x40_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x40  VL256 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3210},
/*h(2)=1 VV1 0x40  VL128 V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3208},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x40  VL256 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3211},
/*h(3)=4 VV1 0x40  VL128 V66 V0F38 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3209}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x41_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(14)=0 VV1 0x41   V66 V0F38 VL128 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {3668},
/*h(15)=1 VV1 0x41  V66 V0F38 VL128 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3669}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 14;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x45_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x45  VL128 V0F38 V66 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 2393},
/*h(23)=1 VV1 0x45  VL256 V0F38 V66 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 2372},
/*h(7)=2 VV1 0x45  VL128 V0F38 V66 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 2370},
/*h(20)=3 VV1 0x45  VL256 V0F38 V66  W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 2394},
/*h(4)=4 VV1 0x45  VL128 V0F38 V66  W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2392},
/*h(22)=5 VV1 0x45  VL256 V0F38 V66  W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 2371},
/*h(6)=6 VV1 0x45  VL128 V0F38 V66  W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 2369},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x45  VL256 V0F38 V66 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 2395}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x46_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(5)=0 VV1 0x46  VL128 V0F38 V66 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 2949},
/*h(20)=1 VV1 0x46  VL256 V0F38 V66  W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 2950},
/*h(4)=2 VV1 0x46  VL128 V0F38 V66  W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2948},
/*empty slot1 */ {0,0},
/*h(21)=4 VV1 0x46  VL256 V0F38 V66 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 2951}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x47_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x47  VL128 V0F38 V66 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 3722},
/*h(23)=1 VV1 0x47  VL256 V0F38 V66 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 3752},
/*h(7)=2 VV1 0x47  VL128 V0F38 V66 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3750},
/*h(20)=3 VV1 0x47  VL256 V0F38 V66  W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 3723},
/*h(4)=4 VV1 0x47  VL128 V0F38 V66  W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 3721},
/*h(22)=5 VV1 0x47  VL256 V0F38 V66  W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 3751},
/*h(6)=6 VV1 0x47  VL128 V0F38 V66  W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3749},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x47  VL256 V0F38 V66 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 3724}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x58_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[8] = {
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(28)=2 VV1 0x58 VL128 V66 V0F38 W0 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {28, 2873},
/*h(93)=3 VV1 0x58 VL256 V66 V0F38 W0 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {93, 2876},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(92)=6 VV1 0x58 VL256 V66 V0F38 W0 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {92, 2875},
/*h(29)=7 VV1 0x58 VL128 V66 V0F38 W0 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {29, 2874}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-3));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x59_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[8] = {
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(28)=2 VV1 0x59 VL128 V66 V0F38 W0 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {28, 3371},
/*h(93)=3 VV1 0x59 VL256 V66 V0F38 W0 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {93, 3374},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(92)=6 VV1 0x59 VL256 V66 V0F38 W0 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {92, 3373},
/*h(29)=7 VV1 0x59 VL128 V66 V0F38 W0 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {29, 3372}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-3));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x5a_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[1] = {
/*h(92)=0 VV1 0x5A VL256 V66 V0F38 W0 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {3444}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 92;
if(hidx == 0) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x78_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[8] = {
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(28)=2 VV1 0x78 VL128 V66 V0F38 W0 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {28, 2881},
/*h(93)=3 VV1 0x78 VL256 V66 V0F38 W0 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {93, 2884},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(92)=6 VV1 0x78 VL256 V66 V0F38 W0 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {92, 2883},
/*h(29)=7 VV1 0x78 VL128 V66 V0F38 W0 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {29, 2882}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-3));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x79_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[8] = {
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(28)=2 VV1 0x79 VL128 V66 V0F38 W0 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {28, 2895},
/*h(93)=3 VV1 0x79 VL256 V66 V0F38 W0 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {93, 2898},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(92)=6 VV1 0x79 VL256 V66 V0F38 W0 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {92, 2897},
/*h(29)=7 VV1 0x79 VL128 V66 V0F38 W0 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {29, 2896}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-3));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x8c_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[8] = {
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(20)=2 VV1 0x8C  VL256 V66 V0F38 W0  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 3409},
/*h(4)=3 VV1 0x8C  VL128 V66 V0F38 W0  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 3408},
/*h(22)=4 VV1 0x8C  VL256 V66 V0F38 W1  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 3396},
/*h(6)=5 VV1 0x8C  VL128 V66 V0F38 W1  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3395},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-3));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x8e_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[8] = {
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(20)=2 VV1 0x8E  VL256 V66 V0F38 W0  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 3411},
/*h(4)=3 VV1 0x8E  VL128 V66 V0F38 W0  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 3410},
/*h(22)=4 VV1 0x8E  VL256 V66 V0F38 W1  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 3398},
/*h(6)=5 VV1 0x8E  VL128 V66 V0F38 W1  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3397},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-3));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x90_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[15] = {
/*h(178)=0 VV1 0x90   VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_YMM() eanot16*/ {178, 3691},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(59)=6 VV1 0x90   VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_XMM() eanot16*/ {59, 3698},
/*h(51)=7 VV1 0x90   VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_XMM() eanot16*/ {51, 3692},
/*h(187)=8 VV1 0x90   VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_XMM() eanot16*/ {187, 3697},
/*h(179)=9 VV1 0x90   VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_YMM() eanot16*/ {179, 3691},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(58)=12 VV1 0x90   VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_XMM() eanot16*/ {58, 3698},
/*h(50)=13 VV1 0x90   VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_XMM() eanot16*/ {50, 3692},
/*h(186)=14 VV1 0x90   VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_XMM() eanot16*/ {186, 3697}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_ASZ_NONTERM_EASZ_MOD3_REXW_RM4_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 15ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x91_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[15] = {
/*h(178)=0 VV1 0x91   VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_YMM() eanot16*/ {178, 2717},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(59)=6 VV1 0x91   VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_XMM() eanot16*/ {59, 2744},
/*h(51)=7 VV1 0x91   VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_XMM() eanot16*/ {51, 2718},
/*h(187)=8 VV1 0x91   VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_YMM() eanot16*/ {187, 2743},
/*h(179)=9 VV1 0x91   VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_YMM() eanot16*/ {179, 2717},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(58)=12 VV1 0x91   VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_XMM() eanot16*/ {58, 2744},
/*h(50)=13 VV1 0x91   VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_XMM() eanot16*/ {50, 2718},
/*h(186)=14 VV1 0x91   VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_YMM() eanot16*/ {186, 2743}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_ASZ_NONTERM_EASZ_MOD3_REXW_RM4_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 15ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x92_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[15] = {
/*h(178)=0 VV1 0x92   VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_YMM() eanot16*/ {178, 2715},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(59)=6 VV1 0x92   VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_XMM() eanot16*/ {59, 2727},
/*h(51)=7 VV1 0x92   VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_XMM() eanot16*/ {51, 2716},
/*h(187)=8 VV1 0x92   VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_XMM() eanot16*/ {187, 2726},
/*h(179)=9 VV1 0x92   VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_YMM() eanot16*/ {179, 2715},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(58)=12 VV1 0x92   VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_XMM() eanot16*/ {58, 2727},
/*h(50)=13 VV1 0x92   VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_XMM() eanot16*/ {50, 2716},
/*h(186)=14 VV1 0x92   VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_XMM() eanot16*/ {186, 2726}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_ASZ_NONTERM_EASZ_MOD3_REXW_RM4_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 15ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x93_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[15] = {
/*h(178)=0 VV1 0x93   VL256 V66 V0F38   W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_YMM() eanot16*/ {178, 2329},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(59)=6 VV1 0x93   VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_XMM() eanot16*/ {59, 2322},
/*h(51)=7 VV1 0x93   VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_XMM() eanot16*/ {51, 2330},
/*h(187)=8 VV1 0x93   VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_YMM() eanot16*/ {187, 2321},
/*h(179)=9 VV1 0x93   VL256 V66 V0F38   W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_YMM() eanot16*/ {179, 2329},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(58)=12 VV1 0x93   VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_XMM() eanot16*/ {58, 2322},
/*h(50)=13 VV1 0x93   VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_XMM() eanot16*/ {50, 2330},
/*h(186)=14 VV1 0x93   VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] RM=4 VMODRM_YMM() eanot16*/ {186, 2321}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_ASZ_NONTERM_EASZ_MOD3_REXW_RM4_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 15ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x96_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x96 VL128 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 3683},
/*h(23)=1 VV1 0x96 VL256 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 3677},
/*h(7)=2 VV1 0x96 VL128 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3675},
/*h(20)=3 VV1 0x96 VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 3684},
/*h(4)=4 VV1 0x96 VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 3682},
/*h(22)=5 VV1 0x96 VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 3676},
/*h(6)=6 VV1 0x96 VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3674},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x96 VL256 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 3685}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x97_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x97 VL128 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 3425},
/*h(23)=1 VV1 0x97 VL256 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 3415},
/*h(7)=2 VV1 0x97 VL128 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3413},
/*h(20)=3 VV1 0x97 VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 3426},
/*h(4)=4 VV1 0x97 VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 3424},
/*h(22)=5 VV1 0x97 VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 3414},
/*h(6)=6 VV1 0x97 VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3412},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x97 VL256 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 3427}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x98_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x98 VL128 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 3100},
/*h(23)=1 VV1 0x98 VL256 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 3086},
/*h(7)=2 VV1 0x98 VL128 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3084},
/*h(20)=3 VV1 0x98 VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 3101},
/*h(4)=4 VV1 0x98 VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 3099},
/*h(22)=5 VV1 0x98 VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 3085},
/*h(6)=6 VV1 0x98 VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3083},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x98 VL256 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 3102}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x99_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(4)=0 VV1 0x99  V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2934},
/*h(5)=1 VV1 0x99  V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2935},
/*h(6)=2 VV1 0x99 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2916},
/*h(7)=3 VV1 0x99 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2917}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX(d);
hidx = key - 4;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x9a_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x9A VL128 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 2262},
/*h(23)=1 VV1 0x9A VL256 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 2280},
/*h(7)=2 VV1 0x9A VL128 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 2278},
/*h(20)=3 VV1 0x9A VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 2263},
/*h(4)=4 VV1 0x9A VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2261},
/*h(22)=5 VV1 0x9A VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 2279},
/*h(6)=6 VV1 0x9A VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 2277},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x9A VL256 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 2264}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x9b_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(4)=0 VV1 0x9B  V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2602},
/*h(5)=1 VV1 0x9B  V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2603},
/*h(6)=2 VV1 0x9B V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2634},
/*h(7)=3 VV1 0x9B V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2635}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX(d);
hidx = key - 4;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x9c_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x9C VL128 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 3700},
/*h(23)=1 VV1 0x9C VL256 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 3689},
/*h(7)=2 VV1 0x9C VL128 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3687},
/*h(20)=3 VV1 0x9C VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 3701},
/*h(4)=4 VV1 0x9C VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 3699},
/*h(22)=5 VV1 0x9C VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 3688},
/*h(6)=6 VV1 0x9C VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3686},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x9C VL256 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 3702}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x9d_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(4)=0 VV1 0x9D  V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {3324},
/*h(5)=1 VV1 0x9D  V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3325},
/*h(6)=2 VV1 0x9D V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {3304},
/*h(7)=3 VV1 0x9D V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3305}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX(d);
hidx = key - 4;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x9e_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x9E VL128 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 2842},
/*h(23)=1 VV1 0x9E VL256 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 2828},
/*h(7)=2 VV1 0x9E VL128 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 2826},
/*h(20)=3 VV1 0x9E VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 2843},
/*h(4)=4 VV1 0x9E VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2841},
/*h(22)=5 VV1 0x9E VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 2827},
/*h(6)=6 VV1 0x9E VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 2825},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x9E VL256 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 2844}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0x9f_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(4)=0 VV1 0x9F  V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {3194},
/*h(5)=1 VV1 0x9F  V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3195},
/*h(6)=2 VV1 0x9F V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {3192},
/*h(7)=3 VV1 0x9F V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3193}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX(d);
hidx = key - 4;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xa6_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0xA6 VL128 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 3606},
/*h(23)=1 VV1 0xA6 VL256 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 3620},
/*h(7)=2 VV1 0xA6 VL128 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3618},
/*h(20)=3 VV1 0xA6 VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 3607},
/*h(4)=4 VV1 0xA6 VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 3605},
/*h(22)=5 VV1 0xA6 VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 3619},
/*h(6)=6 VV1 0xA6 VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3617},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0xA6 VL256 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 3608}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xa7_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0xA7 VL128 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 3441},
/*h(23)=1 VV1 0xA7 VL256 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 2623},
/*h(7)=2 VV1 0xA7 VL128 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 2621},
/*h(20)=3 VV1 0xA7 VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 3442},
/*h(4)=4 VV1 0xA7 VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 3440},
/*h(22)=5 VV1 0xA7 VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 2622},
/*h(6)=6 VV1 0xA7 VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 2620},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0xA7 VL256 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 3443}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xa8_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0xA8 VL128 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 3661},
/*h(23)=1 VV1 0xA8 VL256 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 3643},
/*h(7)=2 VV1 0xA8 VL128 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3641},
/*h(20)=3 VV1 0xA8 VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 3662},
/*h(4)=4 VV1 0xA8 VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 3660},
/*h(22)=5 VV1 0xA8 VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 3642},
/*h(6)=6 VV1 0xA8 VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3640},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0xA8 VL256 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 3663}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xa9_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(4)=0 VV1 0xA9  V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {3270},
/*h(5)=1 VV1 0xA9  V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3271},
/*h(6)=2 VV1 0xA9  V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {3252},
/*h(7)=3 VV1 0xA9  V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3253}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX(d);
hidx = key - 4;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xaa_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0xAA VL128 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 2465},
/*h(23)=1 VV1 0xAA VL256 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 2479},
/*h(7)=2 VV1 0xAA VL128 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 2477},
/*h(20)=3 VV1 0xAA VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 2466},
/*h(4)=4 VV1 0xAA VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2464},
/*h(22)=5 VV1 0xAA VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 2478},
/*h(6)=6 VV1 0xAA VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 2476},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0xAA VL256 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 2467}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xab_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(4)=0 VV1 0xAB  V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2832},
/*h(5)=1 VV1 0xAB  V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2833},
/*h(6)=2 VV1 0xAB  V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2821},
/*h(7)=3 VV1 0xAB  V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2822}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX(d);
hidx = key - 4;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xac_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0xAC VL128 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 2679},
/*h(23)=1 VV1 0xAC VL256 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 2703},
/*h(7)=2 VV1 0xAC VL128 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 2701},
/*h(20)=3 VV1 0xAC VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 2680},
/*h(4)=4 VV1 0xAC VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2678},
/*h(22)=5 VV1 0xAC VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 2702},
/*h(6)=6 VV1 0xAC VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 2700},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0xAC VL256 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 2681}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xad_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(4)=0 VV1 0xAD  V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2307},
/*h(5)=1 VV1 0xAD  V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2308},
/*h(6)=2 VV1 0xAD  V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2323},
/*h(7)=3 VV1 0xAD  V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2324}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX(d);
hidx = key - 4;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xae_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0xAE VL128 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 3355},
/*h(23)=1 VV1 0xAE VL256 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 3378},
/*h(7)=2 VV1 0xAE VL128 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3376},
/*h(20)=3 VV1 0xAE VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 3356},
/*h(4)=4 VV1 0xAE VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 3354},
/*h(22)=5 VV1 0xAE VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 3377},
/*h(6)=6 VV1 0xAE VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3375},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0xAE VL256 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 3357}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xaf_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(4)=0 VV1 0xAF  V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {3244},
/*h(5)=1 VV1 0xAF  V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3245},
/*h(6)=2 VV1 0xAF  V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2331},
/*h(7)=3 VV1 0xAF  V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2332}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX(d);
hidx = key - 4;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xb6_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0xB6 VL128 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 2219},
/*h(23)=1 VV1 0xB6 VL256 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 2225},
/*h(7)=2 VV1 0xB6 VL128 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 2223},
/*h(20)=3 VV1 0xB6 VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 2220},
/*h(4)=4 VV1 0xB6 VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2218},
/*h(22)=5 VV1 0xB6 VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 2224},
/*h(6)=6 VV1 0xB6 VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 2222},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0xB6 VL256 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 2221}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xb7_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0xB7 VL128 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 3491},
/*h(23)=1 VV1 0xB7 VL256 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 3518},
/*h(7)=2 VV1 0xB7 VL128 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3516},
/*h(20)=3 VV1 0xB7 VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 3492},
/*h(4)=4 VV1 0xB7 VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 3490},
/*h(22)=5 VV1 0xB7 VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 3517},
/*h(6)=6 VV1 0xB7 VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3515},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0xB7 VL256 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 3493}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xb8_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0xB8 VL128 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 2900},
/*h(23)=1 VV1 0xB8 VL256 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 2880},
/*h(7)=2 VV1 0xB8 VL128 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 2878},
/*h(20)=3 VV1 0xB8 VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 2901},
/*h(4)=4 VV1 0xB8 VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2899},
/*h(22)=5 VV1 0xB8 VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 2879},
/*h(6)=6 VV1 0xB8 VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 2877},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0xB8 VL256 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 2902}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xb9_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(4)=0 VV1 0xB9 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2751},
/*h(5)=1 VV1 0xB9 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2752},
/*h(6)=2 VV1 0xB9 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2761},
/*h(7)=3 VV1 0xB9 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2762}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX(d);
hidx = key - 4;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xba_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0xBA VL128 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 2697},
/*h(23)=1 VV1 0xBA VL256 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 3716},
/*h(7)=2 VV1 0xBA VL128 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3714},
/*h(20)=3 VV1 0xBA VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 2698},
/*h(4)=4 VV1 0xBA VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2696},
/*h(22)=5 VV1 0xBA VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 3715},
/*h(6)=6 VV1 0xBA VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3713},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0xBA VL256 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 2699}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xbb_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(4)=0 VV1 0xBB V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {3061},
/*h(5)=1 VV1 0xBB V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3062},
/*h(6)=2 VV1 0xBB V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {3055},
/*h(7)=3 VV1 0xBB V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3056}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX(d);
hidx = key - 4;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xbc_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0xBC VL128 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 3495},
/*h(23)=1 VV1 0xBC VL256 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 3538},
/*h(7)=2 VV1 0xBC VL128 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3536},
/*h(20)=3 VV1 0xBC VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 3496},
/*h(4)=4 VV1 0xBC VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 3494},
/*h(22)=5 VV1 0xBC VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 3537},
/*h(6)=6 VV1 0xBC VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3535},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0xBC VL256 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 3497}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xbd_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(4)=0 VV1 0xBD V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2974},
/*h(5)=1 VV1 0xBD V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2975},
/*h(6)=2 VV1 0xBD V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2985},
/*h(7)=3 VV1 0xBD V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {2986}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX(d);
hidx = key - 4;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xbe_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0xBE VL128 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 3213},
/*h(23)=1 VV1 0xBE VL256 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {23, 3235},
/*h(7)=2 VV1 0xBE VL128 V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {7, 3233},
/*h(20)=3 VV1 0xBE VL256 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 3214},
/*h(4)=4 VV1 0xBE VL128 V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 3212},
/*h(22)=5 VV1 0xBE VL256 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {22, 3234},
/*h(6)=6 VV1 0xBE VL128 V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {6, 3232},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0xBE VL256 V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 3215}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xbf_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(4)=0 VV1 0xBF V66 V0F38 W0 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {3563},
/*h(5)=1 VV1 0xBF V66 V0F38 W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3564},
/*h(6)=2 VV1 0xBF V66 V0F38 W1 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {3565},
/*h(7)=3 VV1 0xBF V66 V0F38 W1 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3566}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX(d);
hidx = key - 4;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xcf_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(5)=0 VV1 0xCF V66 V0F38 MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL128  W0*/ {5, 3545},
/*h(20)=1 VV1 0xCF V66 V0F38 MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM()  VL256  W0*/ {20, 3548},
/*h(4)=2 VV1 0xCF V66 V0F38 MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM()  VL128  W0*/ {4, 3546},
/*empty slot1 */ {0,0},
/*h(21)=4 VV1 0xCF V66 V0F38 MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL256  W0*/ {21, 3547}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xdb_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(14)=0 VV1 0xDB VL128 V66 V0F38 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2594},
/*h(15)=1 VV1 0xDB VL128 V66 V0F38 NOVSR MOD[0b11] MOD=3  REG[rrr] RM[nnn]*/ {2593}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 14;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xdc_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xDC V66 V0F38 MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM()  VL256*/ {10, 2723},
/*h(2)=1 VV1 0xDC V66 V0F38  MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM() VL128*/ {2, 2721},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xDC V66 V0F38 MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL256*/ {11, 2722},
/*h(3)=4 VV1 0xDC V66 V0F38  MOD[0b11] MOD=3  REG[rrr] RM[nnn] VL128*/ {3, 2720}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xdd_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xDD V66 V0F38 MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM()  VL256*/ {10, 2851},
/*h(2)=1 VV1 0xDD  V66 V0F38 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() VL128*/ {2, 2849},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xDD V66 V0F38 MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL256*/ {11, 2850},
/*h(3)=4 VV1 0xDD V66 V0F38 MOD[0b11] MOD=3  REG[rrr] RM[nnn] VL128*/ {3, 2848}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xde_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xDE V66 V0F38 MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM()  VL256*/ {10, 2328},
/*h(2)=1 VV1 0xDE V66 V0F38 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() VL128*/ {2, 2326},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xDE V66 V0F38 MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL256*/ {11, 2327},
/*h(3)=4 VV1 0xDE V66 V0F38 MOD[0b11] MOD=3  REG[rrr] RM[nnn] VL128*/ {3, 2325}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xdf_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0xDF V66 V0F38 MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM()  VL256*/ {10, 2517},
/*h(2)=1 VV1 0xDF V66 V0F38 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() VL128*/ {2, 2515},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0xDF V66 V0F38 MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL256*/ {11, 2516},
/*h(3)=4 VV1 0xDF V66 V0F38 MOD[0b11] MOD=3  REG[rrr] RM[nnn] VL128*/ {3, 2514}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xf2_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[12] = {
/*h(0)=0 VV1 0xF2 V0F38 VNP  not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {0, 3182},
/*h(8)=1 VV1 0xF2 V0F38 VNP  not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {8, 3182},
/*h(5)=2 VV1 0xF2 V0F38 VNP  W0 mode64 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 3185},
/*h(13)=3 VV1 0xF2 V0F38 VNP W1 VL128  mode64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {13, 3187},
/*h(4)=4 VV1 0xF2 V0F38 VNP  W0 mode64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 3183},
/*h(12)=5 VV1 0xF2 V0F38 VNP W1 VL128  mode64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {12, 3186},
/*h(3)=6 VV1 0xF2 V0F38 VNP  not64 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3184},
/*h(11)=7 VV1 0xF2 V0F38 VNP  not64 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3184},
/*h(2)=8 VV1 0xF2 V0F38 VNP  not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3182},
/*h(10)=9 VV1 0xF2 V0F38 VNP  not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3182},
/*h(1)=10 VV1 0xF2 V0F38 VNP  not64 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {1, 3184},
/*h(9)=11 VV1 0xF2 V0F38 VNP  not64 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {9, 3184}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_MODE_REXW_VEX_PREFIX_VL(d);
hidx = ((10*key % 67) % 12);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xf3_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[72] = {
/*h(89)=0 VV1 0xF3 V0F38 VNP not64 VL128 MOD[0b11] MOD=3 REG[0b011] RM[nnn]*/ {89, 3727},
/*h(18)=1 VV1 0xF3 V0F38 VNP not64 VL128 MOD[mm] MOD!=3 REG[0b010] RM[nnn] MODRM()*/ {18, 2289},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(72)=4 VV1 0xF3 V0F38 VNP not64 VL128  MOD[mm] MOD!=3 REG[0b001] RM[nnn] MODRM()*/ {72, 3733},
/*h(90)=5 VV1 0xF3 V0F38 VNP not64 VL128 MOD[mm] MOD!=3 REG[0b011] RM[nnn] MODRM()*/ {90, 3725},
/*h(19)=6 VV1 0xF3 V0F38 VNP not64 VL128 MOD[0b11] MOD=3 REG[0b010] RM[nnn]*/ {19, 2291},
/*empty slot1 */ {0,0},
/*h(16)=8 VV1 0xF3 V0F38 VNP not64 VL128 MOD[mm] MOD!=3 REG[0b010] RM[nnn] MODRM()*/ {16, 2289},
/*h(73)=9 VV1 0xF3 V0F38 VNP not64 VL128  MOD[0b11] MOD=3 REG[0b001] RM[nnn]*/ {73, 3735},
/*h(91)=10 VV1 0xF3 V0F38 VNP not64 VL128 MOD[0b11] MOD=3 REG[0b011] RM[nnn]*/ {91, 3727},
/*h(20)=11 VV1 0xF3 V0F38 VNP W0 mode64 VL128 MOD[mm] MOD!=3 REG[0b010] RM[nnn] MODRM()*/ {20, 2290},
/*h(88)=12 VV1 0xF3 V0F38 VNP not64 VL128 MOD[mm] MOD!=3 REG[0b011] RM[nnn] MODRM()*/ {88, 3725},
/*h(17)=13 VV1 0xF3 V0F38 VNP not64 VL128 MOD[0b11] MOD=3 REG[0b010] RM[nnn]*/ {17, 2291},
/*h(74)=14 VV1 0xF3 V0F38 VNP not64 VL128  MOD[mm] MOD!=3 REG[0b001] RM[nnn] MODRM()*/ {74, 3733},
/*h(92)=15 VV1 0xF3 V0F38 VNP W1 VL128 mode64 MOD[mm] MOD!=3 REG[0b011] RM[nnn] MODRM()*/ {92, 3729},
/*h(21)=16 VV1 0xF3 V0F38 VNP W0 mode64 VL128 MOD[0b11] MOD=3 REG[0b010] RM[nnn]*/ {21, 2292},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(75)=19 VV1 0xF3 V0F38 VNP not64 VL128  MOD[0b11] MOD=3 REG[0b001] RM[nnn]*/ {75, 3735},
/*h(93)=20 VV1 0xF3 V0F38 VNP W1 VL128 mode64 MOD[0b11] MOD=3 REG[0b011] RM[nnn]*/ {93, 3730},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(76)=24 VV1 0xF3 V0F38 VNP W1 VL128 mode64 MOD[mm] MOD!=3 REG[0b001] RM[nnn] MODRM()*/ {76, 3737},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(77)=29 VV1 0xF3 V0F38 VNP W1 VL128 mode64 MOD[0b11] MOD=3 REG[0b001] RM[nnn]*/ {77, 3738},
/*empty slot1 */ {0,0},
/*h(24)=31 VV1 0xF3 V0F38 VNP not64 VL128 MOD[mm] MOD!=3 REG[0b011] RM[nnn] MODRM()*/ {24, 3725},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(25)=36 VV1 0xF3 V0F38 VNP not64 VL128 MOD[0b11] MOD=3 REG[0b011] RM[nnn]*/ {25, 3727},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(8)=40 VV1 0xF3 V0F38 VNP not64 VL128  MOD[mm] MOD!=3 REG[0b001] RM[nnn] MODRM()*/ {8, 3733},
/*h(26)=41 VV1 0xF3 V0F38 VNP not64 VL128 MOD[mm] MOD!=3 REG[0b011] RM[nnn] MODRM()*/ {26, 3725},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(80)=44 VV1 0xF3 V0F38 VNP not64 VL128 MOD[mm] MOD!=3 REG[0b010] RM[nnn] MODRM()*/ {80, 2289},
/*h(9)=45 VV1 0xF3 V0F38 VNP not64 VL128  MOD[0b11] MOD=3 REG[0b001] RM[nnn]*/ {9, 3735},
/*h(27)=46 VV1 0xF3 V0F38 VNP not64 VL128 MOD[0b11] MOD=3 REG[0b011] RM[nnn]*/ {27, 3727},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(81)=49 VV1 0xF3 V0F38 VNP not64 VL128 MOD[0b11] MOD=3 REG[0b010] RM[nnn]*/ {81, 2291},
/*h(10)=50 VV1 0xF3 V0F38 VNP not64 VL128  MOD[mm] MOD!=3 REG[0b001] RM[nnn] MODRM()*/ {10, 3733},
/*h(28)=51 VV1 0xF3 V0F38 VNP W0 mode64 VL128 MOD[mm] MOD!=3 REG[0b011] RM[nnn] MODRM()*/ {28, 3726},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(82)=54 VV1 0xF3 V0F38 VNP not64 VL128 MOD[mm] MOD!=3 REG[0b010] RM[nnn] MODRM()*/ {82, 2289},
/*h(11)=55 VV1 0xF3 V0F38 VNP not64 VL128  MOD[0b11] MOD=3 REG[0b001] RM[nnn]*/ {11, 3735},
/*h(29)=56 VV1 0xF3 V0F38 VNP W0 mode64 VL128 MOD[0b11] MOD=3 REG[0b011] RM[nnn]*/ {29, 3728},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(83)=59 VV1 0xF3 V0F38 VNP not64 VL128 MOD[0b11] MOD=3 REG[0b010] RM[nnn]*/ {83, 2291},
/*h(12)=60 VV1 0xF3 V0F38 VNP W0 mode64 VL128  MOD[mm] MOD!=3 REG[0b001] RM[nnn] MODRM()*/ {12, 3734},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(84)=64 VV1 0xF3 V0F38 VNP W1 VL128 mode64 MOD[mm] MOD!=3 REG[0b010] RM[nnn] MODRM()*/ {84, 2293},
/*h(13)=65 VV1 0xF3 V0F38 VNP W0 mode64 VL128  MOD[0b11] MOD=3 REG[0b001] RM[nnn]*/ {13, 3736},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(85)=69 VV1 0xF3 V0F38 VNP W1 VL128 mode64 MOD[0b11] MOD=3 REG[0b010] RM[nnn]*/ {85, 2294},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_MODE_REG_REXW_VEX_PREFIX_VL(d);
hidx = ((5*key % 89) % 72);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xf5_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[67] = {
/*h(0)=0 VV1 0xF5 V0F38 VNP not64 VL128  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {0, 2525},
/*h(45)=1 VV1 0xF5 V0F38 VF2 W1 VL128 mode64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {45, 2538},
/*empty slot1 */ {0,0},
/*h(1)=3 VV1 0xF5 V0F38 VNP not64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {1, 2527},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(2)=6 VV1 0xF5 V0F38 VNP not64 VL128  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 2525},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(3)=9 VV1 0xF5 V0F38 VNP not64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 2527},
/*h(48)=10 VV1 0xF5 V0F38 VF3 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {48, 3567},
/*empty slot1 */ {0,0},
/*h(4)=12 VV1 0xF5 V0F38 VNP W0 mode64 VL128  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 2526},
/*h(49)=13 VV1 0xF5 V0F38 VF3 not64 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {49, 3569},
/*empty slot1 */ {0,0},
/*h(5)=15 VV1 0xF5 V0F38 VNP W0 mode64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 2528},
/*h(50)=16 VV1 0xF5 V0F38 VF3 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {50, 3567},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(51)=19 VV1 0xF5 V0F38 VF3 not64 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {51, 3569},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(52)=22 VV1 0xF5 V0F38 VF3 W0 mode64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {52, 3568},
/*empty slot1 */ {0,0},
/*h(8)=24 VV1 0xF5 V0F38 VNP not64 VL128  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {8, 2525},
/*h(53)=25 VV1 0xF5 V0F38 VF3 W0 mode64 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {53, 3570},
/*empty slot1 */ {0,0},
/*h(9)=27 VV1 0xF5 V0F38 VNP not64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {9, 2527},
/*empty slot1 */ {0,0},
/*h(32)=29 VV1 0xF5 V0F38 VF2 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {32, 2533},
/*h(10)=30 VV1 0xF5 V0F38 VNP not64 VL128  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 2525},
/*empty slot1 */ {0,0},
/*h(33)=32 VV1 0xF5 V0F38 VF2 not64 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {33, 2535},
/*h(11)=33 VV1 0xF5 V0F38 VNP not64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 2527},
/*h(56)=34 VV1 0xF5 V0F38 VF3 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {56, 3567},
/*h(34)=35 VV1 0xF5 V0F38 VF2 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {34, 2533},
/*h(12)=36 VV1 0xF5 V0F38 VNP W1 VL128 mode64  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {12, 2529},
/*h(57)=37 VV1 0xF5 V0F38 VF3 not64 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {57, 3569},
/*h(35)=38 VV1 0xF5 V0F38 VF2 not64 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {35, 2535},
/*h(13)=39 VV1 0xF5 V0F38 VNP W1 VL128 mode64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {13, 2530},
/*h(58)=40 VV1 0xF5 V0F38 VF3 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {58, 3567},
/*h(36)=41 VV1 0xF5 V0F38 VF2 W0 mode64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {36, 2534},
/*empty slot1 */ {0,0},
/*h(59)=43 VV1 0xF5 V0F38 VF3 not64 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {59, 3569},
/*h(37)=44 VV1 0xF5 V0F38 VF2 W0 mode64 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {37, 2536},
/*empty slot1 */ {0,0},
/*h(60)=46 VV1 0xF5 V0F38 VF3 W1 VL128 mode64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {60, 3571},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(61)=49 VV1 0xF5 V0F38 VF3 W1 VL128 mode64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {61, 3572},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(40)=53 VV1 0xF5 V0F38 VF2 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {40, 2533},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(41)=56 VV1 0xF5 V0F38 VF2 not64 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {41, 2535},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(42)=59 VV1 0xF5 V0F38 VF2 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {42, 2533},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(43)=62 VV1 0xF5 V0F38 VF2 not64 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {43, 2535},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(44)=65 VV1 0xF5 V0F38 VF2 W1 VL128 mode64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {44, 2537},
/*empty slot1 */ {0,0}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_MODE_REXW_VEX_PREFIX_VL(d);
hidx = (3*key % 67);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xf6_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[18] = {
/*h(34)=0 VV1 0xF6 VF2 V0F38 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {34, 3238},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(44)=3 VV1 0xF6 VF2 V0F38 W1 VL128 mode64  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {44, 3241},
/*h(36)=4 VV1 0xF6 VF2 V0F38 W0 mode64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {36, 3239},
/*empty slot1 */ {0,0},
/*h(41)=6 VV1 0xF6 VF2 V0F38 not64 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {41, 3236},
/*h(33)=7 VV1 0xF6 VF2 V0F38 not64 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {33, 3236},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(43)=10 VV1 0xF6 VF2 V0F38 not64 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {43, 3236},
/*h(35)=11 VV1 0xF6 VF2 V0F38 not64 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {35, 3236},
/*h(40)=12 VV1 0xF6 VF2 V0F38 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {40, 3238},
/*h(32)=13 VV1 0xF6 VF2 V0F38 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {32, 3238},
/*h(45)=14 VV1 0xF6 VF2 V0F38 W1 VL128 mode64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {45, 3240},
/*h(37)=15 VV1 0xF6 VF2 V0F38 W0 mode64 VL128 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {37, 3237},
/*empty slot1 */ {0,0},
/*h(42)=17 VV1 0xF6 VF2 V0F38 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {42, 3238}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_MODE_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 18ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F38_opcode0xf7_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[67] = {
/*h(0)=0 VV1 0xF7 V0F38 VNP not64 VL128  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {0, 3539},
/*h(45)=1 VV1 0xF7 V0F38 VF2  W1 VL128 mode64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {45, 2401},
/*empty slot1 */ {0,0},
/*h(1)=3 VV1 0xF7 V0F38 VNP not64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {1, 3541},
/*empty slot1 */ {0,0},
/*h(24)=5 VV1 0xF7 V0F38 V66 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {24, 3334},
/*h(2)=6 VV1 0xF7 V0F38 VNP not64 VL128  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {2, 3539},
/*empty slot1 */ {0,0},
/*h(25)=8 VV1 0xF7 V0F38 V66 not64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {25, 3336},
/*h(3)=9 VV1 0xF7 V0F38 VNP not64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {3, 3541},
/*h(48)=10 VV1 0xF7 V0F38 VF3 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {48, 2429},
/*h(26)=11 VV1 0xF7 V0F38 V66 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {26, 3334},
/*h(4)=12 VV1 0xF7 V0F38 VNP W0 mode64 VL128  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {4, 3540},
/*h(49)=13 VV1 0xF7 V0F38 VF3 not64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {49, 2431},
/*h(27)=14 VV1 0xF7 V0F38 V66 not64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {27, 3336},
/*h(5)=15 VV1 0xF7 V0F38 VNP W0 mode64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {5, 3542},
/*h(50)=16 VV1 0xF7 V0F38 VF3 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {50, 2429},
/*h(28)=17 VV1 0xF7 V0F38 V66  W1 VL128 mode64  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {28, 3338},
/*empty slot1 */ {0,0},
/*h(51)=19 VV1 0xF7 V0F38 VF3 not64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {51, 2431},
/*h(29)=20 VV1 0xF7 V0F38 V66  W1 VL128 mode64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {29, 3339},
/*empty slot1 */ {0,0},
/*h(52)=22 VV1 0xF7 V0F38 VF3 W0 mode64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {52, 2430},
/*empty slot1 */ {0,0},
/*h(8)=24 VV1 0xF7 V0F38 VNP not64 VL128  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {8, 3539},
/*h(53)=25 VV1 0xF7 V0F38 VF3 W0 mode64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {53, 2432},
/*empty slot1 */ {0,0},
/*h(9)=27 VV1 0xF7 V0F38 VNP not64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {9, 3541},
/*empty slot1 */ {0,0},
/*h(32)=29 VV1 0xF7 V0F38 VF2 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {32, 2396},
/*h(10)=30 VV1 0xF7 V0F38 VNP not64 VL128  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {10, 3539},
/*empty slot1 */ {0,0},
/*h(33)=32 VV1 0xF7 V0F38 VF2 not64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {33, 2398},
/*h(11)=33 VV1 0xF7 V0F38 VNP not64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {11, 3541},
/*h(56)=34 VV1 0xF7 V0F38 VF3 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {56, 2429},
/*h(34)=35 VV1 0xF7 V0F38 VF2 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {34, 2396},
/*h(12)=36 VV1 0xF7 V0F38 VNP W1 VL128 mode64  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {12, 3543},
/*h(57)=37 VV1 0xF7 V0F38 VF3 not64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {57, 2431},
/*h(35)=38 VV1 0xF7 V0F38 VF2 not64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {35, 2398},
/*h(13)=39 VV1 0xF7 V0F38 VNP W1 VL128 mode64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {13, 3544},
/*h(58)=40 VV1 0xF7 V0F38 VF3 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {58, 2429},
/*h(36)=41 VV1 0xF7 V0F38 VF2 W0 mode64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {36, 2397},
/*empty slot1 */ {0,0},
/*h(59)=43 VV1 0xF7 V0F38 VF3 not64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {59, 2431},
/*h(37)=44 VV1 0xF7 V0F38 VF2 W0 mode64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {37, 2399},
/*empty slot1 */ {0,0},
/*h(60)=46 VV1 0xF7 V0F38 VF3  W1 VL128 mode64  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {60, 2433},
/*empty slot1 */ {0,0},
/*h(16)=48 VV1 0xF7 V0F38 V66 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {16, 3334},
/*h(61)=49 VV1 0xF7 V0F38 VF3  W1 VL128 mode64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {61, 2434},
/*empty slot1 */ {0,0},
/*h(17)=51 VV1 0xF7 V0F38 V66 not64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {17, 3336},
/*empty slot1 */ {0,0},
/*h(40)=53 VV1 0xF7 V0F38 VF2 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {40, 2396},
/*h(18)=54 VV1 0xF7 V0F38 V66 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {18, 3334},
/*empty slot1 */ {0,0},
/*h(41)=56 VV1 0xF7 V0F38 VF2 not64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {41, 2398},
/*h(19)=57 VV1 0xF7 V0F38 V66 not64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {19, 3336},
/*empty slot1 */ {0,0},
/*h(42)=59 VV1 0xF7 V0F38 VF2 not64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {42, 2396},
/*h(20)=60 VV1 0xF7 V0F38 V66 W0 mode64 VL128 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {20, 3335},
/*empty slot1 */ {0,0},
/*h(43)=62 VV1 0xF7 V0F38 VF2 not64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {43, 2398},
/*h(21)=63 VV1 0xF7 V0F38 V66 W0 mode64 VL128  MOD[0b11] MOD=3 REG[rrr] RM[nnn]*/ {21, 3337},
/*empty slot1 */ {0,0},
/*h(44)=65 VV1 0xF7 V0F38 VF2  W1 VL128 mode64  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM()*/ {44, 2400},
/*empty slot1 */ {0,0}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_MODE_REXW_VEX_PREFIX_VL(d);
hidx = (3*key % 67);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x0_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(94)=0 VV1 0x00 VL256 V0F3A V66 W1 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2300},
/*h(95)=1 VV1 0x00 VL256 V0F3A V66 W1 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {2301}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 94;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x1_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(94)=0 VV1 0x01 VL256 V0F3A V66 W1 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {3603},
/*h(95)=1 VV1 0x01 VL256 V0F3A V66 W1 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {3604}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 94;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x2_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(5)=0 VV1 0x02  VL128 V66 V0F3A W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {5, 3556},
/*h(20)=1 VV1 0x02  VL256 V66 V0F3A W0  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {20, 3557},
/*h(4)=2 VV1 0x02  VL128 V66 V0F3A W0  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {4, 3555},
/*empty slot1 */ {0,0},
/*h(21)=4 VV1 0x02  VL256 V66 V0F3A W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {21, 3558}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x4_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[8] = {
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(28)=2 VV1 0x04 VL128 V66 V0F3A norexw_prefix NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {28, 2313},
/*h(93)=3 VV1 0x04 VL256 V66 V0F3A norexw_prefix NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {93, 2316},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(92)=6 VV1 0x04 VL256 V66 V0F3A norexw_prefix NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {92, 2315},
/*h(29)=7 VV1 0x04 VL128 V66 V0F3A norexw_prefix NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {29, 2314}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-3));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x5_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[8] = {
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(28)=2 VV1 0x05  VL128 V66 V0F3A norexw_prefix NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {28, 3320},
/*h(93)=3 VV1 0x05  VL256 V66 V0F3A norexw_prefix NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {93, 3323},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(92)=6 VV1 0x05  VL256 V66 V0F3A norexw_prefix NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {92, 3322},
/*h(29)=7 VV1 0x05  VL128 V66 V0F3A norexw_prefix NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {29, 3321}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-3));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x6_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(20)=0 VV1 0x06 VL256 V66 V0F3A norexw_prefix  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2259},
/*h(21)=1 VV1 0x06 VL256 V66 V0F3A norexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {2260}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 20;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x8_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(47)=0 VV1 0x08  VL256 V66 V0F3A NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {47, 3431},
/*h(15)=1 VV1 0x08  VL128 V66 V0F3A NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {15, 3429},
/*h(46)=2 VV1 0x08  VL256 V66 V0F3A NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {46, 3430},
/*h(14)=3 VV1 0x08  VL128 V66 V0F3A NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {14, 3428},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x9_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(47)=0 VV1 0x09  VL256 V66 V0F3A NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {47, 3423},
/*h(15)=1 VV1 0x09  VL128 V66 V0F3A NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {15, 3421},
/*h(46)=2 VV1 0x09  VL256 V66 V0F3A NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {46, 3422},
/*h(14)=3 VV1 0x09  VL128 V66 V0F3A NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {14, 3420},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0xa_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(2)=0 VV1 0x0A  V66 V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2904},
/*h(3)=1 VV1 0x0A  V66 V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {2905}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX(d);
hidx = key - 2;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0xb_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(2)=0 VV1 0x0B  V66 V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2893},
/*h(3)=1 VV1 0x0B  V66 V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {2894}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX(d);
hidx = key - 2;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0xc_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x0C  VL256 V66 V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {10, 3148},
/*h(2)=1 VV1 0x0C  VL128 V66 V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2, 3146},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x0C  VL256 V66 V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {11, 3149},
/*h(3)=4 VV1 0x0C  VL128 V66 V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {3, 3147}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0xd_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x0D  VL256 V66 V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {10, 3136},
/*h(2)=1 VV1 0x0D  VL128 V66 V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2, 3134},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x0D  VL256 V66 V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {11, 3137},
/*h(3)=4 VV1 0x0D  VL128 V66 V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {3, 3135}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0xe_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x0E  VL256 V66 V0F3A  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {10, 3198},
/*h(2)=1 VV1 0x0E  VL128 V66 V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2, 3196},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x0E  VL256 V66 V0F3A  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {11, 3199},
/*h(3)=4 VV1 0x0E  VL128 V66 V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {3, 3197}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0xf_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x0F  VL256 V66 V0F3A  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {10, 2787},
/*h(2)=1 VV1 0x0F  VL128 V66 V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2, 2785},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x0F  VL256 V66 V0F3A  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {11, 2788},
/*h(3)=4 VV1 0x0F  VL128 V66 V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {3, 2786}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x14_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(14)=0 VV1 0x14  VL128 V66 V0F3A NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {3163},
/*h(15)=1 VV1 0x14  VL128 V66 V0F3A NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {3164}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 14;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x15_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(14)=0 VV1 0x15  VL128 V66 V0F3A NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {3175},
/*h(15)=1 VV1 0x15  VL128 V66 V0F3A NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {3176}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 14;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x16_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[17] = {
/*h(123)=0 VV1 0x16 VL128 V66 V0F3A not64  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {123, 3168},
/*h(115)=1 VV1 0x16 VL128 V66 V0F3A not64  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {115, 3168},
/*h(120)=2 VV1 0x16 VL128 V66 V0F3A not64  NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {120, 3167},
/*h(112)=3 VV1 0x16 VL128 V66 V0F3A not64  NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {112, 3167},
/*h(125)=4 VV1 0x16  VL128 V66 V0F3A mode64 rexw_prefix NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {125, 3174},
/*h(117)=5 VV1 0x16 VL128 V66 V0F3A mode64 norexw_prefix NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {117, 3166},
/*h(122)=6 VV1 0x16 VL128 V66 V0F3A not64  NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {122, 3167},
/*h(114)=7 VV1 0x16 VL128 V66 V0F3A not64  NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {114, 3167},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(124)=10 VV1 0x16  VL128 V66 V0F3A mode64 rexw_prefix  NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {124, 3173},
/*h(116)=11 VV1 0x16 VL128 V66 V0F3A mode64 norexw_prefix NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {116, 3165},
/*empty slot1 */ {0,0},
/*h(121)=13 VV1 0x16 VL128 V66 V0F3A not64  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {121, 3168},
/*h(113)=14 VV1 0x16 VL128 V66 V0F3A not64  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {113, 3168},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_MODE_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 17ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x17_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(14)=0 VV1 0x17  VL128 V66 V0F3A  NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2504},
/*h(15)=1 VV1 0x17  VL128 V66 V0F3A  NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {2505}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 14;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x18_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(20)=0 VV1 0x18  norexw_prefix VL256 V66 V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2914},
/*h(21)=1 VV1 0x18  norexw_prefix  VL256 V66 V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {2915}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 20;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x19_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(92)=0 VV1 0x19  norexw_prefix VL256 V66 V0F3A NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {3246},
/*h(93)=1 VV1 0x19  norexw_prefix VL256 V66 V0F3A NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {3247}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 92;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x1d_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[8] = {
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(28)=2 VV1 0x1D VL128 V66 V0F3A NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8() W0*/ {28, 3739},
/*h(93)=3 VV1 0x1D VL256 V66 V0F3A NOVSR  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8() W0*/ {93, 3742},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(92)=6 VV1 0x1D VL256 V66 V0F3A NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8() W0*/ {92, 3741},
/*h(29)=7 VV1 0x1D VL128 V66 V0F3A NOVSR  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8() W0*/ {29, 3740}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-3));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x20_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(2)=0 VV1 0x20  VL128 V66 V0F3A  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2484},
/*h(3)=1 VV1 0x20  VL128 V66 V0F3A  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {2485}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = key - 2;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x21_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(2)=0 VV1 0x21  VL128 V66 V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2783},
/*h(3)=1 VV1 0x21  VL128 V66 V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {2784}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = key - 2;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x22_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[18] = {
/*empty slot1 */ {0,0},
/*h(26)=1 VV1 0x22  VL128 V66 V0F3A not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {26, 3264},
/*h(18)=2 VV1 0x22  VL128 V66 V0F3A not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {18, 3264},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(28)=5 VV1 0x22  VL128 V66 V0F3A mode64 rexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {28, 3266},
/*h(20)=6 VV1 0x22  VL128 V66 V0F3A mode64 norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {20, 3262},
/*empty slot1 */ {0,0},
/*h(25)=8 VV1 0x22  VL128 V66 V0F3A not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {25, 3265},
/*h(17)=9 VV1 0x22  VL128 V66 V0F3A not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {17, 3265},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(27)=12 VV1 0x22  VL128 V66 V0F3A not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {27, 3265},
/*h(19)=13 VV1 0x22  VL128 V66 V0F3A not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {19, 3265},
/*h(24)=14 VV1 0x22  VL128 V66 V0F3A not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {24, 3264},
/*h(16)=15 VV1 0x22  VL128 V66 V0F3A not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {16, 3264},
/*h(29)=16 VV1 0x22  VL128 V66 V0F3A mode64 rexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {29, 3267},
/*h(21)=17 VV1 0x22  VL128 V66 V0F3A mode64 norexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {21, 3263}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_MODE_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 18ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x30_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(31)=0 VV1 0x30 V66 V0F3A MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W1  NOVSR UIMM8()*/ {31, 3576},
/*h(29)=1 VV1 0x30 V66 V0F3A MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR UIMM8()*/ {29, 3591}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-1));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x31_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(31)=0 VV1 0x31 V66 V0F3A MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W1  NOVSR UIMM8()*/ {31, 2719},
/*h(29)=1 VV1 0x31 V66 V0F3A MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR UIMM8()*/ {29, 3598}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-1));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x32_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(31)=0 VV1 0x32 V66 V0F3A MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W1  NOVSR UIMM8()*/ {31, 3659},
/*h(29)=1 VV1 0x32 V66 V0F3A MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR UIMM8()*/ {29, 3648}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-1));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x33_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(31)=0 VV1 0x33 V66 V0F3A MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W1  NOVSR UIMM8()*/ {31, 3162},
/*h(29)=1 VV1 0x33 V66 V0F3A MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL=0  W0  NOVSR UIMM8()*/ {29, 3639}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-1));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x38_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(20)=0 VV1 0x38  VL256 V66 V0F3A W0  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {3436},
/*h(21)=1 VV1 0x38  VL256 V66 V0F3A W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {3437}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 20;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x39_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(92)=0 VV1 0x39  VL256 V66 V0F3A W0  NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {3438},
/*h(93)=1 VV1 0x39  VL256 V66 V0F3A W0 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {3439}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 92;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x40_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x40  VL256 V66 V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {10, 2730},
/*h(2)=1 VV1 0x40  VL128 V66 V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2, 2728},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x40  VL256 V66 V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {11, 2731},
/*h(3)=4 VV1 0x40  VL128 V66 V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {3, 2729}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x41_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(2)=0 VV1 0x41  VL128 V66 V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2713},
/*h(3)=1 VV1 0x41  VL128 V66 V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {2714}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = key - 2;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x42_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x42  VL256 V66 V0F3A  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {10, 3069},
/*h(2)=1 VV1 0x42  VL128 V66 V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {2, 3067},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x42  VL256 V66 V0F3A  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {11, 3070},
/*h(3)=4 VV1 0x42  VL128 V66 V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {3, 3068}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x44_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(10)=0 VV1 0x44 V66 V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM()  VL256     UIMM8()*/ {10, 3465},
/*h(2)=1 VV1 0x44  V66 V0F3A  MOD[mm]  MOD!=3 REG[rrr] RM[nnn] MODRM() VL128 UIMM8()*/ {2, 3463},
/*empty slot1 */ {0,0},
/*h(11)=3 VV1 0x44 V66 V0F3A MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL256     UIMM8()*/ {11, 3464},
/*h(3)=4 VV1 0x44  V66 V0F3A  MOD[0b11]  MOD=3  REG[rrr] RM[nnn] VL128 UIMM8()*/ {3, 3462}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x46_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(20)=0 VV1 0x46  VL256 V66 V0F3A W0  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {3242},
/*h(21)=1 VV1 0x46  VL256 V66 V0F3A W0 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {3243}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = key - 20;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x48_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x48 VL128 V66 V0F3A W0  MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {5, 2438},
/*h(23)=1 VV1 0x48 VL256 V66 V0F3A W1   MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {23, 2444},
/*h(7)=2 VV1 0x48 VL128 V66 V0F3A W1  MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {7, 2442},
/*h(20)=3 VV1 0x48 VL256 V66 V0F3A W0   MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {20, 2439},
/*h(4)=4 VV1 0x48 VL128 V66 V0F3A W0  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {4, 2437},
/*h(22)=5 VV1 0x48 VL256 V66 V0F3A W1   MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {22, 2443},
/*h(6)=6 VV1 0x48 VL128 V66 V0F3A W1  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {6, 2441},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x48 VL256 V66 V0F3A W0   MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {21, 2440}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x49_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x49 VL128 V66 V0F3A W0  MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {5, 2446},
/*h(23)=1 VV1 0x49 VL256 V66 V0F3A W1   MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {23, 2452},
/*h(7)=2 VV1 0x49 VL128 V66 V0F3A W1  MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {7, 2450},
/*h(20)=3 VV1 0x49 VL256 V66 V0F3A W0   MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {20, 2447},
/*h(4)=4 VV1 0x49 VL128 V66 V0F3A W0  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {4, 2445},
/*h(22)=5 VV1 0x49 VL256 V66 V0F3A W1   MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {22, 2451},
/*h(6)=6 VV1 0x49 VL128 V66 V0F3A W1  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {6, 2449},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x49 VL256 V66 V0F3A W0   MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {21, 2448}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x4a_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(5)=0 VV1 0x4A   V66 V0F3A VL128 norexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {5, 3064},
/*h(20)=1 VV1 0x4A   V66 V0F3A VL256 norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {20, 3065},
/*h(4)=2 VV1 0x4A   V66 V0F3A VL128 norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {4, 3063},
/*empty slot1 */ {0,0},
/*h(21)=4 VV1 0x4A   V66 V0F3A VL256 norexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {21, 3066}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x4b_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(5)=0 VV1 0x4B   V66 V0F3A VL128 norexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {5, 2625},
/*h(20)=1 VV1 0x4B   V66 V0F3A VL256 norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {20, 2626},
/*h(4)=2 VV1 0x4B   V66 V0F3A VL128 norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {4, 2624},
/*empty slot1 */ {0,0},
/*h(21)=4 VV1 0x4B   V66 V0F3A VL256 norexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {21, 2627}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x4c_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[5] = {
/*h(5)=0 VV1 0x4C   VL128 V66 V0F3A norexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {5, 2521},
/*h(20)=1 VV1 0x4C   VL256 V66 V0F3A norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {20, 2522},
/*h(4)=2 VV1 0x4C   VL128 V66 V0F3A norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {4, 2520},
/*empty slot1 */ {0,0},
/*h(21)=4 VV1 0x4C   VL256 V66 V0F3A norexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {21, 2523}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 5ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x5c_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x5C V66 W0 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {5, 3014},
/*h(23)=1 VV1 0x5C V66 W1 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {23, 3020},
/*h(7)=2 VV1 0x5C V66 W1 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {7, 3016},
/*h(20)=3 VV1 0x5C V66 W0 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {20, 3017},
/*h(4)=4 VV1 0x5C V66 W0 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {4, 3013},
/*h(22)=5 VV1 0x5C V66 W1 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {22, 3019},
/*h(6)=6 VV1 0x5C V66 W1 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {6, 3015},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x5C V66 W0 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {21, 3018}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x5d_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x5D V66 W0 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {5, 2266},
/*h(23)=1 VV1 0x5D V66 W1 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {23, 2272},
/*h(7)=2 VV1 0x5D V66 W1 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {7, 2268},
/*h(20)=3 VV1 0x5D V66 W0 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {20, 2269},
/*h(4)=4 VV1 0x5D V66 W0 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {4, 2265},
/*h(22)=5 VV1 0x5D V66 W1 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {22, 2271},
/*h(6)=6 VV1 0x5D V66 W1 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {6, 2267},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x5D V66 W0 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {21, 2270}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x5e_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x5E V66 W0 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {5, 3627},
/*h(23)=1 VV1 0x5E V66 W1 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {23, 3633},
/*h(7)=2 VV1 0x5E V66 W1 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {7, 3629},
/*h(20)=3 VV1 0x5E V66 W0 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {20, 3630},
/*h(4)=4 VV1 0x5E V66 W0 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {4, 3626},
/*h(22)=5 VV1 0x5E V66 W1 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {22, 3632},
/*h(6)=6 VV1 0x5E V66 W1 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {6, 3628},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x5E V66 W0 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {21, 3631}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x5f_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x5F V66 W0 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {5, 3610},
/*h(23)=1 VV1 0x5F V66 W1 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {23, 3616},
/*h(7)=2 VV1 0x5F V66 W1 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {7, 3612},
/*h(20)=3 VV1 0x5F V66 W0 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {20, 3613},
/*h(4)=4 VV1 0x5F V66 W0 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {4, 3609},
/*h(22)=5 VV1 0x5F V66 W1 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {22, 3615},
/*h(6)=6 VV1 0x5F V66 W1 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {6, 3611},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x5F V66 W0 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {21, 3614}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x60_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[17] = {
/*h(123)=0 VV1 0x60  VL128 V66 V0F3A NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {123, 3094},
/*h(115)=1 VV1 0x60  VL128 V66 V0F3A NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {115, 3094},
/*h(120)=2 VV1 0x60  VL128 V66 V0F3A NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {120, 3093},
/*h(112)=3 VV1 0x60  VL128 V66 V0F3A NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {112, 3093},
/*h(125)=4 VV1 0x60  VL128 V66 V0F3A NOVSR mode64 rexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {125, 3098},
/*h(117)=5 VV1 0x60  VL128 V66 V0F3A NOVSR mode64 norexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {117, 3096},
/*h(122)=6 VV1 0x60  VL128 V66 V0F3A NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {122, 3093},
/*h(114)=7 VV1 0x60  VL128 V66 V0F3A NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {114, 3093},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(124)=10 VV1 0x60  VL128 V66 V0F3A NOVSR mode64 rexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {124, 3097},
/*h(116)=11 VV1 0x60  VL128 V66 V0F3A NOVSR mode64 norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {116, 3095},
/*empty slot1 */ {0,0},
/*h(121)=13 VV1 0x60  VL128 V66 V0F3A NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {121, 3094},
/*h(113)=14 VV1 0x60  VL128 V66 V0F3A NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {113, 3094},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_MODE_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 17ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x61_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[17] = {
/*h(123)=0 VV1 0x61  VL128 V66 V0F3A NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {123, 3088},
/*h(115)=1 VV1 0x61  VL128 V66 V0F3A NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {115, 3088},
/*h(120)=2 VV1 0x61  VL128 V66 V0F3A NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {120, 3087},
/*h(112)=3 VV1 0x61  VL128 V66 V0F3A NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {112, 3087},
/*h(125)=4 VV1 0x61  VL128 V66 V0F3A NOVSR mode64 rexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {125, 3092},
/*h(117)=5 VV1 0x61  VL128 V66 V0F3A NOVSR mode64 norexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {117, 3090},
/*h(122)=6 VV1 0x61  VL128 V66 V0F3A NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {122, 3087},
/*h(114)=7 VV1 0x61  VL128 V66 V0F3A NOVSR not64 MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {114, 3087},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(124)=10 VV1 0x61  VL128 V66 V0F3A NOVSR mode64 rexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {124, 3091},
/*h(116)=11 VV1 0x61  VL128 V66 V0F3A NOVSR mode64 norexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {116, 3089},
/*empty slot1 */ {0,0},
/*h(121)=13 VV1 0x61  VL128 V66 V0F3A NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {121, 3088},
/*h(113)=14 VV1 0x61  VL128 V66 V0F3A NOVSR not64 MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {113, 3088},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_MODE_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 17ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x62_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(14)=0 VV1 0x62  VL128 V66 V0F3A NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {3218},
/*h(15)=1 VV1 0x62  VL128 V66 V0F3A NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {3219}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 14;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x63_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[17] = {
/*h(123)=0 VV1 0x63  VL128 V66 V0F3A NOVSR  not64  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {123, 3221},
/*h(115)=1 VV1 0x63  VL128 V66 V0F3A NOVSR  not64  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {115, 3221},
/*h(120)=2 VV1 0x63  VL128 V66 V0F3A NOVSR  not64  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {120, 3220},
/*h(112)=3 VV1 0x63  VL128 V66 V0F3A NOVSR  not64  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {112, 3220},
/*h(125)=4 VV1 0x63  VL128 V66 V0F3A NOVSR mode64 rexw_prefix  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {125, 3225},
/*h(117)=5 VV1 0x63  VL128 V66 V0F3A NOVSR mode64 norexw_prefix MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {117, 3223},
/*h(122)=6 VV1 0x63  VL128 V66 V0F3A NOVSR  not64  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {122, 3220},
/*h(114)=7 VV1 0x63  VL128 V66 V0F3A NOVSR  not64  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {114, 3220},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(124)=10 VV1 0x63  VL128 V66 V0F3A NOVSR mode64 rexw_prefix MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {124, 3224},
/*h(116)=11 VV1 0x63  VL128 V66 V0F3A NOVSR mode64 norexw_prefix  MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {116, 3222},
/*empty slot1 */ {0,0},
/*h(121)=13 VV1 0x63  VL128 V66 V0F3A NOVSR  not64  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {121, 3221},
/*h(113)=14 VV1 0x63  VL128 V66 V0F3A NOVSR  not64  MOD[0b11] MOD=3 REG[rrr] RM[nnn] UIMM8()*/ {113, 3221},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_MODE_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 17ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x68_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x68 V66 W0 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {5, 3524},
/*h(23)=1 VV1 0x68 V66 W1 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {23, 3530},
/*h(7)=2 VV1 0x68 V66 W1 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {7, 3526},
/*h(20)=3 VV1 0x68 V66 W0 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {20, 3527},
/*h(4)=4 VV1 0x68 V66 W0 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {4, 3523},
/*h(22)=5 VV1 0x68 V66 W1 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {22, 3529},
/*h(6)=6 VV1 0x68 V66 W1 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {6, 3525},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x68 V66 W0 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {21, 3528}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x69_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x69 V66 W0 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {5, 3507},
/*h(23)=1 VV1 0x69 V66 W1 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {23, 3513},
/*h(7)=2 VV1 0x69 V66 W1 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {7, 3509},
/*h(20)=3 VV1 0x69 V66 W0 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {20, 3510},
/*h(4)=4 VV1 0x69 V66 W0 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {4, 3506},
/*h(22)=5 VV1 0x69 V66 W1 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {22, 3512},
/*h(6)=6 VV1 0x69 V66 W1 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {6, 3508},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x69 V66 W0 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {21, 3511}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x6a_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(4)=0 VV1 0x6A V66 W0  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {3047},
/*h(5)=1 VV1 0x6A V66 W0  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {3048},
/*h(6)=2 VV1 0x6A V66 W1  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {3049},
/*h(7)=3 VV1 0x6A V66 W1  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {3050}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX(d);
hidx = key - 4;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x6b_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(4)=0 VV1 0x6B V66 W0  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {3057},
/*h(5)=1 VV1 0x6B V66 W0  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {3058},
/*h(6)=2 VV1 0x6B V66 W1  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {3059},
/*h(7)=3 VV1 0x6B V66 W1  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {3060}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX(d);
hidx = key - 4;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x6c_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x6C V66 W0 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {5, 3151},
/*h(23)=1 VV1 0x6C V66 W1 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {23, 3157},
/*h(7)=2 VV1 0x6C V66 W1 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {7, 3153},
/*h(20)=3 VV1 0x6C V66 W0 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {20, 3154},
/*h(4)=4 VV1 0x6C V66 W0 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {4, 3150},
/*h(22)=5 VV1 0x6C V66 W1 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {22, 3156},
/*h(6)=6 VV1 0x6C V66 W1 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {6, 3152},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x6C V66 W0 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {21, 3155}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x6d_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x6D V66 W0 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {5, 3139},
/*h(23)=1 VV1 0x6D V66 W1 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {23, 3145},
/*h(7)=2 VV1 0x6D V66 W1 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {7, 3141},
/*h(20)=3 VV1 0x6D V66 W0 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {20, 3142},
/*h(4)=4 VV1 0x6D V66 W0 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {4, 3138},
/*h(22)=5 VV1 0x6D V66 W1 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {22, 3144},
/*h(6)=6 VV1 0x6D V66 W1 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {6, 3140},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x6D V66 W0 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {21, 3143}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x6e_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(4)=0 VV1 0x6E V66 W0  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {3288},
/*h(5)=1 VV1 0x6E V66 W0  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {3289},
/*h(6)=2 VV1 0x6E V66 W1  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {3290},
/*h(7)=3 VV1 0x6E V66 W1  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {3291}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX(d);
hidx = key - 4;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x6f_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(4)=0 VV1 0x6F V66 W0  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {3306},
/*h(5)=1 VV1 0x6F V66 W0  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {3307},
/*h(6)=2 VV1 0x6F V66 W1  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {3308},
/*h(7)=3 VV1 0x6F V66 W1  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {3309}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX(d);
hidx = key - 4;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x78_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x78 V66 W0 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {5, 3388},
/*h(23)=1 VV1 0x78 V66 W1 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {23, 3394},
/*h(7)=2 VV1 0x78 V66 W1 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {7, 3390},
/*h(20)=3 VV1 0x78 V66 W0 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {20, 3391},
/*h(4)=4 VV1 0x78 V66 W0 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {4, 3387},
/*h(22)=5 VV1 0x78 V66 W1 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {22, 3393},
/*h(6)=6 VV1 0x78 V66 W1 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {6, 3389},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x78 V66 W0 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {21, 3392}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x79_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x79 V66 W0 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {5, 3483},
/*h(23)=1 VV1 0x79 V66 W1 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {23, 3489},
/*h(7)=2 VV1 0x79 V66 W1 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {7, 3485},
/*h(20)=3 VV1 0x79 V66 W0 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {20, 3486},
/*h(4)=4 VV1 0x79 V66 W0 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {4, 3482},
/*h(22)=5 VV1 0x79 V66 W1 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {22, 3488},
/*h(6)=6 VV1 0x79 V66 W1 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {6, 3484},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x79 V66 W0 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {21, 3487}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x7a_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(4)=0 VV1 0x7A V66 W0  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {2421},
/*h(5)=1 VV1 0x7A V66 W0  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {2422},
/*h(6)=2 VV1 0x7A V66 W1  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {2423},
/*h(7)=3 VV1 0x7A V66 W1  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {2424}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX(d);
hidx = key - 4;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x7b_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(4)=0 VV1 0x7B V66 W0  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {2415},
/*h(5)=1 VV1 0x7B V66 W0  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {2416},
/*h(6)=2 VV1 0x7B V66 W1  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {2417},
/*h(7)=3 VV1 0x7B V66 W1  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {2418}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX(d);
hidx = key - 4;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x7c_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x7C V66 W0 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {5, 2967},
/*h(23)=1 VV1 0x7C V66 W1 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {23, 2973},
/*h(7)=2 VV1 0x7C V66 W1 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {7, 2969},
/*h(20)=3 VV1 0x7C V66 W0 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {20, 2970},
/*h(4)=4 VV1 0x7C V66 W0 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {4, 2966},
/*h(22)=5 VV1 0x7C V66 W1 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {22, 2972},
/*h(6)=6 VV1 0x7C V66 W1 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {6, 2968},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x7C V66 W0 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {21, 2971}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x7d_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[9] = {
/*h(5)=0 VV1 0x7D V66 W0 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {5, 2988},
/*h(23)=1 VV1 0x7D V66 W1 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {23, 2994},
/*h(7)=2 VV1 0x7D V66 W1 VL128  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {7, 2990},
/*h(20)=3 VV1 0x7D V66 W0 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {20, 2991},
/*h(4)=4 VV1 0x7D V66 W0 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {4, 2987},
/*h(22)=5 VV1 0x7D V66 W1 VL256  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {22, 2993},
/*h(6)=6 VV1 0x7D V66 W1 VL128  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {6, 2989},
/*empty slot1 */ {0,0},
/*h(21)=8 VV1 0x7D V66 W0 VL256  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {21, 2992}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 9ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x7e_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(4)=0 VV1 0x7E V66 W0  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {3498},
/*h(5)=1 VV1 0x7E V66 W0  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {3499},
/*h(6)=2 VV1 0x7E V66 W1  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {3500},
/*h(7)=3 VV1 0x7E V66 W1  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {3501}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX(d);
hidx = key - 4;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0x7f_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[4] = {
/*h(4)=0 VV1 0x7F V66 W0  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {3531},
/*h(5)=1 VV1 0x7F V66 W0  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {3532},
/*h(6)=2 VV1 0x7F V66 W1  V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() SE_IMM8()*/ {3533},
/*h(7)=3 VV1 0x7F V66 W1  V0F3A MOD[0b11] MOD=3 REG[rrr] RM[nnn] SE_IMM8()*/ {3534}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX(d);
hidx = key - 4;
if(hidx <= 3) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0xce_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[8] = {
/*empty slot1 */ {0,0},
/*h(23)=1 VV1 0xCE V66 V0F3A MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL256  W1   UIMM8()*/ {23, 2355},
/*h(7)=2 VV1 0xCE V66 V0F3A MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL128  W1   UIMM8()*/ {7, 2353},
/*empty slot1 */ {0,0},
/*h(22)=4 VV1 0xCE V66 V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM()  VL256  W1   UIMM8()*/ {22, 2356},
/*h(6)=5 VV1 0xCE V66 V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM()  VL128  W1   UIMM8()*/ {6, 2354},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-3));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0xcf_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[8] = {
/*empty slot1 */ {0,0},
/*h(23)=1 VV1 0xCF V66 V0F3A MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL256  W1   UIMM8()*/ {23, 2755},
/*h(7)=2 VV1 0xCF V66 V0F3A MOD[0b11] MOD=3  REG[rrr] RM[nnn]  VL128  W1   UIMM8()*/ {7, 2753},
/*empty slot1 */ {0,0},
/*h(22)=4 VV1 0xCF V66 V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM()  VL256  W1   UIMM8()*/ {22, 2756},
/*h(6)=5 VV1 0xCF V66 V0F3A MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM()  VL128  W1   UIMM8()*/ {6, 2754},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0}
};
xed_union64_t t;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_REXW_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key,  t.s.lo32 >> (32-3));
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0xdf_vv1(const xed_decoded_inst_t* d)
{
typedef struct { xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[2] = {
/*h(14)=0 VV1 0xDF  VL128 V66 V0F3A NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn] MODRM() UIMM8()*/ {3654},
/*h(15)=1 VV1 0xDF VL128 V66 V0F3A  NOVSR MOD[0b11] MOD=3  REG[rrr] RM[nnn] UIMM8()*/ {3653}
};
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = key - 14;
if(hidx <= 1) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
static xed_uint32_t xed3_phash_find_map0x0F3A_opcode0xf0_vv1(const xed_decoded_inst_t* d)
{
typedef struct {xed_uint32_t key; xed_uint32_t value;} lu_entry_t;
static const lu_entry_t lu_table[18] = {
/*h(178)=0 VV1 0xF0 VF2 V0F3A not64 VL128 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM() UIMM8()*/ {178, 3005},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(188)=3 VV1 0xF0 VF2 V0F3A W1 VL128 NOVSR mode64 MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM() UIMM8()*/ {188, 3008},
/*h(180)=4 VV1 0xF0 VF2 V0F3A W0 mode64 VL128 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM() UIMM8()*/ {180, 3006},
/*empty slot1 */ {0,0},
/*h(185)=6 VV1 0xF0 VF2 V0F3A not64 VL128 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]  UIMM8()*/ {185, 3003},
/*h(177)=7 VV1 0xF0 VF2 V0F3A not64 VL128 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]  UIMM8()*/ {177, 3003},
/*empty slot1 */ {0,0},
/*empty slot1 */ {0,0},
/*h(187)=10 VV1 0xF0 VF2 V0F3A not64 VL128 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]  UIMM8()*/ {187, 3003},
/*h(179)=11 VV1 0xF0 VF2 V0F3A not64 VL128 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]  UIMM8()*/ {179, 3003},
/*h(184)=12 VV1 0xF0 VF2 V0F3A not64 VL128 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM() UIMM8()*/ {184, 3005},
/*h(176)=13 VV1 0xF0 VF2 V0F3A not64 VL128 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM() UIMM8()*/ {176, 3005},
/*h(189)=14 VV1 0xF0 VF2 V0F3A W1 VL128 NOVSR mode64 MOD[0b11] MOD=3 REG[rrr] RM[nnn]  UIMM8()*/ {189, 3007},
/*h(181)=15 VV1 0xF0 VF2 V0F3A W0 mode64 VL128 NOVSR MOD[0b11] MOD=3 REG[rrr] RM[nnn]  UIMM8()*/ {181, 3004},
/*empty slot1 */ {0,0},
/*h(186)=17 VV1 0xF0 VF2 V0F3A not64 VL128 NOVSR MOD[mm] MOD!=3 REG[rrr] RM[nnn]  MODRM() UIMM8()*/ {186, 3005}
};
xed_union64_t t, u;
xed_uint64_t key = 0;
xed_uint64_t hidx = 0;
key = xed_dec_lu_MOD3_MODE_REXW_VEXDEST210_7_VEXDEST3_VEX_PREFIX_VL(d);
hidx = (t.u64 = 2654435769  * key, u.u64 = t.s.lo32 * 18ULL, u.s.hi32);
if(lu_table[hidx].key == key) {
    return lu_table[hidx].value;
}
else{
    return 0;
}
}
#endif
