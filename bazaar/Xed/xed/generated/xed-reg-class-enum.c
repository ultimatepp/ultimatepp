/// @file xed-reg-class-enum.c

// This file was automatically generated.
// Do not edit this file.

#include <string.h>
#include <assert.h>
#include "xed-reg-class-enum.h"

typedef struct {
    const char* name;
    xed_reg_class_enum_t value;
} name_table_xed_reg_class_enum_t;
static const name_table_xed_reg_class_enum_t name_array_xed_reg_class_enum_t[] = {
{"INVALID", XED_REG_CLASS_INVALID},
{"BNDCFG", XED_REG_CLASS_BNDCFG},
{"BNDSTAT", XED_REG_CLASS_BNDSTAT},
{"BOUND", XED_REG_CLASS_BOUND},
{"CR", XED_REG_CLASS_CR},
{"DR", XED_REG_CLASS_DR},
{"FLAGS", XED_REG_CLASS_FLAGS},
{"GPR", XED_REG_CLASS_GPR},
{"GPR16", XED_REG_CLASS_GPR16},
{"GPR32", XED_REG_CLASS_GPR32},
{"GPR64", XED_REG_CLASS_GPR64},
{"GPR8", XED_REG_CLASS_GPR8},
{"IP", XED_REG_CLASS_IP},
{"MASK", XED_REG_CLASS_MASK},
{"MMX", XED_REG_CLASS_MMX},
{"MSR", XED_REG_CLASS_MSR},
{"MXCSR", XED_REG_CLASS_MXCSR},
{"PSEUDO", XED_REG_CLASS_PSEUDO},
{"PSEUDOX87", XED_REG_CLASS_PSEUDOX87},
{"SR", XED_REG_CLASS_SR},
{"TMP", XED_REG_CLASS_TMP},
{"X87", XED_REG_CLASS_X87},
{"XCR", XED_REG_CLASS_XCR},
{"XMM", XED_REG_CLASS_XMM},
{"YMM", XED_REG_CLASS_YMM},
{"ZMM", XED_REG_CLASS_ZMM},
{"LAST", XED_REG_CLASS_LAST},
{0, XED_REG_CLASS_LAST},
};

        
xed_reg_class_enum_t str2xed_reg_class_enum_t(const char* s)
{
   const name_table_xed_reg_class_enum_t* p = name_array_xed_reg_class_enum_t;
   while( p->name ) {
     if (strcmp(p->name,s) == 0) {
      return p->value;
     }
     p++;
   }
        

   return XED_REG_CLASS_INVALID;
}


const char* xed_reg_class_enum_t2str(const xed_reg_class_enum_t p)
{
   xed_reg_class_enum_t type_idx = p;
   if ( p > XED_REG_CLASS_LAST) type_idx = XED_REG_CLASS_LAST;
   return name_array_xed_reg_class_enum_t[type_idx].name;
}

xed_reg_class_enum_t xed_reg_class_enum_t_last(void) {
    return XED_REG_CLASS_LAST;
}
       
/*

Here is a skeleton switch statement embedded in a comment


  switch(p) {
  case XED_REG_CLASS_INVALID:
  case XED_REG_CLASS_BNDCFG:
  case XED_REG_CLASS_BNDSTAT:
  case XED_REG_CLASS_BOUND:
  case XED_REG_CLASS_CR:
  case XED_REG_CLASS_DR:
  case XED_REG_CLASS_FLAGS:
  case XED_REG_CLASS_GPR:
  case XED_REG_CLASS_GPR16:
  case XED_REG_CLASS_GPR32:
  case XED_REG_CLASS_GPR64:
  case XED_REG_CLASS_GPR8:
  case XED_REG_CLASS_IP:
  case XED_REG_CLASS_MASK:
  case XED_REG_CLASS_MMX:
  case XED_REG_CLASS_MSR:
  case XED_REG_CLASS_MXCSR:
  case XED_REG_CLASS_PSEUDO:
  case XED_REG_CLASS_PSEUDOX87:
  case XED_REG_CLASS_SR:
  case XED_REG_CLASS_TMP:
  case XED_REG_CLASS_X87:
  case XED_REG_CLASS_XCR:
  case XED_REG_CLASS_XMM:
  case XED_REG_CLASS_YMM:
  case XED_REG_CLASS_ZMM:
  case XED_REG_CLASS_LAST:
  default:
     xed_assert(0);
  }
*/
